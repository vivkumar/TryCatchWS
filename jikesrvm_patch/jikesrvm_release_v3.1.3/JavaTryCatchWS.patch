diff --git a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java
index cb4de12..516c745 100644
--- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java
+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java
@@ -34,6 +34,7 @@ import org.vmmagic.pragma.Untraced;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.ObjectReference;
 import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.WordArray;
 import org.jikesrvm.ArchitectureSpecific.Registers;
 
 /**
@@ -135,14 +136,47 @@ import org.jikesrvm.ArchitectureSpecific.Registers;
       VM.sysWriteln("scanning ",thread.getThreadSlot());
     }
 
+    
     /* get the gprs associated with this thread */
     Registers regs=thread.getContextRegisters();
     Address gprs = Magic.objectAsAddress(regs.gprs);
 
-    Address ip=regs.getInnermostInstructionAddress();
-    Address fp=regs.getInnermostFramePointer();
+    Address ip_main=regs.getInnermostInstructionAddress();
+    Address fp_main =regs.getInnermostFramePointer();
+    
+    /*
+     * While performing work-stealing with return barrier, thieves
+     * create a snapshot of victim's thread stack. This cloned stack
+     * contains references to live objects as long as the victim
+     * has return barrier installed on its main stack. 
+     * 
+     * If we do not scan the cloned stack, then we may loose references
+     * to live objects as it may be collected after scanning only the main
+     * stack. Hence, we have to make sure we compute the roots by scanning
+     * both the cloned and main stack as long as return barrier is installed
+     * on victim's main stack
+     * 
+     * As seen on NQueens and UTS benchmarks (which performs GC), there is 
+     * very insignificant change in the gc time due to scanning cloned stack
+     * as well.
+     * 
+     */
+    if(thread.wsMaintainsClonedStackAlso()) {
+    	if(false) {
+    		// Also scan the wsShadowStack
+    		WordArray gprs_actual = regs.gprs;
+    		// initialize it from the backup gprs
+    		regs.clear();
+    		thread.wsSetInnermost();
+    		scanThread(thread, trace, processCodeLocations, gprs, Address.zero());
+    	}
+    	else {
+    		thread.deInstallStackTrampoline_fromGC();
+    	}
+    }
+    
     regs.clear();
-    regs.setInnermost(ip,fp);
+    regs.setInnermost(ip_main,fp_main);
 
     scanThread(thread, trace, processCodeLocations, gprs, Address.zero());
   }
@@ -284,6 +318,14 @@ import org.jikesrvm.ArchitectureSpecific.Registers;
 
     /* If a thread started via createVM or attachVM, base may need scaning */
     checkJNIBase();
+    if (thread.wsSpecialNVMap != 0) {
+      for(int i=0; i < ArchitectureSpecific.ArchConstants.NONVOLATILE_GPRS.length; i++) {
+        int reg = ArchitectureSpecific.ArchConstants.NONVOLATILE_GPRS[i].value();
+        if ((thread.wsSpecialNVMap & (1 << reg)) != 0) {
+          reportDelayedRootEdge(trace, iteratorGroup.getRegisterLocation(reg));
+        }
+      }
+    }
 
     if (verbosity >= 2) Log.writeln("--- End Of Stack Scan ---\n");
   }
diff --git a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Scanning.java b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Scanning.java
index db5ea14..be5dc64 100644
--- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Scanning.java
+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Scanning.java
@@ -182,7 +182,6 @@ public final class Scanning extends org.mmtk.vm.Scanning implements Constants {
       /* scan the thread (stack etc.) */
       ScanThread.scanThread(thread, trace, processCodeLocations);
     }
-
     /* flush out any remset entries generated during the above activities */
     Selected.Mutator.get().flushRememberedSets();
   }
diff --git a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
index 131d14f..82a8520 100644
--- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
@@ -15,6 +15,8 @@ package org.jikesrvm.mm.mmtk;
 import org.mmtk.utility.Constants;
 import org.mmtk.utility.statistics.PerfEvent;
 import org.jikesrvm.runtime.Time;
+import org.jikesrvm.scheduler.WS;
+
 import static org.jikesrvm.runtime.SysCall.sysCall;
 
 import org.vmmagic.pragma.*;
@@ -89,5 +91,23 @@ public final class Statistics extends org.mmtk.vm.Statistics implements Constant
   public void perfEventRead(int id, long[] values) {
     sysCall.sysPerfEventRead(id, values);
   }
+  
+  /**
+   * Work-Stealing harness calls
+   */
+  @Override
+  public void wsHarnessBegin() {
+	  WS.harnessBegin();  
+  }
+  
+  @Override
+  public void wsHarnessEnd() {
+	  WS.harnessEnd();  
+  }
+  
+  @Override
+  public void wsUpdateStealRatioExternally(int steals, int pushes) {
+	  WS.updateStealRatioExternally(steals, pushes);
+  }
 }
 
diff --git a/MMTk/src/org/mmtk/plan/ParallelCollectorGroup.java b/MMTk/src/org/mmtk/plan/ParallelCollectorGroup.java
index 89cfbe2..244ba70 100644
--- a/MMTk/src/org/mmtk/plan/ParallelCollectorGroup.java
+++ b/MMTk/src/org/mmtk/plan/ParallelCollectorGroup.java
@@ -13,10 +13,10 @@
 package org.mmtk.plan;
 
 import org.mmtk.utility.Constants;
-
+//import org.mmtk.utility.Log;
+//import org.mmtk.utility.statistics.EventCounter;
 import org.mmtk.vm.Monitor;
 import org.mmtk.vm.VM;
-
 import org.vmmagic.pragma.*;
 
 /**
@@ -53,7 +53,11 @@ public class ParallelCollectorGroup implements Constants {
 
   /** Which rendezvous counter is currently in use */
   private volatile int currentRendezvousCounter;
-
+//  private final static EventCounter rendezvousTimer_T = new EventCounter("rendezvousTimer", true, true);
+//  private volatile long rendezvousTimer;
+//  private volatile int waiting;
+//  private volatile long startT;
+  
   /****************************************************************************
    *
    * Initialization
@@ -98,6 +102,7 @@ public class ParallelCollectorGroup implements Constants {
   public void triggerCycle() {
     lock.lock();
     triggerCount++;
+//    reset();
     contextsParked = 0;
     lock.broadcast();
     lock.unlock();
@@ -129,6 +134,8 @@ public class ParallelCollectorGroup implements Constants {
     while (contextsParked < contexts.length) {
       lock.await();
     }
+//    double ms = VM.statistics.nanosToMillis(rendezvousTimer);
+//    rendezvousTimer_T.wsInc((long)ms);
     lock.unlock();
   }
 
@@ -169,6 +176,12 @@ public class ParallelCollectorGroup implements Constants {
     return false;
   }
 
+//  private void reset() {
+//	  waiting = 0;
+//	  startT = 0;
+//	  rendezvousTimer = 0;
+//  }
+  
   /**
    * Rendezvous with other active threads in this group.
    *
@@ -176,6 +189,9 @@ public class ParallelCollectorGroup implements Constants {
    */
   public int rendezvous() {
     lock.lock();
+//    if(waiting++==0) {
+//    	startT = VM.statistics.nanoTime();
+//    }
     int i = currentRendezvousCounter;
     int me = rendezvousCounter[i]++;
     if (me == contexts.length-1) {
@@ -187,6 +203,9 @@ public class ParallelCollectorGroup implements Constants {
         lock.await();
       }
     }
+//    if(--waiting == 0) {
+//    	rendezvousTimer += VM.statistics.nanoTime() - startT;
+//    }
     lock.unlock();
     return me;
   }
diff --git a/MMTk/src/org/mmtk/plan/Plan.java b/MMTk/src/org/mmtk/plan/Plan.java
index 015439b..a96dc6b 100644
--- a/MMTk/src/org/mmtk/plan/Plan.java
+++ b/MMTk/src/org/mmtk/plan/Plan.java
@@ -650,6 +650,11 @@ public abstract class Plan implements Constants {
    */
   protected static boolean insideHarness = false;
 
+  @Interruptible
+  public static void updateStealRatioExternally(int steals, int pushes) {
+	  VM.statistics.wsUpdateStealRatioExternally(steals, pushes);
+  }
+  
   /**
    * Generic hook to allow benchmarks to be harnessed.  A plan may use
    * this to perform certain actions prior to the commencement of a
diff --git a/MMTk/src/org/mmtk/utility/statistics/EventCounter.java b/MMTk/src/org/mmtk/utility/statistics/EventCounter.java
index af46028..393b03b 100644
--- a/MMTk/src/org/mmtk/utility/statistics/EventCounter.java
+++ b/MMTk/src/org/mmtk/utility/statistics/EventCounter.java
@@ -91,6 +91,13 @@ public class EventCounter extends Counter {
     if (running) inc(1);
   }
 
+  /*
+   * To be used for jikesrvm work-stealing logs
+   */
+  public void wsInc(long value) {
+          if (running) currentCount += value;
+  }
+
   /**
    * Increment the event counter by <code>value</code>
    *
diff --git a/MMTk/src/org/mmtk/utility/statistics/Stats.java b/MMTk/src/org/mmtk/utility/statistics/Stats.java
index 322951f..a37dc20 100644
--- a/MMTk/src/org/mmtk/utility/statistics/Stats.java
+++ b/MMTk/src/org/mmtk/utility/statistics/Stats.java
@@ -39,7 +39,7 @@ public class Stats {
   public static final boolean GATHER_MARK_CONS_STATS = false;
 
   /** Maximum number of gc/mutator phases that can be counted */
-  static final int MAX_PHASES = 1 << 12;
+  static final int MAX_PHASES = 1 << 17; // To avoid the MAX_PHASE errors in Integrate and Matmul application
   /** Maximum number of counters that can be in operation */
   static final int MAX_COUNTERS = 100;
 
@@ -132,6 +132,9 @@ public class Stats {
         counter[c].start();
     }
 
+    // work-stealing harness hook
+    VM.statistics.wsHarnessBegin();
+    
     if (Options.xmlStats.getValue()) {
       Xml.begin();
       Xml.openTag("mmtk-stats");
@@ -144,6 +147,8 @@ public class Stats {
    */
   @Interruptible
   public static void stopAll() {
+	// work-stealing harness hook
+	VM.statistics.wsHarnessEnd();
     stopAllCounters();
     Stats.printStats();
     if (Options.xmlStats.getValue()) {
diff --git a/MMTk/src/org/mmtk/vm/Statistics.java b/MMTk/src/org/mmtk/vm/Statistics.java
index 46a5d96..c14c0fb 100644
--- a/MMTk/src/org/mmtk/vm/Statistics.java
+++ b/MMTk/src/org/mmtk/vm/Statistics.java
@@ -58,4 +58,11 @@ public abstract class Statistics {
    * Read a performance event value
    */
   public abstract void perfEventRead(int counter, long[] values);
+  
+  /*
+   * Work-Stealing harness calls
+   */
+  public abstract void wsHarnessBegin();
+  public abstract void wsHarnessEnd();
+  public abstract void wsUpdateStealRatioExternally(int steals, int pushes);
 }
diff --git a/bin/buildit b/bin/buildit
index 9f11e91..93d917d 100755
--- a/bin/buildit
+++ b/bin/buildit
@@ -74,6 +74,8 @@ Building Options:
      --x87            Use x87 Compatibility mode.
  -c, --cross-to       Crossbuild to target host (or copy post build).
      --with-perfevent Build with perf event support
+     --with-libnuma   Build with NUMA support
+     --for-macos      Build for MacOSX
  -a, --with-acheck    Build with align checks, implies --x87 --processors 1
  -g, --gdb-symbols    Build with gdb symbols
  -q, --quick          Quick build (not 100% safe - doesn't regenerate source)
@@ -168,6 +170,8 @@ GetOptions(
   "q|quick" => \$quick,
   "processors=s" => \$procs,
   "with-perfevent" => \$with_perfevent,
+  "with-libnuma" => \$with_libnuma,
+  "for-macos" => \$for-macos,
   "a|with-acheck" => \$with_acheck,
   "z|skip-build" => \$skip_build,
   "h|help" => \$help,
@@ -681,6 +685,12 @@ if ($ok) {
     if ($with_perfevent ne "") {
       $defs .= "-Dconfig.include.perfevent=true ";
     }
+    if ($with_libnuma ne "") {
+      $defs .= "-Dconfig.include.libnuma=true ";
+    }
+    if ($for-macos ne "") {
+      $defs .= "-Dconfig.include.macos=true ";
+    }
     if ($with_acheck ne "") {
       $defs .= "-Dconfig.alignment-checking=true ";
     }
diff --git a/build.xml b/build.xml
index 838e9dc..39e524f 100644
--- a/build.xml
+++ b/build.xml
@@ -408,7 +408,15 @@ Check to make sure all required properties are specified. This includes properti
       <equals arg1="${config.include.perfevent}" arg2="true"/>
     </condition>
 
-    <property name="filter" value="${arch.filter} ${os.filter} ${addr.filter} ${gctrace.filter} ${gcspy.filter} ${alignment-checking.filter} ${perfevent.filter} ${classlib.filter}"/>
+    <condition property="libnuma.filter" value="-DRVM_WITH_LIBNUMA=1" else="">
+      <equals arg1="${config.include.libnuma}" arg2="true"/>
+    </condition>
+
+    <condition property="macos.filter" value="-DRVM_FOR_MACOS=1" else="">
+      <equals arg1="${config.include.macos}" arg2="true"/>
+    </condition>
+
+    <property name="filter" value="${arch.filter} ${os.filter} ${addr.filter} ${gctrace.filter} ${gcspy.filter} ${alignment-checking.filter} ${perfevent.filter} ${libnuma.filter} ${macos.filter} ${classlib.filter}"/>
   </target>
 
   <!-- **************************************************************************** -->
@@ -1819,13 +1827,17 @@ Check to make sure all required properties are specified. This includes properti
       <equals arg1="${config.include.perfevent}" arg2="true"/>
     </condition>
 
+    <condition property="libnuma.lib" value="-lnuma" else="">
+      <equals arg1="${config.include.libnuma}" arg2="true"/>
+    </condition>
+
     <if>
       <conditions>
         <equals arg1="${classlib.provider}" arg2="GNU Classpath"/>
       </conditions>
       <sequential>
         <exec executable="${c++.exe}" failonerror="true">
-          <arg line="${c++.args} ${rvm.common.args} ${gcspy.lib.dir} ${perfevent.lib} ${rvm.src} ${c++.librt} -lpthread ${c++.rdynamic} -g"/>
+          <arg line="${c++.args} ${rvm.common.args} ${gcspy.lib.dir} ${perfevent.lib} ${libnuma.lib} ${rvm.src} ${c++.librt} -lpthread ${c++.rdynamic} -g"/>
           <arg value="-o"/>
           <arg value="${build.base}/JikesRVM"/>
           <arg value="-L${build.base}"/>
@@ -1840,7 +1852,7 @@ Check to make sure all required properties are specified. This includes properti
       </conditions>
       <sequential>
         <exec executable="${c++.exe}" failonerror="true">
-          <arg line="${c++.args} ${rvm.common.args} ${gcspy.lib.dir} ${perfevent.lib} ${rvm.src} ${c++.librt} -lpthread ${c++.rdynamic} -g"/>
+          <arg line="${c++.args} ${rvm.common.args} ${gcspy.lib.dir} ${perfevent.lib} ${libnuma.lib} ${rvm.src} ${c++.librt} -lpthread ${c++.rdynamic} -g"/>
           <arg value="-o"/>
           <arg value="${build.base}/JikesRVM"/>
           <arg value="-L${build.base}"/>
@@ -1910,6 +1922,7 @@ config.bootimage.compiler=${config.bootimage.compiler}
 config.mmtk.plan=${config.mmtk.plan}
 config.include.aos=${config.include.aos}
 config.include.perfevent=${config.include.perfevent}
+config.include.libnuma=${config.include.libnuma}
 config.include.gcspy=${config.include.gcspy}
 config.include.gcspy-client=${config.include.gcspy-client}
 config.assertions=${config.assertions}
@@ -1967,6 +1980,7 @@ config.bootimage.compiler=${config.bootimage.compiler}
 config.mmtk.plan=${config.mmtk.plan}
 config.include.aos=${config.include.aos}
 config.include.perfevent=${config.include.perfevent}
+config.include.libnuma=${config.include.libnuma}
 config.include.gcspy=${config.include.gcspy}
 config.include.gcspy-client=${config.include.gcspy-client}
 config.assertions=${config.assertions}
diff --git a/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java b/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java
index 6ea7a32..4b0b05b 100644
--- a/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java
+++ b/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java
@@ -14,6 +14,8 @@ import java.io.*;
 import java.util.*;
 import java.lang.reflect.*;
 
+import org.jikesrvm.VM;
+
 /**
  * <P>
  * Generates the assembler that is used by the optimizing compiler, using a
@@ -1219,9 +1221,31 @@ public class GenerateAssembler {
       emit(" */\n");
       emitTab(1);
       emit("private void do" + opcode + "(Instruction inst) {\n");
+      if (opcode.equals("CALL")) {
+        emitTab(2);
+        emit("boolean join = MIR_Call.getMethod(inst) != null && (MIR_Call.getMethod(inst).getMemberRef() == org.jikesrvm.runtime.Entrypoints.workStealingJoinMethod || MIR_Call.getMethod(inst).getMemberRef() == org.jikesrvm.runtime.Entrypoints.workStealingFinishMethod);\n");
+        emitTab(2);
+        emit("boolean recurse = isImm(MIR_Call.getTarget(inst)) && getImm(MIR_Call.getTarget(inst)) == 0;\n");
+        emitTab(2);
+        emit("int start = getMachineCodeIndex();\n");
+      }
       EmitterSet emitter = buildSetForOpcode(emitters, opcode);
       boolean[][] tp = new boolean[4][ArgumentType.values().length];
       emitter.emitSet(opcode, tp, 2);
+      if (opcode.equals("CALL")) {
+        emitTab(2);
+        emit("if (join) {\n");
+        emitTab(3);
+        emit("addJoinRegion(start, getMachineCodeIndex());\n");
+        emitTab(2);
+        emit("}\n");
+        emitTab(2);
+        emit("if (recurse) {\n");
+        emitTab(3);
+        emit("addRecursion(start);\n");
+        emitTab(2);
+        emit("}\n");
+      }
       emitTab(1);
       emit("}\n\n");
     }
diff --git a/rvm/src-generated/ia32-assembler-opt/Magic.fake b/rvm/src-generated/ia32-assembler-opt/Magic.fake
index 9d651a4..ad4ab95 100644
--- a/rvm/src-generated/ia32-assembler-opt/Magic.fake
+++ b/rvm/src-generated/ia32-assembler-opt/Magic.fake
@@ -18,4 +18,5 @@ import org.vmmagic.unboxed.Address;
 public class Magic {
   public static void setIntAtOffset(Object o, Offset x, int y) { }
   public static Address getTocPointer() { return Address.zero(); }
+  public static Address objectAsAddress(Object o) { return Address.zero(); }
 }
diff --git a/rvm/src-generated/ia32-assembler/Assembler.in b/rvm/src-generated/ia32-assembler/Assembler.in
index 20d9860..75bf3a1 100644
--- a/rvm/src-generated/ia32-assembler/Assembler.in
+++ b/rvm/src-generated/ia32-assembler/Assembler.in
@@ -187,6 +187,36 @@ public abstract class Assembler extends AbstractAssembler implements RegisterCon
    */
   protected final Lister lister;
 
+  public int [] joinRegions = new int[0];
+  
+  protected void addJoinRegion(int start, int end) {
+    int[] newRegions = new int[joinRegions.length+2];
+    for(int i=0;i<joinRegions.length;i++) {
+      newRegions[i] = joinRegions[i];
+    } 
+    joinRegions = newRegions;
+    joinRegions[joinRegions.length-2] = start;
+    joinRegions[joinRegions.length-1] = end - start;
+  }
+  
+  public int [] recursions = new int[0];
+  
+  protected void addRecursion(int start) {
+    int[] newRecursions = new int[recursions.length+1];
+    for(int i=0;i<recursions.length;i++) {
+      newRecursions[i] = recursions[i];
+    } 
+    recursions = newRecursions;
+    recursions[recursions.length-1] = start;
+  }
+  
+  public final void changeCALL_Imm(ArchitectureSpecific.CodeArray code, int start, int imm) {
+    code.set(start+1, (byte) ((imm >>  0) & 0xFF));
+    code.set(start+2, (byte) ((imm >>  8) & 0xFF));
+    code.set(start+3, (byte) ((imm >> 16) & 0xFF));
+    code.set(start+4, (byte) ((imm >> 24) & 0xFF));  
+  }
+  
   /**
    * The array holding the generated binary code.
    */
@@ -318,6 +348,27 @@ public abstract class Assembler extends AbstractAssembler implements RegisterCon
     return trimmed;
   }
 
+  public final ArchitectureSpecific.CodeArray patchMachineCodeForWorkStealing(ArchitectureSpecific.CodeArray slow) {
+    if (joinRegions.length == 0) {
+      return slow;
+    }
+
+    // Generate a fast version without join calls, that recurses to itself.
+    for(int i=0; i<joinRegions.length; i+=2) {
+      replaceWithNOP(joinRegions[i], joinRegions[i+1]);
+    }
+
+    ArchitectureSpecific.CodeArray fast = getMachineCodes();
+
+    // Change the slow version to recurse to the fast version.
+    int delta = Magic.objectAsAddress(fast).diff(Magic.objectAsAddress(slow)).toInt();
+    for(int i=0; i<recursions.length; i++) {
+      changeCALL_Imm(slow, recursions[i], delta - (recursions[i] + 5));
+    }
+
+    return fast;
+  }
+  
   /**
    * Give the lister a message associated with a particular
    * bytecode.  This is used by the baseline assembler to print the
@@ -2015,6 +2066,13 @@ public abstract class Assembler extends AbstractAssembler implements RegisterCon
     setMachineCodes(mi++, (byte) 0x9E);
     if (lister != null) lister.OP(miStart, "SAHF");
   }
+  
+  public final void replaceWithNOP (int start, int length) {
+    int oldMi = mi;
+    mi = start;
+    emitNOP(length);
+    mi = oldMi;
+  }
 
   /**
    * Emit NOP instruction
diff --git a/rvm/src-generated/vm-configuration/ArchitectureSpecific.template b/rvm/src-generated/vm-configuration/ArchitectureSpecific.template
index 16760a8..d55d8d2 100644
--- a/rvm/src-generated/vm-configuration/ArchitectureSpecific.template
+++ b/rvm/src-generated/vm-configuration/ArchitectureSpecific.template
@@ -12,7 +12,7 @@
  */
 package org.jikesrvm;
 
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 import org.vmmagic.pragma.NonMoving;
 
 import org.jikesrvm.compilers.baseline.BaselineCompiledMethod;
@@ -33,7 +33,7 @@ public class ArchitectureSpecific {
   public interface BaselineConstants extends org.jikesrvm.@_ARCH_@.BaselineConstants {}
   public static final class BaselineExceptionDeliverer extends org.jikesrvm.compilers.baseline.@_ARCH_@.BaselineExceptionDeliverer {}
   public static final class BaselineGCMapIterator extends org.jikesrvm.compilers.baseline.@_ARCH_@.BaselineGCMapIterator {
-    public BaselineGCMapIterator(WordArray registerLocations) {
+    public BaselineGCMapIterator(AddressArray registerLocations) {
       super(registerLocations);
     }}
   public static final class CodeArray extends org.jikesrvm.@_ARCH_@.CodeArray {
@@ -69,7 +69,7 @@ public class ArchitectureSpecific {
   public interface TrapConstants extends org.jikesrvm.@_ARCH_@.TrapConstants {}
   public static final class JNICompiler extends org.jikesrvm.jni.@_ARCH_@.JNICompiler {}
   public static final class JNIGCMapIterator extends org.jikesrvm.jni.@_ARCH_@.JNIGCMapIterator {
-    public JNIGCMapIterator(WordArray registerLocations) {
+    public JNIGCMapIterator(AddressArray registerLocations) {
       super(registerLocations);
     }}
   public static final class JNIHelpers extends org.jikesrvm.jni.@_ARCH_@.JNIHelpers {}
diff --git a/rvm/src-generated/vm-configuration/ArchitectureSpecificOpt.template b/rvm/src-generated/vm-configuration/ArchitectureSpecificOpt.template
index 474f1fa..d4a9ae4 100644
--- a/rvm/src-generated/vm-configuration/ArchitectureSpecificOpt.template
+++ b/rvm/src-generated/vm-configuration/ArchitectureSpecificOpt.template
@@ -12,7 +12,7 @@
  */
 package org.jikesrvm;
 
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.compilers.opt.lir2mir.BURS;
@@ -55,7 +55,7 @@ public class ArchitectureSpecificOpt {
   public static final class StackManager extends org.jikesrvm.compilers.opt.regalloc.@_ARCH_@.StackManager {}
   public static final class OptExceptionDeliverer extends org.jikesrvm.compilers.opt.runtimesupport.@_ARCH_@.OptExceptionDeliverer {}
   public static final class OptGCMapIterator extends org.jikesrvm.compilers.opt.runtimesupport.@_ARCH_@.OptGCMapIterator {
-    public OptGCMapIterator(WordArray registerLocations) {
+    public OptGCMapIterator(AddressArray registerLocations) {
       super(registerLocations);
     }}
   public interface OptGCMapIteratorConstants extends org.jikesrvm.compilers.opt.runtimesupport.@_ARCH_@.OptGCMapIteratorConstants {}
diff --git a/rvm/src-generated/vm-configuration/HeapLayoutConstants.template b/rvm/src-generated/vm-configuration/HeapLayoutConstants.template
index fbad113..c4fd9d0 100644
--- a/rvm/src-generated/vm-configuration/HeapLayoutConstants.template
+++ b/rvm/src-generated/vm-configuration/HeapLayoutConstants.template
@@ -36,7 +36,7 @@ public interface HeapLayoutConstants {
     Address.@_ADDRESS_METHOD_@( @_MAXIMUM_MAPPABLE_ADDRESS_@ );
 
   /** The maximum boot image data size */
-  int BOOT_IMAGE_DATA_SIZE = 56<<20;
+  int BOOT_IMAGE_DATA_SIZE = 65<<20;
 
   /** The maximum boot image code size */
   int BOOT_IMAGE_CODE_SIZE = 24<<20;
diff --git a/rvm/src/org/jikesrvm/CommandLineArgs.java b/rvm/src/org/jikesrvm/CommandLineArgs.java
index 0860a1a..2f5bb09 100644
--- a/rvm/src/org/jikesrvm/CommandLineArgs.java
+++ b/rvm/src/org/jikesrvm/CommandLineArgs.java
@@ -23,6 +23,7 @@ import org.jikesrvm.mm.mminterface.MemoryManager;
 
 import static org.jikesrvm.runtime.SysCall.sysCall;
 import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.scheduler.WS;
 
 /**
  * Command line option processing iwth arbitrary prefix support.
@@ -79,7 +80,18 @@ public class CommandLineArgs {
     BOOTCLASSPATH_P_ARG,
     BOOTCLASSPATH_A_ARG,
     BOOTSTRAP_CLASSES_ARG,
-    AVAILABLE_PROCESSORS_ARG
+    AVAILABLE_PROCESSORS_ARG,
+    WS_PIN_MAP_APP_THREADS,
+    WS_AUTO_PIN_APP_THREAD,
+    WS_PIN_LOG,
+    WS_PIN_SOCKETS_HINT,
+    WS_PIN_MAP_SYSTEM_THREADS,
+    PER_THREAD_PERF_EVENTS,
+    WS_PIN_MAP_GC_THREADS,
+    WS_PROCS,
+    WS_AUTOGEN_WSTHREADS,
+    WS_RETURN_BARRIER,
+    WS_STATISTICS,
   }
 
   /** Represent a single command line prefix */
@@ -208,6 +220,17 @@ public class CommandLineArgs {
                                             new Prefix("-X:vm:help$", PrefixType.HELP_ARG),
                                             new Prefix("-X:vm$", PrefixType.HELP_ARG),
                                             new Prefix("-X:vm:", PrefixType.ARG),
+                                            new Prefix("-Xws:pinMap=", PrefixType.WS_PIN_MAP_APP_THREADS),
+                                            new Prefix("-Xws:pinAuto=", PrefixType.WS_AUTO_PIN_APP_THREAD),
+                                            new Prefix("-Xws:pinLog=", PrefixType.WS_PIN_LOG),
+                                            new Prefix("-Xws:pinSocketCPU=", PrefixType.WS_PIN_SOCKETS_HINT),
+                                            new Prefix("-Xws:pinMapSys=", PrefixType.WS_PIN_MAP_SYSTEM_THREADS),
+                                            new Prefix("-Xws:perfEvent=", PrefixType.PER_THREAD_PERF_EVENTS),
+                                            new Prefix("-Xws:pinMapGC=", PrefixType.WS_PIN_MAP_GC_THREADS),
+                                            new Prefix("-Xws:procs=", PrefixType.WS_PROCS),
+                                            new Prefix("-Xws:autoThreads=", PrefixType.WS_AUTOGEN_WSTHREADS),
+                                            new Prefix("-Xws:retBarrier=", PrefixType.WS_RETURN_BARRIER),
+                                            new Prefix("-Xws:stats=", PrefixType.WS_STATISTICS),
 
                                             /* Silently ignored */
                                             new Prefix("-Xverify", PrefixType.VERIFY_ARG),
@@ -664,6 +687,58 @@ public class CommandLineArgs {
             VM.sysExit(VM.EXIT_STATUS_BOGUS_COMMAND_LINE_ARG);
           }
           break;
+        case WS_PIN_MAP_APP_THREADS:
+                final String[] map_ws = arg.split(":");
+                RVMThread.pin_map_workers = new int[map_ws.length];
+                RVMThread.ws_pinning_workers = true;
+                for(int xx=0; xx<map_ws.length; xx++) RVMThread.pin_map_workers[xx] = primitiveParseInt(map_ws[xx]);
+            break;
+        case WS_AUTO_PIN_APP_THREAD:
+                final String[] pinning = getArgs(PrefixType.WS_AUTO_PIN_APP_THREAD);
+                RVMThread.ws_pinning_workers = pinning[0].equals("true");
+            break;
+        case WS_PIN_LOG:
+                final String[] trace = getArgs(PrefixType.WS_PIN_LOG);
+                WS.pinLog = trace[0].equals("true");
+            break;
+        case WS_PIN_SOCKETS_HINT:
+                // cpuMap = <Total Sockets>:<Core Per Socket>
+                RVMThread.ws_pinning_workers = true;
+                final String[] sockets = arg.split(":");
+                RVMThread.sockets = primitiveParseInt(sockets[0]);
+                RVMThread.cpusPerSocket = primitiveParseInt(sockets[1]);
+            break;
+        case WS_PIN_MAP_SYSTEM_THREADS:
+                final String[] map_sys = arg.split(":");
+                RVMThread.pin_map_system = new int[map_sys.length];
+                RVMThread.ws_pinning_system = true;
+                for(int xx=0; xx<map_sys.length; xx++) RVMThread.pin_map_system[xx] = primitiveParseInt(map_sys[xx]);
+            break;
+        case WS_PIN_MAP_GC_THREADS:
+                final String[] map_gc = arg.split(":");
+                RVMThread.pin_map_gc = new int[map_gc.length];
+                RVMThread.ws_pinning_gc = true;
+                for(int xx=0; xx<map_gc.length; xx++) RVMThread.pin_map_gc[xx] = primitiveParseInt(map_gc[xx]);
+                break;
+        case PER_THREAD_PERF_EVENTS:
+        	final String[] perf_ws = getArgs(PrefixType.PER_THREAD_PERF_EVENTS);
+        	RVMThread.wsPerThreadPerf = perf_ws[0].equals("true");
+        	break;
+        case WS_PROCS:
+        	WS.wsProcs = primitiveParseInt(arg);
+        	break;
+        case WS_AUTOGEN_WSTHREADS:
+//        	final String[] autogen_ws = getArgs(PrefixType.WS_AUTOGEN_WSTHREADS);
+//        	RVMThread.autogenWSThread = autogen_ws[0].equals("true");
+        	break;
+        case WS_RETURN_BARRIER:
+        	final String[] useBarrier = getArgs(PrefixType.WS_RETURN_BARRIER);
+        	RVMThread.wsRetBarrier = useBarrier[0].equals("true");
+        	break;
+        case WS_STATISTICS:
+        	final String[] wsStats = getArgs(PrefixType.WS_STATISTICS);
+        	WS.stats = wsStats[0].equals("true");
+        	break;
       }
     }
   }
diff --git a/rvm/src/org/jikesrvm/VM.java b/rvm/src/org/jikesrvm/VM.java
index ac1a746..cbc6551 100644
--- a/rvm/src/org/jikesrvm/VM.java
+++ b/rvm/src/org/jikesrvm/VM.java
@@ -159,7 +159,7 @@ public class VM extends Properties implements Constants, ExitStatus {
     // get pthread_id from OS and store into vm_processor field
     //
     sysCall.sysSetupHardwareTrapHandler();
-    RVMThread.getCurrentThread().pthread_id = sysCall.sysGetThreadId();
+    RVMThread.getCurrentThread().thread_id = sysCall.sysGetThreadId();
     RVMThread.availableProcessors = SysCall.sysCall.sysNumProcessors();
 
     // Set up buffer locks used by Thread for logging and status dumping.
@@ -963,7 +963,7 @@ public class VM extends Properties implements Constants, ExitStatus {
   @NoInline
   /* don't waste code space inlining these --dave */
   public static void write(long value) {
-    write(value, true);
+    write(value, false);
   }
 
   /**
@@ -1088,6 +1088,22 @@ public class VM extends Properties implements Constants, ExitStatus {
   }
 
   @NoInline
+  public static void sysWriteln(int a, String b, String c, String d, long e, String f, long g, String h, long i) {
+	  swLock();
+	  write(a);
+	  write(b);
+	  write(c);
+	  write(d);
+	  write(e);
+	  write(f);
+	  write(g);
+	  write(h);
+	  write(i);
+	  write("\n");
+	  swUnlock();
+  }
+
+  @NoInline
   public static void sysWrite(RVMMember m) {
     swLock();
     write(m);
@@ -1562,6 +1578,17 @@ public class VM extends Properties implements Constants, ExitStatus {
     swUnlock();
   }
   @NoInline
+  public static void sysWriteln(Address a1, Address a2, Address a3) {
+    swLock();
+    write(a1);
+    write(" ");
+    write(a2);
+    write(" ");
+    write(a3);
+    writeln();
+    swUnlock();
+  }
+  @NoInline
   public static void sysWriteln(String s1, Address a1,Address a2) {
     swLock();
     write(s1);
@@ -1654,6 +1681,16 @@ public class VM extends Properties implements Constants, ExitStatus {
     writeln();
     swUnlock();
   }
+  
+  @NoInline
+  public static void sysWriteln(Offset o1, String s, Offset o2) {
+    swLock();
+    write(o1);
+    write(s);
+    write(o2);
+    writeln();
+    swUnlock();
+  }
 
   @NoInline
   public static void sysWrite(String s1, String s2, String s3) {
@@ -1921,6 +1958,55 @@ public class VM extends Properties implements Constants, ExitStatus {
     writeln();
     swUnlock();
   }
+  
+  @NoInline
+  public static void sysWriteln(String s1, Offset o1, String s2, Offset o2) {
+    swLock();
+    write(s1);
+    write(o1);
+    write(s2);
+    write(o2);
+    writeln();
+    swUnlock();
+  }
+  
+  @NoInline
+  public static void sysWriteln(Offset o, String s1, Offset o1, String s2, Offset o2) {
+    swLock();
+    write(o);
+    write(s1);
+    write(o1);
+    write(s2);
+    write(o2);
+    writeln();
+    swUnlock();
+  }
+  
+  @NoInline
+  public static void sysWriteln(int i1, String s1, Offset o, String s2, int i2) {
+    swLock();
+    write(i1);
+    write(s1);
+    write(o);
+    write(s2);
+    write(i2);
+    writeln();
+    swUnlock();
+  }
+
+  @NoInline
+  public static void sysWriteln(int i1, int i2, Offset o1, Offset o2) {
+    swLock();
+    write(i1);
+    write(" ");
+    write(i2);
+    write(" ");
+    write(o1);
+    write(" ");
+    write(o2);
+    writeln();
+    swUnlock();
+  }
 
   @NoInline
   public static void sysWrite(String s1, double d, String s2) {
diff --git a/rvm/src/org/jikesrvm/classloader/RVMType.java b/rvm/src/org/jikesrvm/classloader/RVMType.java
index e1d9423..ada2b95 100644
--- a/rvm/src/org/jikesrvm/classloader/RVMType.java
+++ b/rvm/src/org/jikesrvm/classloader/RVMType.java
@@ -135,6 +135,11 @@ public abstract class RVMType extends AnnotatedElement
   public static final RVMClass IMTType;
   public static final RVMClass FunctionTableType;
   public static final RVMClass LinkageTripletTableType;
+  public static final RVMClass WSContinuationType;
+  public static final RVMClass WSFinishType;
+  public static final RVMClass WSJoinType;
+  public static final RVMClass WSFinishFirstType;
+  public static final RVMClass RVMThreadType;
 
   static {
     // Primitive types
@@ -180,6 +185,12 @@ public abstract class RVMType extends AnnotatedElement
     JavaIoSerializableType = TypeReference.JavaIoSerializable.resolve().asClass();
     JavaLangRefReferenceType = TypeReference.JavaLangRefReference.resolve().asClass();
     JavaLangRefReferenceReferenceField = JavaLangRefReferenceType.findDeclaredField(Atom.findAsciiAtom("_referent"));
+    // WorkStealing
+    WSContinuationType = TypeReference.WSContinuation.resolve().asClass();
+    WSJoinType =  TypeReference.WSJoin.resolve().asClass();
+    WSFinishFirstType =  TypeReference.WSFinishFirst.resolve().asClass();
+    WSFinishType =  TypeReference.WSFinish.resolve().asClass();
+    RVMThreadType = TypeReference.RVMThread.resolve().asClass();
   }
 
   /**
diff --git a/rvm/src/org/jikesrvm/classloader/TypeReference.java b/rvm/src/org/jikesrvm/classloader/TypeReference.java
index a634e60..74ecbea 100644
--- a/rvm/src/org/jikesrvm/classloader/TypeReference.java
+++ b/rvm/src/org/jikesrvm/classloader/TypeReference.java
@@ -176,6 +176,11 @@ public final class TypeReference {
   public static final TypeReference BaselineSaveLSRegisters = findOrCreate(org.vmmagic.pragma.BaselineSaveLSRegisters.class);
   public static final TypeReference ReferenceFieldsVary = findOrCreate(org.vmmagic.pragma.ReferenceFieldsVary.class);
 
+  public static final TypeReference WSContinuation = findOrCreate(org.jikesrvm.scheduler.WS.Continuation.class);
+  public static final TypeReference WSJoin = findOrCreate(org.jikesrvm.scheduler.WS.Join.class);
+  public static final TypeReference WSFinish = findOrCreate(org.jikesrvm.scheduler.WS.Finish.class);
+  public static final TypeReference WSFinishFirst = findOrCreate(org.jikesrvm.scheduler.WS.FinishFirst.class);
+  public static final TypeReference RVMThread = findOrCreate(org.jikesrvm.scheduler.RVMThread.class);
 
   public static final TypeReference ReferenceMaps =
       findOrCreate(org.jikesrvm.compilers.baseline.ReferenceMaps.class);
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java
index fb9017b..016fb66 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java
@@ -197,11 +197,11 @@ public final class BaselineCompiledMethod extends CompiledMethod implements Base
    */
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
     if (eTable == null) {
-      return -1;
+      return Offset.fromIntSignExtend(-1);
     } else {
-      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType);
+      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType, exactType);
     }
   }
 
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java
index 40f6d45..5820186 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java
@@ -293,7 +293,7 @@ public abstract class BaselineCompiler extends TemplateCompilerFramework {
         ((BaselineCompiledMethod) compiledMethod).setLockAcquisitionOffset(lockOffset);
       }
       ((BaselineCompiledMethod) compiledMethod).encodeMappingInfo(refMaps, bcMap);
-      compiledMethod.compileComplete(instructions);
+      compiledMethod.compileComplete(instructions, instructions);
       if (edgeCounterIdx > 0) {
         EdgeCounts.allocateCounters(method, edgeCounterIdx);
       }
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java
index bf2ac72..88793e8 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java
@@ -95,7 +95,7 @@ public abstract class BaselineExceptionDeliverer extends ExceptionDeliverer impl
                   0)) - BYTES_IN_ADDRESS).loadAddress());
         }
         if (ObjectModel.holdsLock(lock, RVMThread.getCurrentThread())) {
-          ObjectModel.genericUnlock(lock);
+          ObjectModel.genericUnlock_internal(lock);
         }
       }
     }
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java
index 31013d2..b5d9631 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java
@@ -24,16 +24,16 @@ import org.jikesrvm.ia32.BaselineConstants;
 import org.jikesrvm.mm.mminterface.GCMapIterator;
 import org.jikesrvm.runtime.DynamicLink;
 import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 /**
- * Iterator for stack frame  built by the Baseline compiler.
- * <p>
+ * Iterator for stack frame  built by the Baseline compiler
  * An Instance of this class will iterate through a particular
- * reference map of a method returning the offsets of any references
+ * reference map of a method returning the offsets of any refereces
  * that are part of the input parameters, local variables, and
  * java stack for the stack frame.
  */
@@ -96,7 +96,7 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
    * iterators (ones for the opt compiler built frames) The locations are kept
    * as addresses within the stack.
    */
-  public BaselineGCMapIterator(WordArray registerLocations) {
+  public BaselineGCMapIterator(AddressArray registerLocations) {
     this.registerLocations = registerLocations; // (in superclass)
     dynamicLink = new DynamicLink();
   }
@@ -115,11 +115,10 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
    * @param instructionOffset
    *          identifies the map to be scanned.
    * @param fp
-   *          identifies a specific occurrence of this method and allows for
+   *          identifies a specific occurrance of this method and allows for
    *          processing instance specific information i.e JSR return address
    *          values
    */
-  @Override
   public void setupIterator(CompiledMethod compiledMethod, Offset instructionOffset, Address fp) {
     currentCompiledMethod = (BaselineCompiledMethod) compiledMethod;
     currentMethod = (NormalMethod) currentCompiledMethod.getMethod();
@@ -173,7 +172,7 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
     bridgeSpilledParamLocation = Address.zero();
 
     if (currentMethod.getDeclaringClass().hasDynamicBridgeAnnotation()) {
-      Address ip = Magic.getReturnAddressUnchecked(fp);
+    	Address ip = Magic.getReturnAddress(fp);
       fp = Magic.getCallerFramePointer(fp);
       int callingCompiledMethodId = Magic.getCompiledMethodID(fp);
       CompiledMethod callingCompiledMethod = CompiledMethods.getCompiledMethod(callingCompiledMethodId);
@@ -200,7 +199,6 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
    * Reset iteration to initial state. This allows a map to be scanned multiple
    * times.
    */
-  @Override
   public void reset() {
     mapIndex = 0;
     finishedWithRegularMap = false;
@@ -218,10 +216,8 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
   }
 
   /**
-   * Converts a biased index from a local area into an offset in the stack.
-   *
-   * @param index index in the local area (biased : local0 has index 1)
-   * @return corresponding offset in the stack
+   * given a index in the local area (biased : local0 has index 1)
+   *   this routine determines the correspondig offset in the stack
    */
   public short convertIndexToLocation(int index) {
     if (index == 0) return 0;
@@ -244,12 +240,30 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
     return offset;
   }
 
-  @Override
+  public final int getNVRegistersSaved() {
+    int result = (1 << EDI.value()) | (1 << EBX.value());
+    if (currentMethod.hasBaselineSaveLSRegistersAnnotation()) {
+      result |= 1 << EBP.value();
+    }
+    return result;
+  }
+
+  public final int getNVObjectMap() {
+    if (currentCompiledMethod.hasCounterArray()) {
+      return 1 << EBX.value();
+    }
+    return 0;
+  }
+  
+  /**
+   * Get location of next reference. A zero return indicates that no more
+   * references exist.
+   */
   public Address getNextReferenceAddress() {
     if (!finishedWithRegularMap) {
       if (counterArrayBase) {
         counterArrayBase = false;
-        return registerLocations.get(EBX.value()).toAddress();
+        return registerLocations.get(EBX.value());
       }
       if (mapId < 0) {
         mapIndex = maps.getNextJSRRefIndex(mapIndex);
@@ -303,10 +317,10 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
       if (!bridgeRegistersLocationUpdated) {
         // point registerLocations[] to our callers stackframe
         //
-        registerLocations.set(EDI.value(), framePtr.plus(EDI_SAVE_OFFSET).toWord());
-        registerLocations.set(T0.value(), framePtr.plus(T0_SAVE_OFFSET).toWord());
-        registerLocations.set(T1.value(), framePtr.plus(T1_SAVE_OFFSET).toWord());
-        registerLocations.set(EBX.value(), framePtr.plus(EBX_SAVE_OFFSET).toWord());
+        registerLocations.set(EDI.value(), framePtr.plus(EDI_SAVE_OFFSET));
+        registerLocations.set(T0.value(), framePtr.plus(T0_SAVE_OFFSET));
+        registerLocations.set(T1.value(), framePtr.plus(T1_SAVE_OFFSET));
+        registerLocations.set(EBX.value(), framePtr.plus(EBX_SAVE_OFFSET));
 
         bridgeRegistersLocationUpdated = true;
       }
@@ -374,17 +388,20 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
     } else {
       // point registerLocations[] to our callers stackframe
       //
-      registerLocations.set(EDI.value(), framePtr.plus(EDI_SAVE_OFFSET).toWord());
-      registerLocations.set(EBX.value(), framePtr.plus(EBX_SAVE_OFFSET).toWord());
+      registerLocations.set(EDI.value(), framePtr.plus(EDI_SAVE_OFFSET));
+      registerLocations.set(EBX.value(), framePtr.plus(EBX_SAVE_OFFSET));
       if (currentMethod.hasBaselineSaveLSRegistersAnnotation()) {
-        registerLocations.set(EBP.value(), framePtr.plus(EBP_SAVE_OFFSET).toWord());
+        registerLocations.set(EBP.value(), framePtr.plus(EBP_SAVE_OFFSET));
       }
     }
 
     return Address.zero();
   }
 
-  @Override
+  /**
+   * Gets the location of the next return address after the current position. A
+   * zero return indicates that no more references exist
+   */
   public Address getNextReturnAddressAddress() {
     if (mapId >= 0) {
       if (VM.TraceStkMaps || TRACE_ALL) {
@@ -405,10 +422,9 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
 
   /**
    * Cleanup pointers - used with method maps to release data structures early
-   * ... they may be in temporary storage i.e. storage only used during garbage
+   * ... they may be in temporary storage ie storage only used during garbage
    * collection
    */
-  @Override
   public void cleanupPointers() {
     maps.cleanupPointers();
     maps = null;
@@ -419,7 +435,6 @@ public abstract class BaselineGCMapIterator extends GCMapIterator implements Bas
     bridgeParameterTypes = null;
   }
 
-  @Override
   public int getType() {
     return CompiledMethod.BASELINE;
   }
diff --git a/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java b/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java
index 056c84a..863a507 100644
--- a/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java
+++ b/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java
@@ -33,6 +33,8 @@ import org.vmmagic.unboxed.Word;
 
 /**
  * A method that has been compiled into machine code by one of our compilers.
+ * We implement SynchronizedObject because we need to synchronize
+ * on the CompiledMethod object as part of the invalidation protocol.
  */
 public abstract class CompiledMethod implements SizeConstants {
 
@@ -84,6 +86,11 @@ public abstract class CompiledMethod implements SizeConstants {
   protected CodeArray instructions;
 
   /**
+   * The compiled machine code for said method.
+   */
+  protected CodeArray joinInstructions;
+
+  /**
    * the offset of instructions in JTOC, for osr-special compiled
    * method only. all osr-ed method is treated like static.
    * TODO: OSR redesign: put in subclass?  Stick somewhere else?
@@ -107,7 +114,7 @@ public abstract class CompiledMethod implements SizeConstants {
 
   public void setSpecialForOSR() {
     flags |= SPECIAL_FOR_OSR;
-    // set JTOC
+    // set jtoc
     this.osrJTOCoffset = Statics.allocateReferenceSlot(false).toInt();
     Statics.setSlotContents(this.getOsrJTOCoffset(), this.instructions);
   }
@@ -201,16 +208,18 @@ public abstract class CompiledMethod implements SizeConstants {
     if (getCompilerType() == JNI || getCompilerType() == TRAP) {
       return Offset.zero();
     } else {
-      Offset offset = ip.diff(Magic.objectAsAddress(instructions));
-      int max = (instructions.length() + 1) << ArchitectureSpecific.ArchConstants.LG_INSTRUCTION_WIDTH;
+      CodeArray base = instructions;
+      if (inJoinInstructions(ip)) base = joinInstructions;
+      Offset offset = ip.diff(Magic.objectAsAddress(base));
+      int max = (base.length() + 1) << ArchitectureSpecific.ArchConstants.LG_INSTRUCTION_WIDTH;
       if (!offset.toWord().LT(Word.fromIntZeroExtend(max))) {
-        if (RVMThread.isTrampolineIP(ip)) {
-          ip = RVMThread.getCurrentThread().getTrampolineHijackedReturnAddress();
-          offset = ip.diff(Magic.objectAsAddress(instructions));
-          if (offset.toWord().LT(Word.fromIntZeroExtend(max)))
-            return offset;
-        }
-        Address instructionStart = Magic.objectAsAddress(instructions);
+    	  if (RVMThread.isTrampolineIP(ip)) {
+    		  ip = RVMThread.getCurrentThread().getTrampolineHijackedReturnAddress();
+    		  offset = ip.diff(Magic.objectAsAddress(instructions));
+    		  if (offset.toWord().LT(Word.fromIntZeroExtend(max)))
+    			  return offset;
+    	  }
+        Address instructionStart = Magic.objectAsAddress(base);
         VM.sysWriteln("\nIn thread ",RVMThread.getCurrentThreadSlot()," getInstructionOffset: ip is not within compiled code for method: ",ip);
         VM.sysWrite("\tsupposed method is ");
         VM.sysWrite(method);
@@ -238,7 +247,7 @@ public abstract class CompiledMethod implements SizeConstants {
       return offset;
     }
   }
-
+  
   /**
    * Return the address of the instruction at offset offset in the method's instruction stream.
    * @param offset the offset of the desired instruction (as returned by getInstructionOffset)
@@ -249,6 +258,17 @@ public abstract class CompiledMethod implements SizeConstants {
     Address startAddress = Magic.objectAsAddress(instructions);
     return startAddress.plus(offset);
   }
+  
+  /**
+   * Return the address of the instruction at offset offset in the method's instruction stream.
+   * @param offset the offset of the desired instruction (as returned by getInstructionOffset)
+   * @return Address of the specified instruction
+   */
+  @Uninterruptible
+  public final Address getInstructionAddress(boolean inJoin, Offset offset) {
+    Address startAddress = Magic.objectAsAddress(inJoin ? joinInstructions : instructions);
+    return startAddress.plus(offset);
+  }
 
   /**
    * Return the code array for this method that contains the given offset.
@@ -263,10 +283,31 @@ public abstract class CompiledMethod implements SizeConstants {
   /**
    * Does the code for the compiled method contain the given return address?
    * @param ip a return address
-   * @return {@code true} if it belongs to this method's code, {@code false} otherwise.
+   * @return true if it belongs to this method's code, false otherwise.
    */
   @Uninterruptible
   public final boolean containsReturnAddress(Address ip) {
+    return inRange(ip, instructions) || inJoinInstructions(ip);
+  }
+
+  @Uninterruptible
+  public final boolean inJoinInstructions(Address ip) {
+    return joinInstructions != null && inRange(ip, joinInstructions);
+  }
+
+  @Uninterruptible
+  public final boolean hasJoinInstructions() {
+    return joinInstructions != null && joinInstructions != instructions;
+  }
+
+
+  @Uninterruptible
+  public final Offset joinDelta() {
+    return Magic.objectAsAddress(joinInstructions).diff(Magic.objectAsAddress(instructions));
+  }
+  
+  @Uninterruptible
+  private static final boolean inRange(Address ip, CodeArray instructions) {
     Address beg = Magic.objectAsAddress(instructions);
     Address end = beg.plus(instructions.length() << ArchitectureSpecific.ArchConstants.LG_INSTRUCTION_WIDTH);
 
@@ -280,8 +321,9 @@ public abstract class CompiledMethod implements SizeConstants {
   /**
    * Record that the compilation is complete.
    */
-  public final void compileComplete(CodeArray code) {
+  public final void compileComplete(CodeArray code, CodeArray joinCode) {
     instructions = code;
+    joinInstructions = joinCode;
     flags |= COMPILED;
   }
 
@@ -311,7 +353,7 @@ public abstract class CompiledMethod implements SizeConstants {
   }
 
   /**
-   * Mark the compiled method as outdated (i.e. requires OSR),
+   * Mark the compiled method as outdated (ie requires OSR),
    * the flag is set in AnalyticModel
    */
   @Uninterruptible
@@ -358,14 +400,14 @@ public abstract class CompiledMethod implements SizeConstants {
     return (flags & ACTIVE_ON_STACK) != 0;
   }
 
-  public final double getCompilationTime() { return compilationTime; }
+  public final double getCompilationTime() { return (double) compilationTime; }
 
   public final void setCompilationTime(double ct) { compilationTime = (float) ct; }
 
   /**
    * Identify the compiler that produced this compiled method.
    * @return one of TRAP, BASELINE, OPT, or JNI.
-   * Note: use this instead of "instanceof" when GC is disabled (i.e. during GC)
+   * Note: use this instead of "instanceof" when gc is disabled (ie. during gc)
    */
   @Uninterruptible
   public abstract int getCompilerType();
@@ -402,7 +444,12 @@ public abstract class CompiledMethod implements SizeConstants {
   /**
    * Find "catch" block for a machine instruction of
    * this method that might be guarded
-   * against specified class of exceptions by a "try" block.<p>
+   * against specified class of exceptions by a "try" block .
+   *
+   * @param instructionOffset offset of machine instruction from start of this method, in bytes
+   * @param exceptionType type of exception being thrown - something like "NullPointerException"
+   * @return offset of machine instruction for catch block
+   * (-1 --> no catch block)
    *
    * Notes:
    * <ul>
@@ -411,9 +458,9 @@ public abstract class CompiledMethod implements SizeConstants {
    * instruction whose catch block is sought.
    * This allows us to properly handle the case where
    * the only address we have to work with is a return address
-   * (i.e. from a stackframe)
+   * (ie. from a stackframe)
    * or an exception address
-   * (i.e. from a {@code null} pointer dereference, array bounds check,
+   * (ie. from a null pointer dereference, array bounds check,
    * or divide by zero) on a machine architecture with variable length
    * instructions.
    * In such situations we'd have no idea how far to back up the
@@ -421,20 +468,18 @@ public abstract class CompiledMethod implements SizeConstants {
    * to point to the "call site" or "exception site".
    *
    * <li> This method must not cause any allocations, because it executes with
-   * GC disabled when called by RuntimeEntrypoints.deliverException().
+   * gc disabled when called by RuntimeEntrypoints.deliverException().
    * </ul>
-   *
-   * @param instructionOffset offset of machine instruction from start of this method, in bytes
-   * @param exceptionType type of exception being thrown - something like "NullPointerException"
-   * @return offset of machine instruction for catch block
-   * (-1 --> no catch block)
    */
   @Unpreemptible
-  public abstract int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType);
+  public abstract Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType);
 
   /**
    * Fetch symbolic reference to a method that's called by one of
-   * this method's instructions.<p>
+   * this method's instructions.
+   * @param dynamicLink place to put return information
+   * @param instructionOffset offset of machine instruction from start of
+   * this method, in bytes
    *
    * Notes:
    * <ul>
@@ -443,7 +488,7 @@ public abstract class CompiledMethod implements SizeConstants {
    * instruction whose target method is sought.
    * This allows us to properly handle the case where
    * the only address we have to work with is a return address
-   * (i.e. from a stackframe)
+   * (ie. from a stackframe)
    * on a machine architecture with variable length instructions.
    * In such situations we'd have no idea how far to back up the
    * instruction pointer
@@ -451,12 +496,8 @@ public abstract class CompiledMethod implements SizeConstants {
    *
    * <li> The implementation must not cause any allocations,
    * because it executes with
-   * GC disabled when called by GCMapIterator.
+   * gc disabled when called by GCMapIterator.
    * <ul>
-   *
-   * @param dynamicLink place to put return information
-   * @param instructionOffset offset of machine instruction from start of
-   * this method, in bytes
    */
   @Uninterruptible
   public abstract void getDynamicLink(DynamicLink dynamicLink, Offset instructionOffset);
@@ -464,6 +505,9 @@ public abstract class CompiledMethod implements SizeConstants {
   /**
    * Find source line number corresponding to one of this method's
    * machine instructions.
+   * @param instructionOffset of machine instruction from start of this method, in bytes
+   * @return source line number
+   * (0 == no line info available, 1 == first line of source file)
    *
    * <p> Usage note: "instructionOffset" must point to the
    * instruction <em> following </em> the actual instruction
@@ -478,11 +522,6 @@ public abstract class CompiledMethod implements SizeConstants {
    * In such situations we'd have no idea how far to back up the
    * instruction pointer
    * to point to the "call site" or "exception site".
-   *
-   * @param instructionOffset of machine instruction from start of this method, in bytes
-   * @return source line number
-   * (0 == no line info available, 1 == first line of source file)
-   *
    */
   @Uninterruptible
   public int findLineNumberForInstruction(Offset instructionOffset) {
@@ -494,7 +533,7 @@ public abstract class CompiledMethod implements SizeConstants {
    * of the compiled method's code array) corresponds to an uninterruptible context.
    *
    * @param instructionOffset of addr from start of instructions in bytes
-   * @return {@code true} if the IP is within an Uninterruptible method, {@code false} otherwise.
+   * @return true if the IP is within an Uninterruptible method, false otherwise.
    */
   @Interruptible
   public abstract boolean isWithinUninterruptibleCode(Offset instructionOffset);
@@ -519,7 +558,7 @@ public abstract class CompiledMethod implements SizeConstants {
   /**
    * Return the number of bytes used to encode the compiler-specific mapping
    * information for this compiled method.
-   * Used to gather statistics on the space costs of mapping schemes.
+   * Used to gather stats on the space costs of mapping schemes.
    */
   public int size() { return 0; }
 
diff --git a/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java b/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java
index bde1f38..7eed646 100644
--- a/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java
+++ b/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java
@@ -17,7 +17,9 @@ import org.jikesrvm.Services;
 import org.jikesrvm.classloader.DynamicTypeCheck;
 import org.jikesrvm.classloader.RVMType;
 import org.jikesrvm.objectmodel.TIB;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
 import org.vmmagic.pragma.Unpreemptible;
+import org.vmmagic.pragma.UnpreemptibleNoWarn;
 import org.vmmagic.unboxed.Offset;
 
 /**
@@ -41,10 +43,11 @@ public abstract class ExceptionTable {
    * @param eTable the encoded exception table to search
    * @param instructionOffset the offset of the instruction after the PEI.
    * @param exceptionType the type of exception that was raised
+   * @param exactType only match exact exception types.
    * @return the machine code offset of the catch block.
    */
   @Unpreemptible
-  public static int findCatchBlockForInstruction(int[] eTable, Offset instructionOffset, RVMType exceptionType) {
+  public static Offset findCatchBlockForInstruction(int[] eTable, Offset instructionOffset, RVMType exceptionType, boolean exactType) {
     for (int i = 0, n = eTable.length; i < n; i += 4) {
       // note that instructionOffset points to the instruction after the PEI
       // so the range check here must be "offset >  beg && offset <= end"
@@ -55,18 +58,18 @@ public abstract class ExceptionTable {
           instructionOffset.sLE(Offset.fromIntSignExtend(eTable[i + TRY_END]))) {
         RVMType lhs = RVMType.getType(eTable[i + EX_TYPE]);
         if (lhs == exceptionType) {
-          return eTable[i + CATCH_START];
-        } else if (lhs.isInitialized()) {
+          return Offset.fromIntSignExtend(eTable[i + CATCH_START]);
+        } else if (!exactType && lhs.isInitialized()) {
           TIB rhsTIB = exceptionType.getTypeInformationBlock();
           if (DynamicTypeCheck.instanceOfClass(lhs.asClass(), rhsTIB)) {
-            return eTable[i + CATCH_START];
+            return Offset.fromIntSignExtend(eTable[i + CATCH_START]);
           }
         }
       }
     }
-    return -1;
+    return Offset.fromIntSignExtend(-1);
   }
-
+  
   /**
    * Print an encoded exception table.
    * @param eTable the encoded exception table to print.
diff --git a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java
index 768189b..7c7e15f 100644
--- a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java
+++ b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java
@@ -56,8 +56,8 @@ final class HardwareTrapCompiledMethod extends CompiledMethod {
 
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
-    return -1;
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
+    return Offset.fromIntSignExtend(-1);
   }
 
   @Override
diff --git a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java
index 8dbc213..40792f9 100644
--- a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java
@@ -19,7 +19,7 @@ import org.jikesrvm.runtime.Magic;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 /**
  * Iterator for stack frames inserted by hardware trap handler.
@@ -29,7 +29,7 @@ import org.vmmagic.unboxed.WordArray;
 @Uninterruptible
 public final class HardwareTrapGCMapIterator extends GCMapIterator implements SizeConstants {
 
-  public HardwareTrapGCMapIterator(WordArray registerLocations) {
+  public HardwareTrapGCMapIterator(AddressArray registerLocations) {
     this.registerLocations = registerLocations;
   }
 
@@ -38,6 +38,18 @@ public final class HardwareTrapGCMapIterator extends GCMapIterator implements Si
     this.framePtr = framePtr;
   }
 
+  public final int getNVRegistersSaved() {
+    int result = 0;
+    for (int i=0; i< ArchitectureSpecific.ArchConstants.NONVOLATILE_GPRS.length; i++) {
+      result |= (1 << ArchitectureSpecific.ArchConstants.NONVOLATILE_GPRS[i].value());
+    }
+    return result;
+  }
+
+  public final int getNVObjectMap() {
+    return 0;
+  }
+
   @Override
   public Address getNextReferenceAddress() {
     // update register locations, noting that the trap handler represented by this stackframe
@@ -45,7 +57,7 @@ public final class HardwareTrapGCMapIterator extends GCMapIterator implements Si
     //
     Address registerLocation = Magic.objectAsAddress(thread.getExceptionRegisters().gprs);
     for (int i = 0; i < ArchitectureSpecific.ArchConstants.NUM_GPRS; ++i) {
-      registerLocations.set(i, registerLocation.toWord());
+      registerLocations.set(i, registerLocation);
       registerLocation = registerLocation.plus(BYTES_IN_ADDRESS);
     }
     return Address.zero();
diff --git a/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java b/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java
index 8394d31..3a4079a 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java
@@ -176,7 +176,7 @@ public final class OptimizingCompiler implements Callbacks.StartupMonitor {
       // system a chance to eagerly compile any specialized version
       // that are pending.  TODO: use lazy compilation with specialization.
       SpecializationDatabase.doDeferredSpecializations();
-      ir.compiledMethod.compileComplete(ir.MIRInfo.machinecode);
+      ir.compiledMethod.compileComplete(ir.MIRInfo.fastmachinecode, ir.MIRInfo.machinecode);
       return ir.compiledMethod;
     } catch (OptimizingCompilerException e) {
       throw e;
diff --git a/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java b/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java
index c3857f7..ba2d394 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java
@@ -27,6 +27,11 @@ public final class MIRInfo {
   public CodeArray machinecode;
 
   /**
+   * The generated machinecodes produced by this compilation of 'method'
+   */
+  public CodeArray fastmachinecode;
+
+  /**
    * Estimate produced by FinalMIRExpansion and used by
    * Assembler to create code array; only meaningful on PowerPC
    */
diff --git a/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java b/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java
index eee1f4e..8610fdb 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java
@@ -1072,6 +1072,7 @@ abstract class AssemblerBase extends Assembler
     }
 
     ir.MIRInfo.machinecode = asm.getMachineCodes();
+    ir.MIRInfo.fastmachinecode = asm.patchMachineCodeForWorkStealing(ir.MIRInfo.machinecode);
 
     return ir.MIRInfo.machinecode.length();
   }
diff --git a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java
index a7e89e6..a9e1e62 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java
@@ -79,11 +79,11 @@ public final class OptCompiledMethod extends CompiledMethod {
    */
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
     if (eTable == null) {
-      return -1;
+      return Offset.fromIntSignExtend(-1);
     } else {
-      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType);
+      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType, exactType);
     }
   }
 
diff --git a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java
index 29e1aa1..6b1e863 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java
@@ -24,7 +24,7 @@ import org.jikesrvm.runtime.Magic;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 /**
  * This class contains its architecture-independent code for iteration
@@ -83,7 +83,7 @@ public abstract class OptGenericGCMapIterator extends GCMapIterator
   static final boolean lookForMissedReferencesInSpills = false;
 
   // Constructor
-  protected OptGenericGCMapIterator(WordArray registerLocations) {
+  protected OptGenericGCMapIterator(AddressArray registerLocations) {
     super();
     this.registerLocations = registerLocations;
   }
@@ -178,6 +178,34 @@ public abstract class OptGenericGCMapIterator extends GCMapIterator
     }
   }
 
+  public final int getNVRegistersSaved() {
+    int result = 0;
+    int frameOffset = compiledMethod.getUnsignedNonVolatileOffset();
+    if (frameOffset >= 0) {
+      int first = compiledMethod.getFirstNonVolatileGPR();
+      if (first >= 0) {
+        for (int i = first; i < NUM_NONVOLATILE_GPRS; i++) {
+          result |= (1 << NONVOLATILE_GPRS[i].value());
+        }
+      }
+    }
+    return result;
+  }
+
+  public final int getNVObjectMap() {
+    int result = 0;
+    if (mapIndex == OptGCMap.NO_MAP_ENTRY) {
+      return 0;
+    }
+    for(int i=0; i < NONVOLATILE_GPRS.length; i++) {
+      int reg = NONVOLATILE_GPRS[i].value();
+      if (map.registerIsSet(mapIndex, reg)) {
+        result |= (1 << reg);
+      }
+    }
+    return result;
+  }
+
   /**
    * Returns the next address that contains a reference
    * @return the value of the next reference
@@ -215,7 +243,7 @@ public abstract class OptGenericGCMapIterator extends GCMapIterator
       if (currentRegisterIsValid()) {
         Address regLocation;
         // currentRegister contains a reference, return that location
-        regLocation = registerLocations.get(getCurrentRegister()).toAddress();
+        regLocation = registerLocations.get(getCurrentRegister());
         if (DEBUG) {
           VM.sysWrite(" *** Ref found in reg#");
           VM.sysWrite(getCurrentRegister());
@@ -414,7 +442,7 @@ public abstract class OptGenericGCMapIterator extends GCMapIterator
    */
   final void checkRegistersForMissedReferences(int firstReg, int lastReg) {
     for (int i = firstReg; i <= lastReg; i++) {
-      Address regLocation = registerLocations.get(i).toAddress();
+      Address regLocation = registerLocations.get(i);
       Address regValue = regLocation.loadAddress();
       if (MemoryManager.addressInVM(regValue)) {
         VM.sysWrite("  reg#", getCurrentRegister());
diff --git a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptGCMapIterator.java b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptGCMapIterator.java
index 1bd6155..9f0913d 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptGCMapIterator.java
@@ -18,7 +18,7 @@ import org.jikesrvm.compilers.opt.runtimesupport.OptGenericGCMapIterator;
 import org.jikesrvm.ia32.StackframeLayoutConstants;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 /**
  * An instance of this class provides iteration across the references
@@ -33,7 +33,7 @@ public abstract class OptGCMapIterator extends OptGenericGCMapIterator implement
 
   private static final boolean DEBUG = false;
 
-  public OptGCMapIterator(WordArray registerLocations) {
+  public OptGCMapIterator(AddressArray registerLocations) {
     super(registerLocations);
   }
 
@@ -85,7 +85,7 @@ public abstract class OptGCMapIterator extends OptGenericGCMapIterator implement
         for (int i = first; i < NUM_NONVOLATILE_GPRS; i++) {
           // determine what register index corresponds to this location
           int registerIndex = NONVOLATILE_GPRS[i].value();
-          registerLocations.set(registerIndex, location.toWord());
+          registerLocations.set(registerIndex, location);
           if (DEBUG) {
             VM.sysWrite("UpdateRegisterLocations: Register ");
             VM.sysWrite(registerIndex);
@@ -105,7 +105,7 @@ public abstract class OptGCMapIterator extends OptGenericGCMapIterator implement
         for (int i = 0; i < NUM_VOLATILE_GPRS; i++) {
           // determine what register index corresponds to this location
           int registerIndex = VOLATILE_GPRS[i].value();
-          registerLocations.set(registerIndex, location.toWord());
+          registerLocations.set(registerIndex, location);
           if (DEBUG) {
             VM.sysWrite("UpdateRegisterLocations: Register ");
             VM.sysWrite(registerIndex);
diff --git a/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java b/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java
index 5535f1d..e9e6ce3 100644
--- a/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java
+++ b/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java
@@ -509,7 +509,7 @@ public abstract class OutOfLineMachineCode implements BaselineConstants {
     Assembler asm = new ArchitectureSpecific.Assembler(0);
 
     /* push the hijacked return address (which is held in thread-local state) */
-    asm.emitPUSH_RegDisp(TR, ArchEntrypoints.hijackedReturnAddressField.getOffset());
+//    asm.emitPUSH_RegDisp(TR, ArchEntrypoints.hijackedReturnAddressField.getOffset()); //commented due to work-stealing changes
 
     /* push the GPRs and fp */
     for (int i = 0; i < NUM_GPRS; i++) {
@@ -526,6 +526,18 @@ public abstract class OutOfLineMachineCode implements BaselineConstants {
       asm.emitPOP_Reg(ALL_GPRS[i]);
     }
 
+    /*
+     * When doing Try-Catch work-stealing, it might be the case that the victim is intended to
+     * return to an address A from the return barrier, but once it has branched into the 
+     * return barrier it finds that now that return address A is no more valid
+     * as it has been stolen. Now in this case it should not return to A and instead
+     * return to some new address B. This change is possible only if the return address
+     * is PUSH at this point and not in the begining of this call --  generateStackTrampolineBridgeInstructions().
+     */
+    
+    /* push the hijacked return address (which is held in thread-local state) */
+    asm.emitPUSH_RegDisp(TR, ArchEntrypoints.hijackedReturnAddressField.getOffset());
+    
     /* pop the hijacked return address and return */
     asm.emitRET();
 
diff --git a/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java b/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java
index 9722a26..1eee9ce 100644
--- a/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java
+++ b/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java
@@ -89,8 +89,8 @@ public final class JNICompiledMethod extends CompiledMethod {
 
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
-    return -1;
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
+    return Offset.fromIntSignExtend(-1);
   }
 
   @Override
diff --git a/rvm/src/org/jikesrvm/jni/JNIFunctions.java b/rvm/src/org/jikesrvm/jni/JNIFunctions.java
index 6c3279f..04a7b7f 100644
--- a/rvm/src/org/jikesrvm/jni/JNIFunctions.java
+++ b/rvm/src/org/jikesrvm/jni/JNIFunctions.java
@@ -5594,7 +5594,7 @@ public class JNIFunctions implements SizeConstants {
 
     try {
       Object obj = env.getJNIRef(objJREF);
-      ObjectModel.genericLock(obj);
+      ObjectModel.genericLock_internal(obj);
       return 0;
     } catch (Throwable unexpected) {
       if (traceJNI) unexpected.printStackTrace(System.err);
@@ -5614,7 +5614,7 @@ public class JNIFunctions implements SizeConstants {
 
     try {
       Object obj = env.getJNIRef(objJREF);
-      ObjectModel.genericUnlock(obj);
+      ObjectModel.genericUnlock_internal(obj);
       return 0;
     } catch (Throwable unexpected) {
       if (traceJNI) unexpected.printStackTrace(System.err);
diff --git a/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java b/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java
index 8e3b094..a7b4c58 100644
--- a/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java
+++ b/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java
@@ -555,7 +555,7 @@ public abstract class JNICompiler implements BaselineConstants {
     }
 
     MachineCode machineCode = new ArchitectureSpecific.MachineCode(asm.getMachineCodes(), null);
-    cm.compileComplete(machineCode.getInstructions());
+    cm.compileComplete(machineCode.getInstructions(), machineCode.getInstructions());
     return cm;
   }
 
diff --git a/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java b/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java
index 5716989..61d1ce5 100644
--- a/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java
@@ -20,9 +20,8 @@ import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
-import org.vmmagic.unboxed.AddressArray;
 import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 /**
  * Iterator for stack frames inserted at the transition from Java to
@@ -60,10 +59,18 @@ public abstract class JNIGCMapIterator extends GCMapIterator implements Baseline
   int jniNextRef;
   int jniFramePtr;
 
-  public JNIGCMapIterator(WordArray registerLocations) {
+  public JNIGCMapIterator(AddressArray registerLocations) {
     this.registerLocations = registerLocations;
   }
 
+  public final int getNVRegistersSaved() {
+    return (1 << EDI.value()) | (1 << EBX.value()) | (1 << EBP.value());
+  }
+
+  public final int getNVObjectMap() {
+    return 0;
+  }
+
   // Override newStackWalk() in parent class GCMapIterator to
   // initialize iterator for scan of JNI JREFs stack of refs
   // Taken:    thread
@@ -120,9 +127,9 @@ public abstract class JNIGCMapIterator extends GCMapIterator implements Baseline
     // the JNI transition frame at a fixed negative offset from the callers FP.
     // the save non-volatiles are EBX EBP and EDI.
     //
-    registerLocations.set(EDI.value(), framePtr.plus(JNICompiler.EDI_SAVE_OFFSET).toWord());
-    registerLocations.set(EBX.value(), framePtr.plus(JNICompiler.EBX_SAVE_OFFSET).toWord());
-    registerLocations.set(EBP.value(), framePtr.plus(JNICompiler.EBP_SAVE_OFFSET).toWord());
+    registerLocations.set(EDI.value(), framePtr.plus(JNICompiler.EDI_SAVE_OFFSET));
+    registerLocations.set(EBX.value(), framePtr.plus(JNICompiler.EBX_SAVE_OFFSET));
+    registerLocations.set(EBP.value(), framePtr.plus(JNICompiler.EBP_SAVE_OFFSET));
 
     return Address.zero();  // no more refs to report
   }
diff --git a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java
index ac3012d..9685b9c 100644
--- a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java
+++ b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java
@@ -16,8 +16,8 @@ import org.jikesrvm.compilers.common.CompiledMethod;
 import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.AddressArray;
 import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
 
 /**
  * Base class for iterators that identify object references and JSR return addresses
@@ -36,7 +36,7 @@ public abstract class GCMapIterator {
   public Address framePtr;
 
   /** address where each gpr register was saved by previously scanned stackframe(s) */
-  public WordArray registerLocations;
+  public AddressArray registerLocations;
 
   /**
    * Prepare to scan a thread's stack and saved registers for object references.
@@ -46,7 +46,7 @@ public abstract class GCMapIterator {
   public void newStackWalk(RVMThread thread) {
     this.thread = thread;
   }
-
+  
   /**
    * Prepare to iterate over object references and JSR return addresses held by a stackframe.
    *
@@ -90,6 +90,10 @@ public abstract class GCMapIterator {
    */
   public abstract void cleanupPointers();
 
+  public abstract int getNVRegistersSaved();
+
+  public abstract int getNVObjectMap();
+
   /**
    * Get the type of this iterator (BASELINE, OPT, etc.).
    * Called from GCMapIteratorGroup to select which iterator
diff --git a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java
index ca9e2df..e2cf112 100644
--- a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java
+++ b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java
@@ -23,18 +23,21 @@ import org.jikesrvm.compilers.common.HardwareTrapGCMapIterator;
 import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.AddressArray;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
 import org.vmmagic.unboxed.WordArray;
 
 /**
  * Maintains a collection of compiler specific GCMapIterators that are used
  * by collection threads when scanning thread stacks to locate object references
  * in those stacks. Each collector thread has its own GCMapIteratorGroup.
- * <p>
+ *
  * The group contains a GCMapIterator for each type of stack frame that
  * may be found while scanning a stack during garbage collection, including
  * frames for baseline compiled methods, OPT compiled methods, and frames
  * for transitions from Java into JNI native code. These iterators are
- * responsible for reporting the location of references in the stack or
+ * repsonsible for reporting the location of references in the stack or
  * register save areas.
  *
  * @see GCMapIterator
@@ -44,7 +47,7 @@ import org.vmmagic.unboxed.WordArray;
 public final class GCMapIteratorGroup implements SizeConstants {
 
   /** current location (memory address) of each gpr register */
-  private final WordArray registerLocations;
+  private final AddressArray registerLocations;
 
   /** iterator for baseline compiled frames */
   private final GCMapIterator baselineIterator;
@@ -59,7 +62,7 @@ public final class GCMapIteratorGroup implements SizeConstants {
   private final GCMapIterator jniIterator;
 
   public GCMapIteratorGroup() {
-    registerLocations = WordArray.create(ArchitectureSpecific.ArchConstants.NUM_GPRS);
+    registerLocations = AddressArray.create(ArchitectureSpecific.ArchConstants.NUM_GPRS);
 
     baselineIterator = new BaselineGCMapIterator(registerLocations);
     if (VM.BuildForOptCompiler) {
@@ -70,7 +73,19 @@ public final class GCMapIteratorGroup implements SizeConstants {
     jniIterator = new JNIGCMapIterator(registerLocations);
     hardwareTrapIterator = new HardwareTrapGCMapIterator(registerLocations);
   }
-
+  
+  @Uninterruptible
+  public void dump() {
+	  VM.sysWrite("GCMapIteratorGroup: registerLocations:");
+	  for(int i=0; i<ArchitectureSpecific.ArchConstants.NUM_GPRS; i++)  {
+		  VM.sysWrite("[",i,"] = ");
+		  VM.sysWrite(registerLocations.get(i));
+		  VM.sysWrite(":",registerLocations.get(i).loadWord());
+		  VM.sysWrite(" ");
+	  }
+	  VM.sysWriteln();
+  }
+  
   /**
    * Prepare to scan a thread's stack for object references.
    * Called by collector threads when beginning to scan a threads stack.
@@ -87,7 +102,7 @@ public final class GCMapIteratorGroup implements SizeConstants {
   @Uninterruptible
   public void newStackWalk(RVMThread thread, Address registerLocation) {
     for (int i = 0; i < ArchitectureSpecific.ArchConstants.NUM_GPRS; ++i) {
-      registerLocations.set(i, registerLocation.toWord());
+      registerLocations.set(i, registerLocation);
       registerLocation = registerLocation.plus(BYTES_IN_ADDRESS);
     }
     baselineIterator.newStackWalk(thread);
@@ -99,6 +114,24 @@ public final class GCMapIteratorGroup implements SizeConstants {
   }
 
   /**
+   * Copy out the current register values from register location information.
+   *
+   * @param registerLocation Where to copy the values to.
+   */
+  @Uninterruptible
+  public void copyRegisterValues(Address registerLocation) {
+    for (int i = 0; i < ArchitectureSpecific.ArchConstants.NUM_GPRS; ++i) {
+      registerLocation.store(registerLocations.get(i).loadWord());
+      registerLocation = registerLocation.plus(BYTES_IN_ADDRESS);
+    }
+  }
+
+  @Uninterruptible
+  public Address getRegisterLocation(int reg) {
+    return registerLocations.get(reg);
+  }
+
+  /**
    * Select iterator for scanning for object references in a stackframe.
    * Called by collector threads while scanning a threads stack.
    *
diff --git a/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java b/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java
index b063e9d..0b2518a 100644
--- a/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java
+++ b/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java
@@ -23,6 +23,7 @@ import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.scheduler.Lock;
 import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.scheduler.WS;
 import org.vmmagic.pragma.Entrypoint;
 import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.Interruptible;
@@ -467,6 +468,7 @@ public class ObjectModel implements JavaHeaderConstants, SizeConstants {
   @Entrypoint
   @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
   public static void genericLock(Object o) {
+	WS.pauseStealOnThread();
     JavaHeader.genericLock(o);
   }
 
@@ -477,6 +479,25 @@ public class ObjectModel implements JavaHeaderConstants, SizeConstants {
   @Unpreemptible("No preemption normally, but may raise exceptions")
   public static void genericUnlock(Object o) {
     JavaHeader.genericUnlock(o);
+    WS.resumeStealOnThread();
+  }
+
+  /**
+   * Generic lock - Work-Stealing Specific
+   */
+  @Entrypoint
+  @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
+  public static void genericLock_internal(Object o) {
+    JavaHeader.genericLock(o);
+  }
+
+  /**
+   * Generic lock - Work-Stealing Specific
+   */
+  @Entrypoint
+  @Unpreemptible("No preemption normally, but may raise exceptions")
+  public static void genericUnlock_internal(Object o) {
+    JavaHeader.genericUnlock(o);
   }
 
   /**
diff --git a/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java b/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java
index aa468b7..15aabd9 100644
--- a/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java
+++ b/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java
@@ -46,7 +46,7 @@ public interface ArchEntrypoints {
   RVMField trampolineRegistersField =
         EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "trampolineRegisters", "Lorg/jikesrvm/ArchitectureSpecific$Registers;");
   RVMField hijackedReturnAddressField =
-    EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "hijackedReturnAddress", "Lorg/vmmagic/unboxed/Address;");
+    EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "hijackedReturnAddress_original", "Lorg/vmmagic/unboxed/Address;");
    RVMField registersIPField =
       EntrypointHelper.getField("Lorg/jikesrvm/" + arch + "/Registers;", "ip", "Lorg/vmmagic/unboxed/Address;");
   RVMField registersFPRsField = EntrypointHelper.getField("Lorg/jikesrvm/" + arch + "/Registers;", "fprs", "[D");
diff --git a/rvm/src/org/jikesrvm/runtime/BootRecord.java b/rvm/src/org/jikesrvm/runtime/BootRecord.java
index 8ea6eae..45b5721 100644
--- a/rvm/src/org/jikesrvm/runtime/BootRecord.java
+++ b/rvm/src/org/jikesrvm/runtime/BootRecord.java
@@ -256,6 +256,11 @@ public class BootRecord {
   public Address sysNumProcessorsIP;
   public Address sysThreadBindSupportedIP;
   public Address sysThreadBindIP;
+  public Address sysThreadBindMaskSetIP;
+  public Address wsIniatilizeSysThreadBindMaskIP;
+  public Address wsThreadBindMaskSetIP;
+  public Address sysCheckNUMAnodeIP;
+  public Address sysGetCPUIP;
   public Address sysThreadCreateIP;
   public Address sysThreadYieldIP;
   public Address sysGetThreadIdIP;
@@ -380,5 +385,14 @@ public class BootRecord {
   public Address sysPerfEventEnableIP;
   public Address sysPerfEventDisableIP;
   public Address sysPerfEventReadIP;
+  
+  // per thread perf event support
+  public Address sysPerfEventInit_threadIP;
+  public Address sysPerfEventCreate_threadIP;
+  public Address sysPerfEventOpen_threadIP;
+  public Address sysPerfEventClose_threadIP;
+  public Address sysPerfEventEnable_threadIP;
+  public Address sysPerfEventDisable_threadIP;
+  public Address sysPerfEventRead_threadIP;
 
 }
diff --git a/rvm/src/org/jikesrvm/runtime/Entrypoints.java b/rvm/src/org/jikesrvm/runtime/Entrypoints.java
index bfd53a4..91ad319 100644
--- a/rvm/src/org/jikesrvm/runtime/Entrypoints.java
+++ b/rvm/src/org/jikesrvm/runtime/Entrypoints.java
@@ -16,6 +16,7 @@ import static org.jikesrvm.runtime.EntrypointHelper.getField;
 import static org.jikesrvm.runtime.EntrypointHelper.getMethod;
 
 import org.jikesrvm.VM;
+import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.NormalMethod;
@@ -26,7 +27,7 @@ import org.jikesrvm.classloader.NormalMethod;
  */
 public class Entrypoints {
   // The usual causes for getField/Method() to fail are:
-  //  1. you misspelled the class name, member name, or member signature
+  //  1. you mispelled the class name, member name, or member signature
   //  2. the class containing the specified member didn't get compiled
   //
 
@@ -239,7 +240,6 @@ public class Entrypoints {
                "exceptionRegisters",
                org.jikesrvm.ArchitectureSpecific.Registers.class);
   public static final NormalMethod returnBarrierMethod = getMethod(org.jikesrvm.scheduler.RVMThread.class, "returnBarrier", "()V");
-
   public static final RVMField tracePrevAddressField =
       getField(org.jikesrvm.objectmodel.MiscHeader.class, "prevAddress", org.vmmagic.unboxed.Word.class);
   public static final RVMField traceOIDField =
@@ -250,6 +250,10 @@ public class Entrypoints {
   public static final RVMField lockThreadField =
       getField(org.jikesrvm.mm.mmtk.Lock.class, "thread", org.jikesrvm.scheduler.RVMThread.class);
   */
+  
+  public static final RVMField wsFinishCountField = getField(org.jikesrvm.scheduler.WS.FinishInfo.class, "count", int.class);
+  public static final RVMField wsFinishDataField = getField(org.jikesrvm.scheduler.WS.FinishInfo.class, "data", org.jikesrvm.scheduler.WS.FinishData.class);
+  
   public static final RVMField lockStateField = getField(org.jikesrvm.mm.mmtk.Lock.class, "state", int.class);
   public static final RVMField gcStatusField = getField(org.mmtk.plan.Plan.class, "gcStatus", int.class);
   public static final RVMField SQCFField = getField(org.mmtk.utility.deque.SharedDeque.class, "completionFlag", int.class);
@@ -373,6 +377,11 @@ public class Entrypoints {
   public static final NormalMethod modifyCheckMethod =
       getMethod(org.jikesrvm.mm.mminterface.MemoryManager.class, "modifyCheck", "(Ljava/lang/Object;)V");
 
+  public static final MemberReference workStealingJoinMethod =
+    getMethod(org.jikesrvm.scheduler.WS.class, "join", "()V").getMemberRef();
+  public static final MemberReference workStealingFinishMethod =
+    getMethod(org.jikesrvm.scheduler.WS.class, "finish", "()V").getMemberRef();
+
   // used in boot image writer
   public static final RVMField debugRequestedField =
       getField(org.jikesrvm.scheduler.RVMThread.class, "debugRequested", boolean.class);
diff --git a/rvm/src/org/jikesrvm/runtime/Magic.java b/rvm/src/org/jikesrvm/runtime/Magic.java
index 482dec1..bbb36db 100644
--- a/rvm/src/org/jikesrvm/runtime/Magic.java
+++ b/rvm/src/org/jikesrvm/runtime/Magic.java
@@ -178,6 +178,11 @@ public final class Magic {
   public static Address getReturnAddress(Address fp) {
     return getReturnAddress(fp, RVMThread.getCurrentThread());
   }
+  
+  @Uninterruptible
+  public static Address getReturnAddress_debug(Address fp) {
+    return getReturnAddress_debug(fp, RVMThread.getCurrentThread());
+  }
 
   /**
    * Get return address for a frame in a specific thread
@@ -194,6 +199,17 @@ public final class Magic {
       return ip;
   }
 
+  @Uninterruptible
+  public static Address getReturnAddress_debug(Address fp, RVMThread thread) {
+    Address ip = getReturnAddressLocation(fp).loadAddress();
+    if (RVMThread.isTrampolineIP(ip)) {
+    	VM.sysWrite("<H>");
+    	return thread.getTrampolineHijackedReturnAddress();
+    }
+    else
+      return ip;
+  }
+
   /**
    * Get return address for a frame
    * @param fp its frame pointer
diff --git a/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java b/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java
index 6f8dd04..4f77bc3 100644
--- a/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java
+++ b/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java
@@ -689,12 +689,16 @@ public class RuntimeEntrypoints implements Constants, ArchitectureSpecific.Stack
   @Entrypoint
   @UnpreemptibleNoWarn
   static void deliverHardwareException(int trapCode, int trapInfo) {
-    if (false) VM.sysWriteln("delivering hardware exception");
+    if (true) VM.sysWriteln("delivering hardware exception");
     RVMThread myThread = RVMThread.getCurrentThread();
-    if (false) VM.sysWriteln("we have a thread = ",Magic.objectAsAddress(myThread));
-    if (false) VM.sysWriteln("it's in state = ",myThread.getExecStatus());
+    if (true) {
+    	VM.sysWriteln("we have a thread = ",Magic.objectAsAddress(myThread));
+    	VM.sysWriteln("The thread id = ",myThread.getId());
+    }
+    if (true) VM.sysWriteln("it's in state = ",myThread.getExecStatus());
+    RVMThread.dumpWSDetailsWhileDeliveringHardwareException();
     Registers exceptionRegisters = myThread.getExceptionRegisters();
-    if (false) VM.sysWriteln("we have exception registers = ",Magic.objectAsAddress(exceptionRegisters));
+    if (true) VM.sysWriteln("we have exception registers = ",Magic.objectAsAddress(exceptionRegisters));
 
     if ((trapCode == TRAP_STACK_OVERFLOW || trapCode == TRAP_JNI_STACK) &&
         myThread.getStack().length < (STACK_SIZE_MAX >> LOG_BYTES_IN_ADDRESS) &&
@@ -1006,7 +1010,7 @@ public class RuntimeEntrypoints implements Constants, ArchitectureSpecific.Stack
    * @param exceptionRegisters register state corresponding to exception site
    */
   @Unpreemptible("Deliver exception trying to avoid preemption")
-  private static void deliverException(Throwable exceptionObject, Registers exceptionRegisters) {
+  public static void deliverException(Throwable exceptionObject, Registers exceptionRegisters) {
     if (VM.TraceExceptionDelivery) {
       VM.sysWriteln("RuntimeEntrypoints.deliverException() entered; just got an exception object.");
     }
@@ -1029,13 +1033,14 @@ public class RuntimeEntrypoints implements Constants, ArchitectureSpecific.Stack
       }
       int compiledMethodId = Magic.getCompiledMethodID(fp);
       if (compiledMethodId != INVISIBLE_METHOD_ID) {
-        CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
-        ExceptionDeliverer exceptionDeliverer = compiledMethod.getExceptionDeliverer();
-        Address ip = exceptionRegisters.getInnermostInstructionAddress();
-        Offset ipOffset = compiledMethod.getInstructionOffset(ip);
-        int catchBlockOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, exceptionType);
-
-        if (catchBlockOffset >= 0) {
+      CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+      ExceptionDeliverer exceptionDeliverer = compiledMethod.getExceptionDeliverer();
+      Address ip = exceptionRegisters.getInnermostInstructionAddress();
+      boolean inJoin = compiledMethod.inJoinInstructions(ip);
+   	  Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+   	  Offset catchBlockOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, exceptionType, false);
+
+   	  if (catchBlockOffset.sGE(Offset.zero())) {
           // found an appropriate catch block
           if (VM.TraceExceptionDelivery) {
             VM.sysWriteln("found one; delivering.");
@@ -1045,7 +1050,7 @@ public class RuntimeEntrypoints implements Constants, ArchitectureSpecific.Stack
             if (RVMThread.DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("leapfrogged...");
             t.deInstallStackTrampoline();
           }
-          Address catchBlockStart = compiledMethod.getInstructionAddress(Offset.fromIntSignExtend(catchBlockOffset));
+          Address catchBlockStart = compiledMethod.getInstructionAddress(inJoin, catchBlockOffset);
           exceptionDeliverer.deliverException(compiledMethod, catchBlockStart, exceptionObject, exceptionRegisters);
           if (VM.VerifyAssertions) VM._assert(NOT_REACHED);
         }
diff --git a/rvm/src/org/jikesrvm/runtime/SysCall.java b/rvm/src/org/jikesrvm/runtime/SysCall.java
index f02e229..0a194c7 100644
--- a/rvm/src/org/jikesrvm/runtime/SysCall.java
+++ b/rvm/src/org/jikesrvm/runtime/SysCall.java
@@ -55,6 +55,23 @@ public abstract class SysCall {
       throw new Error(e);
     }
   }
+  
+  /*
+   * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+   * From here---->
+   */
+  @SysCallTemplate
+  public abstract void wsThreadBindMaskSet(int cpuMask);
+  @SysCallTemplate
+  public abstract void sysThreadBindMaskSet();
+  @SysCallTemplate
+  public abstract void wsIniatilizeSysThreadBindMask(int cpuMask);
+  @SysCallTemplate
+  public abstract int sysGetCPU();
+  /*
+   * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+   * Till here <----
+   */
 
   // lowlevel write to console
   @SysCallTemplate
@@ -103,6 +120,26 @@ public abstract class SysCall {
 
   @SysCallTemplate
   public abstract void sysSyncCache(Address address, int size);
+  
+  /*
+   * Interface to per thred performance events
+   */
+  @SysCallTemplate
+  public abstract int sysCheckNUMAnode(Address location);
+  @SysCallTemplate
+  public abstract int sysPerfEventInit_thread(int events);
+  @SysCallTemplate
+  public abstract int sysPerfEventCreate_thread(int id, byte[] name);
+  @SysCallTemplate
+  public abstract void sysPerfEventClose_thread(int id, int[] fds);
+  @SysCallTemplate
+  public abstract void sysPerfEventOpen_thread(int id, Word tid, int[] fds);
+  @SysCallTemplate
+  public abstract int sysPerfEventEnable_thread(int[] fds, int n);
+  @SysCallTemplate
+  public abstract void sysPerfEventDisable_thread(int[] fds, int n);
+  @SysCallTemplate
+  public abstract int sysPerfEventRead_thread(int id, int[] fds, long[] values);
 
   /*
    * Interface to performance events
diff --git a/rvm/src/org/jikesrvm/scheduler/MainThread.java b/rvm/src/org/jikesrvm/scheduler/MainThread.java
index 908b168..9223d53 100644
--- a/rvm/src/org/jikesrvm/scheduler/MainThread.java
+++ b/rvm/src/org/jikesrvm/scheduler/MainThread.java
@@ -144,7 +144,17 @@ public final class MainThread extends Thread {
     launched = true;
 
     if (dbg) VM.sysWriteln("MainThread.run() starting ");
-
+    // Work-Stealing
+    if(RVMThread.autogenWSThread && !RVMThread.wsThreadsLaunched) {
+    	RVMThread.wsThreadsLaunched = true;
+    	Runnable tRun = new Runnable() {
+    		public void run() { WS.workerMain(); }
+    	};
+    	WS.register();
+    	for(int i=0; i<WS.wsProcs-1; i++) {
+    		new Thread(tRun).start();
+    	}
+    }
     // Set up application class loader
     ClassLoader cl = RVMClassLoader.getApplicationClassLoader();
     setContextClassLoader(cl);
@@ -200,5 +210,8 @@ public final class MainThread extends Thread {
     // invoke "main" method with argument list
     Reflection.invoke(mainMethod, null, null, new Object[]{mainArgs}, true);
     if (dbg) VM.sysWriteln("  MainThread.run(): \"main\" method completed.]");
+    if(RVMThread.autogenWSThread && WS.stats) {
+    	WS.dumpWSStatistics();
+    }
   }
 }
diff --git a/rvm/src/org/jikesrvm/scheduler/Monitor.java b/rvm/src/org/jikesrvm/scheduler/Monitor.java
index cca8681..cc002db 100644
--- a/rvm/src/org/jikesrvm/scheduler/Monitor.java
+++ b/rvm/src/org/jikesrvm/scheduler/Monitor.java
@@ -399,7 +399,7 @@ public class Monitor {
   }
   /**
    * Send a broadcast after first acquiring the lock.  Release the lock
-   * after sending the broadcast.  In most cases where you want to send
+   * after sending the broadacst.  In most cases where you want to send
    * a broadcast but you don't need to acquire the lock to set the
    * condition that the other thread(s) are waiting on, you want to call
    * this method instead of <code>broadcast</code>.
@@ -433,10 +433,14 @@ public class Monitor {
                                        Monitor m2,Word priority2) {
     if (priority1.LE(priority2)) {
       m1.lockWithHandshake();
+      //VM.sysWriteln("Thread ", RVMThread.getCurrentThreadSlot(), " has ", priority1.toInt());
       m2.lockWithHandshake();
+      //VM.sysWriteln("Thread ", RVMThread.getCurrentThreadSlot(), " has ", priority2.toInt());
     } else {
       m2.lockWithHandshake();
+      //VM.sysWriteln("Thread ", RVMThread.getCurrentThreadSlot(), " has ", priority2.toInt());
       m1.lockWithHandshake();
+      //VM.sysWriteln("Thread ", RVMThread.getCurrentThreadSlot(), " has ", priority1.toInt());
     }
   }
 }
diff --git a/rvm/src/org/jikesrvm/scheduler/RVMThread.java b/rvm/src/org/jikesrvm/scheduler/RVMThread.java
index 4d71eab..a207b9f 100644
--- a/rvm/src/org/jikesrvm/scheduler/RVMThread.java
+++ b/rvm/src/org/jikesrvm/scheduler/RVMThread.java
@@ -79,6 +79,16 @@ import org.jikesrvm.classloader.NormalMethod;
 import org.jikesrvm.tuningfork.TraceEngine;
 import org.jikesrvm.tuningfork.Feedlet;
 
+import java.util.Random;
+import org.jikesrvm.ArchitectureSpecific.ArchConstants;
+import org.jikesrvm.runtime.ExceptionDeliverer;
+import org.vmmagic.unboxed.AddressArray;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_RETURN_ADDRESS_OFFSET;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACK_SIZE_GUARD;
+import org.jikesrvm.classloader.RVMType;
+
 /**
  * A generic java thread's execution context.
  * <p>
@@ -325,12 +335,12 @@ public final class RVMThread extends ThreadContext implements Constants {
   }
 
   private boolean attemptFastExecStatusTransition(int oldState,
-                                                  int newState) {
+      int newState) {
     if (Synchronization.tryCompareAndSwap(
-          this,
-          Entrypoints.execStatusField.getOffset(),
-          oldState,
-          newState)) {
+        this,
+        Entrypoints.execStatusField.getOffset(),
+        oldState,
+        newState)) {
       observeStateTransition(oldState,newState);
       return true;
     } else {
@@ -453,7 +463,7 @@ public final class RVMThread extends ThreadContext implements Constants {
    */
   public static long timerTicks;
 
-  private long yieldpointsTaken;
+  protected long yieldpointsTaken;
 
   private long yieldpointsTakenFully;
 
@@ -1022,7 +1032,7 @@ public final class RVMThread extends ThreadContext implements Constants {
    * Thread handle. Currently stores pthread_t, which we assume to be no larger
    * than a pointer-sized word.
    */
-  public Word pthread_id;
+  public Word thread_id;
 
   /**
    * Scratch area for use for gpr <=> fpr transfers by PPC baseline compiler.
@@ -1205,6 +1215,68 @@ public final class RVMThread extends ThreadContext implements Constants {
    */
   public Feedlet feedlet;
 
+  //per thread perf event support
+  private static boolean PER_THREAD_PERF_MONITORING = false;
+
+  protected int perfEventGroup = -1;
+  // for work-stealing threads
+  protected static final int PERF_EVENT_GROUP_WS = 3;
+  // for OSR_Organizer and Organizer threads
+  protected static final int PERF_EVENT_GROUP_ORGANIZERS = 2;
+  // for org.mmtk.plan.generational.immix.GenImmixCollector* threads
+  protected static final int PERF_EVENT_GROUP_GC = 1;
+  // for CompilationThread; TimerThread; FinalizerThread; 
+  protected static final int PERF_EVENT_GROUP_SYS = 0;
+
+  private static long[] perfEventTotals_ws;
+  private static long[] perfEventTotals_organizers;
+  private static long[] perfEventTotals_gc;
+  private static long[] perfEventTotals_sys;
+
+  public static boolean wsPerThreadPerf = false;
+
+  /*
+   * From Jikes 3.1.3 release, calling getBytes() on a string variable is
+   * generating ArrayIndexOutOfBoundsException in Thread.java: getThreadLocals(): Line 1076
+   * eg. perfEventNames[i].getBytes(). However, calling getBytes() with a string literal
+   * is working fine, eg. "LLC_MISSES".getBytes()
+   * 
+   * As a temporary work-around on this bug, for adding a new perf event:
+   * 1) add a corresponding entry inside RVMThread.perfEventNames and 
+   * 2) also an entry inside switch-case block inside the method 
+   * 	  RVMThread.getPerfEventByteArray(i).
+   * 
+   * If we have to measure the per thread perf event, we use the command line option 
+   * -Xws:perfEvents=true. By default its always false.
+   */
+  public static final String[] perfEventNames = {
+    // Add more Perf Events if necessary
+    "UNHALTED_CORE_CYCLES",
+    "LLC_MISSES",
+    "LLC_REFERENCES"
+    // Also add corresponding entry inside the method getPerfEventByteArray() below
+  };
+
+  private final static byte[] getPerfEventByteArray(int id) {
+    switch(id) {
+    case 0:
+      return "UNHALTED_CORE_CYCLES".concat("\0").getBytes();
+    case 1:
+      return "LLC_MISSES".concat("\0").getBytes();
+    case 2:
+      return "LLC_REFERENCES".concat("\0").getBytes();
+    default:
+      VM.sysFail("Error in fetching perfevent byte array");
+    }
+    return null;
+  }
+
+  private int[] perfEventFds;
+  private static long[][] perfEventperThread;
+  private static int perfEventThreadNum = 0;
+  private static String[] perfEventThreadName;
+  private long[] perfEventTemp = new long[3];
+
   /**
    * Get a NoYieldpointsCondLock for a given thread slot.
    */
@@ -1229,6 +1301,11 @@ public final class RVMThread extends ThreadContext implements Constants {
     return result;
   }
 
+  @Inline
+  public Monitor wsLock() {
+    return workStealingLockBySlot[threadSlot];
+  }
+
   public Monitor communicationLock() {
     return communicationLockForSlot(threadSlot);
   }
@@ -1243,7 +1320,7 @@ public final class RVMThread extends ThreadContext implements Constants {
     // show up as recursive use of hardware exception registers (eg the
     // long-standing lisp bug)
     BootRecord.the_boot_record.dumpStackAndDieOffset =
-      Entrypoints.dumpStackAndDieMethod.getOffset();
+        Entrypoints.dumpStackAndDieMethod.getOffset();
     Lock.init();
   }
 
@@ -1269,7 +1346,7 @@ public final class RVMThread extends ThreadContext implements Constants {
         VM.sysWriteln("      or: ",expected2);
         VM.sysWriteln("Observed: ",curStatus);
         VM._assert(curStatus==expected1 ||
-                   curStatus==expected2);
+            curStatus==expected2);
       }
     }
   }
@@ -1296,7 +1373,7 @@ public final class RVMThread extends ThreadContext implements Constants {
         VM.sysWriteln("       and: ",unexpected2);
         VM.sysWriteln("  Observed: ",curStatus);
         VM._assert(curStatus!=unexpected1 &&
-                   curStatus!=unexpected2);
+            curStatus!=unexpected2);
       }
     }
   }
@@ -1315,6 +1392,202 @@ public final class RVMThread extends ThreadContext implements Constants {
     }
   }
 
+  @Unpreemptible
+  private void perfEventAttach() {
+    if(PER_THREAD_PERF_MONITORING) {
+      int n = perfEventNames.length;
+      perfEventTemp[0] = 0;
+      perfEventTemp[1] = 0;
+      perfEventTemp[2] = 0;
+      perfEventFds = new int[n];
+      if (n > 0) perfEventFds[0] = -1;
+      for (int i = 0; i < n; i++) {
+        sysCall.sysPerfEventOpen_thread(i, thread_id, perfEventFds);
+      }
+    }
+  }
+
+  @Unpreemptible
+  public static void perfEventStart() {
+    if(PER_THREAD_PERF_MONITORING) {
+      hardHandshakeSuspend();
+      for(int i=0; i<numThreads;i++) {
+        threads[i].perfEventEnable();
+      }
+      hardHandshakeResume();
+    }
+  }
+
+  @Unpreemptible
+  private void perfEventEnable() {
+    int n = perfEventNames.length;
+    sysCall.sysPerfEventEnable_thread(perfEventFds,n);
+  }
+
+  @Unpreemptible
+  private void perfEventDisable() {
+    int n = perfEventNames.length;
+    sysCall.sysPerfEventDisable_thread(perfEventFds,n);
+  }
+
+  @UninterruptibleNoWarn
+  private void perfEventDetach() {
+    int n = perfEventNames.length;
+
+    // assign groups to system threads
+    final String threadName = this.getName();
+    if(threadName.contains("Organizer") || threadName.contains("ControllerThread") || threadName.contains("CompilationThread") ) {
+      perfEventGroup = PERF_EVENT_GROUP_ORGANIZERS;
+    }
+    else if(threadName.contains("TimerThread") || threadName.contains("FinalizerThread")) { 
+      perfEventGroup = PERF_EVENT_GROUP_SYS;
+    }
+    else if(this.isCollectorThread()) {
+      perfEventGroup = PERF_EVENT_GROUP_GC;
+    }
+    if(perfEventGroup == -1) {
+      VM.sysWrite("ERROR (PerThreadPerfMon): Thread Group Not Assigned For Thread-");
+      VM.sysWriteln(threadName);
+      VM.sysFail("PerThreadGroup");
+    }
+
+    acctLock.lockNoHandshake();
+    for (int i = 0; i < n; i++) {
+      long val = perfEventRead(i);	
+      perfEventperThread[i][perfEventThreadNum] = val;
+      switch(perfEventGroup) {
+      case PERF_EVENT_GROUP_WS:
+        perfEventTotals_ws[i] += val;
+        break;
+      case PERF_EVENT_GROUP_ORGANIZERS:
+        perfEventTotals_organizers[i] += val;
+        break;
+      case PERF_EVENT_GROUP_GC:
+        perfEventTotals_gc[i] += val;
+        break;
+      case PERF_EVENT_GROUP_SYS:
+        perfEventTotals_sys[i] += val;
+        break;
+      }
+    }
+    String name = getName().replace(" ", "");
+    name += ".T" + perfEventThreadNum;
+    perfEventThreadName[perfEventThreadNum] = name;
+    ++perfEventThreadNum;
+    acctLock.unlock();
+  }
+
+  public long perfEventRead(int eventIndex) {
+    if(VM.VerifyAssertions) VM._assert(eventIndex >= 0 && eventIndex <= perfEventNames.length, "Invalid perfEventId");
+    sysCall.sysPerfEventRead_thread(eventIndex, perfEventFds, perfEventTemp);
+    if (perfEventTemp[1] != perfEventTemp[2]) {
+      // This thread has never run
+      if(this.systemThread == null) VM.sysFail("Counters overflowed");
+      return 0;
+    }
+    return perfEventTemp[0]; 
+  }
+
+  @Unpreemptible
+  public static void perfEventStop() {
+    if(PER_THREAD_PERF_MONITORING) {
+      hardHandshakeSuspend();
+      for(int i=0; i<numThreads;i++) {
+        threads[i].perfEventDetach();
+      }
+
+      int n = perfEventNames.length;
+      // Thread grouping
+      VM.sysWriteln("============================ Tabulate Statistics ============================");
+      // write names
+      VM.sysWrite("counters");
+      for (int i = 0; i < n; i++) {
+        for (int j = 0; j <= 3; j++){
+          String group = "";
+          switch(j) {
+          case PERF_EVENT_GROUP_WS:
+            group = "WSThreads";
+            break;
+          case PERF_EVENT_GROUP_ORGANIZERS:
+            group = "Organizers";
+            break;
+          case PERF_EVENT_GROUP_GC:
+            group = "GC";
+            break;
+          case PERF_EVENT_GROUP_SYS:
+            group = "System";
+            break;
+          }
+          VM.sysWrite(" ", perfEventNames[i], ".", group);
+        }
+      }
+      VM.sysWriteln();
+
+      // write values
+      VM.sysWrite(n);
+      for (int i = 0; i < n; i++) {
+        for (int j = 0; j <= 3; j++){
+          switch(j) {
+          case PERF_EVENT_GROUP_WS:
+            VM.sysWrite("   ", perfEventTotals_ws[i]);
+            break;
+          case PERF_EVENT_GROUP_ORGANIZERS:
+            VM.sysWrite("   ", perfEventTotals_organizers[i]);
+            break;
+          case PERF_EVENT_GROUP_GC:
+            VM.sysWrite("   ", perfEventTotals_gc[i]);
+            break;
+          case PERF_EVENT_GROUP_SYS:
+            VM.sysWrite("   ", perfEventTotals_sys[i]);
+            break;
+          }
+        }
+      }
+      VM.sysWriteln();
+      // till here
+
+      hardHandshakeResume();
+    }
+  }
+
+  @Unpreemptible
+  public static void perfEventStopAndPrintAll() {
+    if(PER_THREAD_PERF_MONITORING) {
+      hardHandshakeSuspend();
+      for(int i=0; i<numThreads;i++) {
+        threads[i].perfEventDetach();
+      }
+
+      int n = perfEventNames.length;
+      VM.sysWriteln("============================ Tabulate Statistics ============================");
+      VM.sysWrite("counters");
+
+      for (int i = 0; i < n; i++) {
+        for (int j = 0; j < perfEventThreadNum; j++){
+          VM.sysWrite(" ", perfEventNames[i], ".", perfEventThreadName[j]);
+        }
+        //total
+        VM.sysWrite("   ", perfEventNames[i], ".WSThreadsTotal");
+      }
+
+      VM.sysWriteln();
+      VM.sysWrite(n);
+
+      for (int i = 0; i < n; i++) {
+        for (int j = 0; j < perfEventThreadNum; j++){
+          VM.sysWrite(" ", perfEventperThread[i][j]);
+        }
+      }
+
+      for (int i = 0; i < n; i++) {
+        VM.sysWrite("   ", perfEventTotals_ws[i]);
+      }
+      VM.sysWriteln();
+
+      hardHandshakeResume();
+    }
+  }
+
   /**
    * Boot the threading subsystem.
    */
@@ -1331,9 +1604,32 @@ public final class RVMThread extends ThreadContext implements Constants {
     doProfileReport = new Latch(false);
     monitorBySlot[getCurrentThread().threadSlot] = new NoYieldpointsMonitor();
     communicationLockBySlot[getCurrentThread().threadSlot] = new Monitor();
+    workStealingLockBySlot[getCurrentThread().threadSlot] = new Monitor();
+    if(ws_pinning_system) {
+      for(int i=0; i<pin_map_system.length; i++) {
+        sysCall.wsIniatilizeSysThreadBindMask(pin_map_system[i]);
+      }
+    }
     sysCall.sysCreateThreadSpecificDataKeys();
     sysCall.sysStashVMThread(getCurrentThread());
 
+    // Initialize perf event
+    if (wsPerThreadPerf) {
+      PER_THREAD_PERF_MONITORING = true;
+      int n = perfEventNames.length;
+      sysCall.sysPerfEventInit_thread(n);
+      perfEventperThread = new long[n][MAX_THREADS];
+      perfEventTotals_ws = new long[n];
+      perfEventTotals_organizers = new long[n];
+      perfEventTotals_gc = new long[n];
+      perfEventTotals_sys = new long[n];
+      perfEventThreadName = new String[MAX_THREADS];
+      for (int i = 0; i < n; i++) {
+        sysCall.sysPerfEventCreate_thread(i, getPerfEventByteArray(i));
+      }
+      getCurrentThread().perfEventAttach();
+    }
+
     if (traceAcct) {
       VM.sysWriteln("boot thread at ",Magic.objectAsAddress(getCurrentThread()));
     }
@@ -1453,14 +1749,16 @@ public final class RVMThread extends ThreadContext implements Constants {
       }
       if (communicationLockBySlot[threadSlot] == null) {
         Monitor m = new Monitor();
+        Monitor m2 = new Monitor();
         handshakeLock.lockWithHandshake();
         communicationLockBySlot[threadSlot] = m;
+        workStealingLockBySlot[threadSlot] = m2;
         handshakeLock.unlock();
       }
       Magic.sync(); /*
-                     * make sure that nobody sees the thread in any of the
-                     * tables until the thread slot is inited
-                     */
+       * make sure that nobody sees the thread in any of the
+       * tables until the thread slot is inited
+       */
 
       acctLock.lockNoHandshake();
       threadBySlot[threadSlot] = this;
@@ -1488,30 +1786,30 @@ public final class RVMThread extends ThreadContext implements Constants {
     replacementThread.threadIdx = threadIdx;
     threadIdx = -1;
     Magic.sync(); /*
-                   * make sure that if someone is processing the threads array
-                   * without holding the acctLock (which is definitely legal)
-                   * then they see the replacementThread moved to the new index
-                   * before they see the numThreads decremented (otherwise they
-                   * would miss replacementThread; but with the current
-                   * arrangement at worst they will see it twice)
-                   */
+     * make sure that if someone is processing the threads array
+     * without holding the acctLock (which is definitely legal)
+     * then they see the replacementThread moved to the new index
+     * before they see the numThreads decremented (otherwise they
+     * would miss replacementThread; but with the current
+     * arrangement at worst they will see it twice)
+     */
     threads[--numThreads] = null;
     threadBySlot[threadSlot] = null;
     freeSlots[freeSlotN++] = threadSlot;
     acctLock.unlock();
   }
 
-   /**
-    * Create a new RVM Thread
-    *
-    * @param stack The stack on which to execute the thread.
-    * @param thread The corresponding java.lang.Thread.
-    * @param name The name of the thread
-    * @param daemon True if this is a daemon thread.
-    * @param systemThread True if this is a system thread.
-    * @param priority The threads execution priority.
-    */
-   public RVMThread(byte[] stack, Thread thread, String name, boolean daemon, SystemThread systemThread, int priority) {
+  /**
+   * Create a new RVM Thread
+   *
+   * @param stack The stack on which to execute the thread.
+   * @param thread The corresponding java.lang.Thread.
+   * @param name The name of the thread
+   * @param daemon True if this is a daemon thread.
+   * @param systemThread True if this is a system thread.
+   * @param priority The threads execution priority.
+   */
+  public RVMThread(byte[] stack, Thread thread, String name, boolean daemon, SystemThread systemThread, int priority) {
     this.stack = stack;
 
     this.daemon = daemon;
@@ -1699,7 +1997,7 @@ public final class RVMThread extends ThreadContext implements Constants {
    */
   public boolean isInJava() {
     return !isBlocking && !isAboutToTerminate &&
-      (getExecStatus() == IN_JAVA || getExecStatus() == IN_JAVA_TO_BLOCK);
+        (getExecStatus() == IN_JAVA || getExecStatus() == IN_JAVA_TO_BLOCK);
   }
 
   /**
@@ -1760,7 +2058,7 @@ public final class RVMThread extends ThreadContext implements Constants {
 
     if (traceBlock)
       VM.sysWriteln("Thread #", threadSlot,
-                    " has acknowledged soft handshakes");
+          " has acknowledged soft handshakes");
 
     boolean hadReallyBlocked=false;
 
@@ -1774,7 +2072,7 @@ public final class RVMThread extends ThreadContext implements Constants {
       if (traceReallyBlock) {
         hadReallyBlocked=true;
         VM.sysWriteln("Thread #", threadSlot,
-                      " is really blocked with status ", getExecStatus());
+            " is really blocked with status ", getExecStatus());
         VM.sysWriteln("Thread #", threadSlot,
             " has fp = ", Magic.getFramePointer());
         if (dumpStackOnBlock) {
@@ -1876,6 +2174,24 @@ public final class RVMThread extends ThreadContext implements Constants {
     checkBlockNoSaveContext();
   }
 
+  @NoInline
+  @NoOptCompile
+  @BaselineSaveLSRegisters
+  @Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
+  void wsWrapperCheckBlock() {
+    wsCheckBlock();
+  }
+
+  @NoInline
+  @NoOptCompile
+  @BaselineNoRegisters
+  @Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
+  void wsCheckBlock() {
+    wsSafeToInstallRBarrier = true;
+    saveThreadState();
+    checkBlockNoSaveContext();
+  }
+
   /**
    * Internal method for transitioning a thread from IN_JAVA or IN_JAVA_TO_BLOCK to
    * either BLOCKED_IN_NATIVE or BLOCKED_IN_JNI, depending on the value of the jni
@@ -2044,7 +2360,8 @@ public final class RVMThread extends ThreadContext implements Constants {
     if (getCurrentThread() == this) {
       if (traceBlock)
         VM.sysWriteln("Thread #", threadSlot, " is blocking.");
-      checkBlock();
+      wsWrapperCheckBlock();
+      wsSafeToInstallRBarrier = false;
       result = getExecStatus();
     } else {
       if (traceBlock)
@@ -2088,7 +2405,7 @@ public final class RVMThread extends ThreadContext implements Constants {
                 monitor().timedWaitRelativeNoHandshake(1000L * 1000L * 1000L); // 1 sec
                 if (traceReallyBlock) {
                   VM.sysWriteln("Thread #", threadSlot, "'s status is ",
-                                getExecStatus());
+                      getExecStatus());
                 }
                 assertUnacceptableStates(IN_NATIVE);
               } else {
@@ -2124,6 +2441,102 @@ public final class RVMThread extends ThreadContext implements Constants {
     return result;
   }
 
+  private boolean wsSafeToInstallRBarrier = false;
+
+  @Unpreemptible("Only blocks if the receiver is the current thread, or if asynchronous is set to false and the thread is not already blocked")
+  private boolean wsBlock(BlockAdapter ba, boolean asynchronous) {
+    int result;
+    boolean safeWait = false;
+    if (traceBlock)
+      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+          " is requesting that thread #", threadSlot, " blocks.");
+    monitor().lockNoHandshake();
+    int token = ba.requestBlock(this);
+    if (getCurrentThread() == this) {
+      if (traceBlock)
+        VM.sysWriteln("Thread #", threadSlot, " is blocking.");
+      checkBlock();
+      result = getExecStatus();
+    } else {
+      if (traceBlock)
+        VM.sysWriteln("Thread #", threadSlot, " is being told to block.");
+      if (isAboutToTerminate) {
+        if (traceBlock)
+          VM.sysWriteln("Thread #", threadSlot,
+              " is terminating, returning as if blocked in TERMINATED state.");
+        result = TERMINATED;
+      } else {
+        takeYieldpoint = 1;
+        // CAS the execStatus field
+        int newState = setBlockedExecStatus();
+        result = newState;
+        if (traceReallyBlock)
+          VM.sysWriteln("Thread #", getCurrentThreadSlot(),
+              " is blocking thread #", threadSlot, " which is in state ",
+              newState);
+        // this broadcast serves two purposes: notifies threads that are
+        // IN_JAVA but waiting on monitor() that they should awake and
+        // acknowledge the block request; or notifies anyone
+        // waiting for this thread to block that the thread is
+        // BLOCKED_IN_NATIVE or BLOCKED_IN_JNI. in the latter case the
+        // broadcast() happens _before_ the setting of the flags that the
+        // other threads would be awaiting, but that is fine, since we're
+        // still holding the lock anyway.
+        monitor().broadcast();
+        if (newState == IN_JAVA_TO_BLOCK) {
+          if (!asynchronous) {
+            if (traceBlock)
+              VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+                  " is waiting for thread #", threadSlot, " to block.");
+            while (ba.hasBlockRequest(this, token) && !ba.isBlocked(this) && !isAboutToTerminate) {
+              if (traceBlock)
+                VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+                    " is calling wait until thread #", threadSlot, " blocks.");
+              // will this deadlock when the thread dies?
+              if (VM.VerifyAssertions) {
+                // do a timed wait, and assert that the thread did not disappear
+                // into native in the meantime
+                monitor().timedWaitRelativeNoHandshake(1000L * 1000L * 1000L); // 1 sec
+                if (traceReallyBlock) {
+                  VM.sysWriteln("Thread #", threadSlot, "'s status is ",
+                      getExecStatus());
+                }
+                assertUnacceptableStates(IN_NATIVE);
+              } else {
+                monitor().waitNoHandshake();
+              }
+              if (traceBlock)
+                VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+                    " has returned from the wait call.");
+            }
+            if (isAboutToTerminate) {
+              result = TERMINATED;
+            } else {
+              result=getExecStatus();
+            }
+          }
+        } else if (newState == BLOCKED_IN_NATIVE || newState == BLOCKED_IN_JNI) {
+          // we own the thread for now - it cannot go back to executing Java
+          // code until we release the lock. before we do so we change its
+          // state accordingly and tell anyone who is waiting.
+          if (traceBlock)
+            VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+                " has seen thread #", threadSlot,
+                " in native; changing its status accordingly.");
+          ba.clearBlockRequest(this);
+          ba.setBlocked(this, true);
+        }
+      }
+    }
+    safeWait = wsSafeToInstallRBarrier;
+    wsSafeToInstallRBarrier = false;
+    monitor().unlock();
+    if (traceReallyBlock)
+      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+          " is done telling thread #", threadSlot, " to block.");
+    return safeWait;
+  }
+
   public boolean blockedFor(BlockAdapter ba) {
     monitor().lockNoHandshake();
     boolean result = ba.isBlocked(this);
@@ -2143,12 +2556,17 @@ public final class RVMThread extends ThreadContext implements Constants {
     return block(ba, false);
   }
 
+  @Unpreemptible("May block if the receiver is the current thread or if the receiver is not yet blocked; otherwise does not perform actions that lead to blocking")
+  private boolean wsBlock(BlockAdapter ba) {
+    return wsBlock(ba, false);
+  }
+
   @Unpreemptible
   public void beginPairWith(RVMThread other) {
     if (traceBlock) VM.sysWriteln("attempting to pair ",threadSlot," with ",other.threadSlot);
     Monitor.lockWithHandshake(
-      communicationLock(),Word.fromIntSignExtend(threadSlot),
-      other.communicationLock(),Word.fromIntSignExtend(other.threadSlot));
+        communicationLock(),Word.fromIntSignExtend(threadSlot),
+        other.communicationLock(),Word.fromIntSignExtend(other.threadSlot));
   }
 
   public void endPairWith(RVMThread other) {
@@ -2196,6 +2614,12 @@ public final class RVMThread extends ThreadContext implements Constants {
     block(handshakeBlockAdapter);
   }
 
+  @Unpreemptible
+  public boolean wsBeginPairHandshake() {
+    beginPairWithCurrent();
+    return wsBlock(handshakeBlockAdapter);
+  }
+
   @Uninterruptible
   public void endPairHandshake() {
     unblock(handshakeBlockAdapter);
@@ -2210,7 +2634,7 @@ public final class RVMThread extends ThreadContext implements Constants {
   public static void saveThreadState() {
     Address curFP=Magic.getFramePointer();
     getCurrentThread().contextRegisters.setInnermost(Magic.getReturnAddressUnchecked(curFP),
-                                                     Magic.getCallerFramePointer(curFP));
+        Magic.getCallerFramePointer(curFP));
   }
 
   /**
@@ -2572,6 +2996,80 @@ public final class RVMThread extends ThreadContext implements Constants {
     }
   }
 
+  /*
+   * Methods for pinning threads to cores
+   */
+
+  protected static int pin_core_index = 0;
+  @Interruptible
+  private synchronized static int getNextCoreID() {
+    int id = pin_core_index++;
+    if(id == sysCall.sysNumProcessors()) {
+      id = pin_core_index = 0;
+    }
+    return id;
+  }
+
+  /*
+   * This method only support when -Xws:pinSocketCPU is provided
+   * and also hyperthreading is ON
+   * 
+   * A typical layout, which this supports is:
+   * 	
+	  	$ numactl --hardware
+		available: 2 nodes (0-1)
+		node 0 cpus: 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30
+		node 0 size: 24530 MB
+		node 0 free: 208 MB
+		node 1 cpus: 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31
+		node 1 size: 24576 MB
+		node 1 free: 85 MB
+		node distances:
+		node   0   1 
+  		0:  10  20 
+  		1:  20  10 
+   */
+  private static int[] multiSocket_physical_cores_inhyperthreading = new int[0];
+  @Interruptible
+  private synchronized static int getNextCoreID_socketAndCPUHint() {
+    /*
+     *  The implementation of this method assumes the hyperthreading is ON.
+     *  In case hyperthreading is OFF, use the -Xws:pinMap option 
+     *  to hint the pin core ids.
+     *  This function will fail in that case !!
+     */
+    if(multiSocket_physical_cores_inhyperthreading.length == 0) {
+      final int physical_cores = cpusPerSocket * sockets;
+      multiSocket_physical_cores_inhyperthreading = new int[physical_cores];
+      // assuming even number of total processors
+      int curr_cpu = 0;
+      int curr_socket = 0;
+      for(int i=0; i<physical_cores; i++) {
+        if(i == cpusPerSocket*(curr_socket+1)) curr_cpu = ++curr_socket;
+        multiSocket_physical_cores_inhyperthreading[i] = curr_cpu;
+        curr_cpu += 2;
+      }
+    }
+
+    int id = pin_core_index++;
+    if(id == multiSocket_physical_cores_inhyperthreading.length) {
+      id = pin_core_index = 0;
+    }
+    return multiSocket_physical_cores_inhyperthreading[id];
+  }
+
+  /*
+   *  This is used only when a exact pinMap is provided at runtime
+   */
+  @Interruptible
+  private synchronized static int getNextCoreID_fromPinMap() {
+    int id = pin_core_index++;
+    if(id == pin_map_workers.length) {
+      id = pin_core_index = 0;
+    }
+    return pin_map_workers[id];
+  }
+
   /**
    * Begin execution of current thread by calling its "run" method. This method
    * is at the bottom of all created method's stacks.
@@ -2586,15 +3084,17 @@ public final class RVMThread extends ThreadContext implements Constants {
 
     RVMThread currentThread = getCurrentThread();
 
+    currentThread.perfEventAttach();
+
     /*
      * get pthread_id from the operating system and store into RVMThread field
      */
-    currentThread.pthread_id = sysCall.sysGetThreadId();
+    currentThread.thread_id = sysCall.sysGetThreadId();
     currentThread.enableYieldpoints();
     sysCall.sysStashVMThread(currentThread);
     if (traceAcct) {
       VM.sysWriteln("Thread #", currentThread.threadSlot, " with pthread id ",
-          currentThread.pthread_id, " running!");
+          currentThread.thread_id, " running!");
     }
 
     if (trace) {
@@ -2603,9 +3103,38 @@ public final class RVMThread extends ThreadContext implements Constants {
 
     try {
       if (currentThread.systemThread != null) {
+        if(currentThread.isCollectorThread() && ws_pinning_gc) {
+          if(currentThread.getName().contains("org.mmtk.plan.generational")) {
+            final int index = currentThread.getCollectorContext().getId();
+            sysCall.wsThreadBindMaskSet(pin_map_gc[index]);
+          }
+        }
+        else if(ws_pinning_system) {
+          sysCall.sysThreadBindMaskSet();
+        }
+        if(WS.pinLog) {
+          VM.sysWriteln("[PIN_INFO] RVM-", currentThread.getName() ," has affinity for cpuid-",sysCall.sysGetCPU());
+        }
         currentThread.systemThread.run();
       } else {
+        // this is an application thread
+        if(ws_pinning_workers) {
+          // pin to the core
+          int core = 0;
+          if(RVMThread.pin_map_workers.length > 1) {
+            core = getNextCoreID_fromPinMap();
+          }
+          else if(sockets != -1 && cpusPerSocket != -1) {
+            core = getNextCoreID_socketAndCPUHint();
+          }
+          else {
+            core = getNextCoreID();
+          }
+          sysCall.wsThreadBindMaskSet(core);
+        }
+        if(WS.pinLog) VM.sysWriteln("[PIN_INFO] ", currentThread.getName() ," has affinity for cpuid-",sysCall.sysGetCPU());
         currentThread.run();
+        if(autogenWSThread) WS.terminate();
       }
     } finally {
       if (trace) {
@@ -2864,161 +3393,8 @@ public final class RVMThread extends ThreadContext implements Constants {
   }
 
   /**
-   * The return barrier.
-   * <p>
-   * The following code implements return barriers as described
-   * for Lisp by Yuasa
-   *
-   * http://www.yuasa.kuis.kyoto-u.ac.jp/~yuasa/ilc2002/index.html
-   * http://dx.doi.org/10.1109/ISORC.2005.45
-   *
-   * and for Jikes RVM by Kumar et al
-   *
-   * http://dx.doi.org/10.1145/2398857.2384639
-   * <p>
-   * This code is executed when a method returns into a frame that
-   * has been hijacked by the return barrier mechanism.   The return
-   * barrier trampoline will save state, execute this method, and
-   * then upon return from this method will transparently return into
-   * the frame that had been hijacked.
-   * <p>
-   * In this default implementation, the barrier reinstalls itself
-   * in the caller's frame thus incrementally moving the barrier down
-   * the stack.
-   * <p>
-   * The execution of this method is fragile.  It is generally safest
-   * to call some other method from here that does the substantive work
-   * of the barrier.
-   */
-  @Entrypoint
-  @Uninterruptible
-  @Unpreemptible
-  public static void returnBarrier() {
-    /* reinstall the barrier in the caller's frame */
-    if (DEBUG_STACK_TRAMPOLINE) {
-      VM.sysWriteln(getCurrentThread().getId(), " T0: ", getCurrentThread().trampolineRegisters.gprs.get(BaselineConstants.T0_int).toAddress());
-      VM.sysWriteln(getCurrentThread().getId(), " T1: ", getCurrentThread().trampolineRegisters.gprs.get(BaselineConstants.T1_int).toAddress());
-      VM.sysWriteln(getCurrentThread().getId(), " nf: ", getCurrentThread().hijackedReturnCallerFp);
-      VM.sysWriteln(getCurrentThread().getId(), " lf: ", getCurrentThread().hijackedReturnCalleeFp);
-      VM.sysWriteln(getCurrentThread().getId(), " fp: ", Magic.getFramePointer());
-      VM.sysWriteln(getCurrentThread().getId(), " np: ", Magic.getCallerFramePointer(Magic.getFramePointer()));
-    }
-    /* reinstall the barrier in the specified frame */
-    getCurrentThread().installStackTrampolineBridge(getCurrentThread().hijackedReturnCallerFp);
-  }
-
-  /**
-   * Install the stack trampoline bridge at a given frame, hijacking
-   * that frame, saving the hijacked return address and callee fp
-   * in thread-local state to allow execution of the hijacked frame
-   * later.
-   *
-   * @param targetFp The frame to be hijacked.
-   */
-  @Uninterruptible
-  public void installStackTrampolineBridge(Address targetFp) {
-    Address trampoline = getStackTrampolineBridgeIP();
-    if (trampoline.isZero()) {
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-      else
-        VM.sysWriteln("Warning: attempt to install stack trampoline without bridge instructions - nothing done.  See RVMThread.");
-    } else if (trampoline.NE(Magic.getReturnAddressUnchecked(targetFp))) {
-      /* install the trampoline at fp or the next suitable frame after fp */
-      while (true) {
-        if (Magic.getCallerFramePointer(targetFp).EQ(ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
-          /* if we're at the bottom of the stack, then do not install anything */
-          hijackedReturnAddress = Address.zero();
-          hijackedReturnCalleeFp = Address.zero();
-          return;
-        }
-        int cmid = Magic.getCompiledMethodID(targetFp);
-        if (cmid == ArchitectureSpecific.ArchConstants.INVISIBLE_METHOD_ID) {
-          /* skip invisible methods */
-          targetFp = Magic.getCallerFramePointer(targetFp);
-        } else {
-          CompiledMethod calleeCM = CompiledMethods.getCompiledMethod(cmid);
-          if (calleeCM.getCompilerType() == CompiledMethod.TRAP ||
-              calleeCM.getMethod().getDeclaringClass().hasBridgeFromNativeAnnotation()) {
-            /* skip traps and native bridges */
-            targetFp = Magic.getCallerFramePointer(targetFp);
-          } else
-            break;
-        }
-      }
-      hijackedReturnAddress = Magic.getReturnAddressUnchecked(targetFp);
-      hijackedReturnCalleeFp = targetFp;
-      hijackedReturnCallerFp = Magic.getCallerFramePointer(targetFp);
-      if (VM.VerifyAssertions) VM._assert(trampoline.NE(hijackedReturnAddress));
-      if (DEBUG_STACK_TRAMPOLINE) dumpFrame(targetFp);
-      Magic.setReturnAddress(targetFp, trampoline);
-      if (DEBUG_STACK_TRAMPOLINE) {
-        dumpFrame(targetFp);
-        VM.sysWriteln(getId(), " Installing trampoline at: ", targetFp);
-        VM.sysWriteln(getId(), " Trampoline: ", trampoline);
-        VM.sysWriteln(getId(), " Hijacked return address: ", hijackedReturnAddress);
-        VM.sysWriteln(getId(), " Callee fp: ", hijackedReturnCalleeFp);
-        VM.sysWriteln(getId(), " Caller fp: ", hijackedReturnCallerFp);
-        dumpStack(hijackedReturnCalleeFp);
-      }
-    }
-  }
-
-  /**
-   * de-install the stack trampoline (disabling return barriers).
-   */
-  @Uninterruptible
-  public void deInstallStackTrampoline() {
-    if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("deinstalling trampoline: ", framePointer);
-    if (!hijackedReturnCalleeFp.isZero()) {
-      if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("need to reinstall: ", hijackedReturnAddress);
-      hijackedReturnCalleeFp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET).store(hijackedReturnAddress);
-      hijackedReturnCalleeFp = Address.zero();
-      hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
-    }
-  }
-
-  /** @return the address of the stack trampoline bridge code */
-  @Inline
-  private Address getStackTrampolineBridgeIP() { return Magic.objectAsAddress(stackTrampolineBridgeInstructions); }
-
-  /** @return the hijacked return address */
-  @Inline
-  public Address getTrampolineHijackedReturnAddress() { return hijackedReturnAddress; }
-
-  /**
-   * Determine whether a given method is the stack trampoline
-   *
-   * @param ip the code to be checked
-   * @return <code>true</code> if the code is the stack trampoline.
-   */
-  @Inline
-  public static boolean isTrampolineIP(Address ip) { return getCurrentThread().getStackTrampolineBridgeIP().EQ(ip); }
-
-  /**
-   * Given a frame that has been hijacked by the stack trampoline,
-   * return the real (hijacked) return address.
-   *
-   * @param hijackedFp a frame that has been hijacked by the stack trampoline
-   * @return the return address for the frame that was hijacked.
-   */
-  @Uninterruptible
-  public static Address getHijackedReturnAddress(Address hijackedFp) {
-    if (VM.VerifyAssertions) VM._assert(isTrampolineIP(Magic.getReturnAddressUnchecked(hijackedFp)));
-    RVMThread t = getCurrentThread();
-      if (!t.hijackedReturnCalleeFp.EQ(hijackedFp)) {
-        for (int tid = 0; tid < nextSlot; tid++) {
-          t = threadBySlot[tid];
-          if (t != null && t.hijackedReturnCalleeFp.EQ(hijackedFp))
-            break;
-        }
-      }
-      return t.hijackedReturnAddress;
-  }
-
-  /**
-   * Dump the specified frame in a format useful for debugging the stack
-   * trampoline
+   * Dump the specified frame in a format useful for debugging the stack
+   * trampoline
    *
    * @param fp The frame to be dumped.
    */
@@ -3073,7 +3449,7 @@ public final class RVMThread extends ThreadContext implements Constants {
   @UnpreemptibleNoWarn("Exceptions may possibly cause yields")
   public void suspend() {
     if (false) VM.sysWriteln("Thread #",getCurrentThreadSlot()," suspending Thread #",getThreadSlot());
-    ObjectModel.genericUnlock(thread);
+    ObjectModel.genericUnlock_internal(thread);
     Throwable rethrow = null;
     try {
       observeExecStatus();
@@ -3081,13 +3457,13 @@ public final class RVMThread extends ThreadContext implements Constants {
           execStatus != IN_NATIVE && execStatus != BLOCKED_IN_NATIVE &&
           execStatus != BLOCKED_IN_JNI && execStatus != IN_JNI) {
         throw new IllegalThreadStateException(
-          "Cannot suspend a thread that is not running.");
+            "Cannot suspend a thread that is not running.");
       }
       block(suspendBlockAdapter);
     } catch (Throwable t) {
       rethrow = t;
     }
-    ObjectModel.genericLock(thread);
+    ObjectModel.genericLock_internal(thread);
     if (rethrow != null)
       RuntimeEntrypoints.athrow(rethrow);
   }
@@ -3194,7 +3570,7 @@ public final class RVMThread extends ThreadContext implements Constants {
       // block
       monitor().lockNoHandshake();
       while (l.waiting.isQueued(this) && !hasInterrupt && asyncThrowable == null &&
-             (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
+          (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
         if (hasTimeout) {
           monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
         } else {
@@ -3214,9 +3590,9 @@ public final class RVMThread extends ThreadContext implements Constants {
       if (l.waiting.isQueued(this)) {
         l.mutex.lock();
         l.waiting.remove(this); /*
-                                 * in case we got here due to an interrupt or a
-                                 * stop() rather than a notify
-                                 */
+         * in case we got here due to an interrupt or a
+         * stop() rather than a notify
+         */
         l.mutex.unlock();
         // Note that the above must be done before attempting to acquire
         // the lock, since acquiring the lock may require queueing the thread.
@@ -3224,7 +3600,7 @@ public final class RVMThread extends ThreadContext implements Constants {
         // queue.
       }
       // reacquire the lock, restoring the recursion count
-      ObjectModel.genericLock(o);
+      ObjectModel.genericLock_internal(o);
       waitObject = null;
       if (waitCount != 1) { // reset recursion count
         Lock l2 = ObjectModel.getHeavyLock(o, true);
@@ -3368,7 +3744,7 @@ public final class RVMThread extends ThreadContext implements Constants {
     // massive retardation. someone might be holding the java.lang.Thread lock.
     boolean holdsLock = holdsLock(thread);
     if (holdsLock)
-      ObjectModel.genericUnlock(thread);
+      ObjectModel.genericUnlock_internal(thread);
     boolean hasTimeout;
     long whenWakeupNanos;
     hasTimeout = (time != 0);
@@ -3381,7 +3757,7 @@ public final class RVMThread extends ThreadContext implements Constants {
     monitor().lockNoHandshake();
     waiting = hasTimeout ? Waiting.TIMED_WAITING : Waiting.WAITING;
     while (!parkingPermit && !hasInterrupt && asyncThrowable == null &&
-           (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
+        (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
       if (hasTimeout) {
         monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
       } else {
@@ -3397,7 +3773,7 @@ public final class RVMThread extends ThreadContext implements Constants {
     monitor().unlock();
 
     if (holdsLock)
-      ObjectModel.genericLock(thread);
+      ObjectModel.genericLock_internal(thread);
 
     if (throwThis != null) {
       throw throwThis;
@@ -3488,9 +3864,9 @@ public final class RVMThread extends ThreadContext implements Constants {
   @Unpreemptible("Does not perform actions that lead to blocking, but may wait for threads to rendezvous with the soft handshake")
   public static void softHandshake(SoftHandshakeVisitor v) {
     handshakeLock.lockWithHandshake(); /*
-                                        * prevent multiple (soft or hard) handshakes
-                                        * from proceeding concurrently
-                                        */
+     * prevent multiple (soft or hard) handshakes
+     * from proceeding concurrently
+     */
 
     int numToHandshake = snapshotHandshakeThreads(v);
     if (VM.VerifyAssertions)
@@ -3744,7 +4120,7 @@ public final class RVMThread extends ThreadContext implements Constants {
   }
 
   public static final AllButGCHardHandshakeVisitor allButGC=
-    new AllButGCHardHandshakeVisitor();
+      new AllButGCHardHandshakeVisitor();
 
   static long totalSuspendTime;
   static long totalResumeTime;
@@ -3752,7 +4128,7 @@ public final class RVMThread extends ThreadContext implements Constants {
   @Unpreemptible
   @NoCheckStore
   public static void hardHandshakeSuspend(BlockAdapter ba,
-                                          HardHandshakeVisitor hhv) {
+      HardHandshakeVisitor hhv) {
     long before=sysCall.sysNanoTime();
 
     RVMThread current=getCurrentThread();
@@ -3811,10 +4187,10 @@ public final class RVMThread extends ThreadContext implements Constants {
     worldStopped=true;
 
     processAboutToTerminate(); /*
-                                * ensure that any threads that died while
-                                * we were stopping the world notify us
-                                * that they had stopped.
-                                */
+     * ensure that any threads that died while
+     * we were stopping the world notify us
+     * that they had stopped.
+     */
 
     int numUnlockedLocks=0;
     for (int i=0;i<nextSlot;++i) {
@@ -3837,7 +4213,7 @@ public final class RVMThread extends ThreadContext implements Constants {
   @NoCheckStore
   @Unpreemptible
   public static void hardHandshakeResume(BlockAdapter ba,
-                                         HardHandshakeVisitor hhv) {
+      HardHandshakeVisitor hhv) {
     long before=sysCall.sysNanoTime();
 
     handshakeLock.lockWithHandshake();
@@ -3926,7 +4302,7 @@ public final class RVMThread extends ThreadContext implements Constants {
       // do two things: check if we should be blocking, and act upon
       // handshake requests. This also has the effect of reasserting that
       // we are in fact IN_JAVA (as opposed to IN_JAVA_TO_BLOCK).
-      t.checkBlock();
+      t.wsWrapperCheckBlock();
 
       // Process timer interrupt event
       if (t.timeSliceExpired != 0) {
@@ -3963,7 +4339,7 @@ public final class RVMThread extends ThreadContext implements Constants {
         }
         if (VM.BuildForAdaptiveSystem) {
           OSRListener
-              .checkForOSRPromotion(whereFrom, yieldpointServiceMethodFP);
+          .checkForOSRPromotion(whereFrom, yieldpointServiceMethodFP);
         }
       }
 
@@ -5066,7 +5442,7 @@ public final class RVMThread extends ThreadContext implements Constants {
     if (VM.VerifyAssertions) {
       VM._assert(VM.runningVM);
     }
-    Address ip = Magic.getReturnAddress(fp);
+    Address ip = RVMThread.getReturnAddress_(fp);
     fp = Magic.getCallerFramePointer(fp);
     dumpStack(ip, fp);
   }
@@ -5106,12 +5482,13 @@ public final class RVMThread extends ThreadContext implements Constants {
           // skip to next frame
           if (!MemoryManager.addressInVM(ip)) {
             showMethod("native frame", fp);
-            ip = Magic.getReturnAddress(fp);
+            //						ip = Magic.getReturnAddress(fp);
+            ip = RVMThread.getReturnAddress_(fp);
             fp = Magic.getCallerFramePointer(fp);
           } else {
 
             int compiledMethodId = Magic.getCompiledMethodID(fp);
-            VM.sysWrite("("); VM.sysWrite(fp); VM.sysWrite(" "); VM.sysWrite(compiledMethodId); VM.sysWrite(")");
+            //						VM.sysWrite("("); VM.sysWrite(fp); VM.sysWrite(" "); VM.sysWrite(compiledMethodId); VM.sysWrite(")");
             if (compiledMethodId == StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
               showMethod("invisible method", fp);
             } else {
@@ -5154,7 +5531,7 @@ public final class RVMThread extends ThreadContext implements Constants {
                 }
               }
             }
-            ip = Magic.getReturnAddress(fp);
+            ip = RVMThread.getReturnAddress(fp);
             fp = Magic.getCallerFramePointer(fp);
           }
           if (!isAddressValidFramePointer(fp)) {
@@ -5204,7 +5581,7 @@ public final class RVMThread extends ThreadContext implements Constants {
       VM.sysWrite("[");
       VM.sysWrite(fp);
       VM.sysWrite(", ");
-      VM.sysWrite(Magic.getReturnAddress(fp));
+      VM.sysWrite(RVMThread.getReturnAddress_(fp));
       VM.sysWrite("] ");
     }
   }
@@ -5357,11 +5734,11 @@ public final class RVMThread extends ThreadContext implements Constants {
   ////////////////////////// VM.countThreadTransitions support //////////////////////////
 
   static final int[] sloppyExecStatusHistogram =
-    new int[LAST_EXEC_STATUS];
+      new int[LAST_EXEC_STATUS];
   static final int[] statusAtSTWHistogram =
-    new int[LAST_EXEC_STATUS];
+      new int[LAST_EXEC_STATUS];
   static final int[] execStatusTransitionHistogram =
-    new int[LAST_EXEC_STATUS*LAST_EXEC_STATUS];
+      new int[LAST_EXEC_STATUS*LAST_EXEC_STATUS];
 
   public static void reportThreadTransitionCounts() {
     VM.sysWriteln("Thread Transition Counts:");
@@ -5371,8 +5748,8 @@ public final class RVMThread extends ThreadContext implements Constants {
     for (int fromI=0;fromI<LAST_EXEC_STATUS;++fromI) {
       for (int toI=0;toI<LAST_EXEC_STATUS;++toI) {
         int val=
-          execStatusTransitionHistogram[
-            transitionHistogramIndex(fromI,toI)];
+            execStatusTransitionHistogram[
+                                          transitionHistogramIndex(fromI,toI)];
         if (val!=0) {
           VM.sysWriteln("    ",fromI,"->",toI," ",val);
         }
@@ -5409,4 +5786,1543 @@ public final class RVMThread extends ThreadContext implements Constants {
     sloppyExecStatusHistogram[oldState]++;
     sloppyExecStatusHistogram[newState]++;
   }
+
+  /**
+   * JikesRVM TRY-CATCH WORK-STEALING 
+   */
+
+  /*
+   * RDTSC timings for barrier
+   */
+  protected long totalBarrierCPUCycles = 0;
+
+  /*
+   * RDTSC timings for successful steals
+   */
+  protected long totalSuccessStealCPUCycles = 0;
+
+  /*
+   * RDTSC timings for failed steals
+   */
+  protected long totalFailedStealCPUCycles = 0;
+
+  // Automatically launch the workstealing thread
+  // as soon as application's main method is executed
+  public static boolean autogenWSThread = true;
+  protected static boolean wsThreadsLaunched = false;
+
+  /*
+   * Thread pinning support
+   */
+  // {
+  protected boolean trace_cpuid = false; 
+  public static boolean ws_pinning_workers = false;
+  public static int sockets = -1;
+  public static int cpusPerSocket = -1;
+  public static int[] pin_map_workers = new int[0];
+  protected int ws_id = -1;
+  public static boolean ws_pinning_system = false;
+  public static int[] pin_map_system = new int[0];
+  public static boolean ws_pinning_gc = false;
+  public static int[] pin_map_gc = new int[0];
+  // }
+
+  private static final Monitor[] workStealingLockBySlot = new Monitor[MAX_THREADS];
+
+  public StackFrameCopier wsFrameCopier = new StackFrameCopier();
+  private byte[] wsShadowStack;
+  private WS.Continuation wsContinuation = new WS.Continuation(); 
+  public WS.Join wsJoin = new WS.Join();
+  public WS.FinishFirst wsFinishFirst = new WS.FinishFirst();
+  public WS.Finish wsFinish = new WS.Finish();
+  public int wsSpecialNVMap = 0;
+  public boolean wsFlag = false;
+  public volatile boolean wsInJoin = false;
+  Random wsRand;
+
+  public volatile WS.StealInfo wsStealHead = null;
+  public volatile WS.FinishInfo wsFinishHead = null;
+
+
+  public int totalSteals = 0;
+  public int findAttempts = 0;
+  public int pushes = 0;
+  protected int thiefInstalledBarriers = 0;
+  protected int preInstalledBarriers = 0;
+  // following 4 declarations & 2 methods valid only if createContinuationDistribution==true
+  protected int tasksEQ2 = 0;	// tasks <= 2
+  protected int tasksLE4 = 0;	// tasks <= 4
+  protected int tasksGT4 = 0;	// tasks <= 8
+  @Inline
+  private void continuationsDistribution(int tasks) {
+    if(tasks == 2) tasksEQ2++;
+    else if(tasks > 2 && tasks <= 4) tasksLE4++;
+    else if(tasks > 4) tasksGT4++;
+  }
+
+  protected boolean wsThread = false;
+  protected int wsSynchronizationLock = 0;
+
+  private boolean wsWaitingInsideBarrier = false;
+  private byte[] wsVictimShadowStack = null;
+  Address victimYieldFpOnNewStack = Address.zero();
+  Address victimYieldIPOnNewStack = Address.zero();
+  @Inline
+  public void wsSetInnermost() {
+    contextRegisters.setInnermost(victimYieldIPOnNewStack, victimYieldFpOnNewStack);
+  }
+  public final byte[] wsGetClonedStack() {
+    return wsVictimShadowStack;
+  }
+  private final static int ARRAY_OF_CONTINUATIONS_MAXSIZE = 25; 
+  private final static int ON_OVERFLOW_RESTART_INDEX_IN_ARRAY_OF_CONTINUATIONS = 20;
+  private final AddressArray array_of_continuations = AddressArray.create(ARRAY_OF_CONTINUATIONS_MAXSIZE);
+  private int fpsInContList = 0;
+  private int indexInContList = 0;
+  private boolean iInstalledABarrier = false;
+
+  public static boolean wsRetBarrier = false;
+
+  @Uninterruptible
+  @Inline
+  public static Address getReturnAddress_(Address fp) {
+    Address rtn = Magic.getReturnAddressUnchecked(fp);
+    if (isTrampolineIP(rtn)) {
+      RVMThread t = getCurrentThread();
+      if (!t.hijackedReturnCalleeFp.EQ(fp)) {
+        for (int tid = 0; tid < nextSlot; tid++) {
+          t = threadBySlot[tid];
+          if (t != null && t.hijackedReturnCalleeFp.EQ(fp))
+            break;
+        }
+      }
+      VM.sysWrite("<H>");
+      return t.hijackedReturnAddress;
+    } else {
+      return rtn;
+    }
+  }
+
+  @Uninterruptible
+  @Inline
+  public static Address getReturnAddress(Address fp) {
+    Address rtn = Magic.getReturnAddressUnchecked(fp);
+    if (isTrampolineIP(rtn)) {
+      RVMThread t = getCurrentThread();
+      if (!t.hijackedReturnCalleeFp.EQ(fp)) {
+        for (int tid = 0; tid < nextSlot; tid++) {
+          t = threadBySlot[tid];
+          if (t != null && t.hijackedReturnCalleeFp.EQ(fp))
+            break;
+        }
+      }
+      return t.hijackedReturnAddress;
+    } else {
+      return rtn;
+    }
+  }
+
+  /**
+   * The return barrier.
+   * <p>
+   * The following code implements return barriers as described
+   * for Lisp by Yuasa
+   *
+   * http://www.yuasa.kuis.kyoto-u.ac.jp/~yuasa/ilc2002/index.html
+   * http://dx.doi.org/10.1109/ISORC.2005.45
+   *
+   * and for Jikes RVM by Kumar et al
+   *
+   * http://dx.doi.org/10.1145/2398857.2384639
+   * <p>
+   * This code is executed when a method returns into a frame that
+   * has been hijacked by the return barrier mechanism.   The return
+   * barrier trampoline will save state, execute this method, and
+   * then upon return from this method will transparently return into
+   * the frame that had been hijacked.
+   * <p>
+   * In this default implementation, the barrier reinstalls itself
+   * in the caller's frame thus incrementally moving the barrier down
+   * the stack.
+   * <p>
+   * The execution of this method is fragile.  It is generally safest
+   * to call some other method from here that does the substantive work
+   * of the barrier.
+   */
+  @Entrypoint
+  @Uninterruptible
+  @Unpreemptible
+  public static void returnBarrier() {
+    /* reinstall the barrier in the caller's frame */
+    if (DEBUG_STACK_TRAMPOLINE) {
+      VM.sysWriteln(getCurrentThread().getId(), " T0: ", getCurrentThread().trampolineRegisters.gprs.get(BaselineConstants.T0_int).toAddress());
+      VM.sysWriteln(getCurrentThread().getId(), " T1: ", getCurrentThread().trampolineRegisters.gprs.get(BaselineConstants.T1_int).toAddress());
+      VM.sysWriteln(getCurrentThread().getId(), " nf: ", getCurrentThread().hijackedReturnCallerFp);
+      VM.sysWriteln(getCurrentThread().getId(), " lf: ", getCurrentThread().hijackedReturnCalleeFp);
+      VM.sysWriteln(getCurrentThread().getId(), " fp: ", Magic.getFramePointer());
+      VM.sysWriteln(getCurrentThread().getId(), " np: ", Magic.getCallerFramePointer(Magic.getFramePointer()));
+    }
+    /* reinstall the barrier in the specified frame */
+    getCurrentThread().returnBarrier_internal();
+  }
+
+  /**
+   * Install the stack trampoline bridge at a given frame, hijacking
+   * that frame, saving the hijacked return address and callee fp
+   * in thread-local state to allow execution of the hijacked frame
+   * later.
+   *
+   * @param targetFp The frame to be hijacked.
+   */
+  @Uninterruptible
+  @Inline
+  public void wsInstallStackTrampolineBridge(Address targetFp) {
+    Address trampoline = getStackTrampolineBridgeIP();
+    if(wsDebugTrace) {
+      if (trampoline.isZero()) {
+        if (VM.VerifyAssertions)
+          VM._assert(VM.NOT_REACHED);
+        else
+          VM.sysWriteln("Warning: attempt to install stack trampoline without bridge instructions - nothing done.  See RVMThread.");
+      } else if (trampoline.NE(Magic.getReturnAddressUnchecked(targetFp))) {
+        /* install the trampoline at fp or the next suitable frame after fp */
+        while (true) {
+          if (Magic.getCallerFramePointer(targetFp).EQ(ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+            /* if we're at the bottom of the stack, then do not install anything */
+            hijackedReturnAddress = Address.zero();
+            hijackedReturnCalleeFp = Address.zero();
+            return;
+          }
+          int cmid = Magic.getCompiledMethodID(targetFp);
+          if (cmid == ArchitectureSpecific.ArchConstants.INVISIBLE_METHOD_ID) {
+            /* skip invisible methods */
+            VM.sysWriteln("Warning: install stack trampoline skipping INVISIBLE_METHOD..  See RVMThread.");
+            targetFp = Magic.getCallerFramePointer(targetFp);
+          } else {
+            CompiledMethod calleeCM = CompiledMethods.getCompiledMethod(cmid);
+            if (calleeCM.getCompilerType() == CompiledMethod.TRAP ||
+                calleeCM.getMethod().getDeclaringClass().hasBridgeFromNativeAnnotation()) {
+              /* skip traps and native bridges */
+              VM.sysWriteln("Warning: install stack trampoline skipping Traps..  See RVMThread.");
+              targetFp = Magic.getCallerFramePointer(targetFp);
+            } else
+              break;
+          }
+        }
+        if (DEBUG_STACK_TRAMPOLINE) {
+          VM.sysWriteln(getId(), " Installing trampoline at: ", targetFp);
+          VM.sysWriteln(getId(), " Dumping my original stack first");
+          dumpStack(this.contextRegisters.getInnermostInstructionAddress(),this.contextRegisters.getInnermostFramePointer());
+        }
+        hijackedReturnAddress = Magic.getReturnAddressUnchecked(targetFp);
+        hijackedReturnCalleeFp = targetFp;
+        hijackedReturnCallerFp = Magic.getCallerFramePointer(targetFp);
+        if (VM.VerifyAssertions) VM._assert(trampoline.NE(hijackedReturnAddress));
+        Magic.setReturnAddress(targetFp, trampoline);
+        if (DEBUG_STACK_TRAMPOLINE) {
+          VM.sysWriteln(getId(), " Trampoline: ", trampoline);
+          VM.sysWriteln(getId(), " Hijacked return address: ", hijackedReturnAddress);
+          VM.sysWriteln(getId(), " Callee fp: ", hijackedReturnCalleeFp);
+          VM.sysWriteln(getId(), " Caller fp: ", hijackedReturnCallerFp);
+          VM.sysWriteln(getId(), " Trampoline installation done. Now Dumping the new stack");
+          //				dumpStack(hijackedReturnCalleeFp);
+          dumpStack(this.contextRegisters.getInnermostInstructionAddress(),this.contextRegisters.getInnermostFramePointer());
+        }
+      }
+    }
+    else {
+      // No checks on fast path
+      hijackedReturnAddress = Magic.getReturnAddressUnchecked(targetFp);
+      hijackedReturnCalleeFp = targetFp;
+      hijackedReturnCallerFp = Magic.getCallerFramePointer(targetFp);
+      Magic.setReturnAddress(targetFp, trampoline);
+    }
+  }
+
+  @Uninterruptible
+  @Inline
+  public void resetTramoplineInfo() {
+    if(wsDebugTrace) {
+      VM.sysWriteln(getId(),": Resetting my barrier variables");
+    }
+    wsReturnBarrierUninstalled = true;
+    hijackedReturnCalleeFp = Address.zero();
+    hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+  }
+
+  @Uninterruptible
+  @Inline
+  public void resetTramoplineInfo_unlocked() {
+    wsReturnBarrierUninstalled = true;
+    wsSafeToReturnFromBarrier = true;
+    wsWaitingInsideBarrier = false;
+    hijackedReturnCalleeFp = Address.zero();
+    hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+  }
+
+  /**
+   * de-install the stack trampoline (disabling return barriers).
+   */
+  @Uninterruptible
+  @Inline
+  public void deInstallStackTrampoline() {
+    if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": deinstalling trampoline: ", framePointer);
+    if (!hijackedReturnCalleeFp.isZero()) {
+      if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": need to reinstall: ", hijackedReturnAddress);
+      hijackedReturnCalleeFp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET).store(hijackedReturnAddress);
+      hijackedReturnCalleeFp = Address.zero();
+      hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+      wsReturnBarrierUninstalled = true;
+      if(wsDebugTrace) {
+        VM.sysWriteln(getId(),": My barrier is deInstalled by thief W-",getCurrentThread().getId());
+      }
+    }
+  }
+
+  @Uninterruptible
+  @Inline
+  public void deInstallStackTrampoline_fromGC() {
+    if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": deinstalling trampoline: ", framePointer);
+    if (!hijackedReturnCalleeFp.isZero()) {
+      if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": need to reinstall: ", hijackedReturnAddress);
+      hijackedReturnCalleeFp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET).store(hijackedReturnAddress);
+      hijackedReturnCalleeFp = Address.zero();
+      hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+      wsReturnBarrierUninstalled = true;
+      if(workstealingInProgress) VM.sysFail("GC cannot take place when workstealingInProgress");
+      wsSafeToReturnFromBarrier = true;
+      wsWaitingInsideBarrier = false;
+      if(wsDebugTrace) {
+        VM.sysWriteln(getId(),": My barrier is deInstalled from GC");
+      }
+    }
+  }
+
+  @Uninterruptible
+  @Inline
+  private void wsUnlockFromReturnBarrier() {
+    wsLock().lockNoHandshake();
+    /* Never use this method here at all if the victim has already branched into the return barrier else there will be bugs !!
+		deInstallStackTrampoline();
+     */
+
+    // List contains fps of callee to the continuation frames. Once the steal is completed, 
+    // means the last fp in the list is the callee to the task stolen in this steal.
+    fpsInContList--;	
+    wsSafeToReturnFromBarrier = true;
+    wsLock().broadcast();
+    wsLock().unlock();
+  }
+
+  // Some debug flags
+  // {
+  final protected static boolean createContinuationDistribution = false;
+  // Switches to enable / disble optimizations related to return barrier
+  // 1) The most basic optimization w.r.t return barrier
+  final private static boolean victimCanBeReleasedAfterRBarrierIsInstalled = true;
+  // 2) Enable this only if 1 is true
+  final private static boolean victimCanReinstallBarrier = true;
+  // 3) Enable this only if 1 and 2 is true
+  final private static boolean thiefCanInitiateStealFromAPreInstalledBarrier = true;
+  // }
+
+  @Uninterruptible
+  @Inline
+  public void returnBarrier_internal() {
+    if(wsDebugTrace) {
+      VM.sysWriteln(getId(),": Entering inside rbarrier");
+    }
+    {
+      wsLock().lockNoHandshake();
+      hijackedReturnAddress_original = hijackedReturnAddress;
+      while(true) {
+        boolean removeBarrier = false;
+        // 1. should break out if no steals in progress
+        //		1a) try to re-install the barrier 
+        if(wsSafeToReturnFromBarrier) {
+          if(victimCanReinstallBarrier) {
+            if(indexInContList < fpsInContList) {
+              if(false) {
+                final int remaining = fpsInContList - indexInContList;
+                if(remaining >= 4) { 
+                  // install in the middle most fp - better than installing in each fp
+                  final int sum = indexInContList + fpsInContList;
+                  indexInContList = (sum%2 == 0) ? (sum/2 -1) : sum/2;
+                }
+              }
+              wsInstallStackTrampolineBridge(array_of_continuations.get(indexInContList++));	
+              if(wsDebugTrace) {
+                VM.sysWriteln(getId(),": Done reinstalling my own rbarrier");
+              }
+              break;
+            }
+            else {
+              // remove barrier variables as its now going to be unInstalled
+              removeBarrier = true;
+            }
+          }
+          else {
+            // remove barrier variables as its now going to be unInstalled
+            removeBarrier = true;
+          }
+        }
+        // If I am here then it means either: 
+        // a) I shd remove barrier 
+        // 			OR
+        // b) !wsSafeToReturnFromBarrier
+        if(removeBarrier) {
+          // Break out only if 
+          // i) no work-stealing is in progress
+          //				OR
+          // ii) The last thief decided that no further steal happens from this barrier
+          //    position. This is only if there are no more continuations remaining below
+          //    Only one variable workstealingInProgress is not sufficient to decide. 
+          //
+          //    Helps reducing failed steal ========> 
+          //	  If there is no continuations but before I reach here, another thief get
+          //    holds of me then it can do a failed steal attempt.
+          //
+          //	  Helps removing deadlock =========>
+          //	  When the last theif found there are no more continuations left, it marks
+          //    wsReturnBarrierUninstalled =  true. Now if we dont have the check for 
+          //    wsReturnBarrierUninstalled here then there maybe a deadlock. Suppose another
+          //    another theif grabs me mark workstealingInProgress=true. But just then I reach
+          //    over here and see that workstealingInProgress is in progress, I will keep waiting
+          //    However the thief is not aware of this, and it will wait for me to yield, which
+          //    will never happen. Hence two variables required here.
+          if(!workstealingInProgress || wsReturnBarrierUninstalled) {
+            if(wsDebugTrace) {
+              VM.sysWriteln(getId(),": No steal in progress hence removing my barrier");
+            }
+            resetTramoplineInfo();
+            break;
+          }
+          else {
+            if(wsDebugTrace) {
+              VM.sysWriteln(getId(),": There is a steal in progress hence cannot remove my barrier and so waiting");
+            }
+          }
+        }
+        else {
+          // case b
+          // ==> simply wait !!!
+          if(wsDebugTrace) {
+            VM.sysWriteln(getId(),": Thief still access my stack hence waiting in barrier to try unwind");
+          }
+        }
+        final long start = Magic.getTimeBase();
+        wsWaitingInsideBarrier = true;
+        wsLock().waitNoHandshake();
+        wsWaitingInsideBarrier = false;
+        totalBarrierCPUCycles += (Magic.getTimeBase() - start);
+        // 3. update the hijacked return address as thief may have updated it with join instruction
+        hijackedReturnAddress_original = hijackedReturnAddress;
+      }
+
+      wsLock().unlock();
+    }
+    if(wsDebugTrace) {
+      VM.sysWriteln(getId(),": Returning from rbarrier");
+    }
+  }
+
+  private Address hijackedReturnAddress_original; //is set only from returnBarrier() method
+  public Address getHijackedReturnCallerFp() { return hijackedReturnCallerFp; }
+  public Address getHijackedReturnAddress() { return hijackedReturnAddress; }
+
+  public boolean wsMaintainsClonedStackAlso() {
+    return !wsReturnBarrierUninstalled;
+  }
+
+  // Lock/Unlock flags for return barrier: a) and b)
+  /*
+   * a)
+   * --- This flag is turned on by thief at the victim as soon as it installs a barrier
+   * on this victim
+   * --- Thief can mark it off if it starts a steal from a barrier but finds 0 or 1
+   * continuations.
+   * --- Victim is allowed to mark it off only when its removing the barrier from its
+   * stack
+   * 
+   * Thieves use this to decide if they can start stealing from a return barrier
+   * without forcing the victim to execute yieldpoint. 
+   */
+  private boolean wsReturnBarrierUninstalled = true;
+  /*
+   * b) 
+   * -- Default value is true. Only a thief can make it off (false)
+   * Victims can only read but cannot write to it. Victims use it
+   * to decide when it becomes safe for them to re-install this barrier
+   * at a new position.
+   */
+  private boolean wsSafeToReturnFromBarrier = true;
+
+  /*
+   * This lock is used to decide if a steal is is progress at a victim.
+   * However, this flag is also used inside return barrier to decide
+   * if its safe for a victim to remove its return barrier from its stack.
+   * Only a thief is allowed to write to this flag and make it true/false.
+   * Victims can only read it. Unless its false, they cannot remove its
+   * return barrier. 
+   */
+  protected boolean workstealingInProgress = false;
+
+  public void setHijackedReturnAddress(Address ip) { hijackedReturnAddress = ip; } 
+
+  /** @return the address of the stack trampoline bridge code */
+  @Inline
+  private Address getStackTrampolineBridgeIP() { return Magic.objectAsAddress(stackTrampolineBridgeInstructions); }
+
+  /** @return the hijacked return address */
+  @Inline
+  public Address getTrampolineHijackedReturnAddress() { return hijackedReturnAddress; }
+
+  /**
+   * Determine whether a given method is the stack trampoline
+   *
+   * @param ip the code to be checked
+   * @return <code>true</code> if the code is the stack trampoline.
+   */
+  @Inline
+  public static boolean isTrampolineIP(Address ip) { return getCurrentThread().getStackTrampolineBridgeIP().EQ(ip); }
+
+  /**
+   * Given a frame that has been hijacked by the stack trampoline,
+   * return the real (hijacked) return address.
+   *
+   * @param hijackedFp a frame that has been hijacked by the stack trampoline
+   * @return the return address for the frame that was hijacked.
+   */
+  @Uninterruptible
+  public static Address getHijackedReturnAddress(Address hijackedFp) {
+    if (VM.VerifyAssertions) VM._assert(isTrampolineIP(Magic.getReturnAddressUnchecked(hijackedFp)));
+    RVMThread t = getCurrentThread();
+    if (!t.hijackedReturnCalleeFp.EQ(hijackedFp)) {
+      for (int tid = 0; tid < nextSlot; tid++) {
+        t = threadBySlot[tid];
+        if (t != null && t.hijackedReturnCalleeFp.EQ(hijackedFp))
+          break;
+      }
+    }
+    return t.hijackedReturnAddress;
+  }
+
+  @Uninterruptible
+  @Inline
+  public Address getCalleeFramePointer(final Address fp) {
+    Address calleeFP = fp;
+    final Address top = Magic.objectAsAddress(this.getStack());
+    final Address base = top.plus(this.getStackLength());
+
+    while(calleeFP.NE(base)) {
+      if(calleeFP.loadAddress().EQ(fp)) return calleeFP;
+      calleeFP = calleeFP.minus(StackframeLayoutConstants.BYTES_IN_STACKSLOT);
+    }
+    return Address.zero();
+  }
+
+  @Unpreemptible
+  @Inline
+  protected void wsCheckShadowStack_retbarrier(RVMThread victim) {
+    if (wsShadowStack == null || wsShadowStack.length < victim.getStackLength()) {
+      wsShadowStack = MemoryManager.newStack(victim.getStackLength());
+    }
+
+    if (victim.wsVictimShadowStack == null || victim.wsVictimShadowStack.length < victim.getStackLength()) {
+      victim.wsVictimShadowStack = MemoryManager.newStack(victim.getStackLength());
+    }
+  }
+
+  @Unpreemptible
+  @Inline
+  public static Address wsCloneVictimStack(final RVMThread victim, final Address yieldpointFP) {
+    byte[] newStack = victim.wsVictimShadowStack;
+    byte[] currStack = victim.getStack();
+
+    Address currTop = Magic.objectAsAddress(currStack).plus(currStack.length);
+    Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
+
+    Offset currDepth = currTop.diff(yieldpointFP);
+    Address newFP = newTop.minus(currDepth);
+
+    Memory.memcopy(newFP, yieldpointFP, currDepth.toWord().toExtent());
+
+    Offset delta = newFP.diff(yieldpointFP);
+
+    adjustStack(newStack, newFP, delta);
+    victim.victimYieldIPOnNewStack = Magic.getReturnAddress(yieldpointFP);
+
+    return Magic.getCallerFramePointer(newFP);
+  }
+
+  /**
+   * This method should always be called from a method which has following annotations:
+   * 1) @Unpreemptible
+   * 2) @NoInline
+   * 3) @NoOptCompile
+   * 4) @BaselineSaveLSRegisters
+   */
+  @Unpreemptible
+  @NoInline
+  @BaselineNoRegisters
+  private void wsCloneMyOwnStack(Address ip, Address fp) {
+    byte[] newStack = wsVictimShadowStack;
+    byte[] myStack = stack;
+
+    // initialize new stack with live portion of stack we're
+    // currently running on
+    //
+    // lo-mem hi-mem
+    // |<---myDepth----|
+    // +----------+---------------+
+    // | empty | live |
+    // +----------+---------------+
+    // ^myStack ^myFP ^myTop
+    //
+    // +-------------------+---------------+
+    // | empty | live |
+    // +-------------------+---------------+
+    // ^newStack ^newFP ^newTop
+    //
+    Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
+    Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
+
+    Address myFP = Magic.getFramePointer();
+    Offset myDepth = myTop.diff(myFP);
+    Address newFP = newTop.minus(myDepth);
+
+    // The frame pointer addresses the top of the frame on powerpc and
+    // the bottom
+    // on intel. if we copy the stack up to the current
+    // frame pointer in here, the
+    // copy will miss the header of the intel frame. Thus we make another
+    // call
+    // to force the copy. A more explicit way would be to up to the
+    // frame pointer
+    // and the header for intel.
+    Offset delta = copyStack(newStack);
+
+    // fix up registers and save areas so they refer
+    // to "newStack" rather than "myStack"
+    //
+    adjustStack(newStack, newFP, delta);
+
+    victimYieldFpOnNewStack = Magic.getCallerFramePointer(newFP);
+    victimYieldIPOnNewStack = Magic.getReturnAddress(newFP);
+  }
+
+  /**
+   * Replace the execution of the current thread with some stolen work.
+   */
+  @Interruptible
+  public static void wsSteal(java.lang.Thread victim) {
+    wsSteal(JikesRVMSupport.getThread(victim));
+  }
+
+  @Unpreemptible
+  private void wsCheckShadowStack(int length) {
+    if (wsShadowStack == null || wsShadowStack.length < length) {
+      wsShadowStack = MemoryManager.newStack(length);
+    }
+  }
+
+  /**
+   * Replace the execution of the current thread with some stolen work.
+   */
+  @Unpreemptible
+  public static void wsSteal(RVMThread victim) {
+    RVMThread.getCurrentThread().wsStealInternal(victim);
+  }
+
+  @Unpreemptible
+  public static void wsSteal_retbarrier(RVMThread victim) {
+    RVMThread.getCurrentThread().wsStealInternal_retbarrier(victim);
+  }
+
+  public Address stackTop() {
+    return stackTop(stack);
+  }
+
+  public Address stackTop(byte[] stack) {
+    return Magic.objectAsAddress(stack).plus(stack.length);
+  }
+
+  // debugging support
+  final protected static boolean wsDebugTrace = false;
+  private RVMThread wsDebugMyCurrentVictim = null;
+  private boolean wsDebugRBAlreadyInstalled = false;
+  // debugging support
+  @UnpreemptibleNoWarn
+  public static void dumpWSDetailsWhileDeliveringHardwareException() {
+    RVMThread me = getCurrentThread();
+    if(me.wsDebugMyCurrentVictim != null) {
+      VM.sysWriteln("============================================================================================================");
+      VM.sysWriteln("Trying to dump details of current work-stealing... Though it might be dangerous..");
+      VM.sysWriteln("My victim was thread ",me.wsDebugMyCurrentVictim.getId());
+      VM.sysWriteln("Did I installed a return barrier = ",me.iInstalledABarrier);
+      VM.sysWriteln("Did I found a pre-installed return barrier = ",me.wsDebugRBAlreadyInstalled);
+      if((!me.iInstalledABarrier && !me.wsDebugRBAlreadyInstalled) || !RVMThread.victimCanBeReleasedAfterRBarrierIsInstalled) {
+        VM.sysWriteln("First Trying to dump the original stack of victim");
+        dumpStack(me.wsDebugMyCurrentVictim.getContextRegisters().getInnermostInstructionAddress(), me.wsDebugMyCurrentVictim.getContextRegisters().getInnermostFramePointer());
+      }
+      if(me.iInstalledABarrier || me.wsDebugRBAlreadyInstalled) {
+        VM.sysWriteln("Dumping the hijacked addresses w.r.t return barrier at the victim: ");
+        VM.sysWriteln("Hijacked return address: ", me.wsDebugMyCurrentVictim.hijackedReturnAddress);
+        VM.sysWriteln("Callee fp: ", me.wsDebugMyCurrentVictim.hijackedReturnCalleeFp);
+        VM.sysWriteln("Caller fp: ", me.wsDebugMyCurrentVictim.hijackedReturnCallerFp);
+      }
+      if(me.iInstalledABarrier || me.wsDebugRBAlreadyInstalled) {
+        VM.sysWriteln("Now Trying to dump the cloned stack of victim");
+        dumpStack(me.wsDebugMyCurrentVictim.victimYieldIPOnNewStack, me.wsDebugMyCurrentVictim.victimYieldFpOnNewStack);
+      }
+      if(me.wsFrameCopier.debugStackFrameProcessing) {
+        VM.sysWriteln("Hardware Exception was actually generated inside StackFrameCopier.copyStack(.....)");
+        VM.sysWriteln("The fp being scanned was = ",me.wsFrameCopier.debugScanFp);
+        VM.sysWriteln("The ip being scanned was = ",me.wsFrameCopier.debugScanIp);
+      }
+      VM.sysWriteln("DONE dumping details of current work-stealing....");
+      VM.sysWriteln("============================================================================================================");
+    }
+  }
+
+  @UnpreemptibleNoWarn
+  @Inline
+  private boolean wsSafeToAttemptSteal() {
+    boolean safe = false;
+    wsLock().lockNoHandshake();
+    safe = !workstealingInProgress;
+    if(safe) {
+      workstealingInProgress = true;
+      if(!RVMThread.thiefCanInitiateStealFromAPreInstalledBarrier) wsReturnBarrierUninstalled = true;
+      if(wsDebugTrace) {
+        VM.sysWriteln(getCurrentThread().getId(),": Grabbed victim W-",getId());
+      }
+      final boolean barrierPreInstalled = thiefCanInitiateStealFromAPreInstalledBarrier && !wsReturnBarrierUninstalled;
+      if(barrierPreInstalled) {
+        /*
+         * In this case, we can safely decide here if we really need to start
+         * steal from this barrier. If there are no more continuations left
+         * in the continuation list, then no need to use this barrier. Mark
+         * it unusable and start stealing by yielding the victim.
+         */
+        final boolean startStealFromBarrier = indexInContList < fpsInContList;
+        if(startStealFromBarrier) {
+          wsSafeToReturnFromBarrier = false;
+          if(wsDebugTrace) {
+            getCurrentThread().wsDebugRBAlreadyInstalled = true;
+            VM.sysWriteln(getCurrentThread().getId(),": RBarrier preinstalled on W-",getId());
+          }
+        }
+        else {
+          wsReturnBarrierUninstalled = true;
+          wsSafeToReturnFromBarrier = true;
+          if(wsDebugTrace) {
+            getCurrentThread().wsDebugRBAlreadyInstalled = true;
+            VM.sysWriteln(getCurrentThread().getId(),": RBarrier preinstalled But of no use on W-",getId());
+          }
+        }
+      }
+      fpsInContList = 0;
+      indexInContList = 0;
+    }
+    wsLock().unlock();
+    return safe;
+  }
+
+  @UnpreemptibleNoWarn
+  @Inline
+  private void wsFinishedStealing(boolean markBarrierUnusable) {
+    wsLock().lockNoHandshake();
+    workstealingInProgress = false;
+    if(markBarrierUnusable) {
+      wsSafeToReturnFromBarrier = true;
+      wsReturnBarrierUninstalled = true;
+      if(wsDebugTrace) {
+        VM.sysWriteln(getCurrentThread().getId(),": Marking the barrier unsuable and uninstalled for W-",getId());
+      }
+    }
+    if(wsWaitingInsideBarrier) {
+      if(wsDebugTrace) {
+        VM.sysWriteln(getCurrentThread().getId(),": Stealing done and broadcasting to come out of barrier to W-",getId());
+      }
+      // unlock victim from wait inside barrier
+      wsLock().broadcast();
+    }
+    else {
+      if(wsDebugTrace) {
+        VM.sysWriteln(getCurrentThread().getId(),": Stealing done but no broadcast to vicitm W-",getId());
+      }
+    }
+    wsLock().unlock();
+  }
+
+  @UnpreemptibleNoWarn
+  private void wsStealInternal(RVMThread victim) {
+    if (VM.VerifyAssertions) VM._assert(wsStealHead == null);
+    if (VM.VerifyAssertions) VM._assert(this != victim);
+    if (VM.VerifyAssertions) VM._assert(!wsFlag);
+
+    if(!victim.wsSafeToAttemptSteal()) return;
+
+    final long startStealCPUCycles = Magic.getTimeBase();
+
+    findAttempts++;
+
+    // Synchronize with victim
+    victim.beginPairHandshake();
+
+    if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = victim;
+
+    if (!victim.wsFlag) {
+      // Nothing to steal!
+      if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+      victim.endPairHandshake();
+      victim.wsFinishedStealing(false);
+      totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+      return;
+    }
+
+    // Container for steal/join info.
+    WS.StealInfo steal = new WS.StealInfo();
+    WS.FinishInfo finish = new WS.FinishInfo();
+
+    // Ensure stack size now the victim is stopped, should rarely run.
+    wsCheckShadowStack(victim.stack.length);
+
+    // Copy the context registers from the victim.
+    Address ip, fp;
+    contextRegisters.clear();
+    victim.monitor().lockNoHandshake();
+    if (victim.getExecStatus() == RVMThread.BLOCKED_IN_JNI) {
+      ip = Address.zero();
+      fp = victim.getJNIEnv().topJavaFP();
+    } else {
+      ip = victim.getContextRegisters().getInnermostInstructionAddress();
+      fp = victim.getContextRegisters().getInnermostFramePointer();
+    }
+    victim.monitor().unlock();
+    contextRegisters.setInnermost(ip,fp);
+
+    // Search the victim for potential steals
+    int found = victim.wsFindSteal(contextRegisters, steal, finish);
+    if (found <= 1) victim.wsFlag = false;
+    if (found == 0) {
+      // Nothing to steal!
+      if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+      victim.endPairHandshake();
+      victim.wsFinishedStealing(false);
+      totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+      return;
+    }
+    if(createContinuationDistribution) {
+      victim.continuationsDistribution(found);
+    }
+    // New head of our join info is the victims old head.
+    wsStealHead = steal.prev();
+    wsFinishHead = steal.finish;
+
+    // work out how much 
+    Address newTop = stackTop(wsShadowStack);
+    Address vicTop = victim.stackTop();
+    Offset offset = newTop.diff(vicTop);
+    Address newFP = newTop.minus(steal.fpOffset);
+
+    // fix up the stack and registers while walking the real stack
+    contextRegisters.inuse = true;
+    wsFrameCopier.copyStack(fp, ip, victim, this, contextRegisters, steal.fpOffset,
+        -1, offset, vicTop);
+    adjustRegisters(contextRegisters, offset);
+    if (VM.VerifyAssertions) {
+      Address testFp = newFP;
+      while (testFp.NE(ArchConstants.STACKFRAME_SENTINEL_FP)) {
+        VM._assert(testFp.GE(Magic.objectAsAddress(wsShadowStack)));
+        VM._assert(testFp.LT(stackTop(wsShadowStack)));
+        testFp = Magic.getCallerFramePointer(testFp);
+      }
+    }
+
+    // install new stack
+    byte[] temp = stack;
+    stack = wsShadowStack;
+    wsShadowStack = temp;
+
+    // jump into new stack by throwing an exception
+    VM.disableGC();
+    WS.incFinish(steal.finish);
+
+    int compiledMethodId = Magic.getCompiledMethodID(newFP);
+    CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+    Address catchBlockStart = compiledMethod.getInstructionAddress(true, steal.cbOffset);
+    contextRegisters.setInnermost(catchBlockStart, newFP);
+
+    totalSteals++;
+
+    if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+    victim.endPairHandshake();
+    totalSuccessStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+    victim.wsFinishedStealing(false);
+    stackLimit = Magic.objectAsAddress(stack).plus(STACK_SIZE_GUARD);
+    compiledMethod.getExceptionDeliverer().deliverException(compiledMethod, catchBlockStart, wsContinuation, contextRegisters);
+  }
+
+  @UnpreemptibleNoWarn
+  private void wsStealInternal_retbarrier(RVMThread victim) {
+    if (VM.VerifyAssertions) VM._assert(wsStealHead == null);
+    if (VM.VerifyAssertions) VM._assert(this != victim);
+    if (VM.VerifyAssertions) VM._assert(!wsFlag);
+
+    if(wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Stealing from W-",victim.getId());
+    }
+
+    if(!victim.wsSafeToAttemptSteal()) return;
+
+    final long startStealCPUCycles = Magic.getTimeBase();
+    findAttempts++;
+
+    // check if return barrier is already installed
+    // No need to take wsLock(), as we have already told victim not
+    // to unwind from barrier (if any present)
+    final boolean barrierPreInstalled = thiefCanInitiateStealFromAPreInstalledBarrier && !victim.wsReturnBarrierUninstalled;
+
+    /*
+     * ensure that the victim is stopped inside @BaselineSaveLSRegisters frame
+     * so that thief can safely copy its frame and process callee save registers
+     * offline.
+     */
+    boolean wsSafeToInstallRBarrierInVictim = true;
+
+    if(!barrierPreInstalled) {
+      if(RVMThread.wsDebugTrace) {
+        VM.sysWriteln(this.getId(),": Attempting pairing with W-",victim.getId());
+      }
+
+      wsSafeToInstallRBarrierInVictim = victim.wsBeginPairHandshake();
+      victim.deInstallStackTrampoline();
+
+      if(RVMThread.wsDebugTrace) {
+        VM.sysWriteln(this.getId(),": Pairing done with W-",victim.getId());
+      }
+    }
+
+    if(RVMThread.wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Pairing done with W-",victim.getId());
+      wsDebugRBAlreadyInstalled = false;
+      wsDebugMyCurrentVictim = victim;
+    }
+
+    // Ensure stack size now the victim is stopped, should rarely run.
+    wsCheckShadowStack_retbarrier(victim);
+
+    if (!victim.wsFlag) {
+      if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+      if(wsDebugTrace) {
+        VM.sysWriteln(this.getId(),": wsFlag was false, releasing W-",victim.getId());
+      }
+      // Nothing to steal!
+      if(!barrierPreInstalled) {
+        victim.endPairHandshake();
+        totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+      }
+      // No need to sum time for failed steal in case barrierPreInstalled
+      // because the only time lost by victim is what it waits inside
+      // handshake function inside the barrier. That place has its
+      // own timer hence no need for timing victim loss here.
+      victim.wsFinishedStealing(true);
+      return;
+    }
+
+    if(wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Start searching continuation in W-",victim.getId());
+    }
+
+    // Container for steal/join info.
+    WS.StealInfo steal = new WS.StealInfo();
+    WS.FinishInfo finish = new WS.FinishInfo();
+
+    // Copy the context registers from the victim.
+    Address ip, fp;
+    contextRegisters.clear();
+    boolean victimBlockedInJNI = false;
+    if(!barrierPreInstalled) { 
+      victim.monitor().lockNoHandshake();
+      if (victim.getExecStatus() == RVMThread.BLOCKED_IN_JNI) {
+        ip = Address.zero();
+        fp = victim.getJNIEnv().topJavaFP();
+        victimBlockedInJNI = true;
+        if(wsDebugTrace) {
+          VM.sysWriteln(this.getId(),": Found blocked in JNI W-",victim.getId());
+        }
+
+      } else {
+        ip = victim.getContextRegisters().getInnermostInstructionAddress();
+        fp = victim.getContextRegisters().getInnermostFramePointer();
+      }
+      victim.wsSafeToReturnFromBarrier = false;
+      victim.monitor().unlock();
+    }
+    else {
+      fp = victim.victimYieldFpOnNewStack;
+      ip = victim.victimYieldIPOnNewStack;
+      preInstalledBarriers++;
+    }
+
+    contextRegisters.setInnermost(ip,fp);
+
+    Address vicTop = barrierPreInstalled ? victim.stackTop(victim.wsGetClonedStack()) : victim.stackTop();
+    // Search the victim for potential steals
+    int found = (victimBlockedInJNI || !wsSafeToInstallRBarrierInVictim) ? victim.wsFindSteal(contextRegisters, steal, finish) : victim.wsFindSteal_retBarrier(steal, finish, vicTop, barrierPreInstalled, startStealCPUCycles);
+
+    if(wsDebugTrace) {
+      VM.sysWriteln(victim.getId(),": Total available continuations = ",found);
+    }
+
+    if (found <= 1 && !barrierPreInstalled) {
+      /*
+       * If we started the steal from a return barrier and we discover
+       * that found <=1 then it does not mean wsFlag=false for this victim.
+       * There may be continuations available above the barrier, which can
+       * be stolen by yielding the victim.
+       */
+      victim.wsFlag = false;
+    }
+    if (found == 0) {
+      if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+      //Nothing to steal means there was no return barrier installed
+      if(wsDebugTrace) {
+        VM.sysWriteln(this.getId(),": Nothing to steal, releasing W-",victim.getId());
+      }
+      if(!barrierPreInstalled) {
+        victim.wsSafeToReturnFromBarrier = true;
+        victim.endPairHandshake();
+        totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+      }
+      // No need to sum time for failed steal in case barrierPreInstalled
+      // because the only time lost by victim is what it waits inside
+      // handshake function inside the barrier. That place has its
+      // own timer hence no need for timing victim loss here.
+
+      victim.wsFinishedStealing(true);
+      return;
+    }
+    if(createContinuationDistribution) {
+      victim.continuationsDistribution(found);
+    }
+
+    // update variables if I installed a barrier
+    if(iInstalledABarrier) {
+      vicTop =  victim.stackTop(victim.wsGetClonedStack());
+      fp = victim.victimYieldFpOnNewStack;
+      ip = victim.victimYieldIPOnNewStack;
+    }
+
+    // New head of our join info is the victims old head.
+    wsStealHead = steal.prev();
+    wsFinishHead = steal.finish;
+
+    // work out how much 
+    Address newTop = stackTop(wsShadowStack);
+    Offset offset = newTop.diff(vicTop);
+    Address newFP = newTop.minus(steal.fpOffset);
+
+    // fix up the stack and registers while walking the real stack
+    contextRegisters.inuse = true;
+
+    if(wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Start processing frames from W-",victim.getId());
+    }
+
+    wsFrameCopier.copyStack(fp, ip, victim, this, contextRegisters, steal.fpOffset, 
+        -1, offset, vicTop);
+
+    if(wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Done processing stolen frames from W-",victim.getId());
+    }
+
+    WS.incFinish(steal.finish);
+
+    final boolean canReleaseNow = (iInstalledABarrier || barrierPreInstalled) && RVMThread.victimCanBeReleasedAfterRBarrierIsInstalled;
+
+    if(canReleaseNow) {
+      final boolean isBarrierUnusable = (found == 1) && (iInstalledABarrier||barrierPreInstalled);
+      victim.wsFinishedStealing(isBarrierUnusable);
+      if(wsDebugTrace) {
+        VM.sysWriteln(this.getId(),": Releasing from barrier by marking workstealing done for W-",victim.getId());
+      }
+      iInstalledABarrier = false;
+    }
+
+    adjustRegisters(contextRegisters, offset);
+
+    if (VM.VerifyAssertions) {
+      Address testFp = newFP;
+      while (testFp.NE(ArchConstants.STACKFRAME_SENTINEL_FP)) {
+        VM._assert(testFp.GE(Magic.objectAsAddress(wsShadowStack)));
+        VM._assert(testFp.LT(stackTop(wsShadowStack)));
+        testFp = Magic.getCallerFramePointer(testFp);
+      }
+    }
+
+    // install new stack
+    byte[] temp = stack;
+    stack = wsShadowStack;
+    wsShadowStack = temp;
+
+    // jump into new stack by throwing an exception
+    VM.disableGC();
+
+    if(wsDebugTrace) {
+      wsDebugMyCurrentVictim = null;
+      VM.sysWriteln(this.getId(),": Stealing Done from W-",victim.getId());
+    }
+
+    int compiledMethodId = Magic.getCompiledMethodID(newFP);
+    CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+    Address catchBlockStart = compiledMethod.getInstructionAddress(true, steal.cbOffset);
+
+    totalSteals++;
+
+    if(!canReleaseNow) {
+      victim.endPairHandshake();
+      totalSuccessStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles); 
+      victim.wsFinishedStealing(false);
+    }
+
+    if(wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Throwing exception to start continuation");
+    }
+
+    contextRegisters.setInnermost(catchBlockStart, newFP);	//return barrier
+    stackLimit = Magic.objectAsAddress(stack).plus(STACK_SIZE_GUARD);
+    compiledMethod.getExceptionDeliverer().deliverException(compiledMethod, catchBlockStart, wsContinuation, contextRegisters);
+  }
+
+  /**
+   * Implement join functionality. This is always run by the victim, and there are basically two paths here.
+   * 
+   * 1) The victim stops and decrements the finish.
+   * 2) Control is returned to the victim to push some result into the finish state (after which it calls completeJoin). 
+   */
+  @Inline
+  @Unpreemptible
+  public void wsJoinInternal(Address fp, Address ip) {
+    // Medium-path check for unnecessary join call.
+    Offset fpOffset = stackTop().diff(fp);
+    if (wsStealHead == null || !wsStealHead.matches(fpOffset)) {
+      return;
+    }
+
+    int compiledMethodId = Magic.getCompiledMethodID(fp);
+    CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+    Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+    Offset cbOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, RVMType.WSContinuationType, true);
+    if (!wsStealHead.matches(fpOffset, cbOffset)) {
+      // Another check just to make sure we are doing the right thing
+      return;
+    }
+
+    cbOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, RVMType.WSJoinType, true);
+    if (cbOffset.sGE(Offset.zero())) {
+      // This join wants to return data to the finish.
+      wsInJoin = true;
+      wsJoin.finish = wsStealHead.finish;
+      RuntimeEntrypoints.athrow(wsJoin);
+    }
+    wsCompleteJoinInternal();
+  }
+
+  @NoInline
+  @UnpreemptibleNoWarn
+  public void wsCompleteFinishInternal() {
+    ObjectModel.genericUnlock_internal(wsFinishHead);
+    wsInJoin = false;
+    wsFlag = false;
+    wsStealHead = null;
+    wsFinishHead = null;
+    wsSpecialNVMap = 0;
+    if(RVMThread.wsRetBarrier) {
+      resetTramoplineInfo_unlocked();
+      WS.searchForWork_retbarrier();
+    }
+    else {
+      WS.searchForWork();
+    }
+  }
+
+  @NoInline
+  @UnpreemptibleNoWarn
+  public void wsCompleteJoinInternal() {
+    WS.StealInfo steal = wsStealHead;
+    if (WS.decFinish(steal.finish)) {
+      // We are going to run the finish...
+      VM.disableGC();
+      Magic.saveThreadState(contextRegisters);
+      Address fp = contextRegisters.getInnermostFramePointer();
+      Address top = stackTop();
+      // Search for the right frame.
+
+      while (top.diff(fp).NE(wsFinishHead.fpOffset)) {
+        if (VM.VerifyAssertions) VM._assert(fp.NE(STACKFRAME_SENTINEL_FP));
+        int compiledMethodId = Magic.getCompiledMethodID(fp);
+        if (compiledMethodId == INVISIBLE_METHOD_ID) {
+          contextRegisters.unwindStackFrame();
+        } else {
+          CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+          ExceptionDeliverer exceptionDeliverer = compiledMethod.getExceptionDeliverer();
+          exceptionDeliverer.unwindStackFrame(compiledMethod, contextRegisters);
+        }
+        fp = contextRegisters.getInnermostFramePointer();
+      }
+
+      int compiledMethodId = Magic.getCompiledMethodID(fp);
+      CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+      Address catchBlockStart = compiledMethod.getInstructionAddress(true, wsFinishHead.cbOffset);
+      contextRegisters.setInnermost(catchBlockStart, fp);
+      contextRegisters.inuse = true;
+      stackLimit = Magic.objectAsAddress(stack).plus(STACK_SIZE_GUARD);
+      wsFinish.data = wsFinishHead;
+      wsInJoin = false;
+      wsSpecialNVMap = 0;
+      wsStealHead = wsFinishHead.steal;
+      wsFinishHead = wsFinishHead.prev();
+      compiledMethod.getExceptionDeliverer().deliverException(compiledMethod, catchBlockStart, wsFinish, contextRegisters);
+      // Not reached
+    }
+    wsInJoin = false;
+    wsFlag = false;
+    wsStealHead = null;
+    wsFinishHead = null;
+    wsSpecialNVMap = 0;
+    if(wsRetBarrier) {
+      resetTramoplineInfo_unlocked();
+      WS.searchForWork_retbarrier();
+    }
+    else {
+      WS.searchForWork();
+    }
+  }
+
+  @UnpreemptibleNoWarn
+  @Inline
+  public Address getAddressValueOnClonedStack(final Address fp) {
+    if(fp.isZero()) return fp;
+    else return stackTop(wsVictimShadowStack).minus(stackTop().diff(fp));
+  }
+
+  @UnpreemptibleNoWarn
+  @Inline
+  private Address getAddressValueOnMainStack(final Address fp) {
+    return stackTop().minus(stackTop(wsVictimShadowStack).diff(fp));
+  }
+
+  /**
+   * Search through a potential victim's stack, and find:
+   *
+   *   1) The oldest continuation that can be stolen
+   *   2) The enclosing finish for this continuation.
+   * 
+   * The passed JoinInfo and FinishInfo classes are populated
+   * accordingly if a steal is found.
+   *
+   * @param top
+   * @param registers
+   * @param info
+   * @return
+   */
+  @UnpreemptibleNoWarn
+  @Inline
+  private int wsFindSteal(Registers registers, WS.StealInfo steal, WS.FinishInfo finish) {
+    int found = 0;
+    boolean skip = wsInJoin;
+    Address fp = registers.getInnermostFramePointer();
+    Address top = stackTop();
+    Offset stealCBOffset = Offset.zero();
+    Offset stealFPOffset = Offset.zero();
+    Offset finishCBOffset = Offset.zero();
+    Offset finishFPOffset = Offset.zero();
+    Address prevFp = Address.zero();
+    Address stealPrevFp = Address.zero();
+    Address finishPrevFp = Address.zero();
+
+    boolean foundStolen = false;
+    boolean foundFinish = true;
+    while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+      Offset fpOffset = top.diff(fp);
+      int compiledMethodId = Magic.getCompiledMethodID(fp);
+      if (compiledMethodId != INVISIBLE_METHOD_ID) {
+        CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+        if (compiledMethod.getCompilerType() == CompiledMethod.OPT || compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
+          // Process each normal stack frame.
+          // First we search for the oldest unstolen continuation. Once we hit an already stolen continuation or reach the end we are done.
+          // We also need to know the enclosing finish block.
+          // We need to try and find the outermost finish block for each method to make sure. 
+
+          Address ip = registers.getInnermostInstructionAddress();
+          Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+
+          Offset currentIPOffset = ipOffset;
+          Offset finishIPOffset = ipOffset;
+
+          // Search for a continuation to steal.
+          if (!foundStolen) {
+            while (true) {
+              Offset catchBlock = compiledMethod.findCatchBlockForInstruction(currentIPOffset, RVMType.WSContinuationType, true);
+              if (catchBlock.sLT(Offset.zero())) break;
+              if (wsStealHead != null && wsStealHead.find(fpOffset, catchBlock) != null) {
+                // This continuation has already been stolen, so we discard the current state. 
+                foundStolen = true;
+                break;
+              }
+              // This continuation has not been stolen, so we update info to reflect it.
+              if (!skip) {
+                finishIPOffset = currentIPOffset;
+                stealCBOffset = catchBlock;
+                stealFPOffset = fpOffset;
+                stealPrevFp = prevFp;
+                found++;
+                foundFinish = false;
+              }
+              skip = false;
+              // Advance into the catch block
+              currentIPOffset = catchBlock.plus(1);
+            }
+          }
+
+          // Search for an enclosing finish.
+          if (!foundFinish) {
+            Offset catchBlock = compiledMethod.findCatchBlockForInstruction(finishIPOffset, RVMType.WSFinishType, true);
+            if (catchBlock.sGE(Offset.zero())) {
+              // We found a finish block.
+              finishCBOffset = catchBlock;
+              finishFPOffset = fpOffset;
+              finishPrevFp = prevFp;
+              foundFinish = true;
+              if (foundStolen) {
+                // We know the continuation we are stealing, and we have found the first finish.
+                break;
+              }
+            }
+          }
+        }
+      }
+      registers.unwindStackFrame();
+      prevFp = fp;
+      fp = registers.getInnermostFramePointer();
+    }
+    if (found > 0) {
+      // Find the finish object to use.
+      if (foundFinish) {
+        // Look for an existing finish.
+        if (wsFinishHead != null) {
+          steal.finish = wsFinishHead.find(finishFPOffset, finishCBOffset);
+        }
+        if (steal.finish == null) {
+          // We are the first to use this finish.
+          finish.set(finishFPOffset, finishCBOffset);
+          finish.setPrev(wsFinishHead);
+          steal.finish = finish;
+          wsFinishHead = finish;
+
+          WS.installJoinInstructions(top.minus(finishFPOffset), finishPrevFp);
+        }
+      } else {
+        // We must be delivering back to a parent finish.
+        steal.finish = wsFinishHead;
+      }
+      WS.installJoinInstructions(top.minus(stealFPOffset), stealPrevFp);
+      steal.set(stealFPOffset, stealCBOffset);
+      steal.setPrev(wsStealHead);
+      wsStealHead = steal;
+      if (VM.VerifyAssertions) VM._assert(steal.finish != null);
+    }
+    return found;
+  }
+
+  @UnpreemptibleNoWarn
+  @Inline
+  private void saveContinuation(final Address fp, final boolean mainStack) {
+    if(fpsInContList == RVMThread.ARRAY_OF_CONTINUATIONS_MAXSIZE) {
+      // reset index
+      fpsInContList = RVMThread.ON_OVERFLOW_RESTART_INDEX_IN_ARRAY_OF_CONTINUATIONS;
+    }
+    final Address fpStore = mainStack ? getAddressValueOnMainStack(fp) : fp;
+    array_of_continuations.set(fpsInContList++, fpStore);
+  }
+
+  @UnpreemptibleNoWarn
+  @Inline
+  private int wsFindSteal_retBarrier(WS.StealInfo steal, WS.FinishInfo finish, Address top, boolean initiateStealFromBarrier, long startStealCPUCycles) {
+    Address fp = initiateStealFromBarrier ? getAddressValueOnClonedStack(hijackedReturnCallerFp) : this.contextRegisters.getInnermostFramePointer();
+    Address ip = initiateStealFromBarrier ? hijackedReturnAddress : this.contextRegisters.getInnermostInstructionAddress();
+
+    int found = 0;
+    boolean skip = wsInJoin;
+    Offset stealCBOffset = Offset.zero();
+    Offset stealFPOffset = Offset.zero();
+    Offset finishCBOffset = Offset.zero();
+    Offset finishFPOffset = Offset.zero();
+
+    Address stealPrevFp = initiateStealFromBarrier ? getAddressValueOnClonedStack(hijackedReturnCalleeFp) : Address.zero();
+
+    Address finishPrevFp = stealPrevFp;
+    Address prevFp = stealPrevFp;
+
+    boolean foundStolen = false;
+    boolean foundFinish = true;
+
+    Address prevJavaFrameFp = Address.zero();
+    boolean firstContinuationFound = false;
+    boolean barrierInstalled = false;
+
+    while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+      final Offset fpOffset = top.diff(fp);
+      final int compiledMethodId = Magic.getCompiledMethodID(fp);
+      if (compiledMethodId != INVISIBLE_METHOD_ID) {
+        final CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+        if (compiledMethod.getCompilerType() == CompiledMethod.OPT || compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
+          // Process each normal stack frame.
+          // First we search for the oldest unstolen continuation. Once we hit an already stolen continuation or reach the end we are done.
+          // We also need to know the enclosing finish block.
+          // We need to try and find the outermost finish block for each method to make sure. 
+          final Offset ipOffset = compiledMethod.getInstructionOffset(ip);	// it has debug info
+
+          Offset currentIPOffset = ipOffset;
+          Offset finishIPOffset = ipOffset;
+          // Search for a continuation to steal.
+          if (!foundStolen) {
+            while (true) {
+              final Offset catchBlock = compiledMethod.findCatchBlockForInstruction(currentIPOffset, RVMType.WSContinuationType, true);
+              if (catchBlock.sLT(Offset.zero())) break;
+              if (wsStealHead != null && wsStealHead.find(fpOffset, catchBlock) != null) {
+                // This continuation has already been stolen, so we discard the current state. 
+                foundStolen = true;
+                break;
+              }
+              // This continuation has not been stolen, so we update info to reflect it.
+              if (!skip) {
+                if(initiateStealFromBarrier) {
+                  if(!prevJavaFrameFp.isZero()) {
+                    saveContinuation(prevJavaFrameFp, true);
+                  }
+                }
+                else {
+                  if(!prevJavaFrameFp.isZero() && firstContinuationFound) {
+                    saveContinuation(prevJavaFrameFp, false);
+                  }
+                  //install return barrier for the callee of the newest continuation on victim stack
+                  else if(!prevJavaFrameFp.isZero() && !firstContinuationFound) {
+                    firstContinuationFound = true;
+                  }
+                }
+                finishIPOffset = currentIPOffset;
+                stealCBOffset = catchBlock;
+                stealFPOffset = fpOffset;
+                stealPrevFp = prevFp;
+                found++;
+                foundFinish = false;
+              }
+              skip = false;
+              // Advance into the catch block
+              currentIPOffset = catchBlock.plus(1);
+            }
+          }
+
+          // Search for an enclosing finish.
+          if (!foundFinish) {
+            Offset catchBlock = compiledMethod.findCatchBlockForInstruction(finishIPOffset, RVMType.WSFinishType, true);
+            if (catchBlock.sGE(Offset.zero())) {
+              // We found a finish block.
+              finishCBOffset = catchBlock;
+              finishFPOffset = fpOffset;
+              finishPrevFp = prevFp;
+              foundFinish = true;
+            }
+          }
+          if(!initiateStealFromBarrier && firstContinuationFound && !barrierInstalled) {
+            final RVMThread me = getCurrentThread();
+            me.iInstalledABarrier = true;
+            barrierInstalled = true;
+            wsReturnBarrierUninstalled = false;
+            if(wsDebugTrace) {
+              VM.sysWriteln(getCurrentThread().getId(),": Cloning stack of W-",getId());
+            }
+            victimYieldFpOnNewStack = wsCloneVictimStack(this, this.contextRegisters.getInnermostFramePointer());
+            //keep a copy of the gprs obtained by stackwalk of only the topmost frame of this yielded victim
+            if(wsDebugTrace) {
+              VM.sysWriteln(getCurrentThread().getId(),": Going to install return barrier in W-",getId());
+            }
+            wsInstallStackTrampolineBridge(prevJavaFrameFp);
+            thiefInstalledBarriers++;
+            if(wsDebugTrace) {
+              VM.sysWriteln(getCurrentThread().getId(),": Installed rbarrier in W-",getId());
+            }
+            if(RVMThread.victimCanBeReleasedAfterRBarrierIsInstalled) {
+              endPairHandshake();
+            }
+            me.totalSuccessStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+          }
+          prevJavaFrameFp = fp;
+          if(foundStolen && foundFinish) break;
+        }
+        else {
+          prevJavaFrameFp = Address.zero();
+        }
+      }
+      ip = RVMThread.getReturnAddress(fp);
+      prevFp = fp;
+      fp = Magic.getCallerFramePointer(prevFp);
+    }
+
+    if (found > 0) {
+      // Notify the victim to awake if its waiting inside return barrier
+      if(initiateStealFromBarrier || barrierInstalled) {
+        if(wsDebugTrace) {
+          VM.sysWriteln(getCurrentThread().getId(),": Send broadcast to release from barrier to W-",getId());
+        }
+        wsUnlockFromReturnBarrier();
+      }
+
+      // Find the finish object to use.
+      if (foundFinish) {
+        // Look for an existing finish.
+        if (wsFinishHead != null) {
+          steal.finish = wsFinishHead.find(finishFPOffset, finishCBOffset);
+        }
+        if (steal.finish == null) {
+          // We are the first to use this finish.
+          finish.set(finishFPOffset, finishCBOffset);
+          finish.setPrev(wsFinishHead);
+          steal.finish = finish;
+          wsFinishHead = finish;
+          if (VM.VerifyAssertions) VM._assert(finishPrevFp.GE(stealPrevFp));	//return barrier
+          if(!initiateStealFromBarrier) WS.installJoinInstructions(top.minus(finishFPOffset), finishPrevFp, this);
+          else WS.installJoinInstructions(stackTop().minus(finishFPOffset), getAddressValueOnMainStack(finishPrevFp), this);
+        }
+      } else {
+        // We must be delivering back to a parent finish.
+        steal.finish = wsFinishHead;
+      }
+
+      if(!initiateStealFromBarrier) {
+        WS.installJoinInstructions(top.minus(stealFPOffset), stealPrevFp, this);
+        // install join instruction in the coloned stack as well
+        final Address retAddress = stealPrevFp.EQ(hijackedReturnCalleeFp) ? hijackedReturnAddress : RVMThread.getReturnAddress(stealPrevFp);
+        Magic.setReturnAddress(getAddressValueOnClonedStack(stealPrevFp), retAddress);
+        steal.set(stealFPOffset, stealCBOffset, stealPrevFp);
+      }
+      else {
+        final Address stealPrevFpOnMainStack = getAddressValueOnMainStack(stealPrevFp);
+        WS.installJoinInstructions(stackTop().minus(stealFPOffset), stealPrevFpOnMainStack, this);
+        final Address retAddress = stealPrevFpOnMainStack.EQ(hijackedReturnCalleeFp) ? hijackedReturnAddress : RVMThread.getReturnAddress(stealPrevFpOnMainStack);
+        Magic.setReturnAddress(stealPrevFp, retAddress);
+        steal.set(stealFPOffset, stealCBOffset, stealPrevFpOnMainStack);
+      }
+
+      steal.setPrev(wsStealHead);
+      wsStealHead = steal;
+      if (VM.VerifyAssertions) VM._assert(steal.finish != null);
+    }
+
+    return found;
+  }
 }
diff --git a/tools/bootImageRunner/cmdLine.h b/tools/bootImageRunner/cmdLine.h
index 01d8102..d95040c 100644
--- a/tools/bootImageRunner/cmdLine.h
+++ b/tools/bootImageRunner/cmdLine.h
@@ -38,7 +38,7 @@ static const int OPT_INDEX                     = BASE_INDEX+1;
 static const int VMCLASSES_INDEX               = OPT_INDEX+1;
 static const int PROCESSORS_INDEX              = VMCLASSES_INDEX+1;
 
-static const int numNonstandardArgs      = PROCESSORS_INDEX+1;
+static const int numNonstandardArgs      = PROCESSORS_INDEX+11;
 
 static const char* nonStandardArgs[numNonstandardArgs] = {
    "-X",
@@ -59,6 +59,16 @@ static const char* nonStandardArgs[numNonstandardArgs] = {
    "-X:opt",
    "-X:vmClasses=",
    "-X:availableProcessors=",
+   "-Xws:pinAuto=",
+   "-Xws:pinMap=",
+   "-Xws:pinLog=",
+   "-Xws:pinSocketCPU=",
+   "-Xws:pinMapSys=",
+   "-Xws:perfEvent=",
+   "-Xws:pinMapGC=",
+   "-Xws:retBarrier=",
+   "-Xws:procs=",
+   "-Xws:stats=",
 };
 
 // a NULL-terminated list.
@@ -93,6 +103,29 @@ static const char* nonStandardUsage[] = {
    "  -Xbootclasspath/a:<cp>     (a)ppend specified classpath to bootclasspath",
    "  -X:availableProcessors=<n> desired level of application parallelism (set",
    "                             -X:gc:threads to control gc parallelism)",
+   "#====================================================================================",
+   "#============== WORK-STEALING SPECIFIC OPTIONS ======================================",
+   "#====================================================================================",
+   "#1. THREAD PINNING SPECIFIC......",
+   "  -Xws:pinAuto=<true/false>  Pin work-stealing threads to core id",
+   "  -Xws:pinMap=<0:2:4:6...>   Provide cpu map to pin the worker-stealing threads",
+   "  -Xws:pinLog=<true/false>   Print cpu id on which each work-stealing threads are running",
+   "				 (printing is done at the launch and end of application)",
+   "  -Xws:pinSocketCPU=<1:8>    Provide number of sockets and number of cpus available",
+   "				 (format is num_sockets:num_cpus_per_socket)",
+   "  -Xws:pinMapSys=<0:2...>    Provide set of cpus where system threads should run",
+   "                             This also includes GC threads if they are not pinned separately",
+   "  -Xws:pinMapGC=<0:1...>     Provide set of cpus where GC threads should run",
+   "                             map should be for each and every GC threads",
+   "#2. LINUX PERF EVENTS COUNTERS...",
+   "  -Xws:perfEvent=<true>      True if want to measure per thread performance counter events", 
+   "#3. NORMAL USAGE...",
+   "  -Xws:retBarrier=<true>     Use return barrier to reduce the steal time",
+   "                             default option is false",
+   "  -Xws:procs=<number>        Total work-stealing worker threads",
+   "  -Xws:stats=<true>     	 Display work-stealing statistics. Useful in a large project",
+   "				 where you dont know where exactly main method is being called.",
+   "                             The default option is false",
    NULL                         /* End of messages */
 };
 
diff --git a/tools/bootImageRunner/sys.C b/tools/bootImageRunner/sys.C
index 7c7a4e2..4fa0e67 100644
--- a/tools/bootImageRunner/sys.C
+++ b/tools/bootImageRunner/sys.C
@@ -47,6 +47,10 @@ extern "C" int sched_yield(void);
 #include <utime.h>
 #include <setjmp.h>
 
+#ifndef RVM_FOR_MACOS
+#include <linux/unistd.h>
+#endif
+
 #ifdef RVM_WITH_PERFEVENT
 #include <perfmon/pfmlib_perf_event.h>
 #include <err.h>
@@ -62,6 +66,7 @@ extern "C" int sched_yield(void);
 #include <asm/ioctls.h>
 #endif
 
+//#define _GNU_SOURCE         /* See feature_test_macros(7) */
 # include <sched.h>
 
 /* OSX/Darwin */
@@ -110,6 +115,11 @@ extern "C" int     incinterval(timer_t id, itimerstruc_t *newvalue, itimerstruc_
 #include "InterfaceDeclarations.h"
 #include "bootImageRunner.h"    // In tools/bootImageRunner.
 
+#ifdef RVM_WITH_LIBNUMA
+#include <numa.h>
+#include <numaif.h>
+#endif
+
 #ifdef RVM_FOR_HARMONY
 #ifdef RVM_FOR_LINUX
 #define LINUX
@@ -542,6 +552,110 @@ void sysPerfEventRead(int id, long long *values)
 #endif
 } // extern "C"
 
+/*
+ * Per thread performance counter support using the linux perf event system.
+ */
+extern "C" {
+#ifndef RVM_WITH_PERFEVENT
+void sysPerfEventInit_thread(int events) {}
+void sysPerfEventCreate_thread(int id, const char *eventName) {}
+void sysPerfEventOpen_thread(int id, void*tid, int *fds) {}
+void sysPerfEventClose_thread(int id, int *fds) {}
+void sysPerfEventEnable_thread(int *fds, int numEvents) {}
+void sysPerfEventDisable_thread(int *fds, int numEvents) {}
+void sysPerfEventRead_thread(int id, int *fds, uint64_t *values) {}
+#else
+static int perfVerbose = 0;
+static struct perf_event_attr *perf_event_attrs_thread;
+extern "C" Word sysGetThreadId();
+
+void sysPerfEventInit_thread(int numEvents)
+{
+  int ret = pfm_initialize();
+  if (ret != PFM_SUCCESS) {
+    errx(1, "error in pfm_initialize: %s", pfm_strerror(ret));
+  }
+
+  perf_event_attrs_thread = (struct perf_event_attr *)calloc(numEvents, sizeof(struct perf_event_attr));
+  if (!perf_event_attrs_thread) {
+    errx(1, "error allocating perf_event_attrs_thread");
+  }
+  for(int i=0; i < numEvents; i++) {
+    perf_event_attrs_thread[i].size = sizeof(struct perf_event_attr);
+  }
+ // enabled = 1;
+}
+
+void sysPerfEventCreate_thread(int id, const char *eventName)
+{
+  struct perf_event_attr *pe = (perf_event_attrs_thread + id);
+  int ret = pfm_get_perf_event_encoding(eventName, PFM_PLM3, pe, NULL, NULL);
+  if (ret != PFM_SUCCESS) {
+    errx(1, "error creating event %d '%s': %s\n", id, eventName, pfm_strerror(ret));
+  }
+  pe->read_format = PERF_FORMAT_TOTAL_TIME_ENABLED | PERF_FORMAT_TOTAL_TIME_RUNNING;
+  pe->disabled = 1;
+  pe->inherit = 0;
+}
+
+void sysPerfEventClose_thread(int id, int *fds) {
+  close(fds[id]);
+}
+
+void sysPerfEventOpen_thread(int id, void* tid, int *fds) {
+  struct perf_event_attr *pe = (perf_event_attrs_thread + id);
+  fds[id] = perf_event_open(pe, 0, -1, -1, 0);
+  if (fds[id] == -1) {
+    err(1, "error in perf_event_open for event %d", id);
+  }
+  if(perfVerbose)
+    printf("Create Counter %d at fd %d for thread %d\n", id, fds[id],sysGetThreadId());
+}
+
+void sysPerfEventEnable_thread(int *fds, int numEvents)
+{
+	int i;
+	for(i=0; i< numEvents; i++) {
+		if (ioctl(fds[i], PERF_EVENT_IOC_ENABLE, 0)) {
+			err(1, "error enabling perf event");
+		}
+	}
+}
+
+void sysPerfEventDisable_thread(int *fds, int numEvents)
+{
+	int i;
+	for(i=0; i< numEvents; i++) {
+		if (ioctl(fds[i], PERF_EVENT_IOC_DISABLE, 0)) {
+			err(1, "error disabling perf event");
+		}
+	}
+}
+
+void sysPerfEventRead_thread(int id, int *fds, uint64_t *values)
+{
+  if (fds[id] < 0) {
+	  printf("ERROR: reading event %d\n",id);
+	  return;
+  }
+  memset(values, 0, sizeof(uint64_t) * 3);
+  size_t expectedBytes = 3 * sizeof(uint64_t);
+  int ret = read(fds[id], values, expectedBytes);
+  if (ret < 0) {
+    err(1, "error reading event: %s", strerror(errno));
+  }
+  if (ret != expectedBytes) {
+    errx(1, "read of perf event did not return 3 64-bit values");
+  }
+  if(perfVerbose)
+    printf("Counter %d at fd %d: value %lld\n",sysGetThreadId(),fds[id], values[0]);
+  close(fds[id]);
+  fds[id] = -1;
+}
+#endif
+} // extern "C"
+
+
 //------------------------//
 // Filesystem operations. //
 //------------------------//
@@ -1052,6 +1166,82 @@ sysThreadBind(int UNUSED cpuId)
 #endif
 }
 
+/*
+ * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+ * From here---->
+ */
+
+extern "C" {
+#ifndef RVM_WITH_LIBNUMA
+int sysCheckNUMAnode(void* memory) { return -1;}
+#else
+int sysCheckNUMAnode(void* memory) {
+  int status[1];
+  int ret_code;
+  status[0]=-1;
+  ret_code=move_pages(0 /*self memory */, 1, &memory, NULL, status, 0);
+  if(ret_code != 0) {
+    fprintf(stderr,"sysCheckNUMAnode failed (errno=%d)\n",ret_code);
+    exit(1);
+  }
+  return status[0];
+}
+#endif
+}
+
+#ifndef RVM_FOR_MACOS
+static cpu_set_t ws_sysThread_cpuset;
+#endif
+
+extern "C" void
+wsIniatilizeSysThreadBindMask(int cpuMask) {
+#ifndef RVM_FOR_MACOS
+	static int first = 0;
+	if(first == 0) {
+		CPU_ZERO(&ws_sysThread_cpuset);
+		first = 1;
+	}
+	CPU_SET( cpuMask, &ws_sysThread_cpuset );
+#endif
+}
+
+extern "C" void
+wsThreadBindMaskSet( int cpuMask ) {
+#ifndef RVM_FOR_HARMONY || RVM_FOR_MACOS
+#ifdef RVM_FOR_LINUX
+	cpu_set_t cpuset;
+	CPU_ZERO(&cpuset);
+	CPU_SET( cpuMask, &cpuset );
+	pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);
+#endif
+#endif
+}
+
+extern "C" void
+sysThreadBindMaskSet() {
+#ifndef RVM_FOR_HARMONY 
+#ifdef RVM_FOR_LINUX
+#ifndef RVM_FOR_MACOS
+	pthread_setaffinity_np(pthread_self(), sizeof(ws_sysThread_cpuset), &ws_sysThread_cpuset);
+#endif
+#endif
+#endif
+}
+
+extern "C" int
+sysGetCPU( ) {
+#ifndef RVM_FOR_HARMONY || RVM_FOR_MACOS
+#ifdef RVM_FOR_LINUX
+	return sched_getcpu();
+#endif
+#endif
+}
+
+/*
+ * Till Here <----
+ * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+ */
+
 /** jump buffer for primordial thread */
 jmp_buf primordial_jb;
 
@@ -1137,7 +1327,11 @@ sysThreadStartup(void *args)
 extern "C" Word
 sysGetThreadId()
 {
-    return (Word)getThreadId();
+#ifndef RVM_FOR_MACOS
+	return (Word)(pid_t)syscall(__NR_gettid);
+#else
+	return NULL;
+#endif
 }
 
 extern "C" void*
@@ -1785,6 +1979,9 @@ sysMMapErrno(char *start , size_t length ,
         int protection , int flags ,
         int fd , Offset offset)
 {
+  #ifdef RVM_WITH_LIBNUMA
+  numa_set_localalloc();
+  #endif
   void* res = mmap(start, (size_t)(length), protection, flags, fd, (off_t)offset);
   if (res == (void *) -1){
 #if RVM_FOR_32_ADDR
