diff -r ab5908222258 MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java
--- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java	Fri Mar 21 09:37:25 2014 +0530
@@ -34,6 +34,7 @@
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.ObjectReference;
 import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.WordArray;
 import org.jikesrvm.ArchitectureSpecific.Registers;
 
 /**
@@ -135,14 +136,47 @@
       VM.sysWriteln("scanning ",thread.getThreadSlot());
     }
 
+    
     /* get the gprs associated with this thread */
     Registers regs=thread.getContextRegisters();
     Address gprs = Magic.objectAsAddress(regs.gprs);
 
-    Address ip=regs.getInnermostInstructionAddress();
-    Address fp=regs.getInnermostFramePointer();
+    Address ip_main=regs.getInnermostInstructionAddress();
+    Address fp_main =regs.getInnermostFramePointer();
+    
+    /*
+     * While performing work-stealing with return barrier, thieves
+     * create a snapshot of victim's thread stack. This cloned stack
+     * contains references to live objects as long as the victim
+     * has return barrier installed on its main stack. 
+     * 
+     * If we do not scan the cloned stack, then we may loose references
+     * to live objects as it may be collected after scanning only the main
+     * stack. Hence, we have to make sure we compute the roots by scanning
+     * both the cloned and main stack as long as return barrier is installed
+     * on victim's main stack
+     * 
+     * As seen on NQueens and UTS benchmarks (which performs GC), there is 
+     * very insignificant change in the gc time due to scanning cloned stack
+     * as well.
+     * 
+     */
+    if(thread.wsMaintainsClonedStackAlso()) {
+    	if(false) {
+    		// Also scan the wsShadowStack
+    		WordArray gprs_actual = regs.gprs;
+    		// initialize it from the backup gprs
+    		regs.clear();
+    		thread.wsSetInnermost();
+    		scanThread(thread, trace, processCodeLocations, gprs, Address.zero());
+    	}
+    	else {
+    		thread.deInstallStackTrampoline_fromGC();
+    	}
+    }
+    
     regs.clear();
-    regs.setInnermost(ip,fp);
+    regs.setInnermost(ip_main,fp_main);
 
     scanThread(thread, trace, processCodeLocations, gprs, Address.zero());
   }
@@ -284,6 +318,14 @@
 
     /* If a thread started via createVM or attachVM, base may need scaning */
     checkJNIBase();
+    if (thread.wsSpecialNVMap != 0) {
+      for(int i=0; i < ArchitectureSpecific.ArchConstants.NONVOLATILE_GPRS.length; i++) {
+        int reg = ArchitectureSpecific.ArchConstants.NONVOLATILE_GPRS[i].value();
+        if ((thread.wsSpecialNVMap & (1 << reg)) != 0) {
+          reportDelayedRootEdge(trace, iteratorGroup.getRegisterLocation(reg));
+        }
+      }
+    }
 
     if (verbosity >= 2) Log.writeln("--- End Of Stack Scan ---\n");
   }
diff -r ab5908222258 MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Scanning.java
--- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Scanning.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Scanning.java	Fri Mar 21 09:37:25 2014 +0530
@@ -182,7 +182,6 @@
       /* scan the thread (stack etc.) */
       ScanThread.scanThread(thread, trace, processCodeLocations);
     }
-
     /* flush out any remset entries generated during the above activities */
     Selected.Mutator.get().flushRememberedSets();
   }
diff -r ab5908222258 MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
--- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java	Fri Mar 21 09:37:25 2014 +0530
@@ -15,6 +15,8 @@
 import org.mmtk.utility.Constants;
 import org.mmtk.utility.statistics.PerfEvent;
 import org.jikesrvm.runtime.Time;
+import org.jikesrvm.scheduler.WS;
+
 import static org.jikesrvm.runtime.SysCall.sysCall;
 
 import org.vmmagic.pragma.*;
@@ -89,5 +91,23 @@
   public void perfEventRead(int id, long[] values) {
     sysCall.sysPerfEventRead(id, values);
   }
+  
+  /**
+   * Work-Stealing harness calls
+   */
+  @Override
+  public void wsHarnessBegin() {
+	  WS.harnessBegin();  
+  }
+  
+  @Override
+  public void wsHarnessEnd() {
+	  WS.harnessEnd();  
+  }
+  
+  @Override
+  public void wsUpdateStealRatioExternally(int steals, int pushes) {
+	  WS.updateStealRatioExternally(steals, pushes);
+  }
 }
 
diff -r ab5908222258 MMTk/src/org/mmtk/plan/ParallelCollectorGroup.java
--- a/MMTk/src/org/mmtk/plan/ParallelCollectorGroup.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/MMTk/src/org/mmtk/plan/ParallelCollectorGroup.java	Fri Mar 21 09:37:25 2014 +0530
@@ -13,10 +13,10 @@
 package org.mmtk.plan;
 
 import org.mmtk.utility.Constants;
-
+//import org.mmtk.utility.Log;
+//import org.mmtk.utility.statistics.EventCounter;
 import org.mmtk.vm.Monitor;
 import org.mmtk.vm.VM;
-
 import org.vmmagic.pragma.*;
 
 /**
@@ -53,7 +53,11 @@
 
   /** Which rendezvous counter is currently in use */
   private volatile int currentRendezvousCounter;
-
+//  private final static EventCounter rendezvousTimer_T = new EventCounter("rendezvousTimer", true, true);
+//  private volatile long rendezvousTimer;
+//  private volatile int waiting;
+//  private volatile long startT;
+  
   /****************************************************************************
    *
    * Initialization
@@ -98,6 +102,7 @@
   public void triggerCycle() {
     lock.lock();
     triggerCount++;
+//    reset();
     contextsParked = 0;
     lock.broadcast();
     lock.unlock();
@@ -129,6 +134,8 @@
     while (contextsParked < contexts.length) {
       lock.await();
     }
+//    double ms = VM.statistics.nanosToMillis(rendezvousTimer);
+//    rendezvousTimer_T.wsInc((long)ms);
     lock.unlock();
   }
 
@@ -169,6 +176,12 @@
     return false;
   }
 
+//  private void reset() {
+//	  waiting = 0;
+//	  startT = 0;
+//	  rendezvousTimer = 0;
+//  }
+  
   /**
    * Rendezvous with other active threads in this group.
    *
@@ -176,6 +189,9 @@
    */
   public int rendezvous() {
     lock.lock();
+//    if(waiting++==0) {
+//    	startT = VM.statistics.nanoTime();
+//    }
     int i = currentRendezvousCounter;
     int me = rendezvousCounter[i]++;
     if (me == contexts.length-1) {
@@ -187,6 +203,9 @@
         lock.await();
       }
     }
+//    if(--waiting == 0) {
+//    	rendezvousTimer += VM.statistics.nanoTime() - startT;
+//    }
     lock.unlock();
     return me;
   }
diff -r ab5908222258 MMTk/src/org/mmtk/plan/Plan.java
--- a/MMTk/src/org/mmtk/plan/Plan.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/MMTk/src/org/mmtk/plan/Plan.java	Fri Mar 21 09:37:25 2014 +0530
@@ -650,6 +650,11 @@
    */
   protected static boolean insideHarness = false;
 
+  @Interruptible
+  public static void updateStealRatioExternally(int steals, int pushes) {
+	  VM.statistics.wsUpdateStealRatioExternally(steals, pushes);
+  }
+  
   /**
    * Generic hook to allow benchmarks to be harnessed.  A plan may use
    * this to perform certain actions prior to the commencement of a
diff -r ab5908222258 MMTk/src/org/mmtk/utility/statistics/EventCounter.java
--- a/MMTk/src/org/mmtk/utility/statistics/EventCounter.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/MMTk/src/org/mmtk/utility/statistics/EventCounter.java	Fri Mar 21 09:37:25 2014 +0530
@@ -91,6 +91,13 @@
     if (running) inc(1);
   }
 
+  /*
+   * To be used for jikesrvm work-stealing logs
+   */
+  public void wsInc(long value) {
+          if (running) currentCount += value;
+  }
+
   /**
    * Increment the event counter by <code>value</code>
    *
diff -r ab5908222258 MMTk/src/org/mmtk/utility/statistics/Stats.java
--- a/MMTk/src/org/mmtk/utility/statistics/Stats.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/MMTk/src/org/mmtk/utility/statistics/Stats.java	Fri Mar 21 09:37:25 2014 +0530
@@ -39,7 +39,7 @@
   public static final boolean GATHER_MARK_CONS_STATS = false;
 
   /** Maximum number of gc/mutator phases that can be counted */
-  static final int MAX_PHASES = 1 << 12;
+  static final int MAX_PHASES = 1 << 17; // To avoid the MAX_PHASE errors in Integrate and Matmul application
   /** Maximum number of counters that can be in operation */
   static final int MAX_COUNTERS = 100;
 
@@ -132,6 +132,9 @@
         counter[c].start();
     }
 
+    // work-stealing harness hook
+    VM.statistics.wsHarnessBegin();
+    
     if (Options.xmlStats.getValue()) {
       Xml.begin();
       Xml.openTag("mmtk-stats");
@@ -144,6 +147,8 @@
    */
   @Interruptible
   public static void stopAll() {
+	// work-stealing harness hook
+	VM.statistics.wsHarnessEnd();
     stopAllCounters();
     Stats.printStats();
     if (Options.xmlStats.getValue()) {
diff -r ab5908222258 MMTk/src/org/mmtk/vm/Statistics.java
--- a/MMTk/src/org/mmtk/vm/Statistics.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/MMTk/src/org/mmtk/vm/Statistics.java	Fri Mar 21 09:37:25 2014 +0530
@@ -58,4 +58,11 @@
    * Read a performance event value
    */
   public abstract void perfEventRead(int counter, long[] values);
+  
+  /*
+   * Work-Stealing harness calls
+   */
+  public abstract void wsHarnessBegin();
+  public abstract void wsHarnessEnd();
+  public abstract void wsUpdateStealRatioExternally(int steals, int pushes);
 }
diff -r ab5908222258 bin/buildit
--- a/bin/buildit	Fri Mar 21 09:33:02 2014 +0530
+++ b/bin/buildit	Fri Mar 21 09:37:25 2014 +0530
@@ -74,6 +74,8 @@
      --x87            Use x87 Compatibility mode.
  -c, --cross-to       Crossbuild to target host (or copy post build).
      --with-perfevent Build with perf event support
+     --with-libnuma   Build with NUMA support
+     --for-macos      Build for MacOSX
  -a, --with-acheck    Build with align checks, implies --x87 --processors 1
  -g, --gdb-symbols    Build with gdb symbols
  -q, --quick          Quick build (not 100% safe - doesn't regenerate source)
@@ -168,6 +170,8 @@
   "q|quick" => \$quick,
   "processors=s" => \$procs,
   "with-perfevent" => \$with_perfevent,
+  "with-libnuma" => \$with_libnuma,
+  "for-macos" => \$for-macos,
   "a|with-acheck" => \$with_acheck,
   "z|skip-build" => \$skip_build,
   "h|help" => \$help,
@@ -681,6 +685,12 @@
     if ($with_perfevent ne "") {
       $defs .= "-Dconfig.include.perfevent=true ";
     }
+    if ($with_libnuma ne "") {
+      $defs .= "-Dconfig.include.libnuma=true ";
+    }
+    if ($for-macos ne "") {
+      $defs .= "-Dconfig.include.macos=true ";
+    }
     if ($with_acheck ne "") {
       $defs .= "-Dconfig.alignment-checking=true ";
     }
diff -r ab5908222258 build.xml
--- a/build.xml	Fri Mar 21 09:33:02 2014 +0530
+++ b/build.xml	Fri Mar 21 09:37:25 2014 +0530
@@ -408,7 +408,15 @@
       <equals arg1="${config.include.perfevent}" arg2="true"/>
     </condition>
 
-    <property name="filter" value="${arch.filter} ${os.filter} ${addr.filter} ${gctrace.filter} ${gcspy.filter} ${alignment-checking.filter} ${perfevent.filter} ${classlib.filter}"/>
+    <condition property="libnuma.filter" value="-DRVM_WITH_LIBNUMA=1" else="">
+      <equals arg1="${config.include.libnuma}" arg2="true"/>
+    </condition>
+
+    <condition property="macos.filter" value="-DRVM_FOR_MACOS=1" else="">
+      <equals arg1="${config.include.macos}" arg2="true"/>
+    </condition>
+
+    <property name="filter" value="${arch.filter} ${os.filter} ${addr.filter} ${gctrace.filter} ${gcspy.filter} ${alignment-checking.filter} ${perfevent.filter} ${libnuma.filter} ${macos.filter} ${classlib.filter}"/>
   </target>
 
   <!-- **************************************************************************** -->
@@ -1819,13 +1827,17 @@
       <equals arg1="${config.include.perfevent}" arg2="true"/>
     </condition>
 
+    <condition property="libnuma.lib" value="-lnuma" else="">
+      <equals arg1="${config.include.libnuma}" arg2="true"/>
+    </condition>
+
     <if>
       <conditions>
         <equals arg1="${classlib.provider}" arg2="GNU Classpath"/>
       </conditions>
       <sequential>
         <exec executable="${c++.exe}" failonerror="true">
-          <arg line="${c++.args} ${rvm.common.args} ${gcspy.lib.dir} ${perfevent.lib} ${rvm.src} ${c++.librt} -lpthread ${c++.rdynamic} -g"/>
+          <arg line="${c++.args} ${rvm.common.args} ${gcspy.lib.dir} ${perfevent.lib} ${libnuma.lib} ${rvm.src} ${c++.librt} -lpthread ${c++.rdynamic} -g"/>
           <arg value="-o"/>
           <arg value="${build.base}/JikesRVM"/>
           <arg value="-L${build.base}"/>
@@ -1840,7 +1852,7 @@
       </conditions>
       <sequential>
         <exec executable="${c++.exe}" failonerror="true">
-          <arg line="${c++.args} ${rvm.common.args} ${gcspy.lib.dir} ${perfevent.lib} ${rvm.src} ${c++.librt} -lpthread ${c++.rdynamic} -g"/>
+          <arg line="${c++.args} ${rvm.common.args} ${gcspy.lib.dir} ${perfevent.lib} ${libnuma.lib} ${rvm.src} ${c++.librt} -lpthread ${c++.rdynamic} -g"/>
           <arg value="-o"/>
           <arg value="${build.base}/JikesRVM"/>
           <arg value="-L${build.base}"/>
@@ -1910,6 +1922,7 @@
 config.mmtk.plan=${config.mmtk.plan}
 config.include.aos=${config.include.aos}
 config.include.perfevent=${config.include.perfevent}
+config.include.libnuma=${config.include.libnuma}
 config.include.gcspy=${config.include.gcspy}
 config.include.gcspy-client=${config.include.gcspy-client}
 config.assertions=${config.assertions}
@@ -1967,6 +1980,7 @@
 config.mmtk.plan=${config.mmtk.plan}
 config.include.aos=${config.include.aos}
 config.include.perfevent=${config.include.perfevent}
+config.include.libnuma=${config.include.libnuma}
 config.include.gcspy=${config.include.gcspy}
 config.include.gcspy-client=${config.include.gcspy-client}
 config.assertions=${config.assertions}
diff -r ab5908222258 rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java
--- a/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java	Fri Mar 21 09:37:25 2014 +0530
@@ -14,6 +14,8 @@
 import java.util.*;
 import java.lang.reflect.*;
 
+import org.jikesrvm.VM;
+
 /**
  * <P>
  * Generates the assembler that is used by the optimizing compiler, using a
@@ -1219,9 +1221,31 @@
       emit(" */\n");
       emitTab(1);
       emit("private void do" + opcode + "(Instruction inst) {\n");
+      if (opcode.equals("CALL")) {
+        emitTab(2);
+        emit("boolean join = MIR_Call.getMethod(inst) != null && (MIR_Call.getMethod(inst).getMemberRef() == org.jikesrvm.runtime.Entrypoints.workStealingJoinMethod || MIR_Call.getMethod(inst).getMemberRef() == org.jikesrvm.runtime.Entrypoints.workStealingFinishMethod);\n");
+        emitTab(2);
+        emit("boolean recurse = isImm(MIR_Call.getTarget(inst)) && getImm(MIR_Call.getTarget(inst)) == 0;\n");
+        emitTab(2);
+        emit("int start = getMachineCodeIndex();\n");
+      }
       EmitterSet emitter = buildSetForOpcode(emitters, opcode);
       boolean[][] tp = new boolean[4][ArgumentType.values().length];
       emitter.emitSet(opcode, tp, 2);
+      if (opcode.equals("CALL")) {
+        emitTab(2);
+        emit("if (join) {\n");
+        emitTab(3);
+        emit("addJoinRegion(start, getMachineCodeIndex());\n");
+        emitTab(2);
+        emit("}\n");
+        emitTab(2);
+        emit("if (recurse) {\n");
+        emitTab(3);
+        emit("addRecursion(start);\n");
+        emitTab(2);
+        emit("}\n");
+      }
       emitTab(1);
       emit("}\n\n");
     }
diff -r ab5908222258 rvm/src-generated/ia32-assembler-opt/Magic.fake
--- a/rvm/src-generated/ia32-assembler-opt/Magic.fake	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src-generated/ia32-assembler-opt/Magic.fake	Fri Mar 21 09:37:25 2014 +0530
@@ -18,4 +18,5 @@
 public class Magic {
   public static void setIntAtOffset(Object o, Offset x, int y) { }
   public static Address getTocPointer() { return Address.zero(); }
+  public static Address objectAsAddress(Object o) { return Address.zero(); }
 }
diff -r ab5908222258 rvm/src-generated/ia32-assembler/Assembler.in
--- a/rvm/src-generated/ia32-assembler/Assembler.in	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src-generated/ia32-assembler/Assembler.in	Fri Mar 21 09:37:25 2014 +0530
@@ -187,6 +187,36 @@
    */
   protected final Lister lister;
 
+  public int [] joinRegions = new int[0];
+  
+  protected void addJoinRegion(int start, int end) {
+    int[] newRegions = new int[joinRegions.length+2];
+    for(int i=0;i<joinRegions.length;i++) {
+      newRegions[i] = joinRegions[i];
+    } 
+    joinRegions = newRegions;
+    joinRegions[joinRegions.length-2] = start;
+    joinRegions[joinRegions.length-1] = end - start;
+  }
+  
+  public int [] recursions = new int[0];
+  
+  protected void addRecursion(int start) {
+    int[] newRecursions = new int[recursions.length+1];
+    for(int i=0;i<recursions.length;i++) {
+      newRecursions[i] = recursions[i];
+    } 
+    recursions = newRecursions;
+    recursions[recursions.length-1] = start;
+  }
+  
+  public final void changeCALL_Imm(ArchitectureSpecific.CodeArray code, int start, int imm) {
+    code.set(start+1, (byte) ((imm >>  0) & 0xFF));
+    code.set(start+2, (byte) ((imm >>  8) & 0xFF));
+    code.set(start+3, (byte) ((imm >> 16) & 0xFF));
+    code.set(start+4, (byte) ((imm >> 24) & 0xFF));  
+  }
+  
   /**
    * The array holding the generated binary code.
    */
@@ -318,6 +348,27 @@
     return trimmed;
   }
 
+  public final ArchitectureSpecific.CodeArray patchMachineCodeForWorkStealing(ArchitectureSpecific.CodeArray slow) {
+    if (joinRegions.length == 0) {
+      return slow;
+    }
+
+    // Generate a fast version without join calls, that recurses to itself.
+    for(int i=0; i<joinRegions.length; i+=2) {
+      replaceWithNOP(joinRegions[i], joinRegions[i+1]);
+    }
+
+    ArchitectureSpecific.CodeArray fast = getMachineCodes();
+
+    // Change the slow version to recurse to the fast version.
+    int delta = Magic.objectAsAddress(fast).diff(Magic.objectAsAddress(slow)).toInt();
+    for(int i=0; i<recursions.length; i++) {
+      changeCALL_Imm(slow, recursions[i], delta - (recursions[i] + 5));
+    }
+
+    return fast;
+  }
+  
   /**
    * Give the lister a message associated with a particular
    * bytecode.  This is used by the baseline assembler to print the
@@ -2015,6 +2066,13 @@
     setMachineCodes(mi++, (byte) 0x9E);
     if (lister != null) lister.OP(miStart, "SAHF");
   }
+  
+  public final void replaceWithNOP (int start, int length) {
+    int oldMi = mi;
+    mi = start;
+    emitNOP(length);
+    mi = oldMi;
+  }
 
   /**
    * Emit NOP instruction
diff -r ab5908222258 rvm/src-generated/vm-configuration/ArchitectureSpecific.template
--- a/rvm/src-generated/vm-configuration/ArchitectureSpecific.template	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src-generated/vm-configuration/ArchitectureSpecific.template	Fri Mar 21 09:37:25 2014 +0530
@@ -12,7 +12,7 @@
  */
 package org.jikesrvm;
 
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 import org.vmmagic.pragma.NonMoving;
 
 import org.jikesrvm.compilers.baseline.BaselineCompiledMethod;
@@ -33,7 +33,7 @@
   public interface BaselineConstants extends org.jikesrvm.@_ARCH_@.BaselineConstants {}
   public static final class BaselineExceptionDeliverer extends org.jikesrvm.compilers.baseline.@_ARCH_@.BaselineExceptionDeliverer {}
   public static final class BaselineGCMapIterator extends org.jikesrvm.compilers.baseline.@_ARCH_@.BaselineGCMapIterator {
-    public BaselineGCMapIterator(WordArray registerLocations) {
+    public BaselineGCMapIterator(AddressArray registerLocations) {
       super(registerLocations);
     }}
   public static final class CodeArray extends org.jikesrvm.@_ARCH_@.CodeArray {
@@ -69,7 +69,7 @@
   public interface TrapConstants extends org.jikesrvm.@_ARCH_@.TrapConstants {}
   public static final class JNICompiler extends org.jikesrvm.jni.@_ARCH_@.JNICompiler {}
   public static final class JNIGCMapIterator extends org.jikesrvm.jni.@_ARCH_@.JNIGCMapIterator {
-    public JNIGCMapIterator(WordArray registerLocations) {
+    public JNIGCMapIterator(AddressArray registerLocations) {
       super(registerLocations);
     }}
   public static final class JNIHelpers extends org.jikesrvm.jni.@_ARCH_@.JNIHelpers {}
diff -r ab5908222258 rvm/src-generated/vm-configuration/ArchitectureSpecificOpt.template
--- a/rvm/src-generated/vm-configuration/ArchitectureSpecificOpt.template	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src-generated/vm-configuration/ArchitectureSpecificOpt.template	Fri Mar 21 09:37:25 2014 +0530
@@ -12,7 +12,7 @@
  */
 package org.jikesrvm;
 
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.compilers.opt.lir2mir.BURS;
@@ -55,7 +55,7 @@
   public static final class StackManager extends org.jikesrvm.compilers.opt.regalloc.@_ARCH_@.StackManager {}
   public static final class OptExceptionDeliverer extends org.jikesrvm.compilers.opt.runtimesupport.@_ARCH_@.OptExceptionDeliverer {}
   public static final class OptGCMapIterator extends org.jikesrvm.compilers.opt.runtimesupport.@_ARCH_@.OptGCMapIterator {
-    public OptGCMapIterator(WordArray registerLocations) {
+    public OptGCMapIterator(AddressArray registerLocations) {
       super(registerLocations);
     }}
   public interface OptGCMapIteratorConstants extends org.jikesrvm.compilers.opt.runtimesupport.@_ARCH_@.OptGCMapIteratorConstants {}
diff -r ab5908222258 rvm/src-generated/vm-configuration/HeapLayoutConstants.template
--- a/rvm/src-generated/vm-configuration/HeapLayoutConstants.template	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src-generated/vm-configuration/HeapLayoutConstants.template	Fri Mar 21 09:37:25 2014 +0530
@@ -36,7 +36,7 @@
     Address.@_ADDRESS_METHOD_@( @_MAXIMUM_MAPPABLE_ADDRESS_@ );
 
   /** The maximum boot image data size */
-  int BOOT_IMAGE_DATA_SIZE = 56<<20;
+  int BOOT_IMAGE_DATA_SIZE = 65<<20;
 
   /** The maximum boot image code size */
   int BOOT_IMAGE_CODE_SIZE = 24<<20;
diff -r ab5908222258 rvm/src/org/jikesrvm/CommandLineArgs.java
--- a/rvm/src/org/jikesrvm/CommandLineArgs.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/CommandLineArgs.java	Fri Mar 21 09:37:25 2014 +0530
@@ -23,6 +23,7 @@
 
 import static org.jikesrvm.runtime.SysCall.sysCall;
 import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.scheduler.WS;
 
 /**
  * Command line option processing iwth arbitrary prefix support.
@@ -79,7 +80,18 @@
     BOOTCLASSPATH_P_ARG,
     BOOTCLASSPATH_A_ARG,
     BOOTSTRAP_CLASSES_ARG,
-    AVAILABLE_PROCESSORS_ARG
+    AVAILABLE_PROCESSORS_ARG,
+    WS_PIN_MAP_APP_THREADS,
+    WS_AUTO_PIN_APP_THREAD,
+    WS_PIN_LOG,
+    WS_PIN_SOCKETS_HINT,
+    WS_PIN_MAP_SYSTEM_THREADS,
+    PER_THREAD_PERF_EVENTS,
+    WS_PIN_MAP_GC_THREADS,
+    WS_PROCS,
+    WS_AUTOGEN_WSTHREADS,
+    WS_RETURN_BARRIER,
+    WS_STATISTICS,
   }
 
   /** Represent a single command line prefix */
@@ -208,6 +220,17 @@
                                             new Prefix("-X:vm:help$", PrefixType.HELP_ARG),
                                             new Prefix("-X:vm$", PrefixType.HELP_ARG),
                                             new Prefix("-X:vm:", PrefixType.ARG),
+                                            new Prefix("-Xws:pinMap=", PrefixType.WS_PIN_MAP_APP_THREADS),
+                                            new Prefix("-Xws:pinAuto=", PrefixType.WS_AUTO_PIN_APP_THREAD),
+                                            new Prefix("-Xws:pinLog=", PrefixType.WS_PIN_LOG),
+                                            new Prefix("-Xws:pinSocketCPU=", PrefixType.WS_PIN_SOCKETS_HINT),
+                                            new Prefix("-Xws:pinMapSys=", PrefixType.WS_PIN_MAP_SYSTEM_THREADS),
+                                            new Prefix("-Xws:perfEvent=", PrefixType.PER_THREAD_PERF_EVENTS),
+                                            new Prefix("-Xws:pinMapGC=", PrefixType.WS_PIN_MAP_GC_THREADS),
+                                            new Prefix("-Xws:procs=", PrefixType.WS_PROCS),
+                                            new Prefix("-Xws:autoThreads=", PrefixType.WS_AUTOGEN_WSTHREADS),
+                                            new Prefix("-Xws:retBarrier=", PrefixType.WS_RETURN_BARRIER),
+                                            new Prefix("-Xws:stats=", PrefixType.WS_STATISTICS),
 
                                             /* Silently ignored */
                                             new Prefix("-Xverify", PrefixType.VERIFY_ARG),
@@ -664,6 +687,58 @@
             VM.sysExit(VM.EXIT_STATUS_BOGUS_COMMAND_LINE_ARG);
           }
           break;
+        case WS_PIN_MAP_APP_THREADS:
+                final String[] map_ws = arg.split(":");
+                RVMThread.pin_map_workers = new int[map_ws.length];
+                RVMThread.ws_pinning_workers = true;
+                for(int xx=0; xx<map_ws.length; xx++) RVMThread.pin_map_workers[xx] = primitiveParseInt(map_ws[xx]);
+            break;
+        case WS_AUTO_PIN_APP_THREAD:
+                final String[] pinning = getArgs(PrefixType.WS_AUTO_PIN_APP_THREAD);
+                RVMThread.ws_pinning_workers = pinning[0].equals("true");
+            break;
+        case WS_PIN_LOG:
+                final String[] trace = getArgs(PrefixType.WS_PIN_LOG);
+                WS.pinLog = trace[0].equals("true");
+            break;
+        case WS_PIN_SOCKETS_HINT:
+                // cpuMap = <Total Sockets>:<Core Per Socket>
+                RVMThread.ws_pinning_workers = true;
+                final String[] sockets = arg.split(":");
+                RVMThread.sockets = primitiveParseInt(sockets[0]);
+                RVMThread.cpusPerSocket = primitiveParseInt(sockets[1]);
+            break;
+        case WS_PIN_MAP_SYSTEM_THREADS:
+                final String[] map_sys = arg.split(":");
+                RVMThread.pin_map_system = new int[map_sys.length];
+                RVMThread.ws_pinning_system = true;
+                for(int xx=0; xx<map_sys.length; xx++) RVMThread.pin_map_system[xx] = primitiveParseInt(map_sys[xx]);
+            break;
+        case WS_PIN_MAP_GC_THREADS:
+                final String[] map_gc = arg.split(":");
+                RVMThread.pin_map_gc = new int[map_gc.length];
+                RVMThread.ws_pinning_gc = true;
+                for(int xx=0; xx<map_gc.length; xx++) RVMThread.pin_map_gc[xx] = primitiveParseInt(map_gc[xx]);
+                break;
+        case PER_THREAD_PERF_EVENTS:
+        	final String[] perf_ws = getArgs(PrefixType.PER_THREAD_PERF_EVENTS);
+        	RVMThread.wsPerThreadPerf = perf_ws[0].equals("true");
+        	break;
+        case WS_PROCS:
+        	WS.wsProcs = primitiveParseInt(arg);
+        	break;
+        case WS_AUTOGEN_WSTHREADS:
+//        	final String[] autogen_ws = getArgs(PrefixType.WS_AUTOGEN_WSTHREADS);
+//        	RVMThread.autogenWSThread = autogen_ws[0].equals("true");
+        	break;
+        case WS_RETURN_BARRIER:
+        	final String[] useBarrier = getArgs(PrefixType.WS_RETURN_BARRIER);
+        	RVMThread.wsRetBarrier = useBarrier[0].equals("true");
+        	break;
+        case WS_STATISTICS:
+        	final String[] wsStats = getArgs(PrefixType.WS_STATISTICS);
+        	WS.stats = wsStats[0].equals("true");
+        	break;
       }
     }
   }
diff -r ab5908222258 rvm/src/org/jikesrvm/VM.java
--- a/rvm/src/org/jikesrvm/VM.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/VM.java	Fri Mar 21 09:37:25 2014 +0530
@@ -159,7 +159,7 @@
     // get pthread_id from OS and store into vm_processor field
     //
     sysCall.sysSetupHardwareTrapHandler();
-    RVMThread.getCurrentThread().pthread_id = sysCall.sysGetThreadId();
+    RVMThread.getCurrentThread().thread_id = sysCall.sysGetThreadId();
     RVMThread.availableProcessors = SysCall.sysCall.sysNumProcessors();
 
     // Set up buffer locks used by Thread for logging and status dumping.
@@ -963,7 +963,7 @@
   @NoInline
   /* don't waste code space inlining these --dave */
   public static void write(long value) {
-    write(value, true);
+    write(value, false);
   }
 
   /**
@@ -1088,6 +1088,22 @@
   }
 
   @NoInline
+  public static void sysWriteln(int a, String b, String c, String d, long e, String f, long g, String h, long i) {
+	  swLock();
+	  write(a);
+	  write(b);
+	  write(c);
+	  write(d);
+	  write(e);
+	  write(f);
+	  write(g);
+	  write(h);
+	  write(i);
+	  write("\n");
+	  swUnlock();
+  }
+
+  @NoInline
   public static void sysWrite(RVMMember m) {
     swLock();
     write(m);
@@ -1562,6 +1578,17 @@
     swUnlock();
   }
   @NoInline
+  public static void sysWriteln(Address a1, Address a2, Address a3) {
+    swLock();
+    write(a1);
+    write(" ");
+    write(a2);
+    write(" ");
+    write(a3);
+    writeln();
+    swUnlock();
+  }
+  @NoInline
   public static void sysWriteln(String s1, Address a1,Address a2) {
     swLock();
     write(s1);
@@ -1654,6 +1681,16 @@
     writeln();
     swUnlock();
   }
+  
+  @NoInline
+  public static void sysWriteln(Offset o1, String s, Offset o2) {
+    swLock();
+    write(o1);
+    write(s);
+    write(o2);
+    writeln();
+    swUnlock();
+  }
 
   @NoInline
   public static void sysWrite(String s1, String s2, String s3) {
@@ -1921,6 +1958,55 @@
     writeln();
     swUnlock();
   }
+  
+  @NoInline
+  public static void sysWriteln(String s1, Offset o1, String s2, Offset o2) {
+    swLock();
+    write(s1);
+    write(o1);
+    write(s2);
+    write(o2);
+    writeln();
+    swUnlock();
+  }
+  
+  @NoInline
+  public static void sysWriteln(Offset o, String s1, Offset o1, String s2, Offset o2) {
+    swLock();
+    write(o);
+    write(s1);
+    write(o1);
+    write(s2);
+    write(o2);
+    writeln();
+    swUnlock();
+  }
+  
+  @NoInline
+  public static void sysWriteln(int i1, String s1, Offset o, String s2, int i2) {
+    swLock();
+    write(i1);
+    write(s1);
+    write(o);
+    write(s2);
+    write(i2);
+    writeln();
+    swUnlock();
+  }
+
+  @NoInline
+  public static void sysWriteln(int i1, int i2, Offset o1, Offset o2) {
+    swLock();
+    write(i1);
+    write(" ");
+    write(i2);
+    write(" ");
+    write(o1);
+    write(" ");
+    write(o2);
+    writeln();
+    swUnlock();
+  }
 
   @NoInline
   public static void sysWrite(String s1, double d, String s2) {
diff -r ab5908222258 rvm/src/org/jikesrvm/classloader/RVMType.java
--- a/rvm/src/org/jikesrvm/classloader/RVMType.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/classloader/RVMType.java	Fri Mar 21 09:37:25 2014 +0530
@@ -135,6 +135,11 @@
   public static final RVMClass IMTType;
   public static final RVMClass FunctionTableType;
   public static final RVMClass LinkageTripletTableType;
+  public static final RVMClass WSContinuationType;
+  public static final RVMClass WSFinishType;
+  public static final RVMClass WSJoinType;
+  public static final RVMClass WSFinishFirstType;
+  public static final RVMClass RVMThreadType;
 
   static {
     // Primitive types
@@ -180,6 +185,12 @@
     JavaIoSerializableType = TypeReference.JavaIoSerializable.resolve().asClass();
     JavaLangRefReferenceType = TypeReference.JavaLangRefReference.resolve().asClass();
     JavaLangRefReferenceReferenceField = JavaLangRefReferenceType.findDeclaredField(Atom.findAsciiAtom("_referent"));
+    // WorkStealing
+    WSContinuationType = TypeReference.WSContinuation.resolve().asClass();
+    WSJoinType =  TypeReference.WSJoin.resolve().asClass();
+    WSFinishFirstType =  TypeReference.WSFinishFirst.resolve().asClass();
+    WSFinishType =  TypeReference.WSFinish.resolve().asClass();
+    RVMThreadType = TypeReference.RVMThread.resolve().asClass();
   }
 
   /**
diff -r ab5908222258 rvm/src/org/jikesrvm/classloader/TypeReference.java
--- a/rvm/src/org/jikesrvm/classloader/TypeReference.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/classloader/TypeReference.java	Fri Mar 21 09:37:25 2014 +0530
@@ -176,6 +176,11 @@
   public static final TypeReference BaselineSaveLSRegisters = findOrCreate(org.vmmagic.pragma.BaselineSaveLSRegisters.class);
   public static final TypeReference ReferenceFieldsVary = findOrCreate(org.vmmagic.pragma.ReferenceFieldsVary.class);
 
+  public static final TypeReference WSContinuation = findOrCreate(org.jikesrvm.scheduler.WS.Continuation.class);
+  public static final TypeReference WSJoin = findOrCreate(org.jikesrvm.scheduler.WS.Join.class);
+  public static final TypeReference WSFinish = findOrCreate(org.jikesrvm.scheduler.WS.Finish.class);
+  public static final TypeReference WSFinishFirst = findOrCreate(org.jikesrvm.scheduler.WS.FinishFirst.class);
+  public static final TypeReference RVMThread = findOrCreate(org.jikesrvm.scheduler.RVMThread.class);
 
   public static final TypeReference ReferenceMaps =
       findOrCreate(org.jikesrvm.compilers.baseline.ReferenceMaps.class);
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java
--- a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java	Fri Mar 21 09:37:25 2014 +0530
@@ -197,11 +197,11 @@
    */
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
     if (eTable == null) {
-      return -1;
+      return Offset.fromIntSignExtend(-1);
     } else {
-      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType);
+      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType, exactType);
     }
   }
 
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java
--- a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java	Fri Mar 21 09:37:25 2014 +0530
@@ -293,7 +293,7 @@
         ((BaselineCompiledMethod) compiledMethod).setLockAcquisitionOffset(lockOffset);
       }
       ((BaselineCompiledMethod) compiledMethod).encodeMappingInfo(refMaps, bcMap);
-      compiledMethod.compileComplete(instructions);
+      compiledMethod.compileComplete(instructions, instructions);
       if (edgeCounterIdx > 0) {
         EdgeCounts.allocateCounters(method, edgeCounterIdx);
       }
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java
--- a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java	Fri Mar 21 09:37:25 2014 +0530
@@ -95,7 +95,7 @@
                   0)) - BYTES_IN_ADDRESS).loadAddress());
         }
         if (ObjectModel.holdsLock(lock, RVMThread.getCurrentThread())) {
-          ObjectModel.genericUnlock(lock);
+          ObjectModel.genericUnlock_internal(lock);
         }
       }
     }
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java
--- a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java	Fri Mar 21 09:37:25 2014 +0530
@@ -24,16 +24,16 @@
 import org.jikesrvm.mm.mminterface.GCMapIterator;
 import org.jikesrvm.runtime.DynamicLink;
 import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 /**
- * Iterator for stack frame  built by the Baseline compiler.
- * <p>
+ * Iterator for stack frame  built by the Baseline compiler
  * An Instance of this class will iterate through a particular
- * reference map of a method returning the offsets of any references
+ * reference map of a method returning the offsets of any refereces
  * that are part of the input parameters, local variables, and
  * java stack for the stack frame.
  */
@@ -96,7 +96,7 @@
    * iterators (ones for the opt compiler built frames) The locations are kept
    * as addresses within the stack.
    */
-  public BaselineGCMapIterator(WordArray registerLocations) {
+  public BaselineGCMapIterator(AddressArray registerLocations) {
     this.registerLocations = registerLocations; // (in superclass)
     dynamicLink = new DynamicLink();
   }
@@ -115,11 +115,10 @@
    * @param instructionOffset
    *          identifies the map to be scanned.
    * @param fp
-   *          identifies a specific occurrence of this method and allows for
+   *          identifies a specific occurrance of this method and allows for
    *          processing instance specific information i.e JSR return address
    *          values
    */
-  @Override
   public void setupIterator(CompiledMethod compiledMethod, Offset instructionOffset, Address fp) {
     currentCompiledMethod = (BaselineCompiledMethod) compiledMethod;
     currentMethod = (NormalMethod) currentCompiledMethod.getMethod();
@@ -173,7 +172,7 @@
     bridgeSpilledParamLocation = Address.zero();
 
     if (currentMethod.getDeclaringClass().hasDynamicBridgeAnnotation()) {
-      Address ip = Magic.getReturnAddressUnchecked(fp);
+    	Address ip = Magic.getReturnAddress(fp);
       fp = Magic.getCallerFramePointer(fp);
       int callingCompiledMethodId = Magic.getCompiledMethodID(fp);
       CompiledMethod callingCompiledMethod = CompiledMethods.getCompiledMethod(callingCompiledMethodId);
@@ -200,7 +199,6 @@
    * Reset iteration to initial state. This allows a map to be scanned multiple
    * times.
    */
-  @Override
   public void reset() {
     mapIndex = 0;
     finishedWithRegularMap = false;
@@ -218,10 +216,8 @@
   }
 
   /**
-   * Converts a biased index from a local area into an offset in the stack.
-   *
-   * @param index index in the local area (biased : local0 has index 1)
-   * @return corresponding offset in the stack
+   * given a index in the local area (biased : local0 has index 1)
+   *   this routine determines the correspondig offset in the stack
    */
   public short convertIndexToLocation(int index) {
     if (index == 0) return 0;
@@ -244,12 +240,30 @@
     return offset;
   }
 
-  @Override
+  public final int getNVRegistersSaved() {
+    int result = (1 << EDI.value()) | (1 << EBX.value());
+    if (currentMethod.hasBaselineSaveLSRegistersAnnotation()) {
+      result |= 1 << EBP.value();
+    }
+    return result;
+  }
+
+  public final int getNVObjectMap() {
+    if (currentCompiledMethod.hasCounterArray()) {
+      return 1 << EBX.value();
+    }
+    return 0;
+  }
+  
+  /**
+   * Get location of next reference. A zero return indicates that no more
+   * references exist.
+   */
   public Address getNextReferenceAddress() {
     if (!finishedWithRegularMap) {
       if (counterArrayBase) {
         counterArrayBase = false;
-        return registerLocations.get(EBX.value()).toAddress();
+        return registerLocations.get(EBX.value());
       }
       if (mapId < 0) {
         mapIndex = maps.getNextJSRRefIndex(mapIndex);
@@ -303,10 +317,10 @@
       if (!bridgeRegistersLocationUpdated) {
         // point registerLocations[] to our callers stackframe
         //
-        registerLocations.set(EDI.value(), framePtr.plus(EDI_SAVE_OFFSET).toWord());
-        registerLocations.set(T0.value(), framePtr.plus(T0_SAVE_OFFSET).toWord());
-        registerLocations.set(T1.value(), framePtr.plus(T1_SAVE_OFFSET).toWord());
-        registerLocations.set(EBX.value(), framePtr.plus(EBX_SAVE_OFFSET).toWord());
+        registerLocations.set(EDI.value(), framePtr.plus(EDI_SAVE_OFFSET));
+        registerLocations.set(T0.value(), framePtr.plus(T0_SAVE_OFFSET));
+        registerLocations.set(T1.value(), framePtr.plus(T1_SAVE_OFFSET));
+        registerLocations.set(EBX.value(), framePtr.plus(EBX_SAVE_OFFSET));
 
         bridgeRegistersLocationUpdated = true;
       }
@@ -374,17 +388,20 @@
     } else {
       // point registerLocations[] to our callers stackframe
       //
-      registerLocations.set(EDI.value(), framePtr.plus(EDI_SAVE_OFFSET).toWord());
-      registerLocations.set(EBX.value(), framePtr.plus(EBX_SAVE_OFFSET).toWord());
+      registerLocations.set(EDI.value(), framePtr.plus(EDI_SAVE_OFFSET));
+      registerLocations.set(EBX.value(), framePtr.plus(EBX_SAVE_OFFSET));
       if (currentMethod.hasBaselineSaveLSRegistersAnnotation()) {
-        registerLocations.set(EBP.value(), framePtr.plus(EBP_SAVE_OFFSET).toWord());
+        registerLocations.set(EBP.value(), framePtr.plus(EBP_SAVE_OFFSET));
       }
     }
 
     return Address.zero();
   }
 
-  @Override
+  /**
+   * Gets the location of the next return address after the current position. A
+   * zero return indicates that no more references exist
+   */
   public Address getNextReturnAddressAddress() {
     if (mapId >= 0) {
       if (VM.TraceStkMaps || TRACE_ALL) {
@@ -405,10 +422,9 @@
 
   /**
    * Cleanup pointers - used with method maps to release data structures early
-   * ... they may be in temporary storage i.e. storage only used during garbage
+   * ... they may be in temporary storage ie storage only used during garbage
    * collection
    */
-  @Override
   public void cleanupPointers() {
     maps.cleanupPointers();
     maps = null;
@@ -419,7 +435,6 @@
     bridgeParameterTypes = null;
   }
 
-  @Override
   public int getType() {
     return CompiledMethod.BASELINE;
   }
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java
--- a/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java	Fri Mar 21 09:37:25 2014 +0530
@@ -33,6 +33,8 @@
 
 /**
  * A method that has been compiled into machine code by one of our compilers.
+ * We implement SynchronizedObject because we need to synchronize
+ * on the CompiledMethod object as part of the invalidation protocol.
  */
 public abstract class CompiledMethod implements SizeConstants {
 
@@ -84,6 +86,11 @@
   protected CodeArray instructions;
 
   /**
+   * The compiled machine code for said method.
+   */
+  protected CodeArray joinInstructions;
+
+  /**
    * the offset of instructions in JTOC, for osr-special compiled
    * method only. all osr-ed method is treated like static.
    * TODO: OSR redesign: put in subclass?  Stick somewhere else?
@@ -107,7 +114,7 @@
 
   public void setSpecialForOSR() {
     flags |= SPECIAL_FOR_OSR;
-    // set JTOC
+    // set jtoc
     this.osrJTOCoffset = Statics.allocateReferenceSlot(false).toInt();
     Statics.setSlotContents(this.getOsrJTOCoffset(), this.instructions);
   }
@@ -201,16 +208,18 @@
     if (getCompilerType() == JNI || getCompilerType() == TRAP) {
       return Offset.zero();
     } else {
-      Offset offset = ip.diff(Magic.objectAsAddress(instructions));
-      int max = (instructions.length() + 1) << ArchitectureSpecific.ArchConstants.LG_INSTRUCTION_WIDTH;
+      CodeArray base = instructions;
+      if (inJoinInstructions(ip)) base = joinInstructions;
+      Offset offset = ip.diff(Magic.objectAsAddress(base));
+      int max = (base.length() + 1) << ArchitectureSpecific.ArchConstants.LG_INSTRUCTION_WIDTH;
       if (!offset.toWord().LT(Word.fromIntZeroExtend(max))) {
-        if (RVMThread.isTrampolineIP(ip)) {
-          ip = RVMThread.getCurrentThread().getTrampolineHijackedReturnAddress();
-          offset = ip.diff(Magic.objectAsAddress(instructions));
-          if (offset.toWord().LT(Word.fromIntZeroExtend(max)))
-            return offset;
-        }
-        Address instructionStart = Magic.objectAsAddress(instructions);
+    	  if (RVMThread.isTrampolineIP(ip)) {
+    		  ip = RVMThread.getCurrentThread().getTrampolineHijackedReturnAddress();
+    		  offset = ip.diff(Magic.objectAsAddress(instructions));
+    		  if (offset.toWord().LT(Word.fromIntZeroExtend(max)))
+    			  return offset;
+    	  }
+        Address instructionStart = Magic.objectAsAddress(base);
         VM.sysWriteln("\nIn thread ",RVMThread.getCurrentThreadSlot()," getInstructionOffset: ip is not within compiled code for method: ",ip);
         VM.sysWrite("\tsupposed method is ");
         VM.sysWrite(method);
@@ -238,7 +247,7 @@
       return offset;
     }
   }
-
+  
   /**
    * Return the address of the instruction at offset offset in the method's instruction stream.
    * @param offset the offset of the desired instruction (as returned by getInstructionOffset)
@@ -249,6 +258,17 @@
     Address startAddress = Magic.objectAsAddress(instructions);
     return startAddress.plus(offset);
   }
+  
+  /**
+   * Return the address of the instruction at offset offset in the method's instruction stream.
+   * @param offset the offset of the desired instruction (as returned by getInstructionOffset)
+   * @return Address of the specified instruction
+   */
+  @Uninterruptible
+  public final Address getInstructionAddress(boolean inJoin, Offset offset) {
+    Address startAddress = Magic.objectAsAddress(inJoin ? joinInstructions : instructions);
+    return startAddress.plus(offset);
+  }
 
   /**
    * Return the code array for this method that contains the given offset.
@@ -263,10 +283,31 @@
   /**
    * Does the code for the compiled method contain the given return address?
    * @param ip a return address
-   * @return {@code true} if it belongs to this method's code, {@code false} otherwise.
+   * @return true if it belongs to this method's code, false otherwise.
    */
   @Uninterruptible
   public final boolean containsReturnAddress(Address ip) {
+    return inRange(ip, instructions) || inJoinInstructions(ip);
+  }
+
+  @Uninterruptible
+  public final boolean inJoinInstructions(Address ip) {
+    return joinInstructions != null && inRange(ip, joinInstructions);
+  }
+
+  @Uninterruptible
+  public final boolean hasJoinInstructions() {
+    return joinInstructions != null && joinInstructions != instructions;
+  }
+
+
+  @Uninterruptible
+  public final Offset joinDelta() {
+    return Magic.objectAsAddress(joinInstructions).diff(Magic.objectAsAddress(instructions));
+  }
+  
+  @Uninterruptible
+  private static final boolean inRange(Address ip, CodeArray instructions) {
     Address beg = Magic.objectAsAddress(instructions);
     Address end = beg.plus(instructions.length() << ArchitectureSpecific.ArchConstants.LG_INSTRUCTION_WIDTH);
 
@@ -280,8 +321,9 @@
   /**
    * Record that the compilation is complete.
    */
-  public final void compileComplete(CodeArray code) {
+  public final void compileComplete(CodeArray code, CodeArray joinCode) {
     instructions = code;
+    joinInstructions = joinCode;
     flags |= COMPILED;
   }
 
@@ -311,7 +353,7 @@
   }
 
   /**
-   * Mark the compiled method as outdated (i.e. requires OSR),
+   * Mark the compiled method as outdated (ie requires OSR),
    * the flag is set in AnalyticModel
    */
   @Uninterruptible
@@ -358,14 +400,14 @@
     return (flags & ACTIVE_ON_STACK) != 0;
   }
 
-  public final double getCompilationTime() { return compilationTime; }
+  public final double getCompilationTime() { return (double) compilationTime; }
 
   public final void setCompilationTime(double ct) { compilationTime = (float) ct; }
 
   /**
    * Identify the compiler that produced this compiled method.
    * @return one of TRAP, BASELINE, OPT, or JNI.
-   * Note: use this instead of "instanceof" when GC is disabled (i.e. during GC)
+   * Note: use this instead of "instanceof" when gc is disabled (ie. during gc)
    */
   @Uninterruptible
   public abstract int getCompilerType();
@@ -402,7 +444,12 @@
   /**
    * Find "catch" block for a machine instruction of
    * this method that might be guarded
-   * against specified class of exceptions by a "try" block.<p>
+   * against specified class of exceptions by a "try" block .
+   *
+   * @param instructionOffset offset of machine instruction from start of this method, in bytes
+   * @param exceptionType type of exception being thrown - something like "NullPointerException"
+   * @return offset of machine instruction for catch block
+   * (-1 --> no catch block)
    *
    * Notes:
    * <ul>
@@ -411,9 +458,9 @@
    * instruction whose catch block is sought.
    * This allows us to properly handle the case where
    * the only address we have to work with is a return address
-   * (i.e. from a stackframe)
+   * (ie. from a stackframe)
    * or an exception address
-   * (i.e. from a {@code null} pointer dereference, array bounds check,
+   * (ie. from a null pointer dereference, array bounds check,
    * or divide by zero) on a machine architecture with variable length
    * instructions.
    * In such situations we'd have no idea how far to back up the
@@ -421,20 +468,18 @@
    * to point to the "call site" or "exception site".
    *
    * <li> This method must not cause any allocations, because it executes with
-   * GC disabled when called by RuntimeEntrypoints.deliverException().
+   * gc disabled when called by RuntimeEntrypoints.deliverException().
    * </ul>
-   *
-   * @param instructionOffset offset of machine instruction from start of this method, in bytes
-   * @param exceptionType type of exception being thrown - something like "NullPointerException"
-   * @return offset of machine instruction for catch block
-   * (-1 --> no catch block)
    */
   @Unpreemptible
-  public abstract int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType);
+  public abstract Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType);
 
   /**
    * Fetch symbolic reference to a method that's called by one of
-   * this method's instructions.<p>
+   * this method's instructions.
+   * @param dynamicLink place to put return information
+   * @param instructionOffset offset of machine instruction from start of
+   * this method, in bytes
    *
    * Notes:
    * <ul>
@@ -443,7 +488,7 @@
    * instruction whose target method is sought.
    * This allows us to properly handle the case where
    * the only address we have to work with is a return address
-   * (i.e. from a stackframe)
+   * (ie. from a stackframe)
    * on a machine architecture with variable length instructions.
    * In such situations we'd have no idea how far to back up the
    * instruction pointer
@@ -451,12 +496,8 @@
    *
    * <li> The implementation must not cause any allocations,
    * because it executes with
-   * GC disabled when called by GCMapIterator.
+   * gc disabled when called by GCMapIterator.
    * <ul>
-   *
-   * @param dynamicLink place to put return information
-   * @param instructionOffset offset of machine instruction from start of
-   * this method, in bytes
    */
   @Uninterruptible
   public abstract void getDynamicLink(DynamicLink dynamicLink, Offset instructionOffset);
@@ -464,6 +505,9 @@
   /**
    * Find source line number corresponding to one of this method's
    * machine instructions.
+   * @param instructionOffset of machine instruction from start of this method, in bytes
+   * @return source line number
+   * (0 == no line info available, 1 == first line of source file)
    *
    * <p> Usage note: "instructionOffset" must point to the
    * instruction <em> following </em> the actual instruction
@@ -478,11 +522,6 @@
    * In such situations we'd have no idea how far to back up the
    * instruction pointer
    * to point to the "call site" or "exception site".
-   *
-   * @param instructionOffset of machine instruction from start of this method, in bytes
-   * @return source line number
-   * (0 == no line info available, 1 == first line of source file)
-   *
    */
   @Uninterruptible
   public int findLineNumberForInstruction(Offset instructionOffset) {
@@ -494,7 +533,7 @@
    * of the compiled method's code array) corresponds to an uninterruptible context.
    *
    * @param instructionOffset of addr from start of instructions in bytes
-   * @return {@code true} if the IP is within an Uninterruptible method, {@code false} otherwise.
+   * @return true if the IP is within an Uninterruptible method, false otherwise.
    */
   @Interruptible
   public abstract boolean isWithinUninterruptibleCode(Offset instructionOffset);
@@ -519,7 +558,7 @@
   /**
    * Return the number of bytes used to encode the compiler-specific mapping
    * information for this compiled method.
-   * Used to gather statistics on the space costs of mapping schemes.
+   * Used to gather stats on the space costs of mapping schemes.
    */
   public int size() { return 0; }
 
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java
--- a/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java	Fri Mar 21 09:37:25 2014 +0530
@@ -17,7 +17,9 @@
 import org.jikesrvm.classloader.DynamicTypeCheck;
 import org.jikesrvm.classloader.RVMType;
 import org.jikesrvm.objectmodel.TIB;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
 import org.vmmagic.pragma.Unpreemptible;
+import org.vmmagic.pragma.UnpreemptibleNoWarn;
 import org.vmmagic.unboxed.Offset;
 
 /**
@@ -41,10 +43,11 @@
    * @param eTable the encoded exception table to search
    * @param instructionOffset the offset of the instruction after the PEI.
    * @param exceptionType the type of exception that was raised
+   * @param exactType only match exact exception types.
    * @return the machine code offset of the catch block.
    */
   @Unpreemptible
-  public static int findCatchBlockForInstruction(int[] eTable, Offset instructionOffset, RVMType exceptionType) {
+  public static Offset findCatchBlockForInstruction(int[] eTable, Offset instructionOffset, RVMType exceptionType, boolean exactType) {
     for (int i = 0, n = eTable.length; i < n; i += 4) {
       // note that instructionOffset points to the instruction after the PEI
       // so the range check here must be "offset >  beg && offset <= end"
@@ -55,18 +58,18 @@
           instructionOffset.sLE(Offset.fromIntSignExtend(eTable[i + TRY_END]))) {
         RVMType lhs = RVMType.getType(eTable[i + EX_TYPE]);
         if (lhs == exceptionType) {
-          return eTable[i + CATCH_START];
-        } else if (lhs.isInitialized()) {
+          return Offset.fromIntSignExtend(eTable[i + CATCH_START]);
+        } else if (!exactType && lhs.isInitialized()) {
           TIB rhsTIB = exceptionType.getTypeInformationBlock();
           if (DynamicTypeCheck.instanceOfClass(lhs.asClass(), rhsTIB)) {
-            return eTable[i + CATCH_START];
+            return Offset.fromIntSignExtend(eTable[i + CATCH_START]);
           }
         }
       }
     }
-    return -1;
+    return Offset.fromIntSignExtend(-1);
   }
-
+  
   /**
    * Print an encoded exception table.
    * @param eTable the encoded exception table to print.
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java
--- a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java	Fri Mar 21 09:37:25 2014 +0530
@@ -56,8 +56,8 @@
 
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
-    return -1;
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
+    return Offset.fromIntSignExtend(-1);
   }
 
   @Override
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java
--- a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java	Fri Mar 21 09:37:25 2014 +0530
@@ -19,7 +19,7 @@
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 /**
  * Iterator for stack frames inserted by hardware trap handler.
@@ -29,7 +29,7 @@
 @Uninterruptible
 public final class HardwareTrapGCMapIterator extends GCMapIterator implements SizeConstants {
 
-  public HardwareTrapGCMapIterator(WordArray registerLocations) {
+  public HardwareTrapGCMapIterator(AddressArray registerLocations) {
     this.registerLocations = registerLocations;
   }
 
@@ -38,6 +38,18 @@
     this.framePtr = framePtr;
   }
 
+  public final int getNVRegistersSaved() {
+    int result = 0;
+    for (int i=0; i< ArchitectureSpecific.ArchConstants.NONVOLATILE_GPRS.length; i++) {
+      result |= (1 << ArchitectureSpecific.ArchConstants.NONVOLATILE_GPRS[i].value());
+    }
+    return result;
+  }
+
+  public final int getNVObjectMap() {
+    return 0;
+  }
+
   @Override
   public Address getNextReferenceAddress() {
     // update register locations, noting that the trap handler represented by this stackframe
@@ -45,7 +57,7 @@
     //
     Address registerLocation = Magic.objectAsAddress(thread.getExceptionRegisters().gprs);
     for (int i = 0; i < ArchitectureSpecific.ArchConstants.NUM_GPRS; ++i) {
-      registerLocations.set(i, registerLocation.toWord());
+      registerLocations.set(i, registerLocation);
       registerLocation = registerLocation.plus(BYTES_IN_ADDRESS);
     }
     return Address.zero();
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java
--- a/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java	Fri Mar 21 09:37:25 2014 +0530
@@ -176,7 +176,7 @@
       // system a chance to eagerly compile any specialized version
       // that are pending.  TODO: use lazy compilation with specialization.
       SpecializationDatabase.doDeferredSpecializations();
-      ir.compiledMethod.compileComplete(ir.MIRInfo.machinecode);
+      ir.compiledMethod.compileComplete(ir.MIRInfo.fastmachinecode, ir.MIRInfo.machinecode);
       return ir.compiledMethod;
     } catch (OptimizingCompilerException e) {
       throw e;
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java
--- a/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java	Fri Mar 21 09:37:25 2014 +0530
@@ -27,6 +27,11 @@
   public CodeArray machinecode;
 
   /**
+   * The generated machinecodes produced by this compilation of 'method'
+   */
+  public CodeArray fastmachinecode;
+
+  /**
    * Estimate produced by FinalMIRExpansion and used by
    * Assembler to create code array; only meaningful on PowerPC
    */
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java
--- a/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java	Fri Mar 21 09:37:25 2014 +0530
@@ -1072,6 +1072,7 @@
     }
 
     ir.MIRInfo.machinecode = asm.getMachineCodes();
+    ir.MIRInfo.fastmachinecode = asm.patchMachineCodeForWorkStealing(ir.MIRInfo.machinecode);
 
     return ir.MIRInfo.machinecode.length();
   }
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java
--- a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java	Fri Mar 21 09:37:25 2014 +0530
@@ -79,11 +79,11 @@
    */
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
     if (eTable == null) {
-      return -1;
+      return Offset.fromIntSignExtend(-1);
     } else {
-      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType);
+      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType, exactType);
     }
   }
 
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java
--- a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java	Fri Mar 21 09:37:25 2014 +0530
@@ -24,7 +24,7 @@
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 /**
  * This class contains its architecture-independent code for iteration
@@ -83,7 +83,7 @@
   static final boolean lookForMissedReferencesInSpills = false;
 
   // Constructor
-  protected OptGenericGCMapIterator(WordArray registerLocations) {
+  protected OptGenericGCMapIterator(AddressArray registerLocations) {
     super();
     this.registerLocations = registerLocations;
   }
@@ -178,6 +178,34 @@
     }
   }
 
+  public final int getNVRegistersSaved() {
+    int result = 0;
+    int frameOffset = compiledMethod.getUnsignedNonVolatileOffset();
+    if (frameOffset >= 0) {
+      int first = compiledMethod.getFirstNonVolatileGPR();
+      if (first >= 0) {
+        for (int i = first; i < NUM_NONVOLATILE_GPRS; i++) {
+          result |= (1 << NONVOLATILE_GPRS[i].value());
+        }
+      }
+    }
+    return result;
+  }
+
+  public final int getNVObjectMap() {
+    int result = 0;
+    if (mapIndex == OptGCMap.NO_MAP_ENTRY) {
+      return 0;
+    }
+    for(int i=0; i < NONVOLATILE_GPRS.length; i++) {
+      int reg = NONVOLATILE_GPRS[i].value();
+      if (map.registerIsSet(mapIndex, reg)) {
+        result |= (1 << reg);
+      }
+    }
+    return result;
+  }
+
   /**
    * Returns the next address that contains a reference
    * @return the value of the next reference
@@ -215,7 +243,7 @@
       if (currentRegisterIsValid()) {
         Address regLocation;
         // currentRegister contains a reference, return that location
-        regLocation = registerLocations.get(getCurrentRegister()).toAddress();
+        regLocation = registerLocations.get(getCurrentRegister());
         if (DEBUG) {
           VM.sysWrite(" *** Ref found in reg#");
           VM.sysWrite(getCurrentRegister());
@@ -414,7 +442,7 @@
    */
   final void checkRegistersForMissedReferences(int firstReg, int lastReg) {
     for (int i = firstReg; i <= lastReg; i++) {
-      Address regLocation = registerLocations.get(i).toAddress();
+      Address regLocation = registerLocations.get(i);
       Address regValue = regLocation.loadAddress();
       if (MemoryManager.addressInVM(regValue)) {
         VM.sysWrite("  reg#", getCurrentRegister());
diff -r ab5908222258 rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptGCMapIterator.java
--- a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptGCMapIterator.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/ia32/OptGCMapIterator.java	Fri Mar 21 09:37:25 2014 +0530
@@ -18,7 +18,7 @@
 import org.jikesrvm.ia32.StackframeLayoutConstants;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
-import org.vmmagic.unboxed.WordArray;
+import org.vmmagic.unboxed.AddressArray;
 
 /**
  * An instance of this class provides iteration across the references
@@ -33,7 +33,7 @@
 
   private static final boolean DEBUG = false;
 
-  public OptGCMapIterator(WordArray registerLocations) {
+  public OptGCMapIterator(AddressArray registerLocations) {
     super(registerLocations);
   }
 
@@ -85,7 +85,7 @@
         for (int i = first; i < NUM_NONVOLATILE_GPRS; i++) {
           // determine what register index corresponds to this location
           int registerIndex = NONVOLATILE_GPRS[i].value();
-          registerLocations.set(registerIndex, location.toWord());
+          registerLocations.set(registerIndex, location);
           if (DEBUG) {
             VM.sysWrite("UpdateRegisterLocations: Register ");
             VM.sysWrite(registerIndex);
@@ -105,7 +105,7 @@
         for (int i = 0; i < NUM_VOLATILE_GPRS; i++) {
           // determine what register index corresponds to this location
           int registerIndex = VOLATILE_GPRS[i].value();
-          registerLocations.set(registerIndex, location.toWord());
+          registerLocations.set(registerIndex, location);
           if (DEBUG) {
             VM.sysWrite("UpdateRegisterLocations: Register ");
             VM.sysWrite(registerIndex);
diff -r ab5908222258 rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java
--- a/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java	Fri Mar 21 09:37:25 2014 +0530
@@ -509,7 +509,7 @@
     Assembler asm = new ArchitectureSpecific.Assembler(0);
 
     /* push the hijacked return address (which is held in thread-local state) */
-    asm.emitPUSH_RegDisp(TR, ArchEntrypoints.hijackedReturnAddressField.getOffset());
+//    asm.emitPUSH_RegDisp(TR, ArchEntrypoints.hijackedReturnAddressField.getOffset()); //commented due to work-stealing changes
 
     /* push the GPRs and fp */
     for (int i = 0; i < NUM_GPRS; i++) {
@@ -526,6 +526,18 @@
       asm.emitPOP_Reg(ALL_GPRS[i]);
     }
 
+    /*
+     * When doing Try-Catch work-stealing, it might be the case that the victim is intended to
+     * return to an address A from the return barrier, but once it has branched into the 
+     * return barrier it finds that now that return address A is no more valid
+     * as it has been stolen. Now in this case it should not return to A and instead
+     * return to some new address B. This change is possible only if the return address
+     * is PUSH at this point and not in the begining of this call --  generateStackTrampolineBridgeInstructions().
+     */
+    
+    /* push the hijacked return address (which is held in thread-local state) */
+    asm.emitPUSH_RegDisp(TR, ArchEntrypoints.hijackedReturnAddressField.getOffset());
+    
     /* pop the hijacked return address and return */
     asm.emitRET();
 
diff -r ab5908222258 rvm/src/org/jikesrvm/jni/JNICompiledMethod.java
--- a/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java	Fri Mar 21 09:37:25 2014 +0530
@@ -89,8 +89,8 @@
 
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
-    return -1;
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
+    return Offset.fromIntSignExtend(-1);
   }
 
   @Override
diff -r ab5908222258 rvm/src/org/jikesrvm/jni/JNIFunctions.java
--- a/rvm/src/org/jikesrvm/jni/JNIFunctions.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/jni/JNIFunctions.java	Fri Mar 21 09:37:25 2014 +0530
@@ -5594,7 +5594,7 @@
 
     try {
       Object obj = env.getJNIRef(objJREF);
-      ObjectModel.genericLock(obj);
+      ObjectModel.genericLock_internal(obj);
       return 0;
     } catch (Throwable unexpected) {
       if (traceJNI) unexpected.printStackTrace(System.err);
@@ -5614,7 +5614,7 @@
 
     try {
       Object obj = env.getJNIRef(objJREF);
-      ObjectModel.genericUnlock(obj);
+      ObjectModel.genericUnlock_internal(obj);
       return 0;
     } catch (Throwable unexpected) {
       if (traceJNI) unexpected.printStackTrace(System.err);
diff -r ab5908222258 rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java
--- a/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java	Fri Mar 21 09:37:25 2014 +0530
@@ -555,7 +555,7 @@
     }
 
     MachineCode machineCode = new ArchitectureSpecific.MachineCode(asm.getMachineCodes(), null);
-    cm.compileComplete(machineCode.getInstructions());
+    cm.compileComplete(machineCode.getInstructions(), machineCode.getInstructions());
     return cm;
   }
 
diff -r ab5908222258 rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java
--- a/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java	Fri Mar 21 09:37:25 2014 +0530
@@ -20,9 +20,8 @@
 import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.Offset;
 import org.vmmagic.unboxed.AddressArray;
-import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
 
 /**
  * Iterator for stack frames inserted at the transition from Java to
@@ -60,10 +59,18 @@
   int jniNextRef;
   int jniFramePtr;
 
-  public JNIGCMapIterator(WordArray registerLocations) {
+  public JNIGCMapIterator(AddressArray registerLocations) {
     this.registerLocations = registerLocations;
   }
 
+  public final int getNVRegistersSaved() {
+    return (1 << EDI.value()) | (1 << EBX.value()) | (1 << EBP.value());
+  }
+
+  public final int getNVObjectMap() {
+    return 0;
+  }
+
   // Override newStackWalk() in parent class GCMapIterator to
   // initialize iterator for scan of JNI JREFs stack of refs
   // Taken:    thread
@@ -120,9 +127,9 @@
     // the JNI transition frame at a fixed negative offset from the callers FP.
     // the save non-volatiles are EBX EBP and EDI.
     //
-    registerLocations.set(EDI.value(), framePtr.plus(JNICompiler.EDI_SAVE_OFFSET).toWord());
-    registerLocations.set(EBX.value(), framePtr.plus(JNICompiler.EBX_SAVE_OFFSET).toWord());
-    registerLocations.set(EBP.value(), framePtr.plus(JNICompiler.EBP_SAVE_OFFSET).toWord());
+    registerLocations.set(EDI.value(), framePtr.plus(JNICompiler.EDI_SAVE_OFFSET));
+    registerLocations.set(EBX.value(), framePtr.plus(JNICompiler.EBX_SAVE_OFFSET));
+    registerLocations.set(EBP.value(), framePtr.plus(JNICompiler.EBP_SAVE_OFFSET));
 
     return Address.zero();  // no more refs to report
   }
diff -r ab5908222258 rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java
--- a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java	Fri Mar 21 09:37:25 2014 +0530
@@ -16,8 +16,8 @@
 import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.AddressArray;
 import org.vmmagic.unboxed.Offset;
-import org.vmmagic.unboxed.WordArray;
 
 /**
  * Base class for iterators that identify object references and JSR return addresses
@@ -36,7 +36,7 @@
   public Address framePtr;
 
   /** address where each gpr register was saved by previously scanned stackframe(s) */
-  public WordArray registerLocations;
+  public AddressArray registerLocations;
 
   /**
    * Prepare to scan a thread's stack and saved registers for object references.
@@ -46,7 +46,7 @@
   public void newStackWalk(RVMThread thread) {
     this.thread = thread;
   }
-
+  
   /**
    * Prepare to iterate over object references and JSR return addresses held by a stackframe.
    *
@@ -90,6 +90,10 @@
    */
   public abstract void cleanupPointers();
 
+  public abstract int getNVRegistersSaved();
+
+  public abstract int getNVObjectMap();
+
   /**
    * Get the type of this iterator (BASELINE, OPT, etc.).
    * Called from GCMapIteratorGroup to select which iterator
diff -r ab5908222258 rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java
--- a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java	Fri Mar 21 09:37:25 2014 +0530
@@ -23,18 +23,21 @@
 import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.AddressArray;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
 import org.vmmagic.unboxed.WordArray;
 
 /**
  * Maintains a collection of compiler specific GCMapIterators that are used
  * by collection threads when scanning thread stacks to locate object references
  * in those stacks. Each collector thread has its own GCMapIteratorGroup.
- * <p>
+ *
  * The group contains a GCMapIterator for each type of stack frame that
  * may be found while scanning a stack during garbage collection, including
  * frames for baseline compiled methods, OPT compiled methods, and frames
  * for transitions from Java into JNI native code. These iterators are
- * responsible for reporting the location of references in the stack or
+ * repsonsible for reporting the location of references in the stack or
  * register save areas.
  *
  * @see GCMapIterator
@@ -44,7 +47,7 @@
 public final class GCMapIteratorGroup implements SizeConstants {
 
   /** current location (memory address) of each gpr register */
-  private final WordArray registerLocations;
+  private final AddressArray registerLocations;
 
   /** iterator for baseline compiled frames */
   private final GCMapIterator baselineIterator;
@@ -59,7 +62,7 @@
   private final GCMapIterator jniIterator;
 
   public GCMapIteratorGroup() {
-    registerLocations = WordArray.create(ArchitectureSpecific.ArchConstants.NUM_GPRS);
+    registerLocations = AddressArray.create(ArchitectureSpecific.ArchConstants.NUM_GPRS);
 
     baselineIterator = new BaselineGCMapIterator(registerLocations);
     if (VM.BuildForOptCompiler) {
@@ -70,7 +73,19 @@
     jniIterator = new JNIGCMapIterator(registerLocations);
     hardwareTrapIterator = new HardwareTrapGCMapIterator(registerLocations);
   }
-
+  
+  @Uninterruptible
+  public void dump() {
+	  VM.sysWrite("GCMapIteratorGroup: registerLocations:");
+	  for(int i=0; i<ArchitectureSpecific.ArchConstants.NUM_GPRS; i++)  {
+		  VM.sysWrite("[",i,"] = ");
+		  VM.sysWrite(registerLocations.get(i));
+		  VM.sysWrite(":",registerLocations.get(i).loadWord());
+		  VM.sysWrite(" ");
+	  }
+	  VM.sysWriteln();
+  }
+  
   /**
    * Prepare to scan a thread's stack for object references.
    * Called by collector threads when beginning to scan a threads stack.
@@ -87,7 +102,7 @@
   @Uninterruptible
   public void newStackWalk(RVMThread thread, Address registerLocation) {
     for (int i = 0; i < ArchitectureSpecific.ArchConstants.NUM_GPRS; ++i) {
-      registerLocations.set(i, registerLocation.toWord());
+      registerLocations.set(i, registerLocation);
       registerLocation = registerLocation.plus(BYTES_IN_ADDRESS);
     }
     baselineIterator.newStackWalk(thread);
@@ -99,6 +114,24 @@
   }
 
   /**
+   * Copy out the current register values from register location information.
+   *
+   * @param registerLocation Where to copy the values to.
+   */
+  @Uninterruptible
+  public void copyRegisterValues(Address registerLocation) {
+    for (int i = 0; i < ArchitectureSpecific.ArchConstants.NUM_GPRS; ++i) {
+      registerLocation.store(registerLocations.get(i).loadWord());
+      registerLocation = registerLocation.plus(BYTES_IN_ADDRESS);
+    }
+  }
+
+  @Uninterruptible
+  public Address getRegisterLocation(int reg) {
+    return registerLocations.get(reg);
+  }
+
+  /**
    * Select iterator for scanning for object references in a stackframe.
    * Called by collector threads while scanning a threads stack.
    *
diff -r ab5908222258 rvm/src/org/jikesrvm/objectmodel/ObjectModel.java
--- a/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java	Fri Mar 21 09:37:25 2014 +0530
@@ -23,6 +23,7 @@
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.scheduler.Lock;
 import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.scheduler.WS;
 import org.vmmagic.pragma.Entrypoint;
 import org.vmmagic.pragma.Inline;
 import org.vmmagic.pragma.Interruptible;
@@ -467,6 +468,7 @@
   @Entrypoint
   @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
   public static void genericLock(Object o) {
+	WS.pauseStealOnThread();
     JavaHeader.genericLock(o);
   }
 
@@ -477,6 +479,25 @@
   @Unpreemptible("No preemption normally, but may raise exceptions")
   public static void genericUnlock(Object o) {
     JavaHeader.genericUnlock(o);
+    WS.resumeStealOnThread();
+  }
+
+  /**
+   * Generic lock - Work-Stealing Specific
+   */
+  @Entrypoint
+  @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
+  public static void genericLock_internal(Object o) {
+    JavaHeader.genericLock(o);
+  }
+
+  /**
+   * Generic lock - Work-Stealing Specific
+   */
+  @Entrypoint
+  @Unpreemptible("No preemption normally, but may raise exceptions")
+  public static void genericUnlock_internal(Object o) {
+    JavaHeader.genericUnlock(o);
   }
 
   /**
diff -r ab5908222258 rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java
--- a/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java	Fri Mar 21 09:37:25 2014 +0530
@@ -46,7 +46,7 @@
   RVMField trampolineRegistersField =
         EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "trampolineRegisters", "Lorg/jikesrvm/ArchitectureSpecific$Registers;");
   RVMField hijackedReturnAddressField =
-    EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "hijackedReturnAddress", "Lorg/vmmagic/unboxed/Address;");
+    EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "hijackedReturnAddress_original", "Lorg/vmmagic/unboxed/Address;");
    RVMField registersIPField =
       EntrypointHelper.getField("Lorg/jikesrvm/" + arch + "/Registers;", "ip", "Lorg/vmmagic/unboxed/Address;");
   RVMField registersFPRsField = EntrypointHelper.getField("Lorg/jikesrvm/" + arch + "/Registers;", "fprs", "[D");
diff -r ab5908222258 rvm/src/org/jikesrvm/runtime/BootRecord.java
--- a/rvm/src/org/jikesrvm/runtime/BootRecord.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/runtime/BootRecord.java	Fri Mar 21 09:37:25 2014 +0530
@@ -256,6 +256,11 @@
   public Address sysNumProcessorsIP;
   public Address sysThreadBindSupportedIP;
   public Address sysThreadBindIP;
+  public Address sysThreadBindMaskSetIP;
+  public Address wsIniatilizeSysThreadBindMaskIP;
+  public Address wsThreadBindMaskSetIP;
+  public Address sysCheckNUMAnodeIP;
+  public Address sysGetCPUIP;
   public Address sysThreadCreateIP;
   public Address sysThreadYieldIP;
   public Address sysGetThreadIdIP;
@@ -380,5 +385,14 @@
   public Address sysPerfEventEnableIP;
   public Address sysPerfEventDisableIP;
   public Address sysPerfEventReadIP;
+  
+  // per thread perf event support
+  public Address sysPerfEventInit_threadIP;
+  public Address sysPerfEventCreate_threadIP;
+  public Address sysPerfEventOpen_threadIP;
+  public Address sysPerfEventClose_threadIP;
+  public Address sysPerfEventEnable_threadIP;
+  public Address sysPerfEventDisable_threadIP;
+  public Address sysPerfEventRead_threadIP;
 
 }
diff -r ab5908222258 rvm/src/org/jikesrvm/runtime/Entrypoints.java
--- a/rvm/src/org/jikesrvm/runtime/Entrypoints.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/runtime/Entrypoints.java	Fri Mar 21 09:37:25 2014 +0530
@@ -16,6 +16,7 @@
 import static org.jikesrvm.runtime.EntrypointHelper.getMethod;
 
 import org.jikesrvm.VM;
+import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.NormalMethod;
@@ -26,7 +27,7 @@
  */
 public class Entrypoints {
   // The usual causes for getField/Method() to fail are:
-  //  1. you misspelled the class name, member name, or member signature
+  //  1. you mispelled the class name, member name, or member signature
   //  2. the class containing the specified member didn't get compiled
   //
 
@@ -239,7 +240,6 @@
                "exceptionRegisters",
                org.jikesrvm.ArchitectureSpecific.Registers.class);
   public static final NormalMethod returnBarrierMethod = getMethod(org.jikesrvm.scheduler.RVMThread.class, "returnBarrier", "()V");
-
   public static final RVMField tracePrevAddressField =
       getField(org.jikesrvm.objectmodel.MiscHeader.class, "prevAddress", org.vmmagic.unboxed.Word.class);
   public static final RVMField traceOIDField =
@@ -250,6 +250,10 @@
   public static final RVMField lockThreadField =
       getField(org.jikesrvm.mm.mmtk.Lock.class, "thread", org.jikesrvm.scheduler.RVMThread.class);
   */
+  
+  public static final RVMField wsFinishCountField = getField(org.jikesrvm.scheduler.WS.FinishInfo.class, "count", int.class);
+  public static final RVMField wsFinishDataField = getField(org.jikesrvm.scheduler.WS.FinishInfo.class, "data", org.jikesrvm.scheduler.WS.FinishData.class);
+  
   public static final RVMField lockStateField = getField(org.jikesrvm.mm.mmtk.Lock.class, "state", int.class);
   public static final RVMField gcStatusField = getField(org.mmtk.plan.Plan.class, "gcStatus", int.class);
   public static final RVMField SQCFField = getField(org.mmtk.utility.deque.SharedDeque.class, "completionFlag", int.class);
@@ -373,6 +377,11 @@
   public static final NormalMethod modifyCheckMethod =
       getMethod(org.jikesrvm.mm.mminterface.MemoryManager.class, "modifyCheck", "(Ljava/lang/Object;)V");
 
+  public static final MemberReference workStealingJoinMethod =
+    getMethod(org.jikesrvm.scheduler.WS.class, "join", "()V").getMemberRef();
+  public static final MemberReference workStealingFinishMethod =
+    getMethod(org.jikesrvm.scheduler.WS.class, "finish", "()V").getMemberRef();
+
   // used in boot image writer
   public static final RVMField debugRequestedField =
       getField(org.jikesrvm.scheduler.RVMThread.class, "debugRequested", boolean.class);
diff -r ab5908222258 rvm/src/org/jikesrvm/runtime/Magic.java
--- a/rvm/src/org/jikesrvm/runtime/Magic.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/runtime/Magic.java	Fri Mar 21 09:37:25 2014 +0530
@@ -178,6 +178,11 @@
   public static Address getReturnAddress(Address fp) {
     return getReturnAddress(fp, RVMThread.getCurrentThread());
   }
+  
+  @Uninterruptible
+  public static Address getReturnAddress_debug(Address fp) {
+    return getReturnAddress_debug(fp, RVMThread.getCurrentThread());
+  }
 
   /**
    * Get return address for a frame in a specific thread
@@ -194,6 +199,17 @@
       return ip;
   }
 
+  @Uninterruptible
+  public static Address getReturnAddress_debug(Address fp, RVMThread thread) {
+    Address ip = getReturnAddressLocation(fp).loadAddress();
+    if (RVMThread.isTrampolineIP(ip)) {
+    	VM.sysWrite("<H>");
+    	return thread.getTrampolineHijackedReturnAddress();
+    }
+    else
+      return ip;
+  }
+
   /**
    * Get return address for a frame
    * @param fp its frame pointer
diff -r ab5908222258 rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java
--- a/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java	Fri Mar 21 09:37:25 2014 +0530
@@ -689,12 +689,16 @@
   @Entrypoint
   @UnpreemptibleNoWarn
   static void deliverHardwareException(int trapCode, int trapInfo) {
-    if (false) VM.sysWriteln("delivering hardware exception");
+    if (true) VM.sysWriteln("delivering hardware exception");
     RVMThread myThread = RVMThread.getCurrentThread();
-    if (false) VM.sysWriteln("we have a thread = ",Magic.objectAsAddress(myThread));
-    if (false) VM.sysWriteln("it's in state = ",myThread.getExecStatus());
+    if (true) {
+    	VM.sysWriteln("we have a thread = ",Magic.objectAsAddress(myThread));
+    	VM.sysWriteln("The thread id = ",myThread.getId());
+    }
+    if (true) VM.sysWriteln("it's in state = ",myThread.getExecStatus());
+    RVMThread.dumpWSDetailsWhileDeliveringHardwareException();
     Registers exceptionRegisters = myThread.getExceptionRegisters();
-    if (false) VM.sysWriteln("we have exception registers = ",Magic.objectAsAddress(exceptionRegisters));
+    if (true) VM.sysWriteln("we have exception registers = ",Magic.objectAsAddress(exceptionRegisters));
 
     if ((trapCode == TRAP_STACK_OVERFLOW || trapCode == TRAP_JNI_STACK) &&
         myThread.getStack().length < (STACK_SIZE_MAX >> LOG_BYTES_IN_ADDRESS) &&
@@ -1006,7 +1010,7 @@
    * @param exceptionRegisters register state corresponding to exception site
    */
   @Unpreemptible("Deliver exception trying to avoid preemption")
-  private static void deliverException(Throwable exceptionObject, Registers exceptionRegisters) {
+  public static void deliverException(Throwable exceptionObject, Registers exceptionRegisters) {
     if (VM.TraceExceptionDelivery) {
       VM.sysWriteln("RuntimeEntrypoints.deliverException() entered; just got an exception object.");
     }
@@ -1029,13 +1033,14 @@
       }
       int compiledMethodId = Magic.getCompiledMethodID(fp);
       if (compiledMethodId != INVISIBLE_METHOD_ID) {
-        CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
-        ExceptionDeliverer exceptionDeliverer = compiledMethod.getExceptionDeliverer();
-        Address ip = exceptionRegisters.getInnermostInstructionAddress();
-        Offset ipOffset = compiledMethod.getInstructionOffset(ip);
-        int catchBlockOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, exceptionType);
+      CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+      ExceptionDeliverer exceptionDeliverer = compiledMethod.getExceptionDeliverer();
+      Address ip = exceptionRegisters.getInnermostInstructionAddress();
+      boolean inJoin = compiledMethod.inJoinInstructions(ip);
+   	  Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+   	  Offset catchBlockOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, exceptionType, false);
 
-        if (catchBlockOffset >= 0) {
+   	  if (catchBlockOffset.sGE(Offset.zero())) {
           // found an appropriate catch block
           if (VM.TraceExceptionDelivery) {
             VM.sysWriteln("found one; delivering.");
@@ -1045,7 +1050,7 @@
             if (RVMThread.DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("leapfrogged...");
             t.deInstallStackTrampoline();
           }
-          Address catchBlockStart = compiledMethod.getInstructionAddress(Offset.fromIntSignExtend(catchBlockOffset));
+          Address catchBlockStart = compiledMethod.getInstructionAddress(inJoin, catchBlockOffset);
           exceptionDeliverer.deliverException(compiledMethod, catchBlockStart, exceptionObject, exceptionRegisters);
           if (VM.VerifyAssertions) VM._assert(NOT_REACHED);
         }
diff -r ab5908222258 rvm/src/org/jikesrvm/runtime/SysCall.java
--- a/rvm/src/org/jikesrvm/runtime/SysCall.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/runtime/SysCall.java	Fri Mar 21 09:37:25 2014 +0530
@@ -55,6 +55,23 @@
       throw new Error(e);
     }
   }
+  
+  /*
+   * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+   * From here---->
+   */
+  @SysCallTemplate
+  public abstract void wsThreadBindMaskSet(int cpuMask);
+  @SysCallTemplate
+  public abstract void sysThreadBindMaskSet();
+  @SysCallTemplate
+  public abstract void wsIniatilizeSysThreadBindMask(int cpuMask);
+  @SysCallTemplate
+  public abstract int sysGetCPU();
+  /*
+   * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+   * Till here <----
+   */
 
   // lowlevel write to console
   @SysCallTemplate
@@ -103,6 +120,26 @@
 
   @SysCallTemplate
   public abstract void sysSyncCache(Address address, int size);
+  
+  /*
+   * Interface to per thred performance events
+   */
+  @SysCallTemplate
+  public abstract int sysCheckNUMAnode(Address location);
+  @SysCallTemplate
+  public abstract int sysPerfEventInit_thread(int events);
+  @SysCallTemplate
+  public abstract int sysPerfEventCreate_thread(int id, byte[] name);
+  @SysCallTemplate
+  public abstract void sysPerfEventClose_thread(int id, int[] fds);
+  @SysCallTemplate
+  public abstract void sysPerfEventOpen_thread(int id, Word tid, int[] fds);
+  @SysCallTemplate
+  public abstract int sysPerfEventEnable_thread(int[] fds, int n);
+  @SysCallTemplate
+  public abstract void sysPerfEventDisable_thread(int[] fds, int n);
+  @SysCallTemplate
+  public abstract int sysPerfEventRead_thread(int id, int[] fds, long[] values);
 
   /*
    * Interface to performance events
diff -r ab5908222258 rvm/src/org/jikesrvm/scheduler/MainThread.java
--- a/rvm/src/org/jikesrvm/scheduler/MainThread.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/scheduler/MainThread.java	Fri Mar 21 09:37:25 2014 +0530
@@ -144,7 +144,17 @@
     launched = true;
 
     if (dbg) VM.sysWriteln("MainThread.run() starting ");
-
+    // Work-Stealing
+    if(RVMThread.autogenWSThread && !RVMThread.wsThreadsLaunched) {
+    	RVMThread.wsThreadsLaunched = true;
+    	Runnable tRun = new Runnable() {
+    		public void run() { WS.workerMain(); }
+    	};
+    	WS.register();
+    	for(int i=0; i<WS.wsProcs-1; i++) {
+    		new Thread(tRun).start();
+    	}
+    }
     // Set up application class loader
     ClassLoader cl = RVMClassLoader.getApplicationClassLoader();
     setContextClassLoader(cl);
@@ -200,5 +210,8 @@
     // invoke "main" method with argument list
     Reflection.invoke(mainMethod, null, null, new Object[]{mainArgs}, true);
     if (dbg) VM.sysWriteln("  MainThread.run(): \"main\" method completed.]");
+    if(RVMThread.autogenWSThread && WS.stats) {
+    	WS.dumpWSStatistics();
+    }
   }
 }
diff -r ab5908222258 rvm/src/org/jikesrvm/scheduler/Monitor.java
--- a/rvm/src/org/jikesrvm/scheduler/Monitor.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/scheduler/Monitor.java	Fri Mar 21 09:37:25 2014 +0530
@@ -399,7 +399,7 @@
   }
   /**
    * Send a broadcast after first acquiring the lock.  Release the lock
-   * after sending the broadcast.  In most cases where you want to send
+   * after sending the broadacst.  In most cases where you want to send
    * a broadcast but you don't need to acquire the lock to set the
    * condition that the other thread(s) are waiting on, you want to call
    * this method instead of <code>broadcast</code>.
@@ -433,10 +433,14 @@
                                        Monitor m2,Word priority2) {
     if (priority1.LE(priority2)) {
       m1.lockWithHandshake();
+      //VM.sysWriteln("Thread ", RVMThread.getCurrentThreadSlot(), " has ", priority1.toInt());
       m2.lockWithHandshake();
+      //VM.sysWriteln("Thread ", RVMThread.getCurrentThreadSlot(), " has ", priority2.toInt());
     } else {
       m2.lockWithHandshake();
+      //VM.sysWriteln("Thread ", RVMThread.getCurrentThreadSlot(), " has ", priority2.toInt());
       m1.lockWithHandshake();
+      //VM.sysWriteln("Thread ", RVMThread.getCurrentThreadSlot(), " has ", priority1.toInt());
     }
   }
 }
diff -r ab5908222258 rvm/src/org/jikesrvm/scheduler/RVMThread.java
--- a/rvm/src/org/jikesrvm/scheduler/RVMThread.java	Fri Mar 21 09:33:02 2014 +0530
+++ b/rvm/src/org/jikesrvm/scheduler/RVMThread.java	Fri Mar 21 09:37:25 2014 +0530
@@ -14,21 +14,34 @@
 
 import java.security.AccessController;
 import java.security.PrivilegedAction;
-
+import java.util.Random;
+
+import org.jikesrvm.ArchitectureSpecific.ArchConstants;
+import org.jikesrvm.ArchitectureSpecific.BaselineConstants;
 import org.jikesrvm.ArchitectureSpecific.CodeArray;
 import org.jikesrvm.ArchitectureSpecific.Registers;
 import org.jikesrvm.ArchitectureSpecificOpt.PostThreadSwitch;
+
 import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACK_SIZE_NORMAL;
 import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
 import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
 import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACK_SIZE_GUARD;
 import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_METHOD_ID_OFFSET;
 import static org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_RETURN_ADDRESS_OFFSET;
-import org.jikesrvm.ArchitectureSpecific.BaselineConstants;
+
+
+
+
+/* was in other
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_METHOD_ID_OFFSET;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_RETURN_ADDRESS_OFFSET;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACK_SIZE_GUARD;
+*/
 import org.jikesrvm.ArchitectureSpecific.ThreadLocalState;
 import org.jikesrvm.ArchitectureSpecific.StackframeLayoutConstants;
 import org.jikesrvm.ArchitectureSpecific;
-import org.jikesrvm.Constants;
 import org.jikesrvm.VM;
 import org.jikesrvm.Configuration;
 import org.jikesrvm.Services;
@@ -46,6 +59,7 @@
 import org.jikesrvm.objectmodel.ObjectModel;
 import org.jikesrvm.objectmodel.ThinLockConstants;
 import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.ExceptionDeliverer;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.runtime.Memory;
 import org.jikesrvm.runtime.RuntimeEntrypoints;
@@ -66,16 +80,24 @@
 import org.vmmagic.pragma.Untraced;
 import org.vmmagic.pragma.NoCheckStore;
 import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.AddressArray;
 import org.vmmagic.unboxed.Word;
 import org.vmmagic.unboxed.Offset;
-
+import org.jikesrvm.Constants;
+
+import static org.jikesrvm.ia32.StackframeLayoutConstants.INVISIBLE_METHOD_ID;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_RETURN_ADDRESS_OFFSET;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+import static org.jikesrvm.ia32.StackframeLayoutConstants.STACK_SIZE_GUARD;
 import static org.jikesrvm.runtime.SysCall.sysCall;
+
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.compilers.opt.runtimesupport.OptCompiledMethod;
 import org.jikesrvm.compilers.opt.runtimesupport.OptMachineCodeMap;
 import org.jikesrvm.compilers.opt.runtimesupport.OptEncodedCallSiteTree;
 import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.RVMType;
 import org.jikesrvm.tuningfork.TraceEngine;
 import org.jikesrvm.tuningfork.Feedlet;
 
@@ -153,576 +175,555 @@
 @Uninterruptible
 @NonMoving
 public final class RVMThread extends ThreadContext implements Constants {
-  /*
-   * debug and statistics
-   */
-  /** Trace thread blockage */
-  protected static final boolean traceBlock = false;
-
-  /** Trace when a thread is really blocked */
-  protected static final boolean traceReallyBlock = false || traceBlock;
-
-  protected static final boolean traceAboutToTerminate = false;
-
-  protected static final boolean dumpStackOnBlock = false; // DANGEROUS! can lead to crashes!
-
-  protected static final boolean traceBind = false;
-
-  /** Trace thread start/stop */
-  protected static final boolean traceAcct = false;
-
-  /** Trace execution */
-  protected static final boolean trace = false;
-
-  /** Trace thread termination */
-  private static final boolean traceTermination = false;
-
-  /** Trace adjustments to stack size */
-  private static final boolean traceAdjustments = false;
-
-  /** Never kill threads.  Useful for testing bugs related to interaction of
+	/*
+	 * debug and statistics
+	 */
+	/** Trace thread blockage */
+	protected static final boolean traceBlock = false;
+
+	/** Trace when a thread is really blocked */
+	protected static final boolean traceReallyBlock = false || traceBlock;
+
+	protected static final boolean traceAboutToTerminate = false;
+
+	protected static final boolean dumpStackOnBlock = false; // DANGEROUS! can lead to crashes!
+
+	protected static final boolean traceBind = false;
+
+	/** Trace thread start/stop */
+	protected static final boolean traceAcct = false;
+
+	/** Trace execution */
+	protected static final boolean trace = false;
+
+	/** Trace thread termination */
+	private static final boolean traceTermination = false;
+
+	/** Trace adjustments to stack size */
+	private static final boolean traceAdjustments = false;
+
+	/** Never kill threads.  Useful for testing bugs related to interaction of
       thread death with for example MMTk.  For production, this should never
       be set to true. */
-  private static final boolean neverKillThreads = false;
-
-  /** Generate statistics? */
-  private static final boolean STATS = Lock.STATS;
-
-  /** Number of wait operations */
-  static int waitOperations;
-
-  /** Number of timed wait operations */
-  static int timedWaitOperations;
-
-  /** Number of notify operations */
-  static int notifyOperations;
-
-  /** Number of notifyAll operations */
-  static int notifyAllOperations;
-
-  public static final boolean ALWAYS_LOCK_ON_STATE_TRANSITION = false;
-
-  /*
-   * definitions for thread status for interaction of Java-native transitions
-   * and requests for threads to stop.  THESE ARE PRIVATE TO THE SCHEDULER, and
-   * are only used deep within the stack.
-   */
-  /**
-   * Thread has not yet started. This state holds right up until just before we
-   * call pthread_create().
-   */
-  public static final int NEW = 0;
-
-  /** Thread is executing "normal" Java bytecode */
-  public static final int IN_JAVA = 1;
-
-  /**
-   * A state used by the scheduler to mark that a thread is in privileged code
-   * that does not need to synchronize with the collector.  This is a special
-   * state, similar to the IN_JNI state but requiring different interaction with
-   * the collector (as there is no JNI stack frame, the registers have to be
-   * saved in contextRegisters).  As well, this state should only be entered
-   * from privileged code in the org.jikesrvm.scheduler package.  Typically,
-   * this state is entered using a call to enterNative() just prior to idling
-   * the thread; though it would not be wrong to enter it prior to any other
-   * long-running activity that does not require interaction with the GC.
-   */
-  public static final int IN_NATIVE = 2;
-
-  /**
-   * Same as IN_NATIVE, except that we're executing JNI code and thus have a
-   * JNI stack frame and JNI environment, and thus the GC can load registers
-   * from there rather than using contextRegisters.
-   */
-  public static final int IN_JNI = 3;
-
-  /**
-   * thread is in Java code but is expected to block. the transition from IN_JAVA
-   * to IN_jAVA_TO_BLOCK happens as a result of an asynchronous call by the GC
-   * or any other internal VM code that requires this thread to perform an
-   * asynchronous activity (another example is the request to do an isync on PPC).
-   * the point is that we're waiting for the thread to reach a safe point and
-   * expect this to happen in bounded time; but if the thread were to escape to
-   * native we want to know about it. thus, transitions into native code while
-   * in the IN_JAVA_TO_BLOCK state result in a notification (broadcast on the
-   * thread's monitor) and a state change to BLOCKED_IN_NATIVE. Observe that it
-   * is always safe to conservatively change IN_JAVA to IN_JAVA_TO_BLOCK.
-   */
-  public static final int IN_JAVA_TO_BLOCK = 4;
-
-  /**
-   * thread is in native code, and is to block before returning to Java code.
-   * the transition from IN_NATIVE to BLOCKED_IN_NATIVE happens as a result
-   * of an asynchronous call by the GC or any other internal VM code that
-   * requires this thread to perform an asynchronous activity (another example
-   * is the request to do an isync on PPC).  as well, code entering privileged
-   * code that would otherwise go from IN_JAVA to IN_NATIVE will go to
-   * BLOCKED_IN_NATIVE instead, if the state was IN_JAVA_TO_BLOCK.
-   * <p>
-   * the point of this state is that the thread is guaranteed not to execute
-   * any Java code until:
-   * <ol>
-   * <li>The state changes to IN_NATIVE, and
-   * <li>The thread gets a broadcast on its monitor.
-   * </ol>
-   * Observe that it is always safe to conservatively change IN_NATIVE to
-   * BLOCKED_IN_NATIVE.
-   */
-  public static final int BLOCKED_IN_NATIVE = 5;
-
-  /**
-   * like BLOCKED_IN_NATIVE, but indicates that the thread is in JNI rather than
-   * VM native code.
-   */
-  public static final int BLOCKED_IN_JNI = 6;
-
-  /**
-   * Thread has died. As in, it's no longer executing any Java code and will
-   * never do so in the future. Once this is set, the GC will no longer mark any
-   * part of the thread as live; the thread's stack will be deleted. Note that
-   * this is distinct from the aboutToTerminate state.
-   */
-  public static final int TERMINATED = 7;
-
-  /** Not actually a state but just a marker. */
-  public static final int LAST_EXEC_STATUS = 8;
-
-  public static boolean notRunning(int state) {
-    return state == NEW || state == TERMINATED;
-  }
-
-  /** Registers used by return barrier trampoline */
-  private Registers trampolineRegisters = new Registers();
-
-  /** Return address of stack frame hijacked by return barrier */
-  private Address hijackedReturnAddress;
-
-  /** Callee frame pointer for stack frame hijacked by return barrier */
-  private Address hijackedReturnCalleeFp = Address.zero();
-
-  /** Caller frame pointer for stack frame hijacked by return barrier */
-  private Address hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
-
-  /** @return the callee frame pointer for the stack frame hijacked by the return barrier */
-  public Address getHijackedReturnCalleeFp() { return hijackedReturnCalleeFp; }
-
-  /** debugging flag for return barrier trampoline */
-  public static final boolean DEBUG_STACK_TRAMPOLINE = false;
-
-  /** pointer to bridge code for return barrier trampoline */
-  public static ArchitectureSpecific.CodeArray stackTrampolineBridgeInstructions;
-
-  /**
-   * Thread state. Indicates if the thread is running, and if so, what mode of
-   * execution it is using (Java, VM native, or JNI)
-   */
-  @Entrypoint
-  private int execStatus;
-
-  public int getExecStatus() {
-    observeExecStatus();
-    return execStatus;
-  }
-
-  private boolean attemptFastExecStatusTransition(int oldState,
-                                                  int newState) {
-    if (Synchronization.tryCompareAndSwap(
-          this,
-          Entrypoints.execStatusField.getOffset(),
-          oldState,
-          newState)) {
-      observeStateTransition(oldState,newState);
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  // call this only when holding the lock or if you really know what you're
-  // doing.
-  private void setExecStatus(int newState) {
-    observeStateTransition(execStatus,newState);
-    execStatus=newState;
-  }
-
-  /**
-   * Is the thread about to terminate? Protected by the thread's monitor. Note
-   * that this field is not set atomically with the entering of the thread onto
-   * the aboutToTerminate array - in fact it happens before that. When this
-   * field is set to true, the thread's stack will no longer be scanned by GC.
-   * Note that this is distinct from the TERMINATED state.
-   */
-  // FIXME: there should be an execStatus state called TERMINATING that
-  // corresponds to this. that would make a lot more sense.
-  private boolean isAboutToTerminate;
-
-  public boolean getIsAboutToTerminate() { return isAboutToTerminate; }
-
-  /** Is this thread in the process of blocking? */
-  boolean isBlocking;
-
-  /**
-   * Is the thread no longer executing user code? Protected by the Java monitor
-   * associated with the Thread object.
-   */
-  boolean isJoinable;
-
-  /**
-   * Link pointer for queues (specifically ThreadQueue). A thread can only be
-   * on one such queue at a time. The queue that a thread is on is indicated by
-   * <code>queuedOn</code>.
-   */
-  @Untraced
-  RVMThread next;
-
-  /**
-   * The queue that the thread is on, or null if the thread is not on a queue
-   * (specifically ThreadQueue). If the thread is on such a queue, the
-   * <code>next</code> field is used as a link pointer.
-   */
-  @Untraced
-  volatile ThreadQueue queuedOn;
-
-  /**
-   * @return True if this thread is currently on a queue.
-   */
-  public boolean isOnQueue() {
-    return queuedOn != null;
-  }
-
-  /**
-   * Used to handle contention for spin locks
-   */
-  @Untraced
-  SpinLock awaitingSpinLock;
-
-  @Untraced
-  RVMThread contenderLink;
-
-  /**
-   * java.lang.Thread wrapper for this Thread. Not final so it may be assigned
-   * during booting
-   */
-  private Thread thread;
-
-  /** Name of the thread (can be changed during execution) */
-  private String name;
-
-  /**
-   * The virtual machine terminates when the last non-daemon (user) thread
-   * terminates.
-   */
-  protected boolean daemon;
-
-  /**
-   * Scheduling priority for this thread. Note that:
-   * {@link java.lang.Thread#MIN_PRIORITY} <= priority <=
-   * {@link java.lang.Thread#MAX_PRIORITY}.
-   */
-  private int priority;
-
-  /**
-   * Index of this thread in {@link #threadBySlot}[]. This value must be non-zero
-   * because it is shifted and used in {@link Object} lock ownership tests.
-   */
-  @Entrypoint
-  public int threadSlot;
-
-  public int lockingId;
-
-  /**
-   * Non-null indicates this is a system thread, that is one used by the system and as such
-   * doesn't have a Runnable...
-   */
-  private final SystemThread systemThread;
-
-  /**
-   * The boot thread, can't be final so as to allow initialization during boot
-   * image writing.
-   */
-  @Entrypoint
-  public static RVMThread bootThread;
-
-  /**
-   * Is the threading system initialized?
-   */
-  public static boolean threadingInitialized = false;
-
-  /**
-   * Number of timer ticks we've seen
-   */
-  public static long timerTicks;
-
-  private long yieldpointsTaken;
-
-  private long yieldpointsTakenFully;
-
-  private long nativeEnteredBlocked;
-
-  private long jniEnteredBlocked;
-
-  /**
-   * Assertion checking while manipulating raw addresses -- see
-   * {@link VM#disableGC()}/{@link VM#enableGC()}. A value of "true" means
-   * it's an error for this thread to call "new". This is only used for
-   * assertion checking; we do not bother to set it when
-   * {@link VM#VerifyAssertions} is false.
-   */
-  private boolean disallowAllocationsByThisThread;
-
-  /**
-   * Counts the depth of outstanding calls to {@link VM#disableGC()}. If this
-   * is set, then we should also have {@link #disallowAllocationsByThisThread}
-   * set. The converse also holds.
-   */
-  private int disableGCDepth = 0;
-
-  public int barriersEntered = 0;
-
-  public int barriersExited = 0;
-
-  /**
-   * Execution stack for this thread.
-   */
-  @Entrypoint
-  private byte[] stack;
-
-  /** The {@link Address} of the guard area for {@link #stack}. */
-  @Entrypoint
-  public Address stackLimit;
-
-  /* --------- BEGIN IA-specific fields. NOTE: NEED TO REFACTOR --------- */
-  // On powerpc, these values are in dedicated registers,
-  // we don't have registers to burn on IA32, so we indirect
-  // through the TR register to get them instead.
-  /**
-   * FP for current frame, saved in the prologue of every method
-   */
-  Address framePointer;
-
-  /**
-   * "hidden parameter" for interface invocation thru the IMT
-   */
-  int hiddenSignatureId;
-
-  /**
-   * "hidden parameter" from ArrayIndexOutOfBounds trap to C trap handler
-   */
-  int arrayIndexTrapParam;
-
-  /* --------- END IA-specific fields. NOTE: NEED TO REFACTOR --------- */
-
-  /**
-   * Is the next taken yieldpoint in response to a request to perform OSR?
-   */
-  public boolean yieldToOSRRequested;
-
-  /**
-   * Is CBS enabled for 'call' yieldpoints?
-   */
-  public boolean yieldForCBSCall;
-
-  /**
-   * Is CBS enabled for 'method' yieldpoints?
-   */
-  public boolean yieldForCBSMethod;
-
-  /**
-   * Number of CBS samples to take in this window
-   */
-  public int numCBSCallSamples;
-
-  /**
-   * Number of call yieldpoints between CBS samples
-   */
-  public int countdownCBSCall;
-
-  /**
-   * round robin starting point for CBS samples
-   */
-  public int firstCBSCallSample;
-
-  /**
-   * Number of CBS samples to take in this window
-   */
-  public int numCBSMethodSamples;
-
-  /**
-   * Number of counter ticks between CBS samples
-   */
-  public int countdownCBSMethod;
-
-  /**
-   * round robin starting point for CBS samples
-   */
-  public int firstCBSMethodSample;
-
-  /* --------- BEGIN PPC-specific fields. NOTE: NEED TO REFACTOR --------- */
-  /**
-   * flag indicating this processor needs to execute a memory synchronization
-   * sequence Used for code patching on SMP PowerPCs.
-   */
-  public boolean codePatchSyncRequested;
-
-  /* --------- END PPC-specific fields. NOTE: NEED TO REFACTOR --------- */
-
-  /**
-   * For builds using counter-based sampling. This field holds a
-   * processor-specific counter so that it can be updated efficiently on SMP's.
-   */
-  public int thread_cbs_counter;
-
-  /**
-   * Should this thread yield at yieldpoints? A value of: 1 means "yes"
-   * (yieldpoints enabled) <= 0 means "no" (yieldpoints disabled)
-   */
-  private int yieldpointsEnabledCount;
-
-  /**
-   * Is a takeYieldpoint request pending on this thread?
-   */
-  boolean yieldpointRequestPending;
-
-  /**
-   * Are we at a yieldpoint right now?
-   */
-  boolean atYieldpoint;
-
-  /**
-   * Is there a flush request for this thread? This is handled via a soft
-   * handshake.
-   */
-  public boolean flushRequested;
-
-  /**
-   * Is a soft handshake requested? Logically, this field is protected by the
-   * thread's monitor - but it is typically only mucked with when both the
-   * thread's monitor and the softHandshakeDataLock are held.
-   */
-  public boolean softHandshakeRequested;
-
-  /**
-   * How many threads have not yet reached the soft handshake? (protected by
-   * softHandshakeDataLock)
-   */
-  public static int softHandshakeLeft;
-
-  /**
-   * Lock that protects soft handshake fields.
-   */
-  public static Monitor softHandshakeDataLock;
-
-  /**
-   * Lock that prevents multiple (soft or hard) handshakes from proceeding
-   * concurrently.
-   */
-  public static Monitor handshakeLock;
-
-  /**
-   * Place to save register state when this thread is not actually running.
-   */
-  @Entrypoint
-  @Untraced
-  public final Registers contextRegisters;
-  @SuppressWarnings("unused")
-  private final Registers contextRegistersShadow;
-
-  /**
-   * Place to save register state when this thread is not actually running.
-   */
-  @Entrypoint
-  @Untraced
-  public final Registers contextRegistersSave;
-  @SuppressWarnings("unused")
-  private final Registers contextRegistersSaveShadow;
-
-  /**
-   * Place to save register state during hardware(C signal trap handler) or
-   * software (RuntimeEntrypoints.athrow) trap handling.
-   */
-  @Entrypoint
-  @Untraced
-  private final Registers exceptionRegisters;
-  @SuppressWarnings("unused")
-  private final Registers exceptionRegistersShadow;
-
-  /** Count of recursive uncaught exceptions, we need to bail out at some point */
-  private int uncaughtExceptionCount = 0;
-
-  /**
-   * A cached free lock. Not a free list; this will only ever contain 0 or 1
-   * locks!
-   */
-  public Lock cachedFreeLock;
-
-  /*
-   * Wait/notify fields
-   */
-
-  /**
-   * Place to save/restore this thread's monitor state during
-   * {@link Object#wait} and {@link Object#notify}.
-   */
-  protected Object waitObject;
-
-  /** Lock recursion count for this thread's monitor. */
-  protected int waitCount;
-
-  /**
-   * Should the thread suspend?
-   */
-  boolean shouldSuspend;
-
-  /**
-   * An integer token identifying the last suspend request
-   */
-  int shouldSuspendToken;
-
-  /**
-   * Is the thread suspended?
-   */
-  boolean isSuspended;
-
-  /**
-   * Should the thread block for handshake?
-   */
-  boolean shouldBlockForHandshake;
-
-  /**
-   * Is the thread blocked for handshake?
-   */
-  boolean isBlockedForHandshake;
-
-  /**
-   * Should the thread block for a thread-to-thread communication?
-   */
-  boolean shouldBlockForGC;
-
-  /**
-   * Is the thread blocked for thread-to-thread communication?
-   */
-  boolean isBlockedForGC;
-
-  /**
-   * A block adapter specifies the reason for blocking or unblocking a thread.  A thread
-   * remains blocked so long as any of the block adapters say that it should be blocked.
-   * Block adapters are statically allocated, and store their state in instance fields of
-   * RVMThread.
-   */
-  @Uninterruptible
-  @NonMoving
-  public abstract static class BlockAdapter {
-    /** Should the given thread be blocked for this block adapter?  If this returns true,
+	private static final boolean neverKillThreads = false;
+
+	/** Generate statistics? */
+	private static final boolean STATS = Lock.STATS;
+
+	/** Number of wait operations */
+	static int waitOperations;
+
+	/** Number of timed wait operations */
+	static int timedWaitOperations;
+
+	/** Number of notify operations */
+	static int notifyOperations;
+
+	/** Number of notifyAll operations */
+	static int notifyAllOperations;
+
+	public static final boolean ALWAYS_LOCK_ON_STATE_TRANSITION = false;
+
+	/*
+	 * definitions for thread status for interaction of Java-native transitions
+	 * and requests for threads to stop.  THESE ARE PRIVATE TO THE SCHEDULER, and
+	 * are only used deep within the stack.
+	 */
+	/**
+	 * Thread has not yet started. This state holds right up until just before we
+	 * call pthread_create().
+	 */
+	public static final int NEW = 0;
+
+	/** Thread is executing "normal" Java bytecode */
+	public static final int IN_JAVA = 1;
+
+	/**
+	 * A state used by the scheduler to mark that a thread is in privileged code
+	 * that does not need to synchronize with the collector.  This is a special
+	 * state, similar to the IN_JNI state but requiring different interaction with
+	 * the collector (as there is no JNI stack frame, the registers have to be
+	 * saved in contextRegisters).  As well, this state should only be entered
+	 * from privileged code in the org.jikesrvm.scheduler package.  Typically,
+	 * this state is entered using a call to enterNative() just prior to idling
+	 * the thread; though it would not be wrong to enter it prior to any other
+	 * long-running activity that does not require interaction with the GC.
+	 */
+	public static final int IN_NATIVE = 2;
+
+	/**
+	 * Same as IN_NATIVE, except that we're executing JNI code and thus have a
+	 * JNI stack frame and JNI environment, and thus the GC can load registers
+	 * from there rather than using contextRegisters.
+	 */
+	public static final int IN_JNI = 3;
+
+	/**
+	 * thread is in Java code but is expected to block. the transition from IN_JAVA
+	 * to IN_jAVA_TO_BLOCK happens as a result of an asynchronous call by the GC
+	 * or any other internal VM code that requires this thread to perform an
+	 * asynchronous activity (another example is the request to do an isync on PPC).
+	 * the point is that we're waiting for the thread to reach a safe point and
+	 * expect this to happen in bounded time; but if the thread were to escape to
+	 * native we want to know about it. thus, transitions into native code while
+	 * in the IN_JAVA_TO_BLOCK state result in a notification (broadcast on the
+	 * thread's monitor) and a state change to BLOCKED_IN_NATIVE. Observe that it
+	 * is always safe to conservatively change IN_JAVA to IN_JAVA_TO_BLOCK.
+	 */
+	public static final int IN_JAVA_TO_BLOCK = 4;
+
+	/**
+	 * thread is in native code, and is to block before returning to Java code.
+	 * the transition from IN_NATIVE to BLOCKED_IN_NATIVE happens as a result
+	 * of an asynchronous call by the GC or any other internal VM code that
+	 * requires this thread to perform an asynchronous activity (another example
+	 * is the request to do an isync on PPC).  as well, code entering privileged
+	 * code that would otherwise go from IN_JAVA to IN_NATIVE will go to
+	 * BLOCKED_IN_NATIVE instead, if the state was IN_JAVA_TO_BLOCK.
+	 * <p>
+	 * the point of this state is that the thread is guaranteed not to execute
+	 * any Java code until:
+	 * <ol>
+	 * <li>The state changes to IN_NATIVE, and
+	 * <li>The thread gets a broadcast on its monitor.
+	 * </ol>
+	 * Observe that it is always safe to conservatively change IN_NATIVE to
+	 * BLOCKED_IN_NATIVE.
+	 */
+	public static final int BLOCKED_IN_NATIVE = 5;
+
+	/**
+	 * like BLOCKED_IN_NATIVE, but indicates that the thread is in JNI rather than
+	 * VM native code.
+	 */
+	public static final int BLOCKED_IN_JNI = 6;
+
+	/**
+	 * Thread has died. As in, it's no longer executing any Java code and will
+	 * never do so in the future. Once this is set, the GC will no longer mark any
+	 * part of the thread as live; the thread's stack will be deleted. Note that
+	 * this is distinct from the aboutToTerminate state.
+	 */
+	public static final int TERMINATED = 7;
+
+	/** Not actually a state but just a marker. */
+	public static final int LAST_EXEC_STATUS = 8;
+
+	public static boolean notRunning(int state) {
+		return state == NEW || state == TERMINATED;
+	}
+
+	/**
+	 * Thread state. Indicates if the thread is running, and if so, what mode of
+	 * execution it is using (Java, VM native, or JNI)
+	 */
+	@Entrypoint
+	private int execStatus;
+
+	public int getExecStatus() {
+		observeExecStatus();
+		return execStatus;
+	}
+
+	private boolean attemptFastExecStatusTransition(int oldState,
+			int newState) {
+		if (Synchronization.tryCompareAndSwap(
+				this,
+				Entrypoints.execStatusField.getOffset(),
+				oldState,
+				newState)) {
+			observeStateTransition(oldState,newState);
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	// call this only when holding the lock or if you really know what you're
+	// doing.
+	private void setExecStatus(int newState) {
+		observeStateTransition(execStatus,newState);
+		execStatus=newState;
+	}
+
+	/**
+	 * Is the thread about to terminate? Protected by the thread's monitor. Note
+	 * that this field is not set atomically with the entering of the thread onto
+	 * the aboutToTerminate array - in fact it happens before that. When this
+	 * field is set to true, the thread's stack will no longer be scanned by GC.
+	 * Note that this is distinct from the TERMINATED state.
+	 */
+	// FIXME: there should be an execStatus state called TERMINATING that
+	// corresponds to this. that would make a lot more sense.
+	private boolean isAboutToTerminate;
+
+	public boolean getIsAboutToTerminate() { return isAboutToTerminate; }
+
+	/** Is this thread in the process of blocking? */
+	boolean isBlocking;
+
+	/**
+	 * Is the thread no longer executing user code? Protected by the Java monitor
+	 * associated with the Thread object.
+	 */
+	boolean isJoinable;
+
+	/**
+	 * Link pointer for queues (specifically ThreadQueue). A thread can only be
+	 * on one such queue at a time. The queue that a thread is on is indicated by
+	 * <code>queuedOn</code>.
+	 */
+	@Untraced
+	RVMThread next;
+
+	/**
+	 * The queue that the thread is on, or null if the thread is not on a queue
+	 * (specifically ThreadQueue). If the thread is on such a queue, the
+	 * <code>next</code> field is used as a link pointer.
+	 */
+	@Untraced
+	volatile ThreadQueue queuedOn;
+
+	/**
+	 * @return True if this thread is currently on a queue.
+	 */
+	public boolean isOnQueue() {
+		return queuedOn != null;
+	}
+
+	/**
+	 * Used to handle contention for spin locks
+	 */
+	@Untraced
+	SpinLock awaitingSpinLock;
+
+	@Untraced
+	RVMThread contenderLink;
+
+	/**
+	 * java.lang.Thread wrapper for this Thread. Not final so it may be assigned
+	 * during booting
+	 */
+	private Thread thread;
+
+	/** Name of the thread (can be changed during execution) */
+	private String name;
+
+	/**
+	 * The virtual machine terminates when the last non-daemon (user) thread
+	 * terminates.
+	 */
+	protected boolean daemon;
+
+	/**
+	 * Scheduling priority for this thread. Note that:
+	 * {@link java.lang.Thread#MIN_PRIORITY} <= priority <=
+	 * {@link java.lang.Thread#MAX_PRIORITY}.
+	 */
+	private int priority;
+
+	/**
+	 * Index of this thread in {@link #threadBySlot}[]. This value must be non-zero
+	 * because it is shifted and used in {@link Object} lock ownership tests.
+	 */
+	@Entrypoint
+	public int threadSlot;
+
+	public int lockingId;
+
+	/**
+	 * Non-null indicates this is a system thread, that is one used by the system and as such
+	 * doesn't have a Runnable...
+	 */
+	private final SystemThread systemThread;
+
+	/**
+	 * The boot thread, can't be final so as to allow initialization during boot
+	 * image writing.
+	 */
+	@Entrypoint
+	public static RVMThread bootThread;
+
+	/**
+	 * Is the threading system initialized?
+	 */
+	public static boolean threadingInitialized = false;
+
+	/**
+	 * Number of timer ticks we've seen
+	 */
+	public static long timerTicks;
+
+	protected long yieldpointsTaken;
+
+	private long yieldpointsTakenFully;
+
+	private long nativeEnteredBlocked;
+
+	private long jniEnteredBlocked;
+
+	/**
+	 * Assertion checking while manipulating raw addresses -- see
+	 * {@link VM#disableGC()}/{@link VM#enableGC()}. A value of "true" means
+	 * it's an error for this thread to call "new". This is only used for
+	 * assertion checking; we do not bother to set it when
+	 * {@link VM#VerifyAssertions} is false.
+	 */
+	private boolean disallowAllocationsByThisThread;
+
+	/**
+	 * Counts the depth of outstanding calls to {@link VM#disableGC()}. If this
+	 * is set, then we should also have {@link #disallowAllocationsByThisThread}
+	 * set. The converse also holds.
+	 */
+	private int disableGCDepth = 0;
+
+	public int barriersEntered = 0;
+
+	public int barriersExited = 0;
+
+	/**
+	 * Execution stack for this thread.
+	 */
+	@Entrypoint
+	private byte[] stack;
+
+	/** The {@link Address} of the guard area for {@link #stack}. */
+	@Entrypoint
+	public Address stackLimit;
+
+	/* --------- BEGIN IA-specific fields. NOTE: NEED TO REFACTOR --------- */
+	// On powerpc, these values are in dedicated registers,
+	// we don't have registers to burn on IA32, so we indirect
+	// through the TR register to get them instead.
+	/**
+	 * FP for current frame, saved in the prologue of every method
+	 */
+	Address framePointer;
+
+	/**
+	 * "hidden parameter" for interface invocation thru the IMT
+	 */
+	int hiddenSignatureId;
+
+	/**
+	 * "hidden parameter" from ArrayIndexOutOfBounds trap to C trap handler
+	 */
+	int arrayIndexTrapParam;
+
+	/* --------- END IA-specific fields. NOTE: NEED TO REFACTOR --------- */
+
+	/**
+	 * Is the next taken yieldpoint in response to a request to perform OSR?
+	 */
+	public boolean yieldToOSRRequested;
+
+	/**
+	 * Is CBS enabled for 'call' yieldpoints?
+	 */
+	public boolean yieldForCBSCall;
+
+	/**
+	 * Is CBS enabled for 'method' yieldpoints?
+	 */
+	public boolean yieldForCBSMethod;
+
+	/**
+	 * Number of CBS samples to take in this window
+	 */
+	public int numCBSCallSamples;
+
+	/**
+	 * Number of call yieldpoints between CBS samples
+	 */
+	public int countdownCBSCall;
+
+	/**
+	 * round robin starting point for CBS samples
+	 */
+	public int firstCBSCallSample;
+
+	/**
+	 * Number of CBS samples to take in this window
+	 */
+	public int numCBSMethodSamples;
+
+	/**
+	 * Number of counter ticks between CBS samples
+	 */
+	public int countdownCBSMethod;
+
+	/**
+	 * round robin starting point for CBS samples
+	 */
+	public int firstCBSMethodSample;
+
+	/* --------- BEGIN PPC-specific fields. NOTE: NEED TO REFACTOR --------- */
+	/**
+	 * flag indicating this processor needs to execute a memory synchronization
+	 * sequence Used for code patching on SMP PowerPCs.
+	 */
+	public boolean codePatchSyncRequested;
+
+	/* --------- END PPC-specific fields. NOTE: NEED TO REFACTOR --------- */
+
+	/**
+	 * For builds using counter-based sampling. This field holds a
+	 * processor-specific counter so that it can be updated efficiently on SMP's.
+	 */
+	public int thread_cbs_counter;
+
+	/**
+	 * Should this thread yield at yieldpoints? A value of: 1 means "yes"
+	 * (yieldpoints enabled) <= 0 means "no" (yieldpoints disabled)
+	 */
+	private int yieldpointsEnabledCount;
+
+	/**
+	 * Is a takeYieldpoint request pending on this thread?
+	 */
+	boolean yieldpointRequestPending;
+
+	/**
+	 * Are we at a yieldpoint right now?
+	 */
+	boolean atYieldpoint;
+
+	/**
+	 * Is there a flush request for this thread? This is handled via a soft
+	 * handshake.
+	 */
+	public boolean flushRequested;
+
+	/**
+	 * Is a soft handshake requested? Logically, this field is protected by the
+	 * thread's monitor - but it is typically only mucked with when both the
+	 * thread's monitor and the softHandshakeDataLock are held.
+	 */
+	public boolean softHandshakeRequested;
+
+	/**
+	 * How many threads have not yet reached the soft handshake? (protected by
+	 * softHandshakeDataLock)
+	 */
+	public static int softHandshakeLeft;
+
+	/**
+	 * Lock that protects soft handshake fields.
+	 */
+	public static Monitor softHandshakeDataLock;
+
+	/**
+	 * Lock that prevents multiple (soft or hard) handshakes from proceeding
+	 * concurrently.
+	 */
+	public static Monitor handshakeLock;
+
+	/**
+	 * Place to save register state when this thread is not actually running.
+	 */
+	@Entrypoint
+	@Untraced
+	public final Registers contextRegisters;
+	@SuppressWarnings("unused")
+	private final Registers contextRegistersShadow;
+
+	/**
+	 * Place to save register state when this thread is not actually running.
+	 */
+	@Entrypoint
+	@Untraced
+	public final Registers contextRegistersSave;
+	@SuppressWarnings("unused")
+	private final Registers contextRegistersSaveShadow;
+
+	/**
+	 * Place to save register state during hardware(C signal trap handler) or
+	 * software (RuntimeEntrypoints.athrow) trap handling.
+	 */
+	@Entrypoint
+	@Untraced
+	private final Registers exceptionRegisters;
+	@SuppressWarnings("unused")
+	private final Registers exceptionRegistersShadow;
+
+	/** Count of recursive uncaught exceptions, we need to bail out at some point */
+	private int uncaughtExceptionCount = 0;
+
+	/**
+	 * A cached free lock. Not a free list; this will only ever contain 0 or 1
+	 * locks!
+	 */
+	public Lock cachedFreeLock;
+
+	/*
+	 * Wait/notify fields
+	 */
+
+	/**
+	 * Place to save/restore this thread's monitor state during
+	 * {@link Object#wait} and {@link Object#notify}.
+	 */
+	protected Object waitObject;
+
+	/** Lock recursion count for this thread's monitor. */
+	protected int waitCount;
+
+	/**
+	 * Should the thread suspend?
+	 */
+	boolean shouldSuspend;
+
+	/**
+	 * An integer token identifying the last suspend request
+	 */
+	int shouldSuspendToken;
+
+	/**
+	 * Is the thread suspended?
+	 */
+	boolean isSuspended;
+
+	/**
+	 * Should the thread block for handshake?
+	 */
+	boolean shouldBlockForHandshake;
+
+	/**
+	 * Is the thread blocked for handshake?
+	 */
+	boolean isBlockedForHandshake;
+
+	/**
+	 * Should the thread block for a thread-to-thread communication?
+	 */
+	boolean shouldBlockForGC;
+
+	/**
+	 * Is the thread blocked for thread-to-thread communication?
+	 */
+	boolean isBlockedForGC;
+
+	/**
+	 * A block adapter specifies the reason for blocking or unblocking a thread.  A thread
+	 * remains blocked so long as any of the block adapters say that it should be blocked.
+	 * Block adapters are statically allocated, and store their state in instance fields of
+	 * RVMThread.
+	 */
+	@Uninterruptible
+	@NonMoving
+	public abstract static class BlockAdapter {
+		/** Should the given thread be blocked for this block adapter?  If this returns true,
         the thread is guaranteed to block. */
-    abstract boolean isBlocked(RVMThread t);
-
-    /** Specify that the thread is either blocked (value == true) or not blocked
+		abstract boolean isBlocked(RVMThread t);
+
+		/** Specify that the thread is either blocked (value == true) or not blocked
         (value == false) for this block adapter.  This call indicates a statement of
         fact by the thread itself - it's used either to acknowledge a block request
         (see hasBlockRequest below) or to respond to a request to unblock. */
-    abstract void setBlocked(RVMThread t, boolean value);
-
-    /** Request that the thread block, for this block adapter, at its earliest
+		abstract void setBlocked(RVMThread t, boolean value);
+
+		/** Request that the thread block, for this block adapter, at its earliest
         convenience.  Called from RVMThread.block() and associated methods.  Some
         block adapters allow for multiple requests to block; in that case this will
         return a "token" that can be passed to hasBlockRequest() to check, not only
@@ -731,4682 +732,6609 @@
         a suspend() call from stalling due to a concurrent resume() and second
         suspend().  Note that most block adapers don't care about this scenario, and
         will just return 0 (or some other meaningless number) here. */
-    abstract int requestBlock(RVMThread t);
-
-    /** Does the thread have a request to block for this block adapter? */
-    abstract boolean hasBlockRequest(RVMThread t);
-
-    /** Does the thread have a request to block associated with the given requestBlock()
+		abstract int requestBlock(RVMThread t);
+
+		/** Does the thread have a request to block for this block adapter? */
+		abstract boolean hasBlockRequest(RVMThread t);
+
+		/** Does the thread have a request to block associated with the given requestBlock()
         call? */
-    abstract boolean hasBlockRequest(RVMThread t, int token);
-
-    /** Clear any blocking requests. */
-    abstract void clearBlockRequest(RVMThread t);
-  }
-
-  @Uninterruptible
-  @NonMoving
-  public static class SuspendBlockAdapter extends BlockAdapter {
-    @Override
-    boolean isBlocked(RVMThread t) {
-      return t.isSuspended;
+		abstract boolean hasBlockRequest(RVMThread t, int token);
+
+		/** Clear any blocking requests. */
+		abstract void clearBlockRequest(RVMThread t);
+	}
+
+	@Uninterruptible
+	@NonMoving
+	public static class SuspendBlockAdapter extends BlockAdapter {
+		@Override
+		boolean isBlocked(RVMThread t) {
+			return t.isSuspended;
+		}
+
+		@Override
+		void setBlocked(RVMThread t, boolean value) {
+			t.isSuspended = value;
+		}
+
+		@Override
+		int requestBlock(RVMThread t) {
+			if (t.isSuspended || t.shouldSuspend) {
+				return t.shouldSuspendToken;
+			} else {
+				t.shouldSuspend = true;
+				t.shouldSuspendToken++;
+				return t.shouldSuspendToken;
+			}
+		}
+
+		@Override
+		boolean hasBlockRequest(RVMThread t) {
+			return t.shouldSuspend;
+		}
+
+		@Override
+		boolean hasBlockRequest(RVMThread t, int token) {
+			return t.shouldSuspend && t.shouldSuspendToken == token;
+		}
+
+		@Override
+		void clearBlockRequest(RVMThread t) {
+			t.shouldSuspend = false;
+		}
+	}
+
+	public static final SuspendBlockAdapter suspendBlockAdapter = new SuspendBlockAdapter();
+
+	@Uninterruptible
+	@NonMoving
+	public static class HandshakeBlockAdapter extends BlockAdapter {
+		@Override
+		boolean isBlocked(RVMThread t) {
+			return t.isBlockedForHandshake;
+		}
+
+		@Override
+		void setBlocked(RVMThread t, boolean value) {
+			t.isBlockedForHandshake = value;
+		}
+
+		@Override
+		int requestBlock(RVMThread t) {
+			if (!t.isBlockedForHandshake) {
+				t.shouldBlockForHandshake = true;
+			}
+			return 0;
+		}
+
+		@Override
+		boolean hasBlockRequest(RVMThread t) {
+			return t.shouldBlockForHandshake;
+		}
+
+		@Override
+		boolean hasBlockRequest(RVMThread t, int token) {
+			return t.shouldBlockForHandshake;
+		}
+
+		@Override
+		void clearBlockRequest(RVMThread t) {
+			t.shouldBlockForHandshake = false;
+		}
+	}
+
+	public static final HandshakeBlockAdapter handshakeBlockAdapter = new HandshakeBlockAdapter();
+
+	@Uninterruptible
+	@NonMoving
+	public static class GCBlockAdapter extends BlockAdapter {
+		@Override
+		boolean isBlocked(RVMThread t) {
+			return t.isBlockedForGC;
+		}
+
+		@Override
+		void setBlocked(RVMThread t, boolean value) {
+			t.isBlockedForGC = value;
+		}
+
+		@Override
+		int requestBlock(RVMThread t) {
+			if (!t.isBlockedForGC) {
+				t.shouldBlockForGC = true;
+			}
+			return 0;
+		}
+
+		@Override
+		boolean hasBlockRequest(RVMThread t) {
+			return t.shouldBlockForGC;
+		}
+
+		@Override
+		boolean hasBlockRequest(RVMThread t, int token) {
+			return t.shouldBlockForGC;
+		}
+
+		@Override
+		void clearBlockRequest(RVMThread t) {
+			t.shouldBlockForGC = false;
+		}
+	}
+
+	public static final GCBlockAdapter gcBlockAdapter = new GCBlockAdapter();
+
+	static final BlockAdapter[] blockAdapters = new BlockAdapter[] {
+		suspendBlockAdapter, handshakeBlockAdapter, gcBlockAdapter };
+
+	/**
+	 * An enumeration that describes the different manners in which a thread might
+	 * be voluntarily waiting.
+	 */
+	protected static enum Waiting {
+		/** The thread is not waiting at all. In fact it's running. */
+		RUNNABLE,
+		/** The thread is waiting without a timeout. */
+		WAITING,
+		/** The thread is waiting with a timeout. */
+		TIMED_WAITING
+	}
+
+	/**
+	 * Accounting of whether or not a thread is waiting (in the Java thread state
+	 * sense), and if so, how it's waiting.
+	 * <p>
+	 * Invariant: the RVM runtime does not ever use this field for any purpose
+	 * other than updating it so that the java.lang.Thread knows the state. Thus,
+	 * if you get sloppy with this field, the worst case outcome is that some Java
+	 * program that queries the thread state will get something other than what it
+	 * may or may not have expected.
+	 */
+	protected Waiting waiting;
+
+	/**
+	 * Exception to throw in this thread at the earliest possible point.
+	 */
+	Throwable asyncThrowable;
+
+	/**
+	 * Has the thread been interrupted?
+	 */
+	boolean hasInterrupt;
+
+	/**
+	 * Should the next executed yieldpoint be taken? Can be true for a variety of
+	 * reasons. See RVMThread.yieldpoint
+	 * <p>
+	 * To support efficient sampling of only prologue/epilogues we also encode
+	 * some extra information into this field. 0 means that the yieldpoint should
+	 * not be taken. >0 means that the next yieldpoint of any type should be taken
+	 * <0 means that the next prologue/epilogue yieldpoint should be taken
+	 * <p>
+	 * Note the following rules:
+	 * <ol>
+	 * <li>If takeYieldpoint is set to 0 or -1 it is perfectly safe to set it to
+	 * 1; this will have almost no effect on the system. Thus, setting
+	 * takeYieldpoint to 1 can always be done without acquiring locks.</li>
+	 * <li>Setting takeYieldpoint to any value other than 1 should be done while
+	 * holding the thread's monitor().</li>
+	 * <li>The exception to rule (2) above is that the yieldpoint itself sets
+	 * takeYieldpoint to 0 without holding a lock - but this is done after it
+	 * ensures that the yieldpoint is deferred by setting yieldpointRequestPending
+	 * to true.
+	 * </ol>
+	 */
+	@Entrypoint
+	public int takeYieldpoint;
+
+	/**
+	 * How many times has the "timeslice" expired? This is only used for profiling
+	 * and OSR (in particular base-to-opt OSR).
+	 */
+	public int timeSliceExpired;
+
+	/** Is a running thread permitted to ignore the next park request */
+	private boolean parkingPermit;
+
+	/*
+	 * JNI fields
+	 */
+
+	/**
+	 * Cached JNI environment for this thread
+	 */
+	@Entrypoint
+	@Untraced
+	private JNIEnvironment jniEnv;
+	@SuppressWarnings("unused")
+	private JNIEnvironment jniEnvShadow;
+
+	/** Used by GC to determine collection success */
+	private boolean physicalAllocationFailed;
+
+	/** Used by GC to determine collection success */
+	private int collectionAttempt;
+
+	/** The OOME to throw */
+	private static OutOfMemoryError outOfMemoryError;
+
+	/*
+	 * Enumerate different types of yield points for sampling
+	 */
+	public static final int PROLOGUE = 0;
+
+	public static final int BACKEDGE = 1;
+
+	public static final int EPILOGUE = 2;
+
+	public static final int NATIVE_PROLOGUE = 3;
+
+	public static final int NATIVE_EPILOGUE = 4;
+
+	public static final int OSROPT = 5;
+
+	/*
+	 * Fields used for on stack replacement
+	 */
+
+	/**
+	 * Only used by OSR when VM.BuildForAdaptiveSystem. Declared as an Object to
+	 * cut link to adaptive system. Ugh.
+	 */
+	public final Object /* OnStackReplacementEvent */onStackReplacementEvent;
+
+	/**
+	 * The flag indicates whether this thread is waiting for on stack replacement
+	 * before being rescheduled.
+	 */
+	// flags should be packaged or replaced by other solutions
+	public boolean isWaitingForOsr = false;
+
+	/**
+	 * Before call new instructions, we need a bridge to recover register states
+	 * from the stack frame.
+	 */
+	public CodeArray bridgeInstructions = null;
+
+	/** Foo frame pointer offset */
+	public Offset fooFPOffset = Offset.zero();
+
+	/** Thread switch frame pointer offset */
+	public Offset tsFPOffset = Offset.zero();
+
+	/**
+	 * Flag to synchronize with osr organizer, the trigger sets osr requests the
+	 * organizer clear the requests
+	 */
+	public boolean requesting_osr = false;
+
+	/**
+	 * Flag to indicate that the last OSR request is done.
+	 */
+	public boolean osr_done = false;
+
+	//per thread perf event support
+	private static boolean PER_THREAD_PERF_MONITORING = false;
+
+	protected int perfEventGroup = -1;
+	// for work-stealing threads
+	protected static final int PERF_EVENT_GROUP_WS = 3;
+	// for OSR_Organizer and Organizer threads
+	protected static final int PERF_EVENT_GROUP_ORGANIZERS = 2;
+	// for org.mmtk.plan.generational.immix.GenImmixCollector* threads
+	protected static final int PERF_EVENT_GROUP_GC = 1;
+	// for CompilationThread; TimerThread; FinalizerThread; 
+	protected static final int PERF_EVENT_GROUP_SYS = 0;
+
+	private static long[] perfEventTotals_ws;
+	private static long[] perfEventTotals_organizers;
+	private static long[] perfEventTotals_gc;
+	private static long[] perfEventTotals_sys;
+
+	public static boolean wsPerThreadPerf = false;
+	
+	/*
+	 * From Jikes 3.1.3 release, calling getBytes() on a string variable is
+	 * generating ArrayIndexOutOfBoundsException in Thread.java: getThreadLocals(): Line 1076
+	 * eg. perfEventNames[i].getBytes(). However, calling getBytes() with a string literal
+	 * is working fine, eg. "LLC_MISSES".getBytes()
+	 * 
+	 * As a temporary work-around on this bug, for adding a new perf event:
+	 * 1) add a corresponding entry inside RVMThread.perfEventNames and 
+	 * 2) also an entry inside switch-case block inside the method 
+	 * 	  RVMThread.getPerfEventByteArray(i).
+	 * 
+	 * If we have to measure the per thread perf event, we use the command line option 
+	 * -Xws:perfEvents=true. By default its always false.
+	 */
+	public static final String[] perfEventNames = {
+		// Add more Perf Events if necessary
+		"UNHALTED_CORE_CYCLES",
+		"LLC_MISSES",
+		"LLC_REFERENCES"
+		// Also add corresponding entry inside the method getPerfEventByteArray() below
+	};
+	
+	private final static byte[] getPerfEventByteArray(int id) {
+		switch(id) {
+		case 0:
+			return "UNHALTED_CORE_CYCLES".concat("\0").getBytes();
+		case 1:
+			return "LLC_MISSES".concat("\0").getBytes();
+		case 2:
+			return "LLC_REFERENCES".concat("\0").getBytes();
+		default:
+			VM.sysFail("Error in fetching perfevent byte array");
+		}
+		return null;
+	}
+
+	private int[] perfEventFds;
+	private static long[][] perfEventperThread;
+	private static int perfEventThreadNum = 0;
+	private static String[] perfEventThreadName;
+	private long[] perfEventTemp = new long[3];
+
+	/**
+	 * The number of processors to use.
+	 */
+	public static int availableProcessors = -1;
+
+	/**
+	 * Thread handle. Currently stores pthread_t, which we assume to be no larger
+	 * than a pointer-sized word.
+	 */
+	public Word thread_id;
+
+	/**
+	 * Scratch area for use for gpr <=> fpr transfers by PPC baseline compiler.
+	 * Used to transfer x87 to SSE registers on IA32
+	 */
+	@SuppressWarnings({ "unused" })
+	// accessed via EntryPoints
+	private double scratchStorage;
+
+	/**
+	 * Current index of this thread in the threads array. This may be changed by
+	 * another thread, but only while the acctLock is held.
+	 */
+	private int threadIdx;
+
+	/**
+	 * Is the system in the process of shutting down (has System.exit been called)
+	 */
+	private static boolean systemShuttingDown = false;
+
+	/**
+	 * Flag set by external signal to request debugger activation at next thread
+	 * switch. See also: RunBootImage.C
+	 */
+	public static volatile boolean debugRequested;
+
+	public volatile boolean asyncDebugRequestedForThisThread;
+
+	/**
+	 * The latch for reporting profile data.
+	 */
+	public static Latch doProfileReport;
+
+	/** Number of times dump stack has been called recursively */
+	protected int inDumpStack = 0;
+
+	/** Is this a "registered mutator?" */
+	public boolean activeMutatorContext = false;
+
+	/** Lock used for dumping stack and such. */
+	public static Monitor dumpLock;
+
+	/** In dump stack and dying */
+	protected static boolean exitInProgress = false;
+
+	private static boolean worldStopped;
+
+	/** Extra debug from traces */
+	protected static final boolean traceDetails = false;
+
+	/** Toggle display of frame pointer address in stack dump */
+	private static final boolean SHOW_FP_IN_STACK_DUMP = true;
+
+	/** Index of thread in which "VM.boot()" runs */
+	public static final int PRIMORDIAL_THREAD_INDEX = 1;
+
+	/** Maximum number of RVMThread's that we can support. */
+	public static final int LOG_MAX_THREADS = 10;
+
+	public static final int MAX_THREADS = 1 << LOG_MAX_THREADS;
+
+	/**
+	 * thread array - all threads are stored in this array according to their
+	 * threadSlot.
+	 */
+	public static RVMThread[] threadBySlot = new RVMThread[MAX_THREADS];
+
+	/**
+	 * Per-thread monitors. Note that this array is statically initialized. It
+	 * starts out all null. When a new thread slot is allocated, a monitor is
+	 * added for that slot.
+	 * <p>
+	 * Question: what is the outcome, if any, of taking a yieldpoint while holding
+	 * this lock?
+	 * <ol>
+	 * <li>If there is a GC request we will wait on this condition variable and
+	 * thus release it. Someone else might then acquire the lock before realizing
+	 * that there is a GC request and then do bad things.</li>
+	 * <li>The yieldpoint might acquire another thread's monitor. Thus, two
+	 * threads may get into lock inversion with each other.</li>
+	 * <li>???</li>
+	 * </ol>
+	 */
+	private static final NoYieldpointsMonitor[] monitorBySlot = new NoYieldpointsMonitor[MAX_THREADS];
+
+	private static final Monitor[] communicationLockBySlot = new Monitor[MAX_THREADS];
+
+	/**
+	 * Lock (mutex) used for creating and destroying threads as well as thread
+	 * accounting.  This mutex should not be held while thread monitors (see monitorBySlot)
+	 * are held.  Use this mutex only to protect accesses to:
+	 * <ul>
+	 * <li>the global thread lists, such as threadBySlot, aboutToTerminate, threads, and
+	 *     freeLots</li>
+	 * <li>threadIdx field of RVMThread</li>
+	 * <li>numThreads, numActiveThreads, numActiveDaemons static fields of RVMThread</li>
+	 * </ul>
+	 */
+	public static NoYieldpointsMonitor acctLock;
+
+	/**
+	 * Lock (mutex) used for servicing debug requests.
+	 */
+	public static NoYieldpointsMonitor debugLock;
+
+	/**
+	 * Lock used for generating debug output.
+	 */
+	private static NoYieldpointsMonitor outputLock;
+
+	/**
+	 * Thread slots of threads that are about to terminate.  This must be
+	 * an int array because it's accessed from code that cannot have
+	 * barriers.
+	 */
+	private static final int[] aboutToTerminate = new int[MAX_THREADS];
+
+	/**
+	 * Number of threads that are about to terminate.
+	 */
+	private static int aboutToTerminateN;
+
+	/**
+	 * Free thread slots
+	 */
+	private static final int[] freeSlots = new int[MAX_THREADS];
+
+	/**
+	 * Number of free thread slots.
+	 */
+	private static int freeSlotN;
+
+	/**
+	 * When there are no thread slots on the free list, this is the next one to
+	 * use.
+	 */
+	public static int nextSlot = 2;
+
+	/**
+	 * Number of threads in the system (some of which may not be active).
+	 */
+	public static int numThreads;
+
+	/**
+	 * Packed and unordered array or active threads. Only entries in the range 0
+	 * to numThreads-1 (inclusive) are defined. Note that it should be possible to
+	 * scan this array without locking and get all of the threads - but only if
+	 * you scan downward and place a memory fence between loads.
+	 * <p>
+	 * Note further that threads remain in this array even after the Java
+	 * libraries no longer consider the thread to be active.
+	 */
+	public static final RVMThread[] threads = new RVMThread[MAX_THREADS];
+
+	/**
+	 * Preallocated array for use in handshakes. Protected by handshakeLock.
+	 */
+	public static final RVMThread[] handshakeThreads = new RVMThread[MAX_THREADS];
+
+	/**
+	 * Preallocated array for use in debug requested. Protected by debugLock.
+	 */
+	public static final RVMThread[] debugThreads = new RVMThread[MAX_THREADS];
+
+	/**
+	 * Number of active threads in the system.
+	 */
+	private static int numActiveThreads;
+
+	/**
+	 * Number of active daemon threads.
+	 */
+	private static int numActiveDaemons;
+
+	/*
+	 * TuningFork instrumentation support
+	 */
+	/**
+	 * The Feedlet instance for this thread to use to make addEvent calls.
+	 */
+	public Feedlet feedlet;
+
+	/**
+	 * Get a NoYieldpointsCondLock for a given thread slot.
+	 */
+	static NoYieldpointsMonitor monitorForSlot(int slot) {
+		NoYieldpointsMonitor result = monitorBySlot[slot];
+		if (VM.VerifyAssertions)
+			VM._assert(result != null);
+		return result;
+	}
+
+	/**
+	 * Get the NoYieldpointsCondLock for this thread.
+	 */
+	public NoYieldpointsMonitor monitor() {
+		return monitorForSlot(threadSlot);
+	}
+
+	public Monitor communicationLockForSlot(int slot) {
+		Monitor result = communicationLockBySlot[slot];
+		if (VM.VerifyAssertions)
+			VM._assert(result != null);
+		return result;
+	}
+
+	@Inline
+	public Monitor wsLock() {
+		return workStealingLockBySlot[threadSlot];
+	}
+
+	public Monitor communicationLock() {
+		return communicationLockForSlot(threadSlot);
+	}
+
+	/**
+	 * Initialize the threading subsystem for the boot image.
+	 */
+	@Interruptible
+	public static void init() {
+		// Enable us to dump a Java Stack from the C trap handler to aid in
+		// debugging things that
+		// show up as recursive use of hardware exception registers (eg the
+		// long-standing lisp bug)
+		BootRecord.the_boot_record.dumpStackAndDieOffset =
+				Entrypoints.dumpStackAndDieMethod.getOffset();
+		Lock.init();
+	}
+
+	public void assertAcceptableStates(int expected) {
+		if (VM.VerifyAssertions) {
+			int curStatus=getExecStatus();
+			if (curStatus!=expected) {
+				VM.sysWriteln("FATAL ERROR: unexpected thread state.");
+				VM.sysWriteln("Expected: ",expected);
+				VM.sysWriteln("Observed: ",curStatus);
+				VM._assert(curStatus==expected);
+			}
+		}
+	}
+
+	public void assertAcceptableStates(int expected1,int expected2) {
+		if (VM.VerifyAssertions) {
+			int curStatus=getExecStatus();
+			if (curStatus!=expected1 &&
+					curStatus!=expected2) {
+				VM.sysWriteln("FATAL ERROR: unexpected thread state.");
+				VM.sysWriteln("Expected: ",expected1);
+				VM.sysWriteln("      or: ",expected2);
+				VM.sysWriteln("Observed: ",curStatus);
+				VM._assert(curStatus==expected1 ||
+						curStatus==expected2);
+			}
+		}
+	}
+
+	public void assertUnacceptableStates(int unexpected) {
+		if (VM.VerifyAssertions) {
+			int curStatus=getExecStatus();
+			if (curStatus==unexpected) {
+				VM.sysWriteln("FATAL ERROR: unexpected thread state.");
+				VM.sysWriteln("Unexpected: ",unexpected);
+				VM.sysWriteln("  Observed: ",curStatus);
+				VM._assert(curStatus!=unexpected);
+			}
+		}
+	}
+
+	public void assertUnacceptableStates(int unexpected1,int unexpected2) {
+		if (VM.VerifyAssertions) {
+			int curStatus=getExecStatus();
+			if (curStatus==unexpected1 ||
+					curStatus==unexpected2) {
+				VM.sysWriteln("FATAL ERROR: unexpected thread state for thread", threadSlot);
+				VM.sysWriteln("Unexpected: ",unexpected1);
+				VM.sysWriteln("       and: ",unexpected2);
+				VM.sysWriteln("  Observed: ",curStatus);
+				VM._assert(curStatus!=unexpected1 &&
+						curStatus!=unexpected2);
+			}
+		}
+	}
+
+	static void bind(int cpuId) {
+		if (VM.VerifyAssertions) VM._assert(sysCall.sysThreadBindSupported()==1);
+		sysCall.sysThreadBind(cpuId);
+	}
+
+	static void bindIfRequested() {
+		if (VM.forceOneCPU>=0) {
+			if (traceBind) {
+				VM.sysWriteln("binding thread to CPU: ",VM.forceOneCPU);
+			}
+			bind(VM.forceOneCPU);
+		}
+	}
+
+	@Unpreemptible
+	private void perfEventAttach() {
+		if(PER_THREAD_PERF_MONITORING) {
+			int n = perfEventNames.length;
+			perfEventTemp[0] = 0;
+			perfEventTemp[1] = 0;
+			perfEventTemp[2] = 0;
+			perfEventFds = new int[n];
+			if (n > 0) perfEventFds[0] = -1;
+			for (int i = 0; i < n; i++) {
+				sysCall.sysPerfEventOpen_thread(i, thread_id, perfEventFds);
+			}
+		}
+	}
+
+	@Unpreemptible
+	public static void perfEventStart() {
+		if(PER_THREAD_PERF_MONITORING) {
+			hardHandshakeSuspend();
+			for(int i=0; i<numThreads;i++) {
+				threads[i].perfEventEnable();
+			}
+			hardHandshakeResume();
+		}
+	}
+
+	@Unpreemptible
+	private void perfEventEnable() {
+		int n = perfEventNames.length;
+		sysCall.sysPerfEventEnable_thread(perfEventFds,n);
+	}
+
+	@Unpreemptible
+	private void perfEventDisable() {
+		int n = perfEventNames.length;
+		sysCall.sysPerfEventDisable_thread(perfEventFds,n);
+	}
+
+	@UninterruptibleNoWarn
+	private void perfEventDetach() {
+		int n = perfEventNames.length;
+
+		// assign groups to system threads
+		final String threadName = this.getName();
+		if(threadName.contains("Organizer") || threadName.contains("ControllerThread") || threadName.contains("CompilationThread") ) {
+			perfEventGroup = PERF_EVENT_GROUP_ORGANIZERS;
+		}
+		else if(threadName.contains("TimerThread") || threadName.contains("FinalizerThread")) { 
+			perfEventGroup = PERF_EVENT_GROUP_SYS;
+		}
+		else if(this.isCollectorThread()) {
+			perfEventGroup = PERF_EVENT_GROUP_GC;
+		}
+		if(perfEventGroup == -1) {
+			VM.sysWrite("ERROR (PerThreadPerfMon): Thread Group Not Assigned For Thread-");
+			VM.sysWriteln(threadName);
+			VM.sysFail("PerThreadGroup");
+		}
+
+		acctLock.lockNoHandshake();
+		for (int i = 0; i < n; i++) {
+			long val = perfEventRead(i);	
+			perfEventperThread[i][perfEventThreadNum] = val;
+			switch(perfEventGroup) {
+			case PERF_EVENT_GROUP_WS:
+				perfEventTotals_ws[i] += val;
+				break;
+			case PERF_EVENT_GROUP_ORGANIZERS:
+				perfEventTotals_organizers[i] += val;
+				break;
+			case PERF_EVENT_GROUP_GC:
+				perfEventTotals_gc[i] += val;
+				break;
+			case PERF_EVENT_GROUP_SYS:
+				perfEventTotals_sys[i] += val;
+				break;
+			}
+		}
+		String name = getName().replace(" ", "");
+		name += ".T" + perfEventThreadNum;
+		perfEventThreadName[perfEventThreadNum] = name;
+		++perfEventThreadNum;
+		acctLock.unlock();
+	}
+
+	public long perfEventRead(int eventIndex) {
+		if(VM.VerifyAssertions) VM._assert(eventIndex >= 0 && eventIndex <= perfEventNames.length, "Invalid perfEventId");
+		sysCall.sysPerfEventRead_thread(eventIndex, perfEventFds, perfEventTemp);
+		if (perfEventTemp[1] != perfEventTemp[2]) {
+			// This thread has never run
+			if(this.systemThread == null) VM.sysFail("Counters overflowed");
+			return 0;
+		}
+		return perfEventTemp[0]; 
+	}
+
+	@Unpreemptible
+	public static void perfEventStop() {
+		if(PER_THREAD_PERF_MONITORING) {
+			hardHandshakeSuspend();
+			for(int i=0; i<numThreads;i++) {
+				threads[i].perfEventDetach();
+			}
+
+			int n = perfEventNames.length;
+			// Thread grouping
+			VM.sysWriteln("============================ Tabulate Statistics ============================");
+			// write names
+			VM.sysWrite("counters");
+			for (int i = 0; i < n; i++) {
+				for (int j = 0; j <= 3; j++){
+					String group = "";
+					switch(j) {
+					case PERF_EVENT_GROUP_WS:
+						group = "WSThreads";
+						break;
+					case PERF_EVENT_GROUP_ORGANIZERS:
+						group = "Organizers";
+						break;
+					case PERF_EVENT_GROUP_GC:
+						group = "GC";
+						break;
+					case PERF_EVENT_GROUP_SYS:
+						group = "System";
+						break;
+					}
+					VM.sysWrite(" ", perfEventNames[i], ".", group);
+				}
+			}
+			VM.sysWriteln();
+
+			// write values
+			VM.sysWrite(n);
+			for (int i = 0; i < n; i++) {
+				for (int j = 0; j <= 3; j++){
+					switch(j) {
+					case PERF_EVENT_GROUP_WS:
+						VM.sysWrite("   ", perfEventTotals_ws[i]);
+						break;
+					case PERF_EVENT_GROUP_ORGANIZERS:
+						VM.sysWrite("   ", perfEventTotals_organizers[i]);
+						break;
+					case PERF_EVENT_GROUP_GC:
+						VM.sysWrite("   ", perfEventTotals_gc[i]);
+						break;
+					case PERF_EVENT_GROUP_SYS:
+						VM.sysWrite("   ", perfEventTotals_sys[i]);
+						break;
+					}
+				}
+			}
+			VM.sysWriteln();
+			// till here
+
+			hardHandshakeResume();
+		}
+	}
+
+	@Unpreemptible
+	public static void perfEventStopAndPrintAll() {
+		if(PER_THREAD_PERF_MONITORING) {
+			hardHandshakeSuspend();
+			for(int i=0; i<numThreads;i++) {
+				threads[i].perfEventDetach();
+			}
+
+			int n = perfEventNames.length;
+			VM.sysWriteln("============================ Tabulate Statistics ============================");
+			VM.sysWrite("counters");
+
+			for (int i = 0; i < n; i++) {
+				for (int j = 0; j < perfEventThreadNum; j++){
+					VM.sysWrite(" ", perfEventNames[i], ".", perfEventThreadName[j]);
+				}
+				//total
+				VM.sysWrite("   ", perfEventNames[i], ".WSThreadsTotal");
+			}
+
+			VM.sysWriteln();
+			VM.sysWrite(n);
+
+			for (int i = 0; i < n; i++) {
+				for (int j = 0; j < perfEventThreadNum; j++){
+					VM.sysWrite(" ", perfEventperThread[i][j]);
+				}
+			}
+
+			for (int i = 0; i < n; i++) {
+				VM.sysWrite("   ", perfEventTotals_ws[i]);
+			}
+			VM.sysWriteln();
+
+			hardHandshakeResume();
+		}
+	}
+
+	/**
+	 * Boot the threading subsystem.
+	 */
+	@Interruptible
+	// except not really, since we don't enable yieldpoints yet
+	public static void boot() {
+		outOfMemoryError = new OutOfMemoryError();
+		dumpLock = new Monitor();
+		acctLock = new NoYieldpointsMonitor();
+		debugLock = new NoYieldpointsMonitor();
+		outputLock = new NoYieldpointsMonitor();
+		softHandshakeDataLock = new Monitor();
+		handshakeLock = new Monitor();
+		doProfileReport = new Latch(false);
+		monitorBySlot[getCurrentThread().threadSlot] = new NoYieldpointsMonitor();
+		communicationLockBySlot[getCurrentThread().threadSlot] = new Monitor();
+		workStealingLockBySlot[getCurrentThread().threadSlot] = new Monitor();
+		if(ws_pinning_system) {
+			for(int i=0; i<pin_map_system.length; i++) {
+				sysCall.wsIniatilizeSysThreadBindMask(pin_map_system[i]);
+			}
+		}
+		sysCall.sysCreateThreadSpecificDataKeys();
+		sysCall.sysStashVMThread(getCurrentThread());
+
+		// Initialize perf event
+		if (wsPerThreadPerf) {
+			PER_THREAD_PERF_MONITORING = true;
+			int n = perfEventNames.length;
+			sysCall.sysPerfEventInit_thread(n);
+			perfEventperThread = new long[n][MAX_THREADS];
+			perfEventTotals_ws = new long[n];
+			perfEventTotals_organizers = new long[n];
+			perfEventTotals_gc = new long[n];
+			perfEventTotals_sys = new long[n];
+			perfEventThreadName = new String[MAX_THREADS];
+			for (int i = 0; i < n; i++) {
+				sysCall.sysPerfEventCreate_thread(i, getPerfEventByteArray(i));
+			}
+			getCurrentThread().perfEventAttach();
+		}
+
+		if (traceAcct) {
+			VM.sysWriteln("boot thread at ",Magic.objectAsAddress(getCurrentThread()));
+		}
+
+		bindIfRequested();
+
+		threadingInitialized = true;
+		// Always run timer thread, so we can respond to debug requests
+		new TimerThread().start();
+		if (VM.BuildForAdaptiveSystem) {
+			ObjectHolder.boot();
+		}
+
+		FinalizerThread.boot();
+		getCurrentThread().enableYieldpoints();
+		if (traceAcct) VM.sysWriteln("RVMThread booted");
+	}
+
+	/**
+	 * Add this thread to the termination watchlist. Called by terminating threads
+	 * before they finish terminating.
+	 */
+	private void addAboutToTerminate() {
+		monitor().lockNoHandshake();
+		isAboutToTerminate = true;
+		activeMutatorContext = false;
+		monitor().broadcast();
+
+		handleHandshakeRequest();
+		deinitMutator();
+
+		// WARNING! DANGER! Since we've set isAboutToTerminate to true, when we
+		// release this lock the GC will:
+		// 1) No longer scan the thread's stack (though it will *see* the
+		// thread's stack and mark the stack itself as live, without scanning
+		// it).
+		// 2) No longer include the thread in any mutator phases ... hence the
+		// need to ensure that the mutator context is flushed above.
+		// 3) No longer attempt to block the thread.
+		// Moreover, we can no longer do anything that leads to write barriers
+		// or allocation.
+		monitor().unlock();
+
+		softRendezvous();
+
+		acctLock.lockNoHandshake();
+		aboutToTerminate[aboutToTerminateN++] = threadSlot;
+		acctLock.unlock();
+	}
+
+	/**
+	 * Method called after processing a list of threads, or before starting a new
+	 * thread.  This does two things.  First, it guarantees that the thread slots
+	 * used by any dead threads are freed.  Second, it guarantees that each thread
+	 * deregisters itself from GC.  Thus, it is essential that after requesting
+	 * things like mutator flushes, you call this, to ensure that any threads that
+	 * had died before or during the mutator flush request do the Right Thing.
+	 */
+	@NoCheckStore
+	public static void processAboutToTerminate() {
+		if (!neverKillThreads) {
+			restart: while(true) {
+				int notKilled = 0;
+				acctLock.lockNoHandshake();
+				for (int i = 0; i < aboutToTerminateN; ++i) {
+					RVMThread t = threadBySlot[aboutToTerminate[i]];
+					if (t.getExecStatus() == TERMINATED) {
+						aboutToTerminate[i--] = aboutToTerminate[--aboutToTerminateN];
+						acctLock.unlock();
+						t.releaseThreadSlot();
+						continue restart;
+					} else {
+						notKilled++;
+					}
+				}
+				acctLock.unlock();
+				if (notKilled > 0 && traceAboutToTerminate) {
+					VM.sysWriteln("didn't kill ", notKilled, " threads");
+				}
+				break;
+			}
+		}
+	}
+
+	/**
+	 * Find a thread slot not in use by any other live thread and bind the given
+	 * thread to it. The thread's threadSlot field is set accordingly.
+	 */
+	@Interruptible
+	void assignThreadSlot() {
+		if (!VM.runningVM) {
+			// primordial thread
+			threadSlot = 1;
+			threadBySlot[1] = this;
+			threads[0] = this;
+			threadIdx = 0;
+			numThreads = 1;
+		} else {
+			processAboutToTerminate();
+			acctLock.lockNoHandshake();
+			if (freeSlotN > 0) {
+				threadSlot = freeSlots[--freeSlotN];
+			} else {
+				if (nextSlot == threads.length) {
+					VM.sysFail("too many threads");
+				}
+				threadSlot = nextSlot++;
+			}
+			acctLock.unlock();
+			// before we actually use this slot, ensure that there is a monitor
+			// for it. note that if the slot doesn't have a monitor, then we
+			// "own" it since we allocated it above but haven't done anything
+			// with it (it's not assigned to a thread, so nobody else can touch
+			// it)
+			if (monitorBySlot[threadSlot] == null) {
+				monitorBySlot[threadSlot] = new NoYieldpointsMonitor();
+			}
+			if (communicationLockBySlot[threadSlot] == null) {
+				Monitor m = new Monitor();
+				Monitor m2 = new Monitor();
+				handshakeLock.lockWithHandshake();
+				communicationLockBySlot[threadSlot] = m;
+				workStealingLockBySlot[threadSlot] = m2;
+				handshakeLock.unlock();
+			}
+			Magic.sync(); /*
+			 * make sure that nobody sees the thread in any of the
+			 * tables until the thread slot is inited
+			 */
+
+			acctLock.lockNoHandshake();
+			threadBySlot[threadSlot] = this;
+
+			threadIdx = numThreads++;
+			threads[threadIdx] = this;
+
+			acctLock.unlock();
+		}
+		lockingId = threadSlot << ThinLockConstants.TL_THREAD_ID_SHIFT;
+		if (traceAcct) {
+			VM.sysWriteln("Thread #", threadSlot, " at ", Magic.objectAsAddress(this));
+			VM.sysWriteln("stack at ", Magic.objectAsAddress(stack), " up to ", Magic.objectAsAddress(stack).plus(stack.length));
+		}
+	}
+
+	/**
+	 * Release a thread's slot in the threads array.
+	 */
+	@NoCheckStore
+	void releaseThreadSlot() {
+		acctLock.lockNoHandshake();
+		RVMThread replacementThread = threads[numThreads - 1];
+		threads[threadIdx] = replacementThread;
+		replacementThread.threadIdx = threadIdx;
+		threadIdx = -1;
+		Magic.sync(); /*
+		 * make sure that if someone is processing the threads array
+		 * without holding the acctLock (which is definitely legal)
+		 * then they see the replacementThread moved to the new index
+		 * before they see the numThreads decremented (otherwise they
+		 * would miss replacementThread; but with the current
+		 * arrangement at worst they will see it twice)
+		 */
+		threads[--numThreads] = null;
+		threadBySlot[threadSlot] = null;
+		freeSlots[freeSlotN++] = threadSlot;
+		acctLock.unlock();
+	}
+
+	/**
+	 * Create a new RVM Thread
+	 *
+	 * @param stack The stack on which to execute the thread.
+	 * @param thread The corresponding java.lang.Thread.
+	 * @param name The name of the thread
+	 * @param daemon True if this is a daemon thread.
+	 * @param systemThread True if this is a system thread.
+	 * @param priority The threads execution priority.
+	 */
+	public RVMThread(byte[] stack, Thread thread, String name, boolean daemon, SystemThread systemThread, int priority) {
+		this.stack = stack;
+
+		this.daemon = daemon;
+		this.priority = priority;
+		this.systemThread = systemThread;
+
+		this.contextRegisters = this.contextRegistersShadow = new Registers();
+		this.contextRegistersSave = this.contextRegistersSaveShadow = new Registers();
+		this.exceptionRegisters = this.exceptionRegistersShadow = new Registers();
+
+		if (VM.runningVM) {
+			feedlet = TraceEngine.engine.makeFeedlet(name, name);
+		}
+
+		if (VM.VerifyAssertions) VM._assert(stack != null);
+
+		// put self in list of threads known to scheduler and garbage collector
+		if (!VM.runningVM) {
+			if (VM.VerifyAssertions) VM._assert(name != null);
+			this.name = name;
+			// create primordial thread (in boot image)
+			assignThreadSlot();
+
+			if (trace)
+				trace("RVMThread create: ", name);
+			if (trace)
+				trace("daemon: ", daemon ? "true" : "false");
+			if (trace)
+				trace("RVMThread", "create");
+
+			initMutator(threadSlot);
+			this.activeMutatorContext = true;
+			// Remember the boot thread
+			this.execStatus = IN_JAVA;
+			this.waiting = Waiting.RUNNABLE;
+			// assign final field
+			onStackReplacementEvent = null;
+		} else {
+			// create a normal (ie. non-primordial) thread
+
+			// set up wrapper Thread if one exists
+			this.thread = thread;
+			// Set thread type
+
+			this.execStatus = NEW;
+			this.waiting = Waiting.RUNNABLE;
+
+			stackLimit = Magic.objectAsAddress(stack).plus(STACK_SIZE_GUARD);
+
+			// get instructions for method to be executed as thread startoff
+			CodeArray instructions = Entrypoints.threadStartoffMethod.getCurrentEntryCodeArray();
+
+			VM.disableGC();
+
+			// initialize thread registers
+			Address ip = Magic.objectAsAddress(instructions);
+			Address sp = Magic.objectAsAddress(stack).plus(stack.length);
+
+			// Initialize the a thread stack as if "startoff" method had been called
+			// by an empty baseline-compiled "sentinel" frame with one local variable.
+			Configuration.archHelper.initializeStack(contextRegisters, ip, sp);
+
+			VM.enableGC();
+
+			assignThreadSlot();
+			this.name = name == null ? "Thread-" + threadSlot : name;
+			initMutator(threadSlot);
+			activeMutatorContext = true;
+			if (traceAcct) {
+				VM.sysWriteln("registered mutator for ", threadSlot);
+			}
+
+			initializeJNIEnv();
+
+			if (VM.BuildForAdaptiveSystem) {
+				onStackReplacementEvent = new OnStackReplacementEvent();
+			} else {
+				onStackReplacementEvent = null;
+			}
+
+			if (thread == null) {
+				// create wrapper Thread if doesn't exist
+				this.thread = java.lang.JikesRVMSupport.createThread(this, name);
+			}
+		}
+	}
+
+	/**
+	 * Create a thread with default stack and with the given name.
+	 */
+	public RVMThread(SystemThread systemThread, String name) {
+		this(MemoryManager.newStack(STACK_SIZE_NORMAL), null, // java.lang.Thread
+				name, true, // daemon
+				systemThread,
+				Thread.NORM_PRIORITY);
+	}
+
+	/**
+	 * Create a thread with the given stack and name. Used by
+	 * {@link org.jikesrvm.mm.mminterface.CollectorThread} and the
+	 * boot image writer for the boot thread.
+	 */
+	public RVMThread(SystemThread systemThread, byte[] stack, String name) {
+		this(stack, null, // java.lang.Thread
+				name, true, // daemon
+				systemThread,
+				Thread.NORM_PRIORITY);
+	}
+
+	/**
+	 * Create a thread with ... called by java.lang.VMThread.create. System thread
+	 * isn't set.
+	 */
+	public RVMThread(Thread thread, long stacksize, String name, boolean daemon, int priority) {
+		this(MemoryManager.newStack((stacksize <= 0) ? STACK_SIZE_NORMAL : (int) stacksize), thread, name, daemon, null, priority);
+	}
+
+	/**
+	 * Check if the thread has block requests (for example, for suspension and GC).  If
+	 * it does, clear the requests and marked the thread as blocked for that request.
+	 * If there were any block requests, do a broadcast() on the thread's monitor().
+	 * This is an internal method and should only be called from code that implements
+	 * thread blocking.  The monitor() lock must be held for this method to work properly.
+	 */
+	private void acknowledgeBlockRequests() {
+		boolean hadSome = false;
+		if (VM.VerifyAssertions)
+			VM._assert(blockAdapters != null);
+		for (int i = 0; i < blockAdapters.length; ++i) {
+			if (blockAdapters[i].hasBlockRequest(this)) {
+				blockAdapters[i].setBlocked(this, true);
+				blockAdapters[i].clearBlockRequest(this);
+				hadSome = true;
+			}
+		}
+		if (hadSome) {
+			monitor().broadcast();
+		}
+	}
+
+	/**
+	 * Checks if the thread system has acknowledged that the thread is supposed
+	 * to be blocked. This will return true if the thread is actually blocking, or
+	 * if the thread is running native code but is guaranteed to block before
+	 * returning to Java.  Only call this method when already holding the monitor(),
+	 * for two reasons:
+	 * <ol>
+	 * <li>This method does not acquire the monitor() lock even though it needs
+	 * to have it acquired given the data structures that it is accessing.
+	 * <li>You will typically want to call this method to decide if you need to
+	 * take action under the assumption that the thread is blocked (or not
+	 * blocked). So long as you hold the lock the thread cannot change state from
+	 * blocked to not blocked.
+	 * </ol>
+	 *
+	 * @return if the thread is supposed to be blocked
+	 */
+	public boolean isBlocked() {
+		for (int i = 0; i < blockAdapters.length; ++i) {
+			if (blockAdapters[i].isBlocked(this)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Checks if the thread is executing Java code. A thread is executing Java
+	 * code if its <code>execStatus</code> is <code>IN_JAVA</code> or
+	 * <code>IN_JAVA_TO_BLOCK</code>, and if it is not
+	 * <code>aboutToTerminate</code>, and if it is not blocked. Only call this
+	 * method when already holding the monitor(), and probably only after calling
+	 * setBlockedExecStatus(), for two reasons:
+	 * <ol>
+	 * <li>This method does not acquire the monitor() lock even though it needs
+	 * to have it acquired given the data structures that it is accessing.
+	 * <li>You will typically want to call this method to decide if you need to
+	 * take action under the assumption that the thread is running Java (or not
+	 * running Java). So long as you hold the lock - and you have called
+	 * setBlockedExecStatus() - the thread cannot change state from running-Java
+	 * to not-running-Java.
+	 * </ol>
+	 *
+	 * @return if the thread is running Java
+	 */
+	public boolean isInJava() {
+		return !isBlocking && !isAboutToTerminate &&
+				(getExecStatus() == IN_JAVA || getExecStatus() == IN_JAVA_TO_BLOCK);
+	}
+
+	/**
+	 * Should the thread by eligible for sampling by the timer thread?
+	 * Heuristically, we use timer-based sampling the in the adaptive system
+	 * to determine where the program is spending time (and thus what to optimize).
+	 * This doesn't have to be a 100% accurate, but it must be non-blocking
+	 * and also closely approximate whether or not the thread is executing.
+	 * For now, approximate just as being in JAVA.
+	 * As a future item, we may want to actually correctly attribute time
+	 * spent in native code to the top native method on the frame when the timer
+	 * goes off.  This will require work in the JNI enter/exit sequence to deal with
+	 * timer samples appropriately.
+	 */
+	public boolean shouldBeSampled() {
+		return execStatus == IN_JAVA;
+	}
+
+	/** A variant of checkBlock() that does not save the thread state. */
+	@NoInline
+	@Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
+	private void checkBlockNoSaveContext() {
+		assertUnacceptableStates(NEW, TERMINATED);
+		if (VM.VerifyAssertions) VM._assert(!isAboutToTerminate);
+		if (VM.VerifyAssertions) VM._assert(!isBlocking);
+
+		if (traceBlock)
+			VM.sysWriteln("Thread #", threadSlot, " in checkBlockNoSaveContext");
+		// NB: anything this method calls CANNOT change the contextRegisters
+		// or the JNI env. as well, this code will be running concurrently
+		// with stop-the-world GC!
+		monitor().lockNoHandshake();
+		isBlocking = true;
+		if (traceBlock)
+			VM.sysWriteln("Thread #", threadSlot,
+					" acquired lock and has notified everyone that we're blocked");
+
+		// deal with requests that would require a soft handshake rendezvous
+		handleHandshakeRequest();
+		// check if a soft handshake has been requested, and if so, clear the
+		// request
+		boolean commitSoftRendezvous = softRendezvousCheckAndClear();
+		if (commitSoftRendezvous) {
+			// if a soft handshake had been requested, we need to acknowledge it.
+			// but to acknowledge it we cannot be holding the monitor() lock.
+			// it turns out that at this point in the code it is perfectly safe
+			// to release it, because:
+			// 1) callers of this method expect that it may, in all likelihood,
+			// release the monitor() lock if they were holding it, since it
+			// calls wait()
+			// 2) if the block requests get cleared when we release the lock,
+			// we won't call wait, since we reacquire the lock prior to checking
+			// for block requests.
+			int recCount = monitor().unlockCompletely();
+			softRendezvousCommit();
+			monitor().relockNoHandshake(recCount);
+		}
+
+		if (traceBlock)
+			VM.sysWriteln("Thread #", threadSlot,
+					" has acknowledged soft handshakes");
+
+		boolean hadReallyBlocked=false;
+
+		for (;;) {
+			// deal with block requests
+			acknowledgeBlockRequests();
+			// are we blocked?
+			if (!isBlocked()) {
+				break;
+			}
+			if (traceReallyBlock) {
+				hadReallyBlocked=true;
+				VM.sysWriteln("Thread #", threadSlot,
+						" is really blocked with status ", getExecStatus());
+				VM.sysWriteln("Thread #", threadSlot,
+						" has fp = ", Magic.getFramePointer());
+				if (dumpStackOnBlock) {
+					dumpStack();
+				}
+			}
+			// what if a GC request comes while we're here for a suspend()
+			// request?
+			// answer: we get awoken, reloop, and acknowledge the GC block
+			// request.
+			monitor().waitNoHandshake();
+
+			if (traceBlock)
+				VM.sysWriteln("Thread #", threadSlot,
+						" has awoken; checking if we're still blocked");
+		}
+
+		if (traceBlock || (traceReallyBlock && hadReallyBlocked))
+			VM.sysWriteln("Thread #", threadSlot, " is unblocking");
+
+		// we're about to unblock, so indicate to the world that we're running
+		// again.
+		setExecStatus(IN_JAVA);
+		// let everyone know that we're back to executing code
+		isBlocking = false;
+		// deal with requests that came up while we were blocked.
+		handleHandshakeRequest();
+		monitor().unlock();
+
+		if (traceBlock)
+			VM.sysWriteln("Thread #", threadSlot, " is unblocked");
+	}
+
+	/**
+	 * Check if the thread is supposed to block, and if so, block it. This method
+	 * will ensure that soft handshake requests are acknowledged or else
+	 * inhibited, that any blocking request is handled, that the execution state
+	 * of the thread (<code>execStatus</code>) is set to <code>IN_JAVA</code>
+	 * once all blocking requests are cleared, and that other threads are notified
+	 * that this thread is in the middle of blocking by setting the appropriate
+	 * flag (<code>isBlocking</code>). Note that this thread acquires the
+	 * monitor(), though it may release it completely either by calling wait() or
+	 * by calling unlockCompletely(). Thus, although it isn't generally a problem
+	 * to call this method while holding the monitor() lock, you should only do so
+	 * if the loss of atomicity is acceptable.
+	 * <p>
+	 * Generally, this method should be called from the following four places:
+	 * <ol>
+	 * <li>The block() method, if the thread is requesting to block itself.
+	 * Currently such requests only come when a thread calls suspend(). Doing so
+	 * has unclear semantics (other threads may call resume() too early causing
+	 * the well-known race) but must be supported because it's still part of the
+	 * JDK. Why it's safe: the block() method needs to hold the monitor() for the
+	 * time it takes it to make the block request, but does not need to continue
+	 * to hold it when it calls checkBlock(). Thus, the fact that checkBlock()
+	 * breaks atomicity is not a concern.
+	 * <li>The yieldpoint. One of the purposes of a yieldpoint is to periodically
+	 * check if the current thread should be blocked. This is accomplished by
+	 * calling checkBlock(). Why it's safe: the yieldpoint performs several
+	 * distinct actions, all of which individually require the monitor() lock -
+	 * but the monitor() lock does not have to be held contiguously. Thus, the
+	 * loss of atomicity from calling checkBlock() is fine.
+	 * <li>The "WithHandshake" methods of HeavyCondLock. These methods allow you to
+	 * block on a mutex or condition variable while notifying the system that you
+	 * are not executing Java code. When these blocking methods return, they check
+	 * if there had been a request to block, and if so, they call checkBlock().
+	 * Why it's safe: This is subtle. Two cases exist. The first case is when a
+	 * WithHandshake method is called on a HeavyCondLock instance that is not a thread
+	 * monitor(). In this case, it does not matter that checkBlock() may acquire
+	 * and then completely release the monitor(), since the user was not holding
+	 * the monitor(). However, this will break if the user is <i>also</i> holding
+	 * the monitor() when calling the WithHandshake method on a different lock. This case
+	 * should never happen because no other locks should ever be acquired when the
+	 * monitor() is held. Additionally: there is the concern that some other locks
+	 * should never be held while attempting to acquire the monitor(); the
+	 * HeavyCondLock ensures that checkBlock() is only called when that lock
+	 * itself is released. The other case is when a WithHandshake method is called on the
+	 * monitor() itself. This should only be done when using <i>your own</i>
+	 * monitor() - that is the monitor() of the thread your are running on. In
+	 * this case, the WithHandshake methods work because: (i) lockWithHandshake() only calls
+	 * checkBlock() on the initial lock entry (not on recursive entry), so
+	 * atomicity is not broken, and (ii) waitWithHandshake() and friends only call
+	 * checkBlock() after wait() returns - at which point it is safe to release
+	 * and reacquire the lock, since there cannot be a race with broadcast() once
+	 * we have committed to not calling wait() again.
+	 * <li>Any code following a potentially-blocking native call. Case (3) above
+	 * is somewhat subsumed in this except that it is special due to the fact that
+	 * it's blocking on VM locks. So, this case refers specifically to JNI. The
+	 * JNI epilogues will call leaveJNIBlocked(), which calls a variant of this
+	 * method.
+	 * </ol>
+	 */
+	@NoInline
+	@NoOptCompile
+	@BaselineSaveLSRegisters
+	@Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
+	void checkBlock() {
+		saveThreadState();
+		checkBlockNoSaveContext();
+	}
+	
+	@NoInline
+	@NoOptCompile
+	@BaselineSaveLSRegisters
+	@Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
+	void wsWrapperCheckBlock() {
+		wsCheckBlock();
+	}
+
+	@NoInline
+	@NoOptCompile
+	@BaselineNoRegisters
+	@Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
+	void wsCheckBlock() {
+		wsSafeToInstallRBarrier = true;
+		saveThreadState();
+		checkBlockNoSaveContext();
+	}
+	
+	/**
+	 * Internal method for transitioning a thread from IN_JAVA or IN_JAVA_TO_BLOCK to
+	 * either BLOCKED_IN_NATIVE or BLOCKED_IN_JNI, depending on the value of the jni
+	 * parameter.  It is always safe to conservatively call this method when transitioning
+	 * to native code, though it is faster to call either enterNative(),
+	 * enterJNIFromCallIntoNative(), or enterJNIFromJNIFunctionCall().
+	 * <p>
+	 * This method takes care of all bookkeeping and notifications required when a
+	 * a thread that has been requested to block instead decides to run native code.
+	 * Threads enter native code never need to block, since they will not be executing
+	 * any Java code.  However, such threads must ensure that any system services (like
+	 * GC) that are waiting for this thread to stop are notified that the thread has
+	 * instead chosen to exit Java.  As well, any requests to perform a sot handshake
+	 * must be serviced and acknowledged.
+	 */
+	private void enterNativeBlockedImpl(boolean jni) {
+		if (traceReallyBlock)
+			VM.sysWriteln("Thread #", threadSlot, " entering native blocked.");
+		// NB: anything this method calls CANNOT change the contextRegisters
+		// or the JNI env. as well, this code will be running concurrently
+		// with stop-the-world GC!
+		boolean commitSoftRendezvous;
+		monitor().lockNoHandshake();
+		if (jni) {
+			jniEnteredBlocked++;
+			setExecStatus(BLOCKED_IN_JNI);
+		} else {
+			nativeEnteredBlocked++;
+			setExecStatus(BLOCKED_IN_NATIVE);
+		}
+		acknowledgeBlockRequests();
+		handleHandshakeRequest();
+		commitSoftRendezvous = softRendezvousCheckAndClear();
+		monitor().unlock();
+		if (traceBlock)
+			VM.sysWriteln("Thread #", threadSlot,
+					" done with the locking part of native entry.");
+		if (commitSoftRendezvous)
+			softRendezvousCommit();
+		if (traceBlock)
+			VM.sysWriteln("Thread #", threadSlot, " done enter native blocked.");
+	}
+
+	@Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
+	private void leaveNativeBlockedImpl() {
+		checkBlockNoSaveContext();
+	}
+
+	private void enterNativeBlocked() {
+		assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
+		enterNativeBlockedImpl(false);
+		assertAcceptableStates(IN_NATIVE,BLOCKED_IN_NATIVE);
+	}
+
+	@Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
+	private void leaveNativeBlocked() {
+		assertAcceptableStates(IN_NATIVE,BLOCKED_IN_NATIVE);
+		leaveNativeBlockedImpl();
+		assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
+	}
+
+	private void enterJNIBlocked() {
+		assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
+		enterNativeBlockedImpl(true);
+		assertAcceptableStates(IN_JNI,BLOCKED_IN_JNI);
+	}
+
+	@Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
+	private void leaveJNIBlocked() {
+		assertAcceptableStates(IN_JNI,BLOCKED_IN_JNI);
+		leaveNativeBlockedImpl();
+		assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
+	}
+
+	@Entrypoint
+	public static void enterJNIBlockedFromJNIFunctionCall() {
+		RVMThread t=getCurrentThread();
+		if (traceReallyBlock) {
+			VM.sysWriteln("Thread #",t.getThreadSlot(), " in enterJNIBlockedFromJNIFunctionCall");
+			VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
+		}
+		t.enterJNIBlocked();
+	}
+
+	@Entrypoint
+	public static void enterJNIBlockedFromCallIntoNative() {
+		RVMThread t=getCurrentThread();
+		if (traceReallyBlock) {
+			VM.sysWriteln("Thread #",t.getThreadSlot(), " in enterJNIBlockedFromCallIntoNative");
+			VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
+		}
+		t.enterJNIBlocked();
+	}
+
+	@Entrypoint
+	@Unpreemptible("May block if the thread was asked to do so, but otherwise will not block")
+	static void leaveJNIBlockedFromJNIFunctionCall() {
+		RVMThread t = getCurrentThread();
+		if (traceReallyBlock) {
+			VM.sysWriteln("Thread #", t.getThreadSlot(),
+					" in leaveJNIBlockedFromJNIFunctionCall");
+			VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
+			VM.sysWriteln("state = ", t.getExecStatus());
+			VM.sysWriteln("jtoc = ", Magic.getJTOC());
+		}
+		t.leaveJNIBlocked();
+	}
+
+	/**
+	 * Called when JNI code tried to transition from  IN_JNI to IN_JAVA but failed
+	 */
+	@Entrypoint
+	@Unpreemptible("May block if the thread was asked to do so, but otherwise will not block")
+	public static void leaveJNIBlockedFromCallIntoNative() {
+		RVMThread t = getCurrentThread();
+		if (traceReallyBlock) {
+			VM.sysWriteln("Thread #", t.getThreadSlot(),
+					" in leaveJNIBlockedFromCallIntoNative");
+			VM.sysWriteln("state = ", t.getExecStatus());
+			VM.sysWriteln("jtoc = ", Magic.getJTOC());
+		}
+		t.leaveJNIBlocked();
+	}
+
+	private int setBlockedExecStatus() {
+		int oldState, newState;
+		do {
+			oldState = getExecStatus();
+			if (oldState == IN_JAVA) {
+				newState = IN_JAVA_TO_BLOCK;
+			} else if (oldState == IN_NATIVE) {
+				newState = BLOCKED_IN_NATIVE;
+			} else if (oldState == IN_JNI) {
+				newState = BLOCKED_IN_JNI;
+			} else {
+				newState = oldState;
+			}
+			/*
+			 * use the CAS to assert that we observed what we
+			 * thought we observed
+			 */
+		} while (!(attemptFastExecStatusTransition(oldState,newState)));
+		return newState;
+	}
+
+	/**
+	 * Attempt to block the thread, and return the state it is in after the
+	 * attempt. If we're blocking ourselves, this will always return IN_JAVA. If
+	 * the thread signals to us the intention to die as we are trying to block it,
+	 * this will return TERMINATED. NOTE: the thread's execStatus will not
+	 * actually be TERMINATED at that point yet.
+	 * <p>
+	 * Note that this method is ridiculously dangerous, especially if you pass
+	 * asynchronous==false.  Waiting for another thread to stop is not in itself
+	 * interruptible - so if you ask another thread to block and they ask you
+	 * to block, you might deadlock.
+	 */
+	@Unpreemptible("Only blocks if the receiver is the current thread, or if asynchronous is set to false and the thread is not already blocked")
+	int block(BlockAdapter ba, boolean asynchronous) {
+		int result;
+		if (traceBlock)
+			VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+					" is requesting that thread #", threadSlot, " blocks.");
+		monitor().lockNoHandshake();
+		int token = ba.requestBlock(this);
+		if (getCurrentThread() == this) {
+			if (traceBlock)
+				VM.sysWriteln("Thread #", threadSlot, " is blocking.");
+			wsWrapperCheckBlock();
+			wsSafeToInstallRBarrier = false;
+			result = getExecStatus();
+		} else {
+			if (traceBlock)
+				VM.sysWriteln("Thread #", threadSlot, " is being told to block.");
+			if (isAboutToTerminate) {
+				if (traceBlock)
+					VM.sysWriteln("Thread #", threadSlot,
+							" is terminating, returning as if blocked in TERMINATED state.");
+				result = TERMINATED;
+			} else {
+				takeYieldpoint = 1;
+				// CAS the execStatus field
+				int newState = setBlockedExecStatus();
+				result = newState;
+				if (traceReallyBlock)
+					VM.sysWriteln("Thread #", getCurrentThreadSlot(),
+							" is blocking thread #", threadSlot, " which is in state ",
+							newState);
+				// this broadcast serves two purposes: notifies threads that are
+				// IN_JAVA but waiting on monitor() that they should awake and
+				// acknowledge the block request; or notifies anyone
+				// waiting for this thread to block that the thread is
+				// BLOCKED_IN_NATIVE or BLOCKED_IN_JNI. in the latter case the
+				// broadcast() happens _before_ the setting of the flags that the
+				// other threads would be awaiting, but that is fine, since we're
+				// still holding the lock anyway.
+				monitor().broadcast();
+				if (newState == IN_JAVA_TO_BLOCK) {
+					if (!asynchronous) {
+						if (traceBlock)
+							VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+									" is waiting for thread #", threadSlot, " to block.");
+						while (ba.hasBlockRequest(this, token) && !ba.isBlocked(this) && !isAboutToTerminate) {
+							if (traceBlock)
+								VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+										" is calling wait until thread #", threadSlot, " blocks.");
+							// will this deadlock when the thread dies?
+							if (VM.VerifyAssertions) {
+								// do a timed wait, and assert that the thread did not disappear
+								// into native in the meantime
+								monitor().timedWaitRelativeNoHandshake(1000L * 1000L * 1000L); // 1 sec
+								if (traceReallyBlock) {
+									VM.sysWriteln("Thread #", threadSlot, "'s status is ",
+											getExecStatus());
+								}
+								assertUnacceptableStates(IN_NATIVE);
+							} else {
+								monitor().waitNoHandshake();
+							}
+							if (traceBlock)
+								VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+										" has returned from the wait call.");
+						}
+						if (isAboutToTerminate) {
+							result = TERMINATED;
+						} else {
+							result=getExecStatus();
+						}
+					}
+				} else if (newState == BLOCKED_IN_NATIVE || newState == BLOCKED_IN_JNI) {
+					// we own the thread for now - it cannot go back to executing Java
+					// code until we release the lock. before we do so we change its
+					// state accordingly and tell anyone who is waiting.
+					if (traceBlock)
+						VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+								" has seen thread #", threadSlot,
+								" in native; changing its status accordingly.");
+					ba.clearBlockRequest(this);
+					ba.setBlocked(this, true);
+				}
+			}
+		}
+		monitor().unlock();
+		if (traceReallyBlock)
+			VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+					" is done telling thread #", threadSlot, " to block.");
+		return result;
+	}
+
+	private boolean wsSafeToInstallRBarrier = false;
+	
+	@Unpreemptible("Only blocks if the receiver is the current thread, or if asynchronous is set to false and the thread is not already blocked")
+	private boolean wsBlock(BlockAdapter ba, boolean asynchronous) {
+		int result;
+		boolean safeWait = false;
+		if (traceBlock)
+			VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+					" is requesting that thread #", threadSlot, " blocks.");
+		monitor().lockNoHandshake();
+		int token = ba.requestBlock(this);
+		if (getCurrentThread() == this) {
+			if (traceBlock)
+				VM.sysWriteln("Thread #", threadSlot, " is blocking.");
+			checkBlock();
+			result = getExecStatus();
+		} else {
+			if (traceBlock)
+				VM.sysWriteln("Thread #", threadSlot, " is being told to block.");
+			if (isAboutToTerminate) {
+				if (traceBlock)
+					VM.sysWriteln("Thread #", threadSlot,
+							" is terminating, returning as if blocked in TERMINATED state.");
+				result = TERMINATED;
+			} else {
+				takeYieldpoint = 1;
+				// CAS the execStatus field
+				int newState = setBlockedExecStatus();
+				result = newState;
+				if (traceReallyBlock)
+					VM.sysWriteln("Thread #", getCurrentThreadSlot(),
+							" is blocking thread #", threadSlot, " which is in state ",
+							newState);
+				// this broadcast serves two purposes: notifies threads that are
+				// IN_JAVA but waiting on monitor() that they should awake and
+				// acknowledge the block request; or notifies anyone
+				// waiting for this thread to block that the thread is
+				// BLOCKED_IN_NATIVE or BLOCKED_IN_JNI. in the latter case the
+				// broadcast() happens _before_ the setting of the flags that the
+				// other threads would be awaiting, but that is fine, since we're
+				// still holding the lock anyway.
+				monitor().broadcast();
+				if (newState == IN_JAVA_TO_BLOCK) {
+					if (!asynchronous) {
+						if (traceBlock)
+							VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+									" is waiting for thread #", threadSlot, " to block.");
+						while (ba.hasBlockRequest(this, token) && !ba.isBlocked(this) && !isAboutToTerminate) {
+							if (traceBlock)
+								VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+										" is calling wait until thread #", threadSlot, " blocks.");
+							// will this deadlock when the thread dies?
+							if (VM.VerifyAssertions) {
+								// do a timed wait, and assert that the thread did not disappear
+								// into native in the meantime
+								monitor().timedWaitRelativeNoHandshake(1000L * 1000L * 1000L); // 1 sec
+								if (traceReallyBlock) {
+									VM.sysWriteln("Thread #", threadSlot, "'s status is ",
+											getExecStatus());
+								}
+								assertUnacceptableStates(IN_NATIVE);
+							} else {
+								monitor().waitNoHandshake();
+							}
+							if (traceBlock)
+								VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+										" has returned from the wait call.");
+						}
+						if (isAboutToTerminate) {
+							result = TERMINATED;
+						} else {
+							result=getExecStatus();
+						}
+					}
+				} else if (newState == BLOCKED_IN_NATIVE || newState == BLOCKED_IN_JNI) {
+					// we own the thread for now - it cannot go back to executing Java
+					// code until we release the lock. before we do so we change its
+					// state accordingly and tell anyone who is waiting.
+					if (traceBlock)
+						VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+								" has seen thread #", threadSlot,
+								" in native; changing its status accordingly.");
+					ba.clearBlockRequest(this);
+					ba.setBlocked(this, true);
+				}
+			}
+		}
+		safeWait = wsSafeToInstallRBarrier;
+		wsSafeToInstallRBarrier = false;
+		monitor().unlock();
+		if (traceReallyBlock)
+			VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+					" is done telling thread #", threadSlot, " to block.");
+		return safeWait;
+	}
+
+	public boolean blockedFor(BlockAdapter ba) {
+		monitor().lockNoHandshake();
+		boolean result = ba.isBlocked(this);
+		monitor().unlock();
+		return result;
+	}
+
+	@UninterruptibleNoWarn("Never blocks; only asynchronously notifies the receiver to do so")
+	public int asyncBlock(BlockAdapter ba) {
+		if (VM.VerifyAssertions)
+			VM._assert(getCurrentThread() != this);
+		return block(ba, true);
+	}
+
+	@Unpreemptible("May block if the receiver is the current thread or if the receiver is not yet blocked; otherwise does not perform actions that lead to blocking")
+	public int block(BlockAdapter ba) {
+		return block(ba, false);
+	}
+
+	@Unpreemptible("May block if the receiver is the current thread or if the receiver is not yet blocked; otherwise does not perform actions that lead to blocking")
+	private boolean wsBlock(BlockAdapter ba) {
+		return wsBlock(ba, false);
+	}
+
+	@Unpreemptible
+	public void beginPairWith(RVMThread other) {
+		if (traceBlock) VM.sysWriteln("attempting to pair ",threadSlot," with ",other.threadSlot);
+		Monitor.lockWithHandshake(
+				communicationLock(),Word.fromIntSignExtend(threadSlot),
+				other.communicationLock(),Word.fromIntSignExtend(other.threadSlot));
+	}
+
+	public void endPairWith(RVMThread other) {
+		communicationLock().unlock();
+		other.communicationLock().unlock();
+		if (traceBlock) VM.sysWriteln("unpairing ",threadSlot," from ",other.threadSlot);
+	}
+
+	@Unpreemptible
+	public void beginPairWithCurrent() {
+		beginPairWith(getCurrentThread());
+	}
+
+	public void endPairWithCurrent() {
+		endPairWith(getCurrentThread());
+	}
+
+	@Unpreemptible
+	private int safeBlock(BlockAdapter ba, boolean asynchronous) {
+		if (VM.VerifyAssertions)
+			VM._assert(getCurrentThread() != this);
+		beginPairWithCurrent();
+		int result=block(ba,asynchronous);
+		endPairWithCurrent();
+		return result;
+	}
+
+	@Unpreemptible
+	public int safeAsyncBlock(BlockAdapter ba) {
+		return safeBlock(ba, true);
+	}
+
+	@Unpreemptible
+	public int safeBlock(BlockAdapter ba) {
+		if (getCurrentThread()==this) {
+			return block(ba,false);
+		} else {
+			return safeBlock(ba, false);
+		}
+	}
+
+	@Unpreemptible
+	public void beginPairHandshake() {
+		beginPairWithCurrent();
+		block(handshakeBlockAdapter);
+	}
+
+	@Unpreemptible
+	public boolean wsBeginPairHandshake() {
+		beginPairWithCurrent();
+		return wsBlock(handshakeBlockAdapter);
+	}
+
+	@Uninterruptible
+	public void endPairHandshake() {
+		unblock(handshakeBlockAdapter);
+		endPairWithCurrent();
+	}
+
+	/**
+	 * Save the current thread state.  Call this prior to calling enterNative().  You must
+	 * be in a method that is marked BaselineSaveLSRegisters.
+	 */
+	@NoInline
+	public static void saveThreadState() {
+		Address curFP=Magic.getFramePointer();
+		getCurrentThread().contextRegisters.setInnermost(Magic.getReturnAddressUnchecked(curFP),
+				Magic.getCallerFramePointer(curFP));
+	}
+
+	/**
+	 * Indicate that we'd like the current thread to be executing privileged code that
+	 * does not require synchronization with the GC.  This call may be made on a thread
+	 * that is IN_JAVA or IN_JAVA_TO_BLOCK, and will result in the thread being either
+	 * IN_NATIVE or BLOCKED_IN_NATIVE.  In the case of an
+	 * IN_JAVA_TO_BLOCK-&gt;BLOCKED_IN_NATIVE transition, this call will acquire the
+	 * thread's lock and send out a notification to any threads waiting for this thread
+	 * to reach a safepoint.  This notification serves to notify them that the thread
+	 * is in GC-safe code, but will not reach an actual safepoint for an indetermined
+	 * amount of time.  This is significant, because safepoints may perform additional
+	 * actions (such as handling handshake requests, which may include things like
+	 * mutator flushes and running isync) that IN_NATIVE code will not perform until
+	 * returning to IN_JAVA by way of a leaveNative() call.
+	 */
+	@NoInline // so we can get the fp
+	public static void enterNative() {
+		RVMThread t = getCurrentThread();
+		if (ALWAYS_LOCK_ON_STATE_TRANSITION) {
+			t.enterNativeBlocked();
+		} else {
+			int oldState, newState;
+			do {
+				oldState = t.getExecStatus();
+				if (oldState == IN_JAVA) {
+					newState = IN_NATIVE;
+				} else {
+					t.assertAcceptableStates(IN_JAVA_TO_BLOCK);
+					t.enterNativeBlocked();
+					return;
+				}
+			} while (!(t.attemptFastExecStatusTransition(oldState, newState)));
+		}
+		// NB this is not a correct assertion, as there is a race.  we could succeed in
+		// CASing the status to IN_NATIVE, but then someone else could asynchronosly
+		// set it to whatever they want.
+		//if (VM.VerifyAssertions)
+		//  VM._assert(t.execStatus == IN_NATIVE);
+	}
+
+	/**
+	 * Attempt to transition from IN_JNI or IN_NATIVE to IN_JAVA, fail if execStatus is
+	 * anything but IN_JNI or IN_NATIVE.
+	 *
+	 * @return true if thread transitioned to IN_JAVA, otherwise false
+	 */
+	public static boolean attemptLeaveNativeNoBlock() {
+		if (ALWAYS_LOCK_ON_STATE_TRANSITION)
+			return false;
+		RVMThread t = getCurrentThread();
+		int oldState, newState;
+		do {
+			oldState = t.getExecStatus();
+			if (oldState == IN_NATIVE || oldState == IN_JNI) {
+				newState = IN_JAVA;
+			} else {
+				t.assertAcceptableStates(BLOCKED_IN_NATIVE,BLOCKED_IN_JNI);
+				return false;
+			}
+		} while (!(t.attemptFastExecStatusTransition(oldState, newState)));
+		return true;
+	}
+
+	/**
+	 * Leave privileged code.  This is valid for threads that are either IN_NATIVE,
+	 * IN_JNI, BLOCKED_IN_NATIVE, or BLOCKED_IN_JNI, and always results in the thread
+	 * being IN_JAVA.  If the thread was previously BLOCKED_IN_NATIVE or BLOCKED_IN_JNI,
+	 * the thread will block until notified that it can run again.
+	 */
+	@Unpreemptible("May block if the thread was asked to do so; otherwise does no actions that would lead to blocking")
+	public static void leaveNative() {
+		if (!attemptLeaveNativeNoBlock()) {
+			if (traceReallyBlock) {
+				VM.sysWriteln("Thread #", getCurrentThreadSlot(),
+						" is leaving native blocked");
+			}
+			getCurrentThread().leaveNativeBlocked();
+		}
+	}
+
+	public static void enterJNIFromCallIntoNative() {
+		// FIXME: call these in PPC instead of doing it in machine code...
+		getCurrentThread().observeExecStatus();
+		if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JAVA,
+				RVMThread.IN_JNI)) {
+			RVMThread.enterJNIBlockedFromCallIntoNative();
+		}
+	}
+
+	@Unpreemptible
+	public static void leaveJNIFromCallIntoNative() {
+		// FIXME: call these in PPC instead of doing it in machine code...
+		getCurrentThread().observeExecStatus();
+		if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JNI,
+				RVMThread.IN_JAVA)) {
+			RVMThread.leaveJNIBlockedFromCallIntoNative();
+		}
+	}
+
+	public static void enterJNIFromJNIFunctionCall() {
+		// FIXME: call these instead of doing it in machine code...  currently this
+		// is never called.
+		getCurrentThread().observeExecStatus();
+		if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JAVA,
+				RVMThread.IN_JNI)) {
+			RVMThread.enterJNIBlockedFromJNIFunctionCall();
+		}
+	}
+
+	@Unpreemptible
+	public static void leaveJNIFromJNIFunctionCall() {
+		// FIXME: call these instead of doing it in machine code...  currently this
+		// is never called.
+		getCurrentThread().observeExecStatus();
+		if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JNI,
+				RVMThread.IN_JAVA)) {
+			RVMThread.leaveJNIBlockedFromJNIFunctionCall();
+		}
+	}
+
+	public void unblock(BlockAdapter ba) {
+		if (traceBlock)
+			VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+					" is requesting that thread #", threadSlot, " unblocks.");
+		monitor().lockNoHandshake();
+		ba.clearBlockRequest(this);
+		ba.setBlocked(this, false);
+		monitor().broadcast();
+		monitor().unlock();
+		if (traceBlock)
+			VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+					" is done requesting that thread #", threadSlot, " unblocks.");
+	}
+
+	private void handleDebugRequestForThread() {
+		monitor().lockNoHandshake();
+		dumpLock.lockNoHandshake();
+		extDump();
+		if (!isAboutToTerminate) {
+			setBlockedExecStatus();
+			if (isInJava()) {
+				asyncDebugRequestedForThisThread = true;
+				takeYieldpoint = 1;
+				VM.sysWriteln("(stack trace will follow if thread is not lost...)");
+			} else {
+				if (contextRegisters != null) {
+					dumpStack(contextRegisters.getInnermostFramePointer());
+				} else {
+					VM.sysWriteln("(cannot dump stack trace; thread is not running in Java but has no contextRegisters)");
+				}
+			}
+		}
+		dumpLock.unlock();
+		monitor().unlock();
+	}
+
+	@NoCheckStore
+	public static void checkDebugRequest() {
+		if (debugRequested) {
+			debugLock.lockNoHandshake();
+			if (debugRequested) {
+				debugRequested = false;
+				VM.sysWriteln("=== Debug requested - attempting safe VM dump ===");
+				dumpAcct();
+				reportThreadTransitionCounts();
+
+				// FIXME: this code runs concurrently to GC and has no way of stopping
+				// it.  hence it is dangerous.  leaving it as-is for now, since it's
+				// only meant to be used for debugging.
+
+				VM.sysWriteln("Timer ticks = ", timerTicks);
+				doProfileReport.openNoHandshake();
+				// snapshot the threads
+				acctLock.lockNoHandshake();
+				int numDebugThreads = numThreads;
+				for (int i = 0; i < numThreads; ++i) {
+					debugThreads[i] = threads[i];
+				}
+				acctLock.unlock();
+				// do the magic
+				for (int i = 0; i < numDebugThreads; ++i) {
+					debugThreads[i].handleDebugRequestForThread();
+					debugThreads[i] = null;
+				}
+			}
+			debugLock.unlock();
+		}
+	}
+
+	void timerTick() {
+		if (shouldBeSampled()) {
+			timeSliceExpired++;
+			takeYieldpoint=1;
+		}
+	}
+
+	/** Are we allowed to take yieldpoints? */
+	@Inline
+	public boolean yieldpointsEnabled() {
+		return yieldpointsEnabledCount == 1;
+	}
+
+	/** Enable yieldpoints on this thread. */
+	public void enableYieldpoints() {
+		++yieldpointsEnabledCount;
+		if (VM.VerifyAssertions)
+			VM._assert(yieldpointsEnabledCount <= 1);
+		if (yieldpointsEnabled() && yieldpointRequestPending) {
+			takeYieldpoint = 1;
+			yieldpointRequestPending = false;
+		}
+	}
+
+	/** Disable yieldpoints on this thread. */
+	public void disableYieldpoints() {
+		--yieldpointsEnabledCount;
+	}
+
+	/**
+	 * Fail if yieldpoints are disabled on this thread
+	 */
+	public void failIfYieldpointsDisabled() {
+		if (!yieldpointsEnabled()) {
+			VM.sysWrite("No yieldpoints on thread ", threadSlot);
+			VM.sysWrite(" with addr ", Magic.objectAsAddress(this));
+			VM.sysWriteln();
+			VM.sysFail("Yieldpoints are disabled on this thread!");
+		}
+	}
+
+	/**
+	 * @return The currently executing thread
+	 */
+	@Uninterruptible
+	public static RVMThread getCurrentThread() {
+		return ThreadLocalState.getCurrentThread();
+	}
+
+	/**
+	 * @return the unique slot of the currently executing thread
+	 */
+	public static int getCurrentThreadSlot() {
+		return getCurrentThread().threadSlot;
+	}
+
+	/**
+	 * @return the slot of this thread
+	 */
+	public int getThreadSlot() {
+		return threadSlot;
+	}
+
+	/**
+	 * Called during booting to give the boot thread a java.lang.Thread
+	 */
+	@Interruptible
+	public void setupBootJavaThread() {
+		thread = java.lang.JikesRVMSupport.createThread(this,
+				"Jikes_RVM_Boot_Thread");
+	}
+
+	/**
+	 * String representation of thread
+	 */
+	@Override
+	public String toString() {
+		return name;
+	}
+
+	/**
+	 * Get the current java.lang.Thread.
+	 */
+	public Thread getJavaLangThread() {
+		return thread;
+	}
+
+	/**
+	 * Get current thread's JNI environment.
+	 */
+	public JNIEnvironment getJNIEnv() {
+		return jniEnv;
+	}
+
+	/** Get the disable GC depth */
+	public int getDisableGCDepth() {
+		return disableGCDepth;
+	}
+
+	/** Modify the disable GC depth */
+	public void setDisableGCDepth(int d) {
+		disableGCDepth = d;
+	}
+
+	/** Are allocations allowed by this thread? */
+	public boolean getDisallowAllocationsByThisThread() {
+		return disallowAllocationsByThisThread;
+	}
+
+	/** Disallow allocations by this thread */
+	public void setDisallowAllocationsByThisThread() {
+		disallowAllocationsByThisThread = true;
+	}
+
+	/** Allow allocations by this thread */
+	public void clearDisallowAllocationsByThisThread() {
+		disallowAllocationsByThisThread = false;
+	}
+
+	/**
+	 * Initialize JNI environment for system threads. Called by VM.finishBooting
+	 */
+	@Interruptible
+	public void initializeJNIEnv() {
+		this.jniEnv = this.jniEnvShadow = new JNIEnvironment();
+	}
+
+	/**
+	 * Indicate whether the stack of this Thread contains any C frame (used in
+	 * RuntimeEntrypoints.deliverHardwareException for stack resize)
+	 *
+	 * @return false during the prolog of the first Java to C transition true
+	 *         afterward
+	 */
+	public boolean hasNativeStackFrame() {
+		return jniEnv != null && jniEnv.hasNativeStackFrame();
+	}
+
+	/*
+	 * Starting and ending threads
+	 */
+
+	/**
+	 * Method to be executed when this thread starts running. Calls
+	 * java.lang.Thread.run but system threads can override directly.
+	 */
+	@Interruptible
+	@Entrypoint
+	public void run() {
+		try {
+			synchronized (thread) {
+				Throwable t = java.lang.JikesRVMSupport.getStillBorn(thread);
+				if (t != null) {
+					java.lang.JikesRVMSupport.setStillBorn(thread, null);
+					throw t;
+				}
+			}
+			thread.run();
+		} catch (Throwable t) {
+			if (traceAcct) {
+				VM.sysWriteln("Thread ",getThreadSlot()," exiting with exception.");
+			}
+			try {
+				Thread.UncaughtExceptionHandler handler;
+				handler = thread.getUncaughtExceptionHandler();
+				handler.uncaughtException(thread, t);
+			} catch (Throwable ignore) {
+			}
+		}
+	}
+	
+	/*
+	 * Methods for pinning threads to cores
+	 */
+	
+	protected static int pin_core_index = 0;
+	@Interruptible
+	private synchronized static int getNextCoreID() {
+		int id = pin_core_index++;
+		if(id == sysCall.sysNumProcessors()) {
+			id = pin_core_index = 0;
+		}
+		return id;
+	}
+	
+	/*
+	 * This method only support when -Xws:pinSocketCPU is provided
+	 * and also hyperthreading is ON
+	 * 
+	 * A typical layout, which this supports is:
+	 * 	
+	  	$ numactl --hardware
+		available: 2 nodes (0-1)
+		node 0 cpus: 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30
+		node 0 size: 24530 MB
+		node 0 free: 208 MB
+		node 1 cpus: 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31
+		node 1 size: 24576 MB
+		node 1 free: 85 MB
+		node distances:
+		node   0   1 
+  		0:  10  20 
+  		1:  20  10 
+	 */
+	private static int[] multiSocket_physical_cores_inhyperthreading = new int[0];
+	@Interruptible
+	private synchronized static int getNextCoreID_socketAndCPUHint() {
+		/*
+		 *  The implementation of this method assumes the hyperthreading is ON.
+		 *  In case hyperthreading is OFF, use the -Xws:pinMap option 
+		 *  to hint the pin core ids.
+		 *  This function will fail in that case !!
+		 */
+		if(multiSocket_physical_cores_inhyperthreading.length == 0) {
+			final int physical_cores = cpusPerSocket * sockets;
+			multiSocket_physical_cores_inhyperthreading = new int[physical_cores];
+			// assuming even number of total processors
+			int curr_cpu = 0;
+			int curr_socket = 0;
+			for(int i=0; i<physical_cores; i++) {
+				if(i == cpusPerSocket*(curr_socket+1)) curr_cpu = ++curr_socket;
+				multiSocket_physical_cores_inhyperthreading[i] = curr_cpu;
+				curr_cpu += 2;
+			}
+		}
+		
+		int id = pin_core_index++;
+		if(id == multiSocket_physical_cores_inhyperthreading.length) {
+			id = pin_core_index = 0;
+		}
+		return multiSocket_physical_cores_inhyperthreading[id];
+	}
+	
+	/*
+	 *  This is used only when a exact pinMap is provided at runtime
+	 */
+	@Interruptible
+	private synchronized static int getNextCoreID_fromPinMap() {
+		int id = pin_core_index++;
+		if(id == pin_map_workers.length) {
+			id = pin_core_index = 0;
+		}
+		return pin_map_workers[id];
+	}
+
+	/**
+	 * Begin execution of current thread by calling its "run" method. This method
+	 * is at the bottom of all created method's stacks.
+	 */
+	@Interruptible
+	@SuppressWarnings({ "unused" })
+	// Called by back-door methods.
+	private static void startoff() {
+		bindIfRequested();
+
+		sysCall.sysSetupHardwareTrapHandler();
+
+		RVMThread currentThread = getCurrentThread();
+
+		currentThread.perfEventAttach();
+
+		/*
+		 * get pthread_id from the operating system and store into RVMThread field
+		 */
+		currentThread.thread_id = sysCall.sysGetThreadId();
+		currentThread.enableYieldpoints();
+		sysCall.sysStashVMThread(currentThread);
+		if (traceAcct) {
+			VM.sysWriteln("Thread #", currentThread.threadSlot, " with pthread id ",
+					currentThread.thread_id, " running!");
+		}
+
+		if (trace) {
+			VM.sysWriteln("Thread.startoff(): about to call ", currentThread.toString(), ".run()");
+		}
+
+		try {
+			if (currentThread.systemThread != null) {
+				if(currentThread.isCollectorThread() && ws_pinning_gc) {
+					if(currentThread.getName().contains("org.mmtk.plan.generational")) {
+						final int index = currentThread.getCollectorContext().getId();
+						sysCall.wsThreadBindMaskSet(pin_map_gc[index]);
+					}
+				}
+				else if(ws_pinning_system) {
+					sysCall.sysThreadBindMaskSet();
+				}
+				if(WS.pinLog) {
+					VM.sysWriteln("[PIN_INFO] RVM-", currentThread.getName() ," has affinity for cpuid-",sysCall.sysGetCPU());
+				}
+				currentThread.systemThread.run();
+			} else {
+				// this is an application thread
+				if(ws_pinning_workers) {
+					// pin to the core
+					int core = 0;
+					if(RVMThread.pin_map_workers.length > 1) {
+						core = getNextCoreID_fromPinMap();
+					}
+					else if(sockets != -1 && cpusPerSocket != -1) {
+						core = getNextCoreID_socketAndCPUHint();
+					}
+					else {
+						core = getNextCoreID();
+					}
+					sysCall.wsThreadBindMaskSet(core);
+				}
+				if(WS.pinLog) VM.sysWriteln("[PIN_INFO] ", currentThread.getName() ," has affinity for cpuid-",sysCall.sysGetCPU());
+				currentThread.run();
+				if(autogenWSThread) WS.terminate();
+			}
+		} finally {
+			if (trace) {
+				VM.sysWriteln("Thread.startoff(): finished ", currentThread.toString(), ".run()");
+			}
+			currentThread.terminate();
+			if (VM.VerifyAssertions)
+				VM._assert(VM.NOT_REACHED);
+		}
+	}
+
+	/**
+	 * Start execution of 'this' by putting it on the appropriate queue of an
+	 * unspecified virtual processor.
+	 */
+	@Interruptible
+	public void start() {
+		// N.B.: cannot hit a yieldpoint between setting execStatus and starting the
+		// thread!!
+		setExecStatus(IN_JAVA);
+		acctLock.lockNoHandshake();
+		numActiveThreads++;
+		if (daemon) {
+			numActiveDaemons++;
+		}
+		acctLock.unlock();
+		if (traceAcct)
+			VM.sysWriteln("Thread #", threadSlot, " starting!");
+		sysCall.sysThreadCreate(Magic.objectAsAddress(this),
+				contextRegisters.ip, contextRegisters.getInnermostFramePointer());
+	}
+
+	/**
+	 * Terminate execution of current thread by abandoning all references to it
+	 * and resuming execution in some other (ready) thread.
+	 */
+	@Interruptible
+	public void terminate() {
+		if (traceAcct)
+			VM.sysWriteln("in terminate() for Thread #", threadSlot);
+		if (VM.VerifyAssertions)
+			VM._assert(getCurrentThread() == this);
+		boolean terminateSystem = false;
+		if (traceTermination) {
+			VM.disableGC();
+			VM.sysWriteln("[ BEGIN Verbosely dumping stack at time of thread termination");
+			dumpStack();
+			VM.sysWriteln("END Verbosely dumping stack at time of creating thread termination ]");
+			VM.enableGC();
+		}
+
+		// allow java.lang.Thread.exit() to remove this thread from ThreadGroup
+		java.lang.JikesRVMSupport.threadDied(thread);
+
+		TraceEngine.engine.removeFeedlet(feedlet);
+
+		if (VM.VerifyAssertions) {
+			if (Lock.countLocksHeldByThread(getLockingId()) > 0) {
+				VM.sysWriteln("Error, thread terminating holding a lock");
+				RVMThread.dumpVirtualMachine();
+			}
+		}
+
+		if (traceAcct)
+			VM.sysWriteln("doing accounting...");
+		acctLock.lockNoHandshake();
+
+		// if the thread terminated because of an exception, remove
+		// the mark from the exception register object, or else the
+		// garbage collector will attempt to relocate its ip field.
+		exceptionRegisters.inuse = false;
+
+		numActiveThreads -= 1;
+		if (daemon) {
+			numActiveDaemons -= 1;
+		}
+		if (traceAcct)
+			VM.sysWriteln("active = ", numActiveThreads, ", daemons = ",
+					numActiveDaemons);
+		if ((numActiveDaemons == numActiveThreads) && (VM.mainThread != null) && VM.mainThread.launched) {
+			// no non-daemon thread remains and the main thread was launched
+			terminateSystem = true;
+		}
+		if (terminateSystem) {
+			if (systemShuttingDown == false) {
+				systemShuttingDown = true;
+			} else {
+				terminateSystem = false;
+			}
+		}
+		if (traceTermination) {
+			VM.sysWriteln("Thread.terminate: myThread.daemon = ", daemon);
+			VM.sysWriteln("  RVMThread.numActiveThreads = ",
+					RVMThread.numActiveThreads);
+			VM.sysWriteln("  RVMThread.numActiveDaemons = ",
+					RVMThread.numActiveDaemons);
+			VM.sysWriteln("  terminateSystem = ", terminateSystem);
+		}
+
+		acctLock.unlock();
+
+		if (traceAcct)
+			VM.sysWriteln("done with accounting.");
+
+		if (terminateSystem) {
+			if (traceAcct)
+				VM.sysWriteln("terminating system.");
+			if (uncaughtExceptionCount > 0)
+			/* Use System.exit so that any shutdown hooks are run. */{
+				if (VM.TraceExceptionDelivery) {
+					VM.sysWriteln("Calling sysExit due to uncaught exception.");
+				}
+				callSystemExit(VM.EXIT_STATUS_DYING_WITH_UNCAUGHT_EXCEPTION);
+			} else if (thread instanceof MainThread) {
+				MainThread mt = (MainThread) thread;
+				if (!mt.launched) {
+					/*
+					 * Use System.exit so that any shutdown hooks are run. It is possible
+					 * that shutdown hooks may be installed by static initializers which
+					 * were run by classes initialized before we attempted to run the main
+					 * thread. (As of this writing, 24 January 2005, the Classpath
+					 * libraries do not do such a thing, but there is no reason why we
+					 * should not support this.) This was discussed on
+					 * jikesrvm-researchers on 23 Jan 2005 and 24 Jan 2005.
+					 */
+					callSystemExit(VM.EXIT_STATUS_MAIN_THREAD_COULD_NOT_LAUNCH);
+				}
+			}
+			/* Use System.exit so that any shutdown hooks are run. */
+			callSystemExit(0);
+			if (VM.VerifyAssertions)
+				VM._assert(VM.NOT_REACHED);
+		}
+
+		if (traceAcct)
+			VM.sysWriteln("making joinable...");
+
+		// this works.  we use synchronized because we cannot use the thread's
+		// monitor().  see comment in join().  this is fine, because we're still
+		// "running" from the standpoint of GC.
+		synchronized (this) {
+			isJoinable = true;
+			notifyAll();
+		}
+		if (traceAcct)
+			VM.sysWriteln("Thread #", threadSlot, " is joinable.");
+
+		if (traceAcct)
+			VM.sysWriteln("making joinable...");
+
+		// Switch to uninterruptible portion of termination
+		terminateUnpreemptible();
+	}
+
+	/**
+	 * Call System.exit() with the correct security status.
+	 *
+	 * @param exitStatus
+	 */
+	@Interruptible
+	private void callSystemExit(final int exitStatus) {
+		AccessController.doPrivileged(new PrivilegedAction<Object>() {
+			@Override
+			public Object run() {
+				System.exit(exitStatus);
+				return null;
+			}
+		});
+	}
+
+	/**
+	 * Unpreemptible portion of thread termination. Unpreemptible to avoid a dead
+	 * thread from being scheduled.
+	 */
+	@Unpreemptible
+	private void terminateUnpreemptible() {
+		// return cached free lock
+		if (traceAcct)
+			VM.sysWriteln("returning cached lock...");
+
+		if (cachedFreeLock != null) {
+			if (Lock.trace) {
+				VM.sysWriteln("Thread #", threadSlot, ": about to free lock ",
+						Magic.objectAsAddress(cachedFreeLock));
+			}
+			if (VM.VerifyAssertions)
+				VM._assert(cachedFreeLock.mutex.latestContender != this);
+			Lock.returnLock(cachedFreeLock);
+			cachedFreeLock = null;
+		}
+
+		if (traceAcct)
+			VM.sysWriteln("adding to aboutToTerminate...");
+
+		addAboutToTerminate();
+		// NB we can no longer do anything that would lead to write barriers or
+		// GC
+
+		if (traceAcct) {
+			VM.sysWriteln("acquireCount for my monitor: ", monitor().acquireCount);
+			VM.sysWriteln("timer ticks: ", timerTicks);
+			VM.sysWriteln("yieldpoints taken: ", yieldpointsTaken);
+			VM.sysWriteln("yieldpoints taken fully: ", yieldpointsTakenFully);
+		}
+		if (traceAcct)
+			VM.sysWriteln("finishing thread termination...");
+
+		finishThreadTermination();
+	}
+
+	/** Uninterruptible final portion of thread termination. */
+	void finishThreadTermination() {
+		sysCall.sysThreadTerminate();
+		if (VM.VerifyAssertions)
+			VM._assert(VM.NOT_REACHED);
+	}
+
+	/*
+	 * Support for yieldpoints
+	 */
+
+	/**
+	 * Yieldpoint taken in prologue.
+	 */
+	@BaselineSaveLSRegisters
+	// Save all non-volatile registers in prologue
+	@NoOptCompile
+	@NoInline
+	// We should also have a pragma that saves all non-volatiles in opt compiler,
+	// BaselineExecuctionStateExtractor.java, should then restore all
+	// non-volatiles before stack replacement
+	// TODO fix this -- related to SaveVolatile
+	@Entrypoint
+	@Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
+	public static void yieldpointFromPrologue() {
+		Address fp = Magic.getFramePointer();
+		yieldpoint(PROLOGUE, fp);
+	}
+
+	/**
+	 * Yieldpoint taken on backedge.
+	 */
+	@BaselineSaveLSRegisters
+	// Save all non-volatile registers in prologue
+	@NoOptCompile
+	@NoInline
+	// We should also have a pragma that saves all non-volatiles in opt compiler,
+	// BaselineExecuctionStateExtractor.java, should then restore all
+	// non-volatiles before stack replacement
+	// TODO fix this -- related to SaveVolatile
+	@Entrypoint
+	@Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
+	public static void yieldpointFromBackedge() {
+		Address fp = Magic.getFramePointer();
+		yieldpoint(BACKEDGE, fp);
+	}
+
+	/**
+	 * Dump the specified frame in a format useful for debugging the stack
+	 * trampoline
+	 *
+	 * @param fp The frame to be dumped.
+	 */
+	private static void dumpFrame(Address fp) {
+		Address sp = fp.minus(40);
+		VM.sysWriteln("--");
+		Address nextFp = Magic.getCallerFramePointer(fp);
+		while (sp.LE(nextFp)) {
+			VM.sysWrite("["); VM.sysWrite(sp); VM.sysWrite("]");
+			if (sp.EQ(fp) || sp.EQ(nextFp)) VM.sysWrite("* ");
+			else if (sp.EQ(fp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET)) || sp.EQ(nextFp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET))) VM.sysWrite("R ");
+			else if (sp.EQ(fp.plus(STACKFRAME_METHOD_ID_OFFSET)) || sp.EQ(nextFp.plus(STACKFRAME_METHOD_ID_OFFSET))) VM.sysWrite("M ");
+			else VM.sysWrite(" ");
+			VM.sysWriteln(sp.loadInt());
+			sp = sp.plus(4);
+		}
+	}
+
+	/**
+	 * @return the caller of the frame in which the trampoline is installed (STACKFRAME_SENTINEL_FP by default)
+	 */
+	public Address getNextUnencounteredFrame() {
+		return hijackedReturnCallerFp.EQ(ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP) ? hijackedReturnCallerFp : Magic.getCallerFramePointer(hijackedReturnCallerFp);
+	}
+
+	/**
+	 * Yieldpoint taken in epilogue.
+	 */
+	@BaselineSaveLSRegisters
+	// Save all non-volatile registers in prologue
+	@NoOptCompile
+	@NoInline
+	// We should also have a pragma that saves all non-volatiles in opt compiler,
+	// BaselineExecutionStateExtractor.java, should then restore all non-volatiles
+	// before stack replacement
+	// TODO fix this -- related to SaveVolatile
+	@Entrypoint
+	@Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
+	public static void yieldpointFromEpilogue() {
+		Address fp = Magic.getFramePointer();
+		yieldpoint(EPILOGUE, fp);
+	}
+
+	/*
+	 * Support for suspend/resume
+	 */
+
+	/**
+	 * Suspend execution of current thread until it is resumed. Call only if
+	 * caller has appropriate security clearance.
+	 */
+	@UnpreemptibleNoWarn("Exceptions may possibly cause yields")
+	public void suspend() {
+		if (false) VM.sysWriteln("Thread #",getCurrentThreadSlot()," suspending Thread #",getThreadSlot());
+		ObjectModel.genericUnlock_internal(thread);
+		Throwable rethrow = null;
+		try {
+			observeExecStatus();
+			if (execStatus != IN_JAVA && execStatus != IN_JAVA_TO_BLOCK &&
+					execStatus != IN_NATIVE && execStatus != BLOCKED_IN_NATIVE &&
+					execStatus != BLOCKED_IN_JNI && execStatus != IN_JNI) {
+				throw new IllegalThreadStateException(
+						"Cannot suspend a thread that is not running.");
+			}
+			block(suspendBlockAdapter);
+		} catch (Throwable t) {
+			rethrow = t;
+		}
+		ObjectModel.genericLock_internal(thread);
+		if (rethrow != null)
+			RuntimeEntrypoints.athrow(rethrow);
+	}
+
+	/**
+	 * Resume execution of a thread that has been suspended. Call only if caller
+	 * has appropriate security clearance.
+	 */
+	@Interruptible
+	public void resume() {
+		unblock(suspendBlockAdapter);
+	}
+
+	public static void yieldNoHandshake() {
+		sysCall.sysThreadYield();
+	}
+
+	@UnpreemptibleNoWarn
+	public static void yieldWithHandshake() {
+		getCurrentThread().checkBlock();
+		sysCall.sysThreadYield();
+	}
+	/**
+	 * Suspend execution of current thread for specified number of seconds (or
+	 * fraction).
+	 */
+	@Interruptible
+	public static void sleep(long ns) throws InterruptedException {
+		RVMThread t = getCurrentThread();
+		t.waiting = Waiting.TIMED_WAITING;
+		long atStart = sysCall.sysNanoTime();
+		long whenEnd = atStart + ns;
+		t.monitor().lockNoHandshake();
+		while (!t.hasInterrupt && t.asyncThrowable == null &&
+				sysCall.sysNanoTime() < whenEnd) {
+			t.monitor().timedWaitAbsoluteWithHandshake(whenEnd);
+		}
+		boolean throwInterrupt = false;
+		Throwable throwThis = null;
+		if (t.hasInterrupt) {
+			t.hasInterrupt = false;
+			throwInterrupt = true;
+		}
+		if (t.asyncThrowable != null) {
+			throwThis = t.asyncThrowable;
+			t.asyncThrowable = null;
+		}
+		t.monitor().unlock();
+		t.waiting = Waiting.RUNNABLE;
+		if (throwThis != null) {
+			RuntimeEntrypoints.athrow(throwThis);
+		}
+		if (throwInterrupt) {
+			throw new InterruptedException("sleep interrupted");
+		}
+	}
+
+	/**
+	 * Suspend execution of current thread for specified number of seconds (or
+	 * fraction).
+	 */
+	@Interruptible
+	public static void sleep(long millis, int ns) throws InterruptedException {
+		sleep(ns + millis * 1000L * 1000L);
+	}
+
+	/*
+	 * Wait and notify support
+	 */
+
+	@Interruptible
+	void waitImpl(Object o, boolean hasTimeout, long whenWakeupNanos) {
+		boolean throwInterrupt = false;
+		Throwable throwThis = null;
+		if (asyncThrowable != null) {
+			throwThis = asyncThrowable;
+			asyncThrowable = null;
+		} else if (!ObjectModel.holdsLock(o, this)) {
+			throw new IllegalMonitorStateException("waiting on " + o);
+		} else if (hasInterrupt) {
+			throwInterrupt = true;
+			hasInterrupt = false;
+		} else {
+			waiting = hasTimeout ? Waiting.TIMED_WAITING : Waiting.WAITING;
+			// get lock for object
+			Lock l = ObjectModel.getHeavyLock(o, true);
+
+			// release the lock
+			l.mutex.lock();
+			// this thread is supposed to own the lock on o
+			if (VM.VerifyAssertions) VM._assert(l.getOwnerId() == getLockingId());
+			RVMThread toAwaken = l.entering.dequeue();
+			waitObject = l.getLockedObject();
+			waitCount = l.getRecursionCount();
+			l.setOwnerId(0);
+			l.waiting.enqueue(this);
+			l.mutex.unlock();
+
+			// if there was a thread waiting, awaken it
+			if (toAwaken != null) {
+				// is this where the problem is coming from?
+				toAwaken.monitor().lockedBroadcastNoHandshake();
+			}
+			// block
+			monitor().lockNoHandshake();
+			while (l.waiting.isQueued(this) && !hasInterrupt && asyncThrowable == null &&
+					(!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
+				if (hasTimeout) {
+					monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
+				} else {
+					monitor().waitWithHandshake();
+				}
+			}
+			// figure out if anything special happened while we were blocked
+			if (hasInterrupt) {
+				throwInterrupt = true;
+				hasInterrupt = false;
+			}
+			if (asyncThrowable != null) {
+				throwThis = asyncThrowable;
+				asyncThrowable = null;
+			}
+			monitor().unlock();
+			if (l.waiting.isQueued(this)) {
+				l.mutex.lock();
+				l.waiting.remove(this); /*
+				 * in case we got here due to an interrupt or a
+				 * stop() rather than a notify
+				 */
+				l.mutex.unlock();
+				// Note that the above must be done before attempting to acquire
+				// the lock, since acquiring the lock may require queueing the thread.
+				// But we cannot queue the thread if it is already on another
+				// queue.
+			}
+			// reacquire the lock, restoring the recursion count
+			ObjectModel.genericLock_internal(o);
+			waitObject = null;
+			if (waitCount != 1) { // reset recursion count
+				Lock l2 = ObjectModel.getHeavyLock(o, true);
+				l2.setRecursionCount(waitCount);
+			}
+			waiting = Waiting.RUNNABLE;
+		}
+		// check if we should exit in a special way
+		if (throwThis != null) {
+			RuntimeEntrypoints.athrow(throwThis);
+		}
+		if (throwInterrupt) {
+			RuntimeEntrypoints.athrow(new InterruptedException("sleep interrupted"));
+		}
+	}
+
+	/**
+	 * Support for Java {@link java.lang.Object#wait()} synchronization primitive.
+	 *
+	 * @param o
+	 *          the object synchronized on
+	 */
+	@Interruptible
+	/* only loses control at expected points -- I think -dave */
+	public static void wait(Object o) {
+		getCurrentThread().waitImpl(o, false, 0);
+	}
+
+	/**
+	 * Support for Java {@link java.lang.Object#wait()} synchronization primitive.
+	 *
+	 * @param o
+	 *          the object synchronized on
+	 * @param millis
+	 *          the number of milliseconds to wait for notification
+	 */
+	@Interruptible
+	public static void wait(Object o, long millis) {
+		long currentNanos = sysCall.sysNanoTime();
+		getCurrentThread().waitImpl(o, true, currentNanos + millis * 1000 * 1000);
+	}
+
+	/**
+	 * Support for RTSJ- and pthread-style absolute wait.
+	 *
+	 * @param o
+	 *          the object synchronized on
+	 * @param whenNanos
+	 *          the absolute time in nanoseconds when we should wake up
+	 */
+	@Interruptible
+	public static void waitAbsoluteNanos(Object o, long whenNanos) {
+		getCurrentThread().waitImpl(o, true, whenNanos);
+	}
+
+	@UnpreemptibleNoWarn("Possible context when generating exception")
+	public static void raiseIllegalMonitorStateException(String msg, Object o) {
+		throw new IllegalMonitorStateException(msg + (o == null ? "<null>" : o.toString()));
+	}
+
+	/**
+	 * Support for Java {@link java.lang.Object#notify()} synchronization
+	 * primitive.
+	 *
+	 * @param o the object synchronized on
+	 */
+	@Interruptible
+	public static void notify(Object o) {
+		if (STATS)
+			notifyOperations++;
+		Lock l = ObjectModel.getHeavyLock(o, false);
+		if (l == null)
+			return;
+		// the reason for locking: when inflating a lock we *first* install it in the status
+		// word and *then* initialize its state.  but fortunately, we do so while holding
+		// the lock's mutex.  thus acquiring the lock's mutex is the only way to ensure that
+		// we see the lock's state after initialization.
+		l.mutex.lock();
+		int owner=l.getOwnerId();
+		l.mutex.unlock();
+		int me=getCurrentThread().getLockingId();
+		if (owner != me) {
+			raiseIllegalMonitorStateException("notifying (expected lock to be held by "+me+"("+getCurrentThread().getLockingId()+") but was held by "+owner+"("+l.getOwnerId()+")) ", o);
+		}
+		l.mutex.lock();
+		RVMThread toAwaken = l.waiting.dequeue();
+		l.mutex.unlock();
+		if (toAwaken != null) {
+			toAwaken.monitor().lockedBroadcastNoHandshake();
+		}
+	}
+
+	/**
+	 * Support for Java synchronization primitive.
+	 *
+	 * @param o the object synchronized on
+	 * @see java.lang.Object#notifyAll
+	 */
+	@Interruptible
+	public static void notifyAll(Object o) {
+		if (STATS)
+			notifyAllOperations++;
+		Lock l = ObjectModel.getHeavyLock(o, false);
+		if (l == null)
+			return;
+		l.mutex.lock();
+		int owner=l.getOwnerId();
+		l.mutex.unlock();
+		if (owner != getCurrentThread().getLockingId()) {
+			raiseIllegalMonitorStateException("notifying all (expected lock to be held by "+getCurrentThread().getLockingId()+" but was held by "+l.getOwnerId()+") ", o);
+		}
+		for (;;) {
+			l.mutex.lock();
+			RVMThread toAwaken = l.waiting.dequeue();
+			l.mutex.unlock();
+			if (toAwaken == null)
+				break;
+			toAwaken.monitor().lockedBroadcastNoHandshake();
+		}
+	}
+
+	public void stop(Throwable cause) {
+		monitor().lockNoHandshake();
+		asyncThrowable = cause;
+		takeYieldpoint = 1;
+		monitor().broadcast();
+		monitor().unlock();
+	}
+
+	/*
+	 * Park and unpark support
+	 */
+	@Interruptible
+	public void park(boolean isAbsolute, long time) throws Throwable {
+		if (parkingPermit) {
+			// fast path
+			parkingPermit = false;
+			Magic.sync();
+			return;
+		}
+		// massive retardation. someone might be holding the java.lang.Thread lock.
+		boolean holdsLock = holdsLock(thread);
+		if (holdsLock)
+			ObjectModel.genericUnlock_internal(thread);
+		boolean hasTimeout;
+		long whenWakeupNanos;
+		hasTimeout = (time != 0);
+		if (isAbsolute) {
+			whenWakeupNanos = time;
+		} else {
+			whenWakeupNanos = sysCall.sysNanoTime() + time;
+		}
+		Throwable throwThis = null;
+		monitor().lockNoHandshake();
+		waiting = hasTimeout ? Waiting.TIMED_WAITING : Waiting.WAITING;
+		while (!parkingPermit && !hasInterrupt && asyncThrowable == null &&
+				(!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
+			if (hasTimeout) {
+				monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
+			} else {
+				monitor().waitWithHandshake();
+			}
+		}
+		waiting = Waiting.RUNNABLE;
+		parkingPermit = false;
+		if (asyncThrowable != null) {
+			throwThis = asyncThrowable;
+			asyncThrowable = null;
+		}
+		monitor().unlock();
+
+		if (holdsLock)
+			ObjectModel.genericLock_internal(thread);
+
+		if (throwThis != null) {
+			throw throwThis;
+		}
+	}
+
+	@Interruptible
+	public void unpark() {
+		monitor().lockNoHandshake();
+		parkingPermit = true;
+		monitor().broadcast();
+		monitor().unlock();
+	}
+
+	/**
+	 * Get this thread's id for use in lock ownership tests. This is just the
+	 * thread's slot as returned by {@link #getThreadSlot()}, shifted appropriately
+	 * so it can be directly used in the ownership tests.
+	 */
+	public int getLockingId() {
+		return lockingId;
+	}
+
+	@Uninterruptible
+	public static class SoftHandshakeVisitor {
+		/**
+		 * Set whatever flags need to be set to signal that the given thread should
+		 * perform some action when it acknowledges the soft handshake. If not
+		 * interested in this thread, return false; otherwise return true. Returning
+		 * true will cause a soft handshake request to be put through.
+		 * <p>
+		 * This method is called with the thread's monitor() held, but while the
+		 * thread may still be running. This method is not called on mutators that
+		 * have indicated that they are about to terminate.
+		 */
+		public boolean checkAndSignal(RVMThread t) {
+			return true;
+		}
+
+		/**
+		 * Called when it is determined that the thread is stuck in native. While
+		 * this method is being called, the thread cannot return to running Java
+		 * code. As such, it is safe to perform actions "on the thread's behalf".
+		 */
+		public void notifyStuckInNative(RVMThread t) {
+		}
+
+		/**
+		 * Check whether to include the specified thread in the soft handshake.
+		 *
+		 * @param t The thread to check for inclusion
+		 * @return True if the thread should be included.
+		 */
+		public boolean includeThread(RVMThread t) {
+			return true;
+		}
+	}
+
+	@NoCheckStore
+	public static int snapshotHandshakeThreads(SoftHandshakeVisitor v) {
+		// figure out which threads to consider
+		acctLock.lockNoHandshake(); /* get a consistent view of which threads are live. */
+
+		int numToHandshake = 0;
+		for (int i = 0; i < numThreads; ++i) {
+			RVMThread t = threads[i];
+			if (t != RVMThread.getCurrentThread() && !t.ignoreHandshakesAndGC() && v.includeThread(t)) {
+				handshakeThreads[numToHandshake++] = t;
+			}
+		}
+		acctLock.unlock();
+		return numToHandshake;
+	}
+
+	/**
+	 * Tell each thread to take a yieldpoint and wait until all of them have done
+	 * so at least once. Additionally, call the visitor on each thread when making
+	 * the yieldpoint request; the purpose of the visitor is to set any additional
+	 * fields as needed to make specific requests to the threads that yield. Note
+	 * that the visitor's <code>visit()</code> method is called with both the
+	 * thread's monitor held, and the <code>softHandshakeDataLock</code> held.
+	 * <p>
+	 * Currently we only use this mechanism for code patch isync requests on PPC,
+	 * but this mechanism is powerful enough to be used by sliding-views style
+	 * concurrent GC.
+	 */
+	@NoCheckStore
+	@Unpreemptible("Does not perform actions that lead to blocking, but may wait for threads to rendezvous with the soft handshake")
+	public static void softHandshake(SoftHandshakeVisitor v) {
+		handshakeLock.lockWithHandshake(); /*
+		 * prevent multiple (soft or hard) handshakes
+		 * from proceeding concurrently
+		 */
+
+		int numToHandshake = snapshotHandshakeThreads(v);
+		if (VM.VerifyAssertions)
+			VM._assert(softHandshakeLeft == 0);
+
+		// in turn, check if each thread needs a handshake, and if so,
+		// request one
+		for (int i = 0; i < numToHandshake; ++i) {
+			RVMThread t = handshakeThreads[i];
+			handshakeThreads[i] = null; // help GC
+			t.monitor().lockNoHandshake();
+			boolean waitForThisThread = false;
+			if (!t.isAboutToTerminate && v.checkAndSignal(t)) {
+				// CAS the execStatus field
+				t.setBlockedExecStatus();
+				// Note that at this point if the thread tries to either enter or
+				// exit Java code, it will be diverted into either
+				// enterNativeBlocked() or checkBlock(), both of which cannot do
+				// anything until they acquire the monitor() lock, which we now
+				// hold. Thus, the code below can, at its leisure, examine the
+				// thread's state and make its decision about what to do, fully
+				// confident that the thread's state is blocked from changing.
+				if (t.isInJava()) {
+					// the thread is currently executing Java code, so we must ensure
+					// that it either:
+					// 1) takes the next yieldpoint and rendezvous with this soft
+					// handshake request (see yieldpoint), or
+					// 2) performs the rendezvous when leaving Java code
+					// (see enterNativeBlocked, checkBlock, and addAboutToTerminate)
+					// either way, we will wait for it to get there before exiting
+					// this call, since the caller expects that after softHandshake()
+					// returns, no thread will be running Java code without having
+					// acknowledged.
+					t.softHandshakeRequested = true;
+					t.takeYieldpoint = 1;
+					waitForThisThread = true;
+				} else {
+					// the thread is not in Java code (it may be blocked or it may be
+					// in native), so we don't have to wait for it since it will
+					// do the Right Thing before returning to Java code. essentially,
+					// the thread cannot go back to running Java without doing whatever
+					// was requested because:
+					// A) we've set the execStatus to blocked, and
+					// B) we're holding its lock.
+					v.notifyStuckInNative(t);
+				}
+			}
+			t.monitor().unlock();
+
+			// NOTE: at this point the thread may already decrement the
+			// softHandshakeLeft counter, causing it to potentially go negative.
+			// this is unlikely and completely harmless.
+
+			if (waitForThisThread) {
+				softHandshakeDataLock.lockNoHandshake();
+				softHandshakeLeft++;
+				softHandshakeDataLock.unlock();
+			}
+		}
+
+		// wait for all threads to reach the handshake
+		softHandshakeDataLock.lockNoHandshake();
+		if (VM.VerifyAssertions)
+			VM._assert(softHandshakeLeft >= 0);
+		while (softHandshakeLeft > 0) {
+			// wait and tell the world that we're off in native land. this way
+			// if someone tries to block us at this point (suspend() or GC),
+			// they'll know not to wait for us.
+			softHandshakeDataLock.waitWithHandshake();
+		}
+		if (VM.VerifyAssertions)
+			VM._assert(softHandshakeLeft == 0);
+		softHandshakeDataLock.unlock();
+
+		processAboutToTerminate();
+
+		handshakeLock.unlock();
+	}
+
+	/**
+	 * Check and clear the need for a soft handshake rendezvous.  This method
+	 * cannot do anything that leads to a write barrier or allocation.
+	 */
+	public boolean softRendezvousCheckAndClear() {
+		boolean result = false;
+		monitor().lockNoHandshake();
+		if (softHandshakeRequested) {
+			softHandshakeRequested = false;
+			result = true;
+		}
+		monitor().unlock();
+		return result;
+	}
+
+	/**
+	 * Commit the soft handshake rendezvous.  This method cannot do anything
+	 * that leads to a write barrier or allocation.
+	 */
+	public void softRendezvousCommit() {
+		softHandshakeDataLock.lockNoHandshake();
+		softHandshakeLeft--;
+		if (softHandshakeLeft == 0) {
+			softHandshakeDataLock.broadcast();
+		}
+		softHandshakeDataLock.unlock();
+	}
+
+	/**
+	 * Rendezvous with a soft handshake request. Can only be called when the
+	 * thread's monitor is held.
+	 */
+	public void softRendezvous() {
+		if (softRendezvousCheckAndClear())
+			softRendezvousCommit();
+	}
+
+	/**
+	 * Handle requests that required a soft handshake. May be called after we
+	 * acknowledged the soft handshake. Thus - this is for actions in which it is
+	 * sufficient for the thread to acknowledge that it plans to act upon the
+	 * request in the immediate future, rather than that the thread acts upon the
+	 * request prior to acknowledging.
+	 * <p>
+	 * This is almost always called with the monitor() lock held, but that's
+	 * not guaranteed.  If you need that lock, you can grab it (since it's a
+	 * recursive lock).  But you should avoid grabbing other sorts of locks since
+	 * that might cause deadlock.
+	 */
+	void handleHandshakeRequest() {
+		// Process request for code-patch memory sync operation
+		if (VM.BuildForPowerPC && codePatchSyncRequested) {
+			codePatchSyncRequested = false;
+			// Q: Is this sufficient? Ask Steve why we don't need to sync
+			// icache/dcache. --dave
+			// A: Yes, this is sufficient. We (Filip and Dave) talked about it and
+			// agree that remote processors only need to execute isync. --Filip
+			// make sure not get stale data
+			Magic.isync();
+		}
+		// process memory management requests
+		if (flushRequested && activeMutatorContext) {
+			MemoryManager.flushMutatorContext();
+			flushRequested = false;
+		}
+		// not really a "soft handshake" request but we handle it here anyway
+		if (asyncDebugRequestedForThisThread) {
+			asyncDebugRequestedForThisThread = false;
+			dumpLock.lockNoHandshake();
+			VM.sysWriteln("Handling async stack trace request...");
+			dump();
+			VM.sysWriteln();
+			dumpStack();
+			dumpLock.unlock();
+		}
+	}
+
+	/**
+	 * Stop all mutator threads. This is current intended to be run by a single thread.
+	 *
+	 * Fixpoint until there are no threads that we haven't blocked. Fixpoint is needed to
+	 * catch the (unlikely) case that a thread spawns another thread while we are waiting.
+	 */
+	@NoCheckStore
+	@Unpreemptible
+	public static void blockAllMutatorsForGC() {
+		RVMThread.handshakeLock.lockNoHandshake();
+		while (true) {
+			// (1) Find all the threads that need to be blocked for GC
+			RVMThread.acctLock.lockNoHandshake();
+			int numToHandshake = 0;
+			for (int i = 0; i < RVMThread.numThreads; i++) {
+				RVMThread t = RVMThread.threads[i];
+				if (!t.isCollectorThread() && !t.ignoreHandshakesAndGC()) {
+					RVMThread.handshakeThreads[numToHandshake++] = t;
+				}
+			}
+			RVMThread.acctLock.unlock();
+
+			// (2) Remove any threads that have already been blocked from the list.
+			for (int i = 0; i < numToHandshake; i++) {
+				RVMThread t = RVMThread.handshakeThreads[i];
+				t.monitor().lockNoHandshake();
+				if (t.blockedFor(RVMThread.gcBlockAdapter) || RVMThread.notRunning(t.asyncBlock(RVMThread.gcBlockAdapter))) {
+					// Already blocked or not running, remove.
+					RVMThread.handshakeThreads[i--] = RVMThread.handshakeThreads[--numToHandshake];
+					RVMThread.handshakeThreads[numToHandshake] = null; // help GC
+				}
+				t.monitor().unlock();
+			}
+
+			// (3) Quit trying to block threads if all threads are either blocked
+			//     or not running (a thread is "not running" if it is NEW or TERMINATED;
+			//     in the former case it means that the thread has not had start()
+			//     called on it while in the latter case it means that the thread
+			//     is either in the TERMINATED state or is about to be in that state
+			//     real soon now, and will not perform any heap-related work before
+			//     terminating).
+			if (numToHandshake == 0) break;
+
+			// (4) Request a block for GC from all other threads.
+			for (int i = 0; i < numToHandshake; i++) {
+				if (false) VM.sysWriteln("Waiting for ", RVMThread.handshakeThreads[i].getThreadSlot(), " to block.");
+				RVMThread t = RVMThread.handshakeThreads[i];
+				RVMThread.observeExecStatusAtSTW(t.block(RVMThread.gcBlockAdapter));
+				RVMThread.handshakeThreads[i] = null; // help GC
+			}
+		}
+		RVMThread.handshakeLock.unlock();
+
+		// Deal with terminating threads to ensure that all threads are either dead to MMTk or stopped above.
+		RVMThread.processAboutToTerminate();
+	}
+
+	/**
+	 * Unblock all mutators blocked for GC.
+	 */
+	@NoCheckStore
+	@Unpreemptible
+	public static void unblockAllMutatorsForGC() {
+		RVMThread.handshakeLock.lockNoHandshake();
+		RVMThread.acctLock.lockNoHandshake();
+		int numToHandshake = 0;
+		for (int i = 0; i < RVMThread.numThreads; i++) {
+			RVMThread t = RVMThread.threads[i];
+			if (!t.isCollectorThread() && !t.ignoreHandshakesAndGC()) {
+				RVMThread.handshakeThreads[numToHandshake++] = t;
+			}
+		}
+		RVMThread.acctLock.unlock();
+		for (int i = 0; i < numToHandshake; i++) {
+			RVMThread.handshakeThreads[i].unblock(RVMThread.gcBlockAdapter);
+			RVMThread.handshakeThreads[i] = null; // Help GC
+		}
+		RVMThread.handshakeLock.unlock();
+	}
+
+	@Uninterruptible
+	public static class HardHandshakeVisitor {
+		public boolean includeThread(RVMThread t) {
+			return true;
+		}
+	}
+
+	@Uninterruptible
+	@NonMoving
+	static class AllButGCHardHandshakeVisitor extends HardHandshakeVisitor {
+		@Override
+		public boolean includeThread(RVMThread t) {
+			return !t.isCollectorThread();
+		}
+	}
+
+	public static final AllButGCHardHandshakeVisitor allButGC=
+			new AllButGCHardHandshakeVisitor();
+
+	static long totalSuspendTime;
+	static long totalResumeTime;
+
+	@Unpreemptible
+	@NoCheckStore
+	public static void hardHandshakeSuspend(BlockAdapter ba,
+			HardHandshakeVisitor hhv) {
+		long before=sysCall.sysNanoTime();
+
+		RVMThread current=getCurrentThread();
+
+		handshakeLock.lockWithHandshake();
+		int numLockedLocks=0;
+		for (int i=0;i<nextSlot;++i) {
+			Monitor l=communicationLockBySlot[i];
+			if (l!=null) {
+				l.lockWithHandshake();
+				numLockedLocks++;
+			}
+		}
+
+		// fixpoint until there are no threads that we haven't blocked.
+		// fixpoint is needed in case some thread spawns another thread
+		// while we're waiting.  that is unlikely but possible.
+		for (;;) {
+			acctLock.lockNoHandshake();
+			int numToHandshake=0;
+			for (int i=0;i<numThreads;++i) {
+				RVMThread t=threads[i];
+				if (t!=current &&
+						!t.ignoreHandshakesAndGC() &&
+						hhv.includeThread(t)) {
+					handshakeThreads[numToHandshake++]=t;
+				}
+			}
+			acctLock.unlock();
+
+			for (int i=0;i<numToHandshake;++i) {
+				RVMThread t=handshakeThreads[i];
+				t.monitor().lockNoHandshake();
+				if (t.blockedFor(ba) ||
+						notRunning(t.asyncBlock(ba))) {
+					// already blocked or not running, remove
+					handshakeThreads[i--]=handshakeThreads[--numToHandshake];
+					handshakeThreads[numToHandshake]=null; // help GC
+				}
+				t.monitor().unlock();
+			}
+			// quit trying to block threads if all threads are either blocked
+			// or not running (a thread is "not running" if it is NEW or TERMINATED;
+			// in the former case it means that the thread has not had start()
+			// called on it while in the latter case it means that the thread
+			// is either in the TERMINATED state or is about to be in that state
+			// real soon now, and will not perform any heap-related stuff before
+			// terminating).
+			if (numToHandshake==0) break;
+			for (int i=0;i<numToHandshake;++i) {
+				RVMThread t=handshakeThreads[i];
+				observeExecStatusAtSTW(t.block(ba));
+				handshakeThreads[i]=null; // help GC
+			}
+		}
+		worldStopped=true;
+
+		processAboutToTerminate(); /*
+		 * ensure that any threads that died while
+		 * we were stopping the world notify us
+		 * that they had stopped.
+		 */
+
+		int numUnlockedLocks=0;
+		for (int i=0;i<nextSlot;++i) {
+			Monitor l=communicationLockBySlot[i];
+			if (l!=null) {
+				l.unlock();
+				numUnlockedLocks++;
+			}
+		}
+		if (VM.VerifyAssertions) VM._assert(numLockedLocks==numUnlockedLocks);
+		handshakeLock.unlock();
+
+		if (false) {
+			long after=sysCall.sysNanoTime();
+			totalSuspendTime+=after-before;
+			VM.sysWriteln("Stopping the world took ",(after-before)," ns (",totalSuspendTime," ns total)");
+		}
+	}
+
+	@NoCheckStore
+	@Unpreemptible
+	public static void hardHandshakeResume(BlockAdapter ba,
+			HardHandshakeVisitor hhv) {
+		long before=sysCall.sysNanoTime();
+
+		handshakeLock.lockWithHandshake();
+
+		RVMThread current=getCurrentThread();
+		worldStopped=false;
+		acctLock.lockNoHandshake();
+		int numToHandshake=0;
+		for (int i=0;i<numThreads;++i) {
+			RVMThread t=threads[i];
+			if (t!=current &&
+					!t.ignoreHandshakesAndGC() &&
+					hhv.includeThread(t)) {
+				handshakeThreads[numToHandshake++]=t;
+			}
+		}
+		acctLock.unlock();
+		for (int i=0;i<numToHandshake;++i) {
+			handshakeThreads[i].unblock(ba);
+			handshakeThreads[i]=null; // help GC
+		}
+
+		handshakeLock.unlock();
+
+		if (false) {
+			long after=sysCall.sysNanoTime();
+			totalResumeTime+=after-before;
+			VM.sysWriteln("Resuming the world took ",(after-before)," ns (",totalResumeTime," ns total)");
+		}
+	}
+
+	@Unpreemptible
+	public static void hardHandshakeSuspend() {
+		hardHandshakeSuspend(handshakeBlockAdapter,allButGC);
+	}
+
+	@Unpreemptible
+	public static void hardHandshakeResume() {
+		hardHandshakeResume(handshakeBlockAdapter,allButGC);
+	}
+
+	public static boolean worldStopped() {
+		return worldStopped;
+	}
+
+	/**
+	 * Process a taken yieldpoint.
+	 */
+	@Unpreemptible("May block if the thread was asked to do so but otherwise does not perform actions that may lead to blocking")
+	public static void yieldpoint(int whereFrom, Address yieldpointServiceMethodFP) {
+		RVMThread t = getCurrentThread();
+		boolean wasAtYieldpoint = t.atYieldpoint;
+		t.atYieldpoint = true;
+		t.yieldpointsTaken++;
+		// If thread is in critical section we can't do anything right now, defer
+		// until later
+		// we do this without acquiring locks, since part of the point of disabling
+		// yieldpoints is to ensure that locks are not "magically" acquired
+		// through unexpected yieldpoints. As well, this makes code running with
+		// yieldpoints disabled more predictable. Note furthermore that the only
+		// race here is setting takeYieldpoint to 0. But this is perfectly safe,
+		// since we are guaranteeing that a yieldpoint will run after we emerge from
+		// the no-yieldpoints code. At worst, setting takeYieldpoint to 0 will be
+		// lost (because some other thread sets it to non-0), but in that case we'll
+		// just come back here and reset it to 0 again.
+		if (!t.yieldpointsEnabled()) {
+			if (VM.VerifyAssertions)
+				VM._assert(!t.yieldToOSRRequested);
+			if (traceBlock && !wasAtYieldpoint) {
+				VM.sysWriteln("Thread #", t.threadSlot, " deferring yield!");
+				dumpStack();
+			}
+			t.yieldpointRequestPending = true;
+			t.takeYieldpoint = 0;
+			t.atYieldpoint = false;
+			return;
+		}
+		t.yieldpointsTakenFully++;
+
+		Throwable throwThis = null;
+		t.monitor().lockNoHandshake();
+
+		int takeYieldpointVal = t.takeYieldpoint;
+		if (takeYieldpointVal != 0) {
+			t.takeYieldpoint = 0;
+			// do two things: check if we should be blocking, and act upon
+			// handshake requests. This also has the effect of reasserting that
+			// we are in fact IN_JAVA (as opposed to IN_JAVA_TO_BLOCK).
+			t.wsWrapperCheckBlock();
+
+			// Process timer interrupt event
+			if (t.timeSliceExpired != 0) {
+				t.timeSliceExpired = 0;
+
+				if (t.yieldForCBSCall || t.yieldForCBSMethod) {
+					/*
+					 * CBS Sampling is still active from previous quantum. Note that fact,
+					 * but leave all the other CBS parameters alone.
+					 */
+				} else {
+					if (VM.CBSCallSamplesPerTick > 0) {
+						t.yieldForCBSCall = true;
+						t.takeYieldpoint = -1;
+						t.firstCBSCallSample++;
+						t.firstCBSCallSample = t.firstCBSCallSample % VM.CBSCallSampleStride;
+						t.countdownCBSCall = t.firstCBSCallSample;
+						t.numCBSCallSamples = VM.CBSCallSamplesPerTick;
+					}
+
+					if (VM.CBSMethodSamplesPerTick > 0) {
+						t.yieldForCBSMethod = true;
+						t.takeYieldpoint = -1;
+						t.firstCBSMethodSample++;
+						t.firstCBSMethodSample = t.firstCBSMethodSample % VM.CBSMethodSampleStride;
+						t.countdownCBSMethod = t.firstCBSMethodSample;
+						t.numCBSMethodSamples = VM.CBSMethodSamplesPerTick;
+					}
+				}
+
+				if (VM.BuildForAdaptiveSystem) {
+					RuntimeMeasurements.takeTimerSample(whereFrom,
+							yieldpointServiceMethodFP);
+				}
+				if (VM.BuildForAdaptiveSystem) {
+					OSRListener
+					.checkForOSRPromotion(whereFrom, yieldpointServiceMethodFP);
+				}
+			}
+
+			if (t.yieldForCBSCall) {
+				if (!(whereFrom == BACKEDGE || whereFrom == OSROPT)) {
+					if (--t.countdownCBSCall <= 0) {
+						if (VM.BuildForAdaptiveSystem) {
+							// take CBS sample
+							RuntimeMeasurements.takeCBSCallSample(whereFrom,
+									yieldpointServiceMethodFP);
+						}
+						t.countdownCBSCall = VM.CBSCallSampleStride;
+						t.numCBSCallSamples--;
+						if (t.numCBSCallSamples <= 0) {
+							t.yieldForCBSCall = false;
+						}
+					}
+				}
+				if (t.yieldForCBSCall) {
+					t.takeYieldpoint = -1;
+				}
+			}
+
+			if (t.yieldForCBSMethod) {
+				if (--t.countdownCBSMethod <= 0) {
+					if (VM.BuildForAdaptiveSystem) {
+						// take CBS sample
+						RuntimeMeasurements.takeCBSMethodSample(whereFrom,
+								yieldpointServiceMethodFP);
+					}
+					t.countdownCBSMethod = VM.CBSMethodSampleStride;
+					t.numCBSMethodSamples--;
+					if (t.numCBSMethodSamples <= 0) {
+						t.yieldForCBSMethod = false;
+					}
+				}
+				if (t.yieldForCBSMethod) {
+					t.takeYieldpoint = 1;
+				}
+			}
+
+			if (VM.BuildForAdaptiveSystem && t.yieldToOSRRequested) {
+				t.yieldToOSRRequested = false;
+				OSRListener.handleOSRFromOpt(yieldpointServiceMethodFP);
+			}
+
+			// what is the reason for this? and what was the reason for doing
+			// a thread switch following the suspension in the OSR trigger code?
+			// ... it seems that at least part of the point here is that if a
+			// thread switch was desired for other reasons, then we need to ensure
+			// that between when this runs and when the glue code runs there will
+			// be no interleaved GC; obviously if we did this before the thread
+			// switch then there would be the possibility of interleaved GC.
+			if (VM.BuildForAdaptiveSystem && t.isWaitingForOsr) {
+				PostThreadSwitch.postProcess(t);
+			}
+			if (t.asyncThrowable != null) {
+				throwThis = t.asyncThrowable;
+				t.asyncThrowable = null;
+			}
+		}
+		t.monitor().unlock();
+		t.atYieldpoint = false;
+		if (throwThis != null) {
+			throwFromUninterruptible(throwThis);
+		}
+	}
+
+	@Unpreemptible
+	private static void throwFromUninterruptible(Throwable e) {
+		RuntimeEntrypoints.athrow(e);
+	}
+
+	/**
+	 * Change the size of the currently executing thread's stack.
+	 *
+	 * @param newSize
+	 *          new size (in bytes)
+	 * @param exceptionRegisters
+	 *          register state at which stack overflow trap was encountered (null
+	 *          --> normal method call, not a trap)
+	 */
+	@Unpreemptible("May block due to allocation")
+	public static void resizeCurrentStack(int newSize,
+			Registers exceptionRegisters) {
+		if (!getCurrentThread().hijackedReturnAddress.isZero()) {
+			/* stack resizing currently unsupported with return barrier */
+			VM.sysFail("system error: resizing stack while return barrier enabled (currently unsupported)");
+		}
+		if (traceAdjustments)
+			VM.sysWrite("Thread: resizeCurrentStack\n");
+		if (MemoryManager.gcInProgress()) {
+			VM.sysFail("system error: resizing stack while GC is in progress");
+		}
+		byte[] newStack = MemoryManager.newStack(newSize);
+		getCurrentThread().disableYieldpoints();
+		transferExecutionToNewStack(newStack, exceptionRegisters);
+		getCurrentThread().enableYieldpoints();
+		if (traceAdjustments) {
+			RVMThread t = getCurrentThread();
+			VM.sysWrite("Thread: resized stack ", t.getThreadSlot());
+			VM.sysWrite(" to ", t.stack.length / 1024);
+			VM.sysWrite("k\n");
+		}
+	}
+
+	@NoInline
+	@BaselineNoRegisters
+	// this method does not do a normal return and hence does not execute epilogue
+	// --> non-volatiles not restored!
+	private static void transferExecutionToNewStack(byte[] newStack,
+			Registers exceptionRegisters) {
+		// prevent opt compiler from inlining a method that contains a magic
+		// (returnToNewStack) that it does not implement.
+
+		RVMThread myThread = getCurrentThread();
+		byte[] myStack = myThread.stack;
+
+		// initialize new stack with live portion of stack we're
+		// currently running on
+		//
+		// lo-mem hi-mem
+		// |<---myDepth----|
+		// +----------+---------------+
+		// | empty | live |
+		// +----------+---------------+
+		// ^myStack ^myFP ^myTop
+		//
+		// +-------------------+---------------+
+		// | empty | live |
+		// +-------------------+---------------+
+		// ^newStack ^newFP ^newTop
+		//
+		Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
+		Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
+
+		Address myFP = Magic.getFramePointer();
+		Offset myDepth = myTop.diff(myFP);
+		Address newFP = newTop.minus(myDepth);
+
+		// The frame pointer addresses the top of the frame on powerpc and
+		// the bottom
+		// on intel. if we copy the stack up to the current
+		// frame pointer in here, the
+		// copy will miss the header of the intel frame. Thus we make another
+		// call
+		// to force the copy. A more explicit way would be to up to the
+		// frame pointer
+		// and the header for intel.
+		Offset delta = copyStack(newStack);
+
+		// fix up registers and save areas so they refer
+		// to "newStack" rather than "myStack"
+		//
+		if (exceptionRegisters != null) {
+			adjustRegisters(exceptionRegisters, delta);
+		}
+		adjustStack(newStack, newFP, delta);
+
+		// install new stack
+		//
+		myThread.stack = newStack;
+		myThread.stackLimit = Magic.objectAsAddress(newStack)
+				.plus(STACK_SIZE_GUARD);
+
+		// return to caller, resuming execution on new stack
+		// (original stack now abandoned)
+		//
+		if (VM.BuildForPowerPC) {
+			Magic.returnToNewStack(Magic.getCallerFramePointer(newFP));
+		} else if (VM.BuildForIA32) {
+			Magic.returnToNewStack(newFP);
+		}
+
+		if (VM.VerifyAssertions)
+			VM._assert(VM.NOT_REACHED);
+	}
+
+	/**
+	 * This (suspended) thread's stack has been moved. Fixup register and memory
+	 * references to reflect its new position.
+	 *
+	 * @param delta
+	 *          displacement to be applied to all interior references
+	 */
+	public void fixupMovedStack(Offset delta) {
+		if (traceAdjustments)
+			VM.sysWrite("Thread: fixupMovedStack\n");
+
+		if (!contextRegisters.getInnermostFramePointer().isZero()) {
+			adjustRegisters(contextRegisters, delta);
+		}
+		if ((exceptionRegisters.inuse) &&
+				(exceptionRegisters.getInnermostFramePointer().NE(Address.zero()))) {
+			adjustRegisters(exceptionRegisters, delta);
+		}
+		if (!contextRegisters.getInnermostFramePointer().isZero()) {
+			adjustStack(stack, contextRegisters.getInnermostFramePointer(), delta);
+		}
+		stackLimit = stackLimit.plus(delta);
+	}
+
+	/**
+	 * A thread's stack has been moved or resized. Adjust registers to reflect new
+	 * position.
+	 *
+	 * @param registers
+	 *          registers to be adjusted
+	 * @param delta
+	 *          displacement to be applied
+	 */
+	private static void adjustRegisters(Registers registers, Offset delta) {
+		if (traceAdjustments)
+			VM.sysWrite("Thread: adjustRegisters\n");
+
+		// adjust FP
+		//
+		Address newFP = registers.getInnermostFramePointer().plus(delta);
+		Address ip = registers.getInnermostInstructionAddress();
+		registers.setInnermost(ip, newFP);
+		if (traceAdjustments) {
+			VM.sysWrite(" fp=");
+			VM.sysWrite(registers.getInnermostFramePointer());
+		}
+
+		// additional architecture specific adjustments
+		// (1) frames from all compilers on IA32 need to update ESP
+		int compiledMethodId = Magic.getCompiledMethodID(registers
+				.getInnermostFramePointer());
+		if (compiledMethodId != INVISIBLE_METHOD_ID) {
+			if (VM.BuildForIA32) {
+				Configuration.archHelper.adjustESP(registers, delta, traceAdjustments);
+			}
+			if (traceAdjustments) {
+				CompiledMethod compiledMethod = CompiledMethods
+						.getCompiledMethod(compiledMethodId);
+				VM.sysWrite(" method=");
+				VM.sysWrite(compiledMethod.getMethod());
+				VM.sysWrite("\n");
+			}
+		}
+	}
+
+	/**
+	 * A thread's stack has been moved or resized. Adjust internal pointers to
+	 * reflect new position.
+	 *
+	 * @param stack
+	 *          stack to be adjusted
+	 * @param fp
+	 *          pointer to its innermost frame
+	 * @param delta
+	 *          displacement to be applied to all its interior references
+	 */
+	private static void adjustStack(byte[] stack, Address fp, Offset delta) {
+		if (traceAdjustments)
+			VM.sysWrite("Thread: adjustStack\n");
+
+		while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+			// adjust FP save area
+			//
+			Magic.setCallerFramePointer(fp, Magic.getCallerFramePointer(fp).plus(
+					delta));
+			if (traceAdjustments) {
+				VM.sysWrite(" fp=", fp.toWord());
+			}
+
+			// advance to next frame
+			//
+			fp = Magic.getCallerFramePointer(fp);
+		}
+	}
+
+	/**
+	 * Initialize a new stack with the live portion of the stack we're currently
+	 * running on.
+	 *
+	 * <pre>
+	 *  lo-mem                                        hi-mem
+	 *                           |&lt;---myDepth----|
+	 *                 +----------+---------------+
+	 *                 |   empty  |     live      |
+	 *                 +----------+---------------+
+	 *                  &circ;myStack   &circ;myFP           &circ;myTop
+	 *       +-------------------+---------------+
+	 *       |       empty       |     live      |
+	 *       +-------------------+---------------+
+	 *        &circ;newStack           &circ;newFP          &circ;newTop
+	 * </pre>
+	 */
+	private static Offset copyStack(byte[] newStack) {
+		RVMThread myThread = getCurrentThread();
+		byte[] myStack = myThread.stack;
+
+		Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
+		Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
+		Address myFP = Magic.getFramePointer();
+		Offset myDepth = myTop.diff(myFP);
+		Address newFP = newTop.minus(myDepth);
+
+		// before copying, make sure new stack isn't too small
+		//
+		if (VM.VerifyAssertions) {
+			VM._assert(newFP.GE(Magic.objectAsAddress(newStack)
+					.plus(STACK_SIZE_GUARD)));
+		}
+
+		Memory.memcopy(newFP, myFP, myDepth.toWord().toExtent());
+
+		return newFP.diff(myFP);
+	}
+
+	/**
+	 * Set the "isDaemon" status of this thread. Although a java.lang.Thread can
+	 * only have setDaemon invoked on it before it is started, Threads can become
+	 * daemons at any time. Note: making the last non daemon a daemon will
+	 * terminate the VM.
+	 * <p>
+	 * Note: This method might need to be uninterruptible so it is final, which is
+	 * why it isn't called setDaemon.
+	 * <p>
+	 * Public so that java.lang.Thread can use it.
+	 */
+	public void makeDaemon(boolean on) {
+		if (daemon == on) {
+			// nothing to do
+		} else {
+			daemon = on;
+			if (getExecStatus() == NEW) {
+				// thread will start as a daemon
+			} else {
+				boolean terminateSystem = false;
+				acctLock.lockNoHandshake();
+				numActiveDaemons += on ? 1 : -1;
+				if (numActiveDaemons == numActiveThreads) {
+					terminateSystem = true;
+				}
+				acctLock.unlock();
+				if (terminateSystem) {
+					if (VM.TraceThreads) {
+						trace("Thread", "last non Daemon demonized");
+					}
+					VM.sysExit(0);
+					if (VM.VerifyAssertions)
+						VM._assert(VM.NOT_REACHED);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Dump information for all threads, via {@link VM#sysWrite(String)}. Each
+	 * thread's info is newline-terminated.
+	 *
+	 * @param verbosity Ignored.
+	 */
+	public static void dumpAll(int verbosity) {
+		for (int i = 0; i < numThreads; i++) {
+			RVMThread t = threads[i];
+			if (t == null)
+				continue;
+			VM.sysWrite("Thread ");
+			VM.sysWriteInt(t.threadSlot);
+			VM.sysWrite(":  ");
+			VM.sysWriteHex(Magic.objectAsAddress(t));
+			VM.sysWrite("   ");
+			t.dump(verbosity);
+			// Compensate for t.dump() not newline-terminating info.
+			VM.sysWriteln();
+		}
+	}
+
+	/** @return The value of {@link #isBootThread} */
+	public boolean isBootThread() {
+		return this == bootThread;
+	}
+
+	/** @return Is this the MainThread ? */
+	private boolean isMainThread() {
+		return thread instanceof MainThread;
+	}
+
+	/** Is this a system thread? */
+	public boolean isSystemThread() {
+		return systemThread != null;
+	}
+
+	/** Get the collector thread this RVMTHread is running */
+	public CollectorThread getCollectorThread() {
+		if (VM.VerifyAssertions) VM._assert(isCollectorThread());
+		return (CollectorThread)systemThread;
+	}
+
+	/** Returns the value of {@link #daemon}. */
+	public boolean isDaemonThread() {
+		return daemon;
+	}
+
+	/**
+	 * Should this thread run concurrently with STW GC and ignore handshakes?
+	 */
+	public boolean ignoreHandshakesAndGC() {
+		if (systemThread == null) return false;
+		return systemThread instanceof TimerThread;
+	}
+
+	/** Is the thread started and not terminated */
+	public boolean isAlive() {
+		monitor().lockNoHandshake();
+		observeExecStatus();
+		boolean result = execStatus != NEW && execStatus != TERMINATED && !isAboutToTerminate;
+		monitor().unlock();
+		return result;
+	}
+
+	/**
+	 * Sets the name of the thread
+	 *
+	 * @param name the new name for the thread
+	 * @see java.lang.Thread#setName(String)
+	 */
+	public void setName(String name) {
+		this.name = name;
+	}
+
+	/**
+	 * Gets the name of the thread
+	 *
+	 * @see java.lang.Thread#getName()
+	 */
+	public String getName() {
+		return name;
+	}
+
+	/**
+	 * Does the currently running Thread hold the lock on an obj?
+	 *
+	 * @param obj
+	 *          the object to check
+	 * @return whether the thread holds the lock
+	 * @see java.lang.Thread#holdsLock(Object)
+	 */
+	public boolean holdsLock(Object obj) {
+		RVMThread mine = getCurrentThread();
+		return ObjectModel.holdsLock(obj, mine);
+	}
+
+	/**
+	 * Was this thread interrupted?
+	 *
+	 * @return whether the thread has been interrupted
+	 * @see java.lang.Thread#isInterrupted()
+	 */
+	public boolean isInterrupted() {
+		return hasInterrupt;
+	}
+
+	/**
+	 * Clear the interrupted status of this thread
+	 *
+	 * @see java.lang.Thread#interrupted()
+	 */
+	public void clearInterrupted() {
+		hasInterrupt = false;
+	}
+
+	/**
+	 * Interrupt this thread
+	 *
+	 * @see java.lang.Thread#interrupt()
+	 */
+	@Interruptible
+	public void interrupt() {
+		monitor().lockNoHandshake();
+		hasInterrupt = true;
+		monitor().broadcast();
+		monitor().unlock();
+	}
+
+	/**
+	 * Get the priority of the thread
+	 *
+	 * @return the thread's priority
+	 * @see java.lang.Thread#getPriority()
+	 */
+	public int getPriority() {
+		return priority;
+	}
+
+	/**
+	 * Set the priority of the thread
+	 *
+	 * @param priority
+	 * @see java.lang.Thread#getPriority()
+	 */
+	public void setPriority(int priority) {
+		this.priority = priority;
+		// @TODO this should be calling a syscall
+	}
+
+	/**
+	 * Get the state of the thread in a manner compatible with the Java API
+	 *
+	 * @return thread state
+	 * @see java.lang.Thread#getState()
+	 */
+	@Interruptible
+	public Thread.State getState() {
+		monitor().lockNoHandshake();
+		try {
+			observeExecStatus();
+			switch (execStatus) {
+			case NEW:
+				return Thread.State.NEW;
+			case IN_JAVA:
+			case IN_NATIVE:
+			case IN_JNI:
+			case IN_JAVA_TO_BLOCK:
+			case BLOCKED_IN_NATIVE:
+			case BLOCKED_IN_JNI:
+				if (isAboutToTerminate) {
+					return Thread.State.TERMINATED;
+				}
+				switch (waiting) {
+				case RUNNABLE:
+					return Thread.State.RUNNABLE;
+				case WAITING:
+					return Thread.State.WAITING;
+				case TIMED_WAITING:
+					return Thread.State.TIMED_WAITING;
+				default:
+					VM.sysFail("Unknown waiting value: " + waiting);
+					return null;
+				}
+			case TERMINATED:
+				return Thread.State.TERMINATED;
+			default:
+				VM.sysFail("Unknown value of execStatus: " + execStatus);
+				return null;
+			}
+		} finally {
+			monitor().unlock();
+		}
+	}
+
+	/**
+	 * Wait for the thread to die or for the timeout to occur
+	 *
+	 * @param ms
+	 *          milliseconds to wait
+	 * @param ns
+	 *          nanoseconds to wait
+	 */
+	@Interruptible
+	public void join(long ms, int ns) throws InterruptedException {
+		RVMThread myThread = getCurrentThread();
+		if (VM.VerifyAssertions)
+			VM._assert(myThread != this);
+		if (traceBlock)
+			VM.sysWriteln("Joining on Thread #", threadSlot);
+		// this uses synchronized because we cannot have one thread acquire
+		// another thread's lock using the WithHandshake scheme, as that would result
+		// in a thread holding two threads' monitor()s.  using synchronized
+		// turns out to be just fine - see comment in terminate().
+		synchronized (this) {
+			if (ms == 0 && ns == 0) {
+				while (!isJoinable) {
+					wait(this);
+					if (traceBlock)
+						VM.sysWriteln("relooping in join on Thread #", threadSlot);
+				}
+			} else {
+				long startNano = Time.nanoTime();
+				long whenWakeup = startNano + ms * 1000L * 1000L + ns;
+				while (!isJoinable) {
+					waitAbsoluteNanos(this, whenWakeup);
+					if (Time.nanoTime() >= whenWakeup) {
+						break;
+					}
+					if (traceBlock)
+						VM.sysWriteln("relooping in join on Thread #", threadSlot);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Count the stack frames of this thread
+	 */
+	@Interruptible
+	public int countStackFrames() {
+		if (!isSuspended) {
+			throw new IllegalThreadStateException(
+					"Thread.countStackFrames called on non-suspended thread");
+		}
+		throw new UnimplementedError();
+	}
+
+	/**
+	 * @return the length of the stack
+	 */
+	public int getStackLength() {
+		return stack.length;
+	}
+
+	/**
+	 * @return the stack
+	 */
+	public byte[] getStack() {
+		return stack;
+	}
+
+	/**
+	 * @return the thread's exception registers
+	 */
+	public Registers getExceptionRegisters() {
+		return exceptionRegisters;
+	}
+
+	/**
+	 * @return the thread's context registers (saved registers when thread is
+	 *         suspended by green-thread scheduler).
+	 */
+	public Registers getContextRegisters() {
+		return contextRegisters;
+	}
+
+	/** Set the initial attempt. */
+	public void reportCollectionAttempt() {
+		collectionAttempt++;
+	}
+
+	/** Set the initial attempt. */
+	public int getCollectionAttempt() {
+		return collectionAttempt;
+	}
+
+	/** Resets the attempts. */
+	public void resetCollectionAttempts() {
+		collectionAttempt = 0;
+	}
+
+	/** Get the physical allocation failed flag. */
+	public boolean physicalAllocationFailed() {
+		return physicalAllocationFailed;
+	}
+
+	/** Set the physical allocation failed flag. */
+	public void setPhysicalAllocationFailed() {
+		physicalAllocationFailed = true;
+	}
+
+	/** Clear the physical allocation failed flag. */
+	public void clearPhysicalAllocationFailed() {
+		physicalAllocationFailed = false;
+	}
+
+	/**
+	 * Returns the outstanding OutOfMemoryError.
+	 */
+	public static OutOfMemoryError getOutOfMemoryError() {
+		return outOfMemoryError;
+	}
+
+	/**
+	 * Number of active threads in the system.
+	 */
+	public static int getNumActiveThreads() {
+		return numActiveThreads;
+	}
+
+	/**
+	 * Number of active daemon threads.
+	 */
+	public static int getNumActiveDaemons() {
+		return numActiveDaemons;
+	}
+
+	@Interruptible
+	public void handleUncaughtException(Throwable exceptionObject) {
+		uncaughtExceptionCount++;
+
+		handlePossibleRecursiveException();
+		VM.enableGC();
+		if (thread == null) {
+			VM.sysWrite("Exception in the primordial thread \"", getName(),
+					"\" while booting: ");
+		} else {
+			// This is output like that of the Sun JDK.
+			VM.sysWrite("Exception in thread \"", getName(), "\": ");
+		}
+		if (exceptionObject instanceof OutOfMemoryError) {
+			VM.sysWriteln("   <<No stacktrace available>>");
+		} else if (VM.fullyBooted) {
+			exceptionObject.printStackTrace();
+		}
+		getCurrentThread().terminate();
+		if (VM.VerifyAssertions)
+			VM._assert(VM.NOT_REACHED);
+	}
+
+	/** Handle the case of exception handling triggering new exceptions. */
+	private void handlePossibleRecursiveException() {
+		if (uncaughtExceptionCount > 1 &&
+				uncaughtExceptionCount <= VM.maxSystemTroubleRecursionDepth + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite) {
+			VM.sysWrite("We got an uncaught exception while (recursively) handling ");
+			VM.sysWrite(uncaughtExceptionCount - 1);
+			VM.sysWrite(" uncaught exception");
+			if (uncaughtExceptionCount - 1 != 1) {
+				VM.sysWrite("s");
+			}
+			VM.sysWriteln(".");
+		}
+		if (uncaughtExceptionCount > VM.maxSystemTroubleRecursionDepth) {
+			dumpVirtualMachine();
+			VM.dieAbruptlyRecursiveSystemTrouble();
+			if (VM.VerifyAssertions)
+				VM._assert(VM.NOT_REACHED);
+		}
+	}
+
+	private static void dumpThread(RVMThread t) {
+		if (t == null) {
+			VM.sysWrite("none");
+		} else {
+			VM.sysWrite(t.threadSlot, "(", t.getExecStatus());
+			if (t.isAboutToTerminate) {
+				VM.sysWrite("T");
+			}
+			if (t.isBlocking) {
+				VM.sysWrite("B");
+			}
+			if (t.isJoinable) {
+				VM.sysWrite("J");
+			}
+			if (t.atYieldpoint) {
+				VM.sysWrite("Y");
+			}
+			VM.sysWrite(")");
+		}
+	}
+
+	private static void dumpThreadArray(RVMThread[] array, int bound) {
+		for (int i = 0; i < bound; ++i) {
+			if (i != 0) {
+				VM.sysWrite(", ");
+			}
+			VM.sysWrite(i, ":");
+			dumpThread(array[i]);
+		}
+	}
+
+	private static void dumpThreadSlotArray(int[] array, int bound) {
+		for (int i = 0; i < bound; ++i) {
+			if (i != 0) {
+				VM.sysWrite(", ");
+			}
+			VM.sysWrite(i, ":");
+			int threadSlot=array[i];
+			VM.sysWrite(threadSlot, ",");
+			dumpThread(threadBySlot[array[i]]);
+		}
+	}
+
+	private static void dumpThreadArray(String name, RVMThread[] array, int bound) {
+		VM.sysWrite(name);
+		VM.sysWrite(": ");
+		dumpThreadArray(array, bound);
+		VM.sysWriteln();
+	}
+
+	private static void dumpThreadSlotArray(String name, int[] array, int bound) {
+		VM.sysWrite(name);
+		VM.sysWrite(": ");
+		dumpThreadSlotArray(array, bound);
+		VM.sysWriteln();
+	}
+
+	public static void dumpAcct() {
+		acctLock.lockNoHandshake();
+		dumpLock.lockNoHandshake();
+		VM.sysWriteln("====== Begin Thread Accounting Dump ======");
+		dumpThreadArray("threadBySlot", threadBySlot, nextSlot);
+		dumpThreadSlotArray("aboutToTerminate", aboutToTerminate, aboutToTerminateN);
+		VM.sysWrite("freeSlots: ");
+		for (int i = 0; i < freeSlotN; ++i) {
+			if (i != 0) {
+				VM.sysWrite(", ");
+			}
+			VM.sysWrite(i, ":", freeSlots[i]);
+		}
+		VM.sysWriteln();
+		dumpThreadArray("threads", threads, numThreads);
+		VM.sysWriteln("====== End Thread Accounting Dump ======");
+		dumpLock.unlock();
+		acctLock.unlock();
+	}
+
+	public void extDump() {
+		dump();
+		VM.sysWriteln();
+		VM.sysWriteln("acquireCount for my monitor: ", monitor().acquireCount);
+		VM.sysWriteln("yieldpoints taken: ", yieldpointsTaken);
+		VM.sysWriteln("yieldpoints taken fully: ", yieldpointsTakenFully);
+		VM.sysWriteln("native entered blocked: ", nativeEnteredBlocked);
+		VM.sysWriteln("JNI entered blocked: ", jniEnteredBlocked);
+	}
+
+	/**
+	 * Dump this thread's identifying information, for debugging, via
+	 * {@link VM#sysWrite(String)}. We do not use any spacing or newline
+	 * characters. Callers are responsible for space-separating or
+	 * newline-terminating output.
+	 */
+	public void dump() {
+		dump(0);
+	}
+
+	/**
+	 * Dump this thread's identifying information, for debugging, via
+	 * {@link VM#sysWrite(String)}. We pad to a minimum of leftJustify
+	 * characters. We do not use any spacing characters. Callers are responsible
+	 * for space-separating or newline-terminating output.
+	 *
+	 * @param leftJustify
+	 *          minimum number of characters emitted, with any extra characters
+	 *          being spaces.
+	 */
+	public void dumpWithPadding(int leftJustify) {
+		char[] buf = Services.grabDumpBuffer();
+		int len = dump(buf);
+		VM.sysWrite(buf, len);
+		for (int i = leftJustify - len; i > 0; i--) {
+			VM.sysWrite(" ");
+		}
+		Services.releaseDumpBuffer();
+	}
+
+	/**
+	 * Dump this thread's identifying information, for debugging, via
+	 * {@link VM#sysWrite(String)}. We do not use any spacing or newline
+	 * characters. Callers are responsible for space-separating or
+	 * newline-terminating output.
+	 *
+	 * This function avoids write barriers and allocation.
+	 *
+	 * @param verbosity
+	 *          Ignored.
+	 */
+	public void dump(int verbosity) {
+		char[] buf = Services.grabDumpBuffer();
+		int len = dump(buf);
+		VM.sysWrite(buf, len);
+		Services.releaseDumpBuffer();
+	}
+
+	/**
+	 * Dump this thread's info, for debugging. Copy the info about it into a
+	 * destination char array. We do not use any spacing or newline characters.
+	 *
+	 * This function may be called during GC; it avoids write barriers and
+	 * allocation.
+	 *
+	 * For this reason, we do not throw an <code>IndexOutOfBoundsException</code>.
+	 *
+	 * @param dest
+	 *          char array to copy the source info into.
+	 * @param offset
+	 *          Offset into <code>dest</code> where we start copying
+	 *
+	 * @return 1 plus the index of the last character written. If we were to write
+	 *         zero characters (which we won't) then we would return
+	 *         <code>offset</code>. This is intended to represent the first
+	 *         unused position in the array <code>dest</code>. However, it also
+	 *         serves as a pseudo-overflow check: It may have the value
+	 *         <code>dest.length</code>, if the array <code>dest</code> was
+	 *         completely filled by the call, or it may have a value greater than
+	 *         <code>dest.length</code>, if the info needs more than
+	 *         <code>dest.length - offset</code> characters of space.
+	 *
+	 * -1 if <code>offset</code> is negative.
+	 */
+	public int dump(char[] dest, int offset) {
+		offset = Services.sprintf(dest, offset, getThreadSlot()); // id
+		if (daemon) {
+			offset = Services.sprintf(dest, offset, "-daemon"); // daemon thread?
+		}
+		if (isBootThread()) {
+			offset = Services.sprintf(dest, offset, "-Boot"); // Boot (Primordial)
+			// thread
+		}
+		if (isSystemThread()) {
+			offset = Services.sprintf(dest, offset, "-system"); // System Thread
+		}
+		if (isMainThread()) {
+			offset = Services.sprintf(dest, offset, "-main"); // Main Thread
+		}
+		if (isCollectorThread()) {
+			offset = Services.sprintf(dest, offset, "-collector"); // gc thread?
+		}
+		offset = Services.sprintf(dest, offset, "-");
+		offset = Services.sprintf(dest, offset, getExecStatus());
+		offset = Services.sprintf(dest, offset, "-");
+		offset = Services.sprintf(dest, offset, java.lang.JikesRVMSupport
+				.getEnumName(waiting));
+		if (hasInterrupt || asyncThrowable != null) {
+			offset = Services.sprintf(dest, offset, "-interrupted");
+		}
+		if (isAboutToTerminate) {
+			offset = Services.sprintf(dest, offset, "-terminating");
+		}
+		return offset;
+	}
+
+	/**
+	 * Dump this thread's info, for debugging. Copy the info about it into a
+	 * destination char array. We do not use any spacing or newline characters.
+	 * <p>
+	 * This is identical to calling {@link #dump(char[],int)} with an
+	 * <code>offset</code> of zero.
+	 */
+	public int dump(char[] dest) {
+		return dump(dest, 0);
+	}
+
+	/** Dump statistics gather on operations */
+	static void dumpStats() {
+		VM.sysWrite("FatLocks: ");
+		VM.sysWrite(waitOperations);
+		VM.sysWrite(" wait operations\n");
+		VM.sysWrite("FatLocks: ");
+		VM.sysWrite(timedWaitOperations);
+		VM.sysWrite(" timed wait operations\n");
+		VM.sysWrite("FatLocks: ");
+		VM.sysWrite(notifyOperations);
+		VM.sysWrite(" notify operations\n");
+		VM.sysWrite("FatLocks: ");
+		VM.sysWrite(notifyAllOperations);
+	}
+
+	/**
+	 * Print out message in format "[j] (cez#td) who: what", where: j = java
+	 * thread id z* = RVMThread.getCurrentThread().yieldpointsEnabledCount (0
+	 * means yieldpoints are enabled outside of the call to debug) t* =
+	 * numActiveThreads d* = numActiveDaemons * parenthetical values, printed only
+	 * if traceDetails = true)
+	 * <p>
+	 * We serialize against a mutex to avoid intermingling debug output from
+	 * multiple threads.
+	 */
+	public static void trace(String who, String what) {
+		outputLock.lockNoHandshake();
+		VM.sysWrite("[");
+		RVMThread t = getCurrentThread();
+		t.dump();
+		VM.sysWrite("] ");
+		if (traceDetails) {
+			VM.sysWrite("(");
+			VM.sysWriteInt(numActiveDaemons);
+			VM.sysWrite("/");
+			VM.sysWriteInt(numActiveThreads);
+			VM.sysWrite(") ");
+		}
+		VM.sysWrite(who);
+		VM.sysWrite(": ");
+		VM.sysWrite(what);
+		VM.sysWrite("\n");
+		outputLock.unlock();
+	}
+
+	/**
+	 * Print out message in format "p[j] (cez#td) who: what howmany", where: p =
+	 * processor id j = java thread id c* = java thread id of the owner of
+	 * threadCreationMutex (if any) e* = java thread id of the owner of
+	 * threadExecutionMutex (if any) t* = numActiveThreads d* = numActiveDaemons *
+	 * parenthetical values, printed only if traceDetails = true)
+	 * <p>
+	 * We serialize against a mutex to avoid intermingling debug output from
+	 * multiple threads.
+	 */
+	public static void trace(String who, String what, int howmany) {
+		_trace(who, what, howmany, false);
+	}
+
+	// same as trace, but prints integer value in hex
+	//
+	public static void traceHex(String who, String what, int howmany) {
+		_trace(who, what, howmany, true);
+	}
+
+	public static void trace(String who, String what, Address addr) {
+		outputLock.lockNoHandshake();
+		VM.sysWrite("[");
+		getCurrentThread().dump();
+		VM.sysWrite("] ");
+		if (traceDetails) {
+			VM.sysWrite("(");
+			VM.sysWriteInt(numActiveDaemons);
+			VM.sysWrite("/");
+			VM.sysWriteInt(numActiveThreads);
+			VM.sysWrite(") ");
+		}
+		VM.sysWrite(who);
+		VM.sysWrite(": ");
+		VM.sysWrite(what);
+		VM.sysWrite(" ");
+		VM.sysWriteHex(addr);
+		VM.sysWrite("\n");
+		outputLock.unlock();
+	}
+
+	private static void _trace(String who, String what, int howmany, boolean hex) {
+		outputLock.lockNoHandshake();
+		VM.sysWrite("[");
+		// VM.sysWriteInt(RVMThread.getCurrentThread().getThreadSlot());
+		getCurrentThread().dump();
+		VM.sysWrite("] ");
+		if (traceDetails) {
+			VM.sysWrite("(");
+			VM.sysWriteInt(numActiveDaemons);
+			VM.sysWrite("/");
+			VM.sysWriteInt(numActiveThreads);
+			VM.sysWrite(") ");
+		}
+		VM.sysWrite(who);
+		VM.sysWrite(": ");
+		VM.sysWrite(what);
+		VM.sysWrite(" ");
+		if (hex) {
+			VM.sysWriteHex(howmany);
+		} else {
+			VM.sysWriteInt(howmany);
+		}
+		VM.sysWrite("\n");
+		outputLock.unlock();
+	}
+
+	/**
+	 * Print interesting scheduler information, starting with a stack traceback.
+	 * <p>
+	 * Note: the system could be in a fragile state when this method is called, so
+	 * we try to rely on as little runtime functionality as possible (eg. use no
+	 * bytecodes that require RuntimeEntrypoints support).
+	 */
+	public static void traceback(String message) {
+		if (VM.runningVM) {
+			outputLock.lockNoHandshake();
+		}
+		VM.sysWriteln(message);
+		tracebackWithoutLock();
+		if (VM.runningVM) {
+			outputLock.unlock();
+		}
+	}
+
+	public static void traceback(String message, int number) {
+		if (VM.runningVM) {
+			outputLock.lockNoHandshake();
+		}
+		VM.sysWriteln(message, number);
+		tracebackWithoutLock();
+		if (VM.runningVM) {
+			outputLock.unlock();
+		}
+	}
+
+	static void tracebackWithoutLock() {
+		if (VM.runningVM) {
+			VM.sysWriteln("Thread #", getCurrentThreadSlot());
+			dumpStack(Magic.getCallerFramePointer(Magic.getFramePointer()));
+		} else {
+			dumpStack();
+		}
+	}
+
+	/**
+	 * Dump stack of calling thread, starting at callers frame
+	 */
+	@UninterruptibleNoWarn("Never blocks")
+	public static void dumpStack() {
+		if (VM.runningVM) {
+			VM.sysWriteln("Dumping stack for Thread #", getCurrentThreadSlot());
+			dumpStack(Magic.getFramePointer());
+		} else {
+			StackTraceElement[] elements = (new Throwable(
+					"--traceback from Jikes RVM's RVMThread class--")).getStackTrace();
+			for (StackTraceElement element : elements) {
+				System.err.println(element.toString());
+			}
+		}
+	}
+
+	/**
+	 * Dump state of a (stopped) thread's stack.
+	 *
+	 * @param fp address of starting frame. first frame output is the calling
+	 * frame of passed frame
+	 */
+	public static void dumpStack(Address fp) {
+		if (VM.VerifyAssertions) {
+			VM._assert(VM.runningVM);
+		}
+		Address ip = RVMThread.getReturnAddress_(fp);
+		fp = Magic.getCallerFramePointer(fp);
+		dumpStack(ip, fp);
+	}
+
+	/**
+	 * Dump state of a (stopped) thread's stack.
+	 *
+	 * @param ip instruction pointer for first frame to dump
+	 * @param fp frame pointer for first frame to dump
+	 */
+	public static void dumpStack(Address ip, Address fp) {
+		boolean b = Monitor.lockNoHandshake(dumpLock);
+		RVMThread t = getCurrentThread();
+		++t.inDumpStack;
+		if (t.inDumpStack > 1 &&
+				t.inDumpStack <= VM.maxSystemTroubleRecursionDepth + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite) {
+			VM.sysWrite("RVMThread.dumpStack(): in a recursive call, ");
+			VM.sysWrite(t.inDumpStack);
+			VM.sysWriteln(" deep.");
+		}
+		if (t.inDumpStack > VM.maxSystemTroubleRecursionDepth) {
+			VM.dieAbruptlyRecursiveSystemTrouble();
+			if (VM.VerifyAssertions)
+				VM._assert(VM.NOT_REACHED);
+		}
+
+		if (!isAddressValidFramePointer(fp)) {
+			VM.sysWrite("Bogus looking frame pointer: ", fp);
+			VM.sysWriteln(" not dumping stack");
+		} else {
+			try {
+				VM.sysWriteln("-- Stack --");
+				while (Magic.getCallerFramePointer(fp).NE(
+						StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+
+					// if code is outside of RVM heap, assume it to be native code,
+					// skip to next frame
+					if (!MemoryManager.addressInVM(ip)) {
+						showMethod("native frame", fp);
+						//						ip = Magic.getReturnAddress(fp);
+						ip = RVMThread.getReturnAddress_(fp);
+						fp = Magic.getCallerFramePointer(fp);
+					} else {
+
+						int compiledMethodId = Magic.getCompiledMethodID(fp);
+//						VM.sysWrite("("); VM.sysWrite(fp); VM.sysWrite(" "); VM.sysWrite(compiledMethodId); VM.sysWrite(")");
+						if (compiledMethodId == StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
+							showMethod("invisible method", fp);
+						} else {
+							// normal java frame(s)
+							CompiledMethod compiledMethod = CompiledMethods
+									.getCompiledMethod(compiledMethodId);
+							if (compiledMethod == null) {
+								showMethod(compiledMethodId, fp);
+							} else if (compiledMethod.getCompilerType() == CompiledMethod.TRAP) {
+								showMethod("hardware trap", fp);
+							} else {
+								RVMMethod method = compiledMethod.getMethod();
+								Offset instructionOffset = compiledMethod
+										.getInstructionOffset(ip);
+								int lineNumber = compiledMethod
+										.findLineNumberForInstruction(instructionOffset);
+								boolean frameShown = false;
+								if (VM.BuildForOptCompiler && compiledMethod.getCompilerType() == CompiledMethod.OPT) {
+									OptCompiledMethod optInfo = (OptCompiledMethod) compiledMethod;
+									// Opt stack frames may contain multiple inlined methods.
+									OptMachineCodeMap map = optInfo.getMCMap();
+									int iei = map.getInlineEncodingForMCOffset(instructionOffset);
+									if (iei >= 0) {
+										int[] inlineEncoding = map.inlineEncoding;
+										int bci = map.getBytecodeIndexForMCOffset(instructionOffset);
+										for (; iei >= 0; iei = OptEncodedCallSiteTree.getParent(iei, inlineEncoding)) {
+											int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
+											method = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember();
+											lineNumber = ((NormalMethod) method).getLineNumberForBCIndex(bci);
+											showMethod(method, lineNumber, fp);
+											if (iei > 0) {
+												bci = OptEncodedCallSiteTree.getByteCodeOffset(iei, inlineEncoding);
+											}
+										}
+										frameShown = true;
+									}
+								}
+								if (!frameShown) {
+									showMethod(method, lineNumber, fp);
+								}
+							}
+						}
+						ip = RVMThread.getReturnAddress(fp);
+						fp = Magic.getCallerFramePointer(fp);
+					}
+					if (!isAddressValidFramePointer(fp)) {
+						VM.sysWrite("Bogus looking frame pointer: ", fp);
+						VM.sysWriteln(" end of stack dump");
+						break;
+					}
+				} // end while
+			} catch (Throwable th) {
+				VM.sysWriteln("Something bad killed the stack dump. The last frame pointer was: ", fp);
+			}
+		}
+		--t.inDumpStack;
+
+		Monitor.unlock(b, dumpLock);
+	}
+
+	/**
+	 * Return true if the supplied address could be a valid frame pointer. To
+	 * check for validity we make sure the frame pointer is in one of the spaces;
+	 * <ul>
+	 * <li>LOS (For regular threads)</li>
+	 * <li>Immortal (For threads allocated in immortal space such as collectors)</li>
+	 * <li>Boot (For the boot thread)</li>
+	 * </ul>
+	 *
+	 * <p>
+	 * or it is {@link StackframeLayoutConstants#STACKFRAME_SENTINEL_FP}. The
+	 * STACKFRAME_SENTINEL_FP is possible when the thread has been created but has
+	 * yet to be scheduled.
+	 * </p>
+	 *
+	 * @param address
+	 *          the address.
+	 * @return true if the address could be a frame pointer, false otherwise.
+	 */
+	private static boolean isAddressValidFramePointer(final Address address) {
+		if (address.EQ(Address.zero()))
+			return false; // Avoid hitting assertion failure in MMTk
+		else
+			return address.EQ(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP) || MemoryManager.mightBeFP(address);
+	}
+
+	private static void showPrologue(Address fp) {
+		VM.sysWrite("   at ");
+		if (SHOW_FP_IN_STACK_DUMP) {
+			VM.sysWrite("[");
+			VM.sysWrite(fp);
+			VM.sysWrite(", ");
+			VM.sysWrite(RVMThread.getReturnAddress_(fp));
+			VM.sysWrite("] ");
+		}
+	}
+
+	/**
+	 * Show a method where getCompiledMethod returns null
+	 *
+	 * @param compiledMethodId
+	 * @param fp
+	 */
+	private static void showMethod(int compiledMethodId, Address fp) {
+		showPrologue(fp);
+		VM.sysWrite(
+				"<unprintable normal Java frame: CompiledMethods.getCompiledMethod(",
+				compiledMethodId, ") returned null>\n");
+	}
+
+	/**
+	 * Show a method that we can't show (ie just a text description of the stack
+	 * frame
+	 *
+	 * @param name
+	 * @param fp
+	 */
+	private static void showMethod(String name, Address fp) {
+		showPrologue(fp);
+		VM.sysWrite("<");
+		VM.sysWrite(name);
+		VM.sysWrite(">\n");
+	}
+
+	/**
+	 * Helper function for {@link #dumpStack(Address,Address)}. Print a stack
+	 * frame showing the method.
+	 */
+	private static void showMethod(RVMMethod method, int lineNumber, Address fp) {
+		showPrologue(fp);
+		if (method == null) {
+			VM.sysWrite("<unknown method>");
+		} else {
+			VM.sysWrite(method.getDeclaringClass().getDescriptor());
+			VM.sysWrite(" ");
+			VM.sysWrite(method.getName());
+			VM.sysWrite(method.getDescriptor());
+		}
+		if (lineNumber > 0) {
+			VM.sysWrite(" at line ");
+			VM.sysWriteInt(lineNumber);
+		}
+		VM.sysWrite("\n");
+	}
+
+	/**
+	 * Dump state of a (stopped) thread's stack and exit the virtual machine.
+	 *
+	 * @param fp
+	 *          address of starting frame Returned: doesn't return. This method is
+	 *          called from RunBootImage.C when something goes horrifically wrong
+	 *          with exception handling and we want to die with useful
+	 *          diagnostics.
+	 */
+	@Entrypoint
+	public static void dumpStackAndDie(Address fp) {
+		if (!exitInProgress) {
+			// This is the first time I've been called, attempt to exit "cleanly"
+			exitInProgress = true;
+			dumpStack(fp);
+			VM.sysExit(VM.EXIT_STATUS_DUMP_STACK_AND_DIE);
+		} else {
+			// Another failure occurred while attempting to exit cleanly.
+			// Get out quick and dirty to avoid hanging.
+			sysCall.sysExit(VM.EXIT_STATUS_RECURSIVELY_SHUTTING_DOWN);
+		}
+	}
+
+	/**
+	 * Is it safe to start forcing garbage collects for stress testing?
+	 */
+	public static boolean safeToForceGCs() {
+		return gcEnabled();
+	}
+
+	/**
+	 * Is it safe to start forcing garbage collects for stress testing?
+	 */
+	public static boolean gcEnabled() {
+		return threadingInitialized && getCurrentThread().yieldpointsEnabled();
+	}
+
+	/**
+	 * Set up the initial thread and processors as part of boot image writing
+	 *
+	 * @return the boot thread
+	 */
+	@Interruptible
+	public static RVMThread setupBootThread() {
+		if (VM.VerifyAssertions) VM._assert(bootThread == null);
+		BootThread bt = new BootThread();
+		bootThread = bt.getRVMThread();
+		bootThread.feedlet = TraceEngine.engine.makeFeedlet(
+				"Jikes RVM boot thread",
+				"Thread used to execute the initial boot sequence of Jikes RVM");
+		numActiveThreads++;
+		numActiveDaemons++;
+		return bootThread;
+	}
+
+	/**
+	 * Dump state of virtual machine.
+	 */
+	public static void dumpVirtualMachine() {
+		boolean b = Monitor.lockNoHandshake(dumpLock);
+		getCurrentThread().disableYieldpoints();
+		VM.sysWrite("\n-- Threads --\n");
+		for (int i = 0; i < numThreads; ++i) {
+			RVMThread t = threads[i];
+			if (t != null) {
+				t.dumpWithPadding(30);
+				VM.sysWrite("\n");
+			}
+		}
+		VM.sysWrite("\n");
+
+		VM.sysWrite("\n-- Locks in use --\n");
+		Lock.dumpLocks();
+
+		VM.sysWriteln("Dumping stack of active thread\n");
+		dumpStack();
+
+		VM.sysWriteln("Attempting to dump the stack of all other live threads");
+		VM.sysWriteln("This is somewhat risky since if the thread is running we're going to be quite confused");
+		for (int i = 0; i < numThreads; ++i) {
+			RVMThread thr = threads[i];
+			if (thr != null && thr != RVMThread.getCurrentThread() && thr.isAlive()) {
+				thr.dump();
+				// PNT: FIXME: this won't work so well since the context registers
+				// don't tend to have sane values
+				if (thr.contextRegisters != null && !thr.ignoreHandshakesAndGC())
+					dumpStack(thr.contextRegisters.getInnermostFramePointer());
+			}
+		}
+		getCurrentThread().enableYieldpoints();
+		Monitor.unlock(b, dumpLock);
+	}
+
+	public static Feedlet getCurrentFeedlet() {
+		return getCurrentThread().feedlet;
+	}
+
+	////////////////////////// VM.countThreadTransitions support //////////////////////////
+
+	static final int[] sloppyExecStatusHistogram =
+			new int[LAST_EXEC_STATUS];
+	static final int[] statusAtSTWHistogram =
+			new int[LAST_EXEC_STATUS];
+	static final int[] execStatusTransitionHistogram =
+			new int[LAST_EXEC_STATUS*LAST_EXEC_STATUS];
+
+	public static void reportThreadTransitionCounts() {
+		VM.sysWriteln("Thread Transition Counts:");
+		dump1DHisto("Sloppy Exec Status Histogram",sloppyExecStatusHistogram);
+		dump1DHisto("Status At Stop-the-world Histogram",statusAtSTWHistogram);
+		VM.sysWriteln("  Exec Status Transition Histogram:");
+		for (int fromI=0;fromI<LAST_EXEC_STATUS;++fromI) {
+			for (int toI=0;toI<LAST_EXEC_STATUS;++toI) {
+				int val=
+						execStatusTransitionHistogram[
+						                              transitionHistogramIndex(fromI,toI)];
+				if (val!=0) {
+					VM.sysWriteln("    ",fromI,"->",toI," ",val);
+				}
+			}
+		}
+	}
+
+	static void dump1DHisto(String name,int[] histo) {
+		VM.sysWriteln("  ",name,":");
+		for (int i=0;i<LAST_EXEC_STATUS;++i) {
+			if (histo[i]!=0) {
+				VM.sysWriteln("    ",i," ",histo[i]);
+			}
+		}
+	}
+
+	void observeExecStatus() {
+		sloppyExecStatusHistogram[execStatus]++;
+	}
+
+	public static void observeExecStatusAtSTW(int execStatus) {
+		statusAtSTWHistogram[execStatus]++;
+	}
+
+	// FIXME: add histograms for states returned from various calls to block()
+	// currently we just do it for the block() call in GC STW.
+
+	static int transitionHistogramIndex(int oldState,int newState) {
+		return oldState+newState*LAST_EXEC_STATUS;
+	}
+
+	static void observeStateTransition(int oldState,int newState) {
+		execStatusTransitionHistogram[transitionHistogramIndex(oldState,newState)]++;
+		sloppyExecStatusHistogram[oldState]++;
+		sloppyExecStatusHistogram[newState]++;
+	}
+
+	/**
+	 * JikesRVM TRY-CATCH WORK-STEALING 
+	 */
+	
+	/*
+	 * RDTSC timings for barrier
+	 */
+	protected long totalBarrierCPUCycles = 0;
+	
+	/*
+	 * RDTSC timings for successful steals
+	 */
+	protected long totalSuccessStealCPUCycles = 0;
+
+	/*
+	 * RDTSC timings for failed steals
+	 */
+	protected long totalFailedStealCPUCycles = 0;
+
+	// Automatically launch the workstealing thread
+	// as soon as application's main method is executed
+	public static boolean autogenWSThread = true;
+    protected static boolean wsThreadsLaunched = false;
+
+	/*
+	 * Thread pinning support
+	 */
+    // {
+	protected boolean trace_cpuid = false; 
+	public static boolean ws_pinning_workers = false;
+	public static int sockets = -1;
+	public static int cpusPerSocket = -1;
+	public static int[] pin_map_workers = new int[0];
+	protected int ws_id = -1;
+	public static boolean ws_pinning_system = false;
+	public static int[] pin_map_system = new int[0];
+	public static boolean ws_pinning_gc = false;
+	public static int[] pin_map_gc = new int[0];
+	// }
+	
+	private static final Monitor[] workStealingLockBySlot = new Monitor[MAX_THREADS];
+
+	public StackFrameCopier wsFrameCopier = new StackFrameCopier();
+	private byte[] wsShadowStack;
+	private WS.Continuation wsContinuation = new WS.Continuation(); 
+	public WS.Join wsJoin = new WS.Join();
+	public WS.FinishFirst wsFinishFirst = new WS.FinishFirst();
+	public WS.Finish wsFinish = new WS.Finish();
+	public int wsSpecialNVMap = 0;
+	public boolean wsFlag = false;
+	public volatile boolean wsInJoin = false;
+	Random wsRand;
+
+	public volatile WS.StealInfo wsStealHead = null;
+	public volatile WS.FinishInfo wsFinishHead = null;
+
+
+	public int totalSteals = 0;
+	public int findAttempts = 0;
+	public int pushes = 0;
+	protected int thiefInstalledBarriers = 0;
+	protected int preInstalledBarriers = 0;
+	// following 4 declarations & 2 methods valid only if createContinuationDistribution==true
+	protected int tasksEQ2 = 0;	// tasks <= 2
+	protected int tasksLE4 = 0;	// tasks <= 4
+	protected int tasksGT4 = 0;	// tasks <= 8
+	@Inline
+	private void continuationsDistribution(int tasks) {
+		if(tasks == 2) tasksEQ2++;
+		else if(tasks > 2 && tasks <= 4) tasksLE4++;
+		else if(tasks > 4) tasksGT4++;
+	}
+
+	protected boolean wsThread = false;
+	protected int wsSynchronizationLock = 0;
+	
+	private boolean wsWaitingInsideBarrier = false;
+	private byte[] wsVictimShadowStack = null;
+	Address victimYieldFpOnNewStack = Address.zero();
+	Address victimYieldIPOnNewStack = Address.zero();
+	@Inline
+	public void wsSetInnermost() {
+		contextRegisters.setInnermost(victimYieldIPOnNewStack, victimYieldFpOnNewStack);
+	}
+	public final byte[] wsGetClonedStack() {
+		return wsVictimShadowStack;
+	}
+	private final static int ARRAY_OF_CONTINUATIONS_MAXSIZE = 25; 
+	private final static int ON_OVERFLOW_RESTART_INDEX_IN_ARRAY_OF_CONTINUATIONS = 20;
+	private final AddressArray array_of_continuations = AddressArray.create(ARRAY_OF_CONTINUATIONS_MAXSIZE);
+	private int fpsInContList = 0;
+	private int indexInContList = 0;
+	private boolean iInstalledABarrier = false;
+	
+	public static boolean wsRetBarrier = false;
+
+	/** Registers used by return barrier trampoline */
+	private Registers trampolineRegisters = new Registers();
+
+	/** Return address of stack frame hijacked by return barrier */
+	private Address hijackedReturnAddress;
+
+	/** Callee frame pointer for stack frame hijacked by return barrier */
+	private Address hijackedReturnCalleeFp = Address.zero();
+
+	/** Caller frame pointer for stack frame hijacked by return barrier */
+	private Address hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+
+	/** @return the callee frame pointer for the stack frame hijacked by the return barrier */
+	public Address getHijackedReturnCalleeFp() { return hijackedReturnCalleeFp; }
+
+	/** debugging flag for return barrier trampoline */
+	public static final boolean DEBUG_STACK_TRAMPOLINE = false;
+
+	/** pointer to bridge code for return barrier trampoline */
+	public static ArchitectureSpecific.CodeArray stackTrampolineBridgeInstructions;
+
+	@Uninterruptible
+    @Inline
+    public static Address getReturnAddress_(Address fp) {
+            Address rtn = Magic.getReturnAddressUnchecked(fp);
+            if (isTrampolineIP(rtn)) {
+                    RVMThread t = getCurrentThread();
+                    if (!t.hijackedReturnCalleeFp.EQ(fp)) {
+                            for (int tid = 0; tid < nextSlot; tid++) {
+                                    t = threadBySlot[tid];
+                                    if (t != null && t.hijackedReturnCalleeFp.EQ(fp))
+                                            break;
+                            }
+                    }
+                    VM.sysWrite("<H>");
+                    return t.hijackedReturnAddress;
+            } else {
+                    return rtn;
+            }
     }
 
-    @Override
-    void setBlocked(RVMThread t, boolean value) {
-      t.isSuspended = value;
+    @Uninterruptible
+    @Inline
+    public static Address getReturnAddress(Address fp) {
+            Address rtn = Magic.getReturnAddressUnchecked(fp);
+            if (isTrampolineIP(rtn)) {
+                    RVMThread t = getCurrentThread();
+                    if (!t.hijackedReturnCalleeFp.EQ(fp)) {
+                            for (int tid = 0; tid < nextSlot; tid++) {
+                                    t = threadBySlot[tid];
+                                    if (t != null && t.hijackedReturnCalleeFp.EQ(fp))
+                                            break;
+                            }
+                    }
+                    return t.hijackedReturnAddress;
+            } else {
+                    return rtn;
+            }
     }
-
-    @Override
-    int requestBlock(RVMThread t) {
-      if (t.isSuspended || t.shouldSuspend) {
-        return t.shouldSuspendToken;
-      } else {
-        t.shouldSuspend = true;
-        t.shouldSuspendToken++;
-        return t.shouldSuspendToken;
-      }
+    
+	/**
+	 * The return barrier.
+	 * <p>
+	 * The following code implements return barriers as described
+	 * for Lisp by Yuasa
+	 *
+	 * http://www.yuasa.kuis.kyoto-u.ac.jp/~yuasa/ilc2002/index.html
+	 * http://dx.doi.org/10.1109/ISORC.2005.45
+	 *
+	 * and for Jikes RVM by Kumar et al
+	 *
+	 * http://dx.doi.org/10.1145/2398857.2384639
+	 * <p>
+	 * This code is executed when a method returns into a frame that
+	 * has been hijacked by the return barrier mechanism.   The return
+	 * barrier trampoline will save state, execute this method, and
+	 * then upon return from this method will transparently return into
+	 * the frame that had been hijacked.
+	 * <p>
+	 * In this default implementation, the barrier reinstalls itself
+	 * in the caller's frame thus incrementally moving the barrier down
+	 * the stack.
+	 * <p>
+	 * The execution of this method is fragile.  It is generally safest
+	 * to call some other method from here that does the substantive work
+	 * of the barrier.
+	 */
+	@Entrypoint
+	@Uninterruptible
+	@Unpreemptible
+	public static void returnBarrier() {
+		/* reinstall the barrier in the caller's frame */
+		if (DEBUG_STACK_TRAMPOLINE) {
+			VM.sysWriteln(getCurrentThread().getId(), " T0: ", getCurrentThread().trampolineRegisters.gprs.get(BaselineConstants.T0_int).toAddress());
+			VM.sysWriteln(getCurrentThread().getId(), " T1: ", getCurrentThread().trampolineRegisters.gprs.get(BaselineConstants.T1_int).toAddress());
+			VM.sysWriteln(getCurrentThread().getId(), " nf: ", getCurrentThread().hijackedReturnCallerFp);
+			VM.sysWriteln(getCurrentThread().getId(), " lf: ", getCurrentThread().hijackedReturnCalleeFp);
+			VM.sysWriteln(getCurrentThread().getId(), " fp: ", Magic.getFramePointer());
+			VM.sysWriteln(getCurrentThread().getId(), " np: ", Magic.getCallerFramePointer(Magic.getFramePointer()));
+		}
+		/* reinstall the barrier in the specified frame */
+		getCurrentThread().returnBarrier_internal();
+	}
+
+	/**
+	 * Install the stack trampoline bridge at a given frame, hijacking
+	 * that frame, saving the hijacked return address and callee fp
+	 * in thread-local state to allow execution of the hijacked frame
+	 * later.
+	 *
+	 * @param targetFp The frame to be hijacked.
+	 */
+	@Uninterruptible
+	@Inline
+	public void wsInstallStackTrampolineBridge(Address targetFp) {
+		Address trampoline = getStackTrampolineBridgeIP();
+		if(wsDebugTrace) {
+			if (trampoline.isZero()) {
+				if (VM.VerifyAssertions)
+					VM._assert(VM.NOT_REACHED);
+				else
+					VM.sysWriteln("Warning: attempt to install stack trampoline without bridge instructions - nothing done.  See RVMThread.");
+			} else if (trampoline.NE(Magic.getReturnAddressUnchecked(targetFp))) {
+				/* install the trampoline at fp or the next suitable frame after fp */
+				while (true) {
+					if (Magic.getCallerFramePointer(targetFp).EQ(ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+						/* if we're at the bottom of the stack, then do not install anything */
+						hijackedReturnAddress = Address.zero();
+						hijackedReturnCalleeFp = Address.zero();
+						return;
+					}
+					int cmid = Magic.getCompiledMethodID(targetFp);
+					if (cmid == ArchitectureSpecific.ArchConstants.INVISIBLE_METHOD_ID) {
+						/* skip invisible methods */
+						VM.sysWriteln("Warning: install stack trampoline skipping INVISIBLE_METHOD..  See RVMThread.");
+						targetFp = Magic.getCallerFramePointer(targetFp);
+					} else {
+						CompiledMethod calleeCM = CompiledMethods.getCompiledMethod(cmid);
+						if (calleeCM.getCompilerType() == CompiledMethod.TRAP ||
+								calleeCM.getMethod().getDeclaringClass().hasBridgeFromNativeAnnotation()) {
+							/* skip traps and native bridges */
+							VM.sysWriteln("Warning: install stack trampoline skipping Traps..  See RVMThread.");
+							targetFp = Magic.getCallerFramePointer(targetFp);
+						} else
+							break;
+					}
+				}
+				if (DEBUG_STACK_TRAMPOLINE) {
+					VM.sysWriteln(getId(), " Installing trampoline at: ", targetFp);
+					VM.sysWriteln(getId(), " Dumping my original stack first");
+					dumpStack(this.contextRegisters.getInnermostInstructionAddress(),this.contextRegisters.getInnermostFramePointer());
+				}
+				hijackedReturnAddress = Magic.getReturnAddressUnchecked(targetFp);
+				hijackedReturnCalleeFp = targetFp;
+				hijackedReturnCallerFp = Magic.getCallerFramePointer(targetFp);
+				if (VM.VerifyAssertions) VM._assert(trampoline.NE(hijackedReturnAddress));
+				Magic.setReturnAddress(targetFp, trampoline);
+				if (DEBUG_STACK_TRAMPOLINE) {
+					VM.sysWriteln(getId(), " Trampoline: ", trampoline);
+					VM.sysWriteln(getId(), " Hijacked return address: ", hijackedReturnAddress);
+					VM.sysWriteln(getId(), " Callee fp: ", hijackedReturnCalleeFp);
+					VM.sysWriteln(getId(), " Caller fp: ", hijackedReturnCallerFp);
+					VM.sysWriteln(getId(), " Trampoline installation done. Now Dumping the new stack");
+					//				dumpStack(hijackedReturnCalleeFp);
+					dumpStack(this.contextRegisters.getInnermostInstructionAddress(),this.contextRegisters.getInnermostFramePointer());
+				}
+			}
+		}
+		else {
+			// No checks on fast path
+			hijackedReturnAddress = Magic.getReturnAddressUnchecked(targetFp);
+			hijackedReturnCalleeFp = targetFp;
+			hijackedReturnCallerFp = Magic.getCallerFramePointer(targetFp);
+			Magic.setReturnAddress(targetFp, trampoline);
+		}
+	}
+	
+	@Uninterruptible
+	@Inline
+	public void resetTramoplineInfo() {
+		if(wsDebugTrace) {
+			VM.sysWriteln(getId(),": Resetting my barrier variables");
+		}
+		wsReturnBarrierUninstalled = true;
+		hijackedReturnCalleeFp = Address.zero();
+		hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+	}
+	
+	@Uninterruptible
+	@Inline
+	public void resetTramoplineInfo_unlocked() {
+		wsReturnBarrierUninstalled = true;
+		wsSafeToReturnFromBarrier = true;
+		wsWaitingInsideBarrier = false;
+		hijackedReturnCalleeFp = Address.zero();
+		hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+	}
+
+	/**
+	 * de-install the stack trampoline (disabling return barriers).
+	 */
+	@Uninterruptible
+	@Inline
+	public void deInstallStackTrampoline() {
+		if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": deinstalling trampoline: ", framePointer);
+		if (!hijackedReturnCalleeFp.isZero()) {
+			if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": need to reinstall: ", hijackedReturnAddress);
+			hijackedReturnCalleeFp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET).store(hijackedReturnAddress);
+			hijackedReturnCalleeFp = Address.zero();
+			hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+			wsReturnBarrierUninstalled = true;
+			if(wsDebugTrace) {
+				VM.sysWriteln(getId(),": My barrier is deInstalled by thief W-",getCurrentThread().getId());
+			}
+		}
+	}
+	
+	@Uninterruptible
+	@Inline
+	public void deInstallStackTrampoline_fromGC() {
+		if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": deinstalling trampoline: ", framePointer);
+		if (!hijackedReturnCalleeFp.isZero()) {
+			if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": need to reinstall: ", hijackedReturnAddress);
+			hijackedReturnCalleeFp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET).store(hijackedReturnAddress);
+			hijackedReturnCalleeFp = Address.zero();
+			hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+			wsReturnBarrierUninstalled = true;
+			if(workstealingInProgress) VM.sysFail("GC cannot take place when workstealingInProgress");
+			wsSafeToReturnFromBarrier = true;
+			wsWaitingInsideBarrier = false;
+			if(wsDebugTrace) {
+				VM.sysWriteln(getId(),": My barrier is deInstalled from GC");
+			}
+		}
+	}
+
+	@Uninterruptible
+	@Inline
+	private void wsUnlockFromReturnBarrier() {
+		wsLock().lockNoHandshake();
+		/* Never use this method here at all if the victim has already branched into the return barrier else there will be bugs !!
+		deInstallStackTrampoline();
+		 */
+		
+		// List contains fps of callee to the continuation frames. Once the steal is completed, 
+		// means the last fp in the list is the callee to the task stolen in this steal.
+		fpsInContList--;	
+		wsSafeToReturnFromBarrier = true;
+		wsLock().broadcast();
+		wsLock().unlock();
+	}
+	
+	// Some debug flags
+	// {
+	final protected static boolean createContinuationDistribution = false;
+	// Switches to enable / disble optimizations related to return barrier
+	// 1) The most basic optimization w.r.t return barrier
+	final private static boolean victimCanBeReleasedAfterRBarrierIsInstalled = true;
+	// 2) Enable this only if 1 is true
+	final private static boolean victimCanReinstallBarrier = true;
+	// 3) Enable this only if 1 and 2 is true
+	final private static boolean thiefCanInitiateStealFromAPreInstalledBarrier = true;
+	// }
+	
+	@Uninterruptible
+	@Inline
+	public void returnBarrier_internal() {
+		if(wsDebugTrace) {
+			VM.sysWriteln(getId(),": Entering inside rbarrier");
+		}
+		{
+			wsLock().lockNoHandshake();
+			hijackedReturnAddress_original = hijackedReturnAddress;
+			while(true) {
+				boolean removeBarrier = false;
+				// 1. should break out if no steals in progress
+				//		1a) try to re-install the barrier 
+				if(wsSafeToReturnFromBarrier) {
+					if(victimCanReinstallBarrier) {
+						if(indexInContList < fpsInContList) {
+							if(false) {
+								final int remaining = fpsInContList - indexInContList;
+								if(remaining >= 4) { 
+									// install in the middle most fp - better than installing in each fp
+									final int sum = indexInContList + fpsInContList;
+									indexInContList = (sum%2 == 0) ? (sum/2 -1) : sum/2;
+								}
+							}
+							wsInstallStackTrampolineBridge(array_of_continuations.get(indexInContList++));	
+							if(wsDebugTrace) {
+								VM.sysWriteln(getId(),": Done reinstalling my own rbarrier");
+							}
+							break;
+						}
+						else {
+							// remove barrier variables as its now going to be unInstalled
+							removeBarrier = true;
+						}
+					}
+					else {
+						// remove barrier variables as its now going to be unInstalled
+						removeBarrier = true;
+					}
+				}
+				// If I am here then it means either: 
+				// a) I shd remove barrier 
+				// 			OR
+				// b) !wsSafeToReturnFromBarrier
+				if(removeBarrier) {
+					// Break out only if 
+					// i) no work-stealing is in progress
+					//				OR
+					// ii) The last thief decided that no further steal happens from this barrier
+					//    position. This is only if there are no more continuations remaining below
+					//    Only one variable workstealingInProgress is not sufficient to decide. 
+					//
+					//    Helps reducing failed steal ========> 
+					//	  If there is no continuations but before I reach here, another thief get
+					//    holds of me then it can do a failed steal attempt.
+					//
+					//	  Helps removing deadlock =========>
+					//	  When the last theif found there are no more continuations left, it marks
+					//    wsReturnBarrierUninstalled =  true. Now if we dont have the check for 
+					//    wsReturnBarrierUninstalled here then there maybe a deadlock. Suppose another
+					//    another theif grabs me mark workstealingInProgress=true. But just then I reach
+					//    over here and see that workstealingInProgress is in progress, I will keep waiting
+					//    However the thief is not aware of this, and it will wait for me to yield, which
+					//    will never happen. Hence two variables required here.
+					if(!workstealingInProgress || wsReturnBarrierUninstalled) {
+						if(wsDebugTrace) {
+							VM.sysWriteln(getId(),": No steal in progress hence removing my barrier");
+						}
+						resetTramoplineInfo();
+						break;
+					}
+					else {
+						if(wsDebugTrace) {
+							VM.sysWriteln(getId(),": There is a steal in progress hence cannot remove my barrier and so waiting");
+						}
+					}
+				}
+				else {
+					// case b
+					// ==> simply wait !!!
+					if(wsDebugTrace) {
+						VM.sysWriteln(getId(),": Thief still access my stack hence waiting in barrier to try unwind");
+					}
+				}
+				final long start = Magic.getTimeBase();
+				wsWaitingInsideBarrier = true;
+				wsLock().waitNoHandshake();
+				wsWaitingInsideBarrier = false;
+				totalBarrierCPUCycles += (Magic.getTimeBase() - start);
+				// 3. update the hijacked return address as thief may have updated it with join instruction
+				hijackedReturnAddress_original = hijackedReturnAddress;
+			}
+			
+			wsLock().unlock();
+		}
+		if(wsDebugTrace) {
+			VM.sysWriteln(getId(),": Returning from rbarrier");
+		}
+	}
+	
+	private Address hijackedReturnAddress_original; //is set only from returnBarrier() method
+	public Address getHijackedReturnCallerFp() { return hijackedReturnCallerFp; }
+	public Address getHijackedReturnAddress() { return hijackedReturnAddress; }
+	
+	public boolean wsMaintainsClonedStackAlso() {
+		return !wsReturnBarrierUninstalled;
+	}
+	
+	// Lock/Unlock flags for return barrier: a) and b)
+	/*
+	 * a)
+	 * --- This flag is turned on by thief at the victim as soon as it installs a barrier
+	 * on this victim
+	 * --- Thief can mark it off if it starts a steal from a barrier but finds 0 or 1
+	 * continuations.
+	 * --- Victim is allowed to mark it off only when its removing the barrier from its
+	 * stack
+	 * 
+	 * Thieves use this to decide if they can start stealing from a return barrier
+	 * without forcing the victim to execute yieldpoint. 
+	 */
+	private boolean wsReturnBarrierUninstalled = true;
+	/*
+	 * b) 
+	 * -- Default value is true. Only a thief can make it off (false)
+	 * Victims can only read but cannot write to it. Victims use it
+	 * to decide when it becomes safe for them to re-install this barrier
+	 * at a new position.
+	 */
+	private boolean wsSafeToReturnFromBarrier = true;
+	
+	/*
+	 * This lock is used to decide if a steal is is progress at a victim.
+	 * However, this flag is also used inside return barrier to decide
+	 * if its safe for a victim to remove its return barrier from its stack.
+	 * Only a thief is allowed to write to this flag and make it true/false.
+	 * Victims can only read it. Unless its false, they cannot remove its
+	 * return barrier. 
+	 */
+	protected boolean workstealingInProgress = false;
+	
+	public void setHijackedReturnAddress(Address ip) { hijackedReturnAddress = ip; } 
+
+	/** @return the address of the stack trampoline bridge code */
+	@Inline
+	private Address getStackTrampolineBridgeIP() { return Magic.objectAsAddress(stackTrampolineBridgeInstructions); }
+
+	/** @return the hijacked return address */
+	@Inline
+	public Address getTrampolineHijackedReturnAddress() { return hijackedReturnAddress; }
+
+	/**
+	 * Determine whether a given method is the stack trampoline
+	 *
+	 * @param ip the code to be checked
+	 * @return <code>true</code> if the code is the stack trampoline.
+	 */
+	@Inline
+	public static boolean isTrampolineIP(Address ip) { return getCurrentThread().getStackTrampolineBridgeIP().EQ(ip); }
+	
+	/**
+	 * Given a frame that has been hijacked by the stack trampoline,
+	 * return the real (hijacked) return address.
+	 *
+	 * @param hijackedFp a frame that has been hijacked by the stack trampoline
+	 * @return the return address for the frame that was hijacked.
+	 */
+	@Uninterruptible
+	public static Address getHijackedReturnAddress(Address hijackedFp) {
+		if (VM.VerifyAssertions) VM._assert(isTrampolineIP(Magic.getReturnAddressUnchecked(hijackedFp)));
+		RVMThread t = getCurrentThread();
+		if (!t.hijackedReturnCalleeFp.EQ(hijackedFp)) {
+			for (int tid = 0; tid < nextSlot; tid++) {
+				t = threadBySlot[tid];
+				if (t != null && t.hijackedReturnCalleeFp.EQ(hijackedFp))
+					break;
+			}
+		}
+		return t.hijackedReturnAddress;
+	}
+	
+	@Uninterruptible
+	@Inline
+	public Address getCalleeFramePointer(final Address fp) {
+		Address calleeFP = fp;
+		final Address top = Magic.objectAsAddress(this.getStack());
+		final Address base = top.plus(this.getStackLength());
+
+		while(calleeFP.NE(base)) {
+			if(calleeFP.loadAddress().EQ(fp)) return calleeFP;
+			calleeFP = calleeFP.minus(StackframeLayoutConstants.BYTES_IN_STACKSLOT);
+		}
+		return Address.zero();
+	}
+	
+	@Unpreemptible
+	@Inline
+	protected void wsCheckShadowStack_retbarrier(RVMThread victim) {
+		if (wsShadowStack == null || wsShadowStack.length < victim.getStackLength()) {
+			wsShadowStack = MemoryManager.newStack(victim.getStackLength());
+		}
+
+		if (victim.wsVictimShadowStack == null || victim.wsVictimShadowStack.length < victim.getStackLength()) {
+			victim.wsVictimShadowStack = MemoryManager.newStack(victim.getStackLength());
+		}
+	}
+	
+	@Unpreemptible
+	@Inline
+	public static Address wsCloneVictimStack(final RVMThread victim, final Address yieldpointFP) {
+		byte[] newStack = victim.wsVictimShadowStack;
+		byte[] currStack = victim.getStack();
+
+		Address currTop = Magic.objectAsAddress(currStack).plus(currStack.length);
+		Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
+
+		Offset currDepth = currTop.diff(yieldpointFP);
+		Address newFP = newTop.minus(currDepth);
+
+		Memory.memcopy(newFP, yieldpointFP, currDepth.toWord().toExtent());
+
+		Offset delta = newFP.diff(yieldpointFP);
+
+		adjustStack(newStack, newFP, delta);
+		victim.victimYieldIPOnNewStack = Magic.getReturnAddress(yieldpointFP);
+
+		return Magic.getCallerFramePointer(newFP);
+	}
+	
+	/**
+	 * This method should always be called from a method which has following annotations:
+	 * 1) @Unpreemptible
+	 * 2) @NoInline
+	 * 3) @NoOptCompile
+	 * 4) @BaselineSaveLSRegisters
+	 */
+	@Unpreemptible
+    @NoInline
+    @BaselineNoRegisters
+    private void wsCloneMyOwnStack(Address ip, Address fp) {
+            byte[] newStack = wsVictimShadowStack;
+            byte[] myStack = stack;
+
+            // initialize new stack with live portion of stack we're
+            // currently running on
+            //
+            // lo-mem hi-mem
+            // |<---myDepth----|
+            // +----------+---------------+
+            // | empty | live |
+            // +----------+---------------+
+            // ^myStack ^myFP ^myTop
+            //
+            // +-------------------+---------------+
+            // | empty | live |
+            // +-------------------+---------------+
+            // ^newStack ^newFP ^newTop
+            //
+            Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
+            Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
+
+            Address myFP = Magic.getFramePointer();
+            Offset myDepth = myTop.diff(myFP);
+            Address newFP = newTop.minus(myDepth);
+
+            // The frame pointer addresses the top of the frame on powerpc and
+            // the bottom
+            // on intel. if we copy the stack up to the current
+            // frame pointer in here, the
+            // copy will miss the header of the intel frame. Thus we make another
+            // call
+            // to force the copy. A more explicit way would be to up to the
+            // frame pointer
+            // and the header for intel.
+            Offset delta = copyStack(newStack);
+
+            // fix up registers and save areas so they refer
+            // to "newStack" rather than "myStack"
+            //
+            adjustStack(newStack, newFP, delta);
+
+            victimYieldFpOnNewStack = Magic.getCallerFramePointer(newFP);
+            victimYieldIPOnNewStack = Magic.getReturnAddress(newFP);
     }
-
-    @Override
-    boolean hasBlockRequest(RVMThread t) {
-      return t.shouldSuspend;
-    }
-
-    @Override
-    boolean hasBlockRequest(RVMThread t, int token) {
-      return t.shouldSuspend && t.shouldSuspendToken == token;
-    }
-
-    @Override
-    void clearBlockRequest(RVMThread t) {
-      t.shouldSuspend = false;
-    }
-  }
-
-  public static final SuspendBlockAdapter suspendBlockAdapter = new SuspendBlockAdapter();
-
-  @Uninterruptible
-  @NonMoving
-  public static class HandshakeBlockAdapter extends BlockAdapter {
-    @Override
-    boolean isBlocked(RVMThread t) {
-      return t.isBlockedForHandshake;
-    }
-
-    @Override
-    void setBlocked(RVMThread t, boolean value) {
-      t.isBlockedForHandshake = value;
-    }
-
-    @Override
-    int requestBlock(RVMThread t) {
-      if (!t.isBlockedForHandshake) {
-        t.shouldBlockForHandshake = true;
-      }
-      return 0;
-    }
-
-    @Override
-    boolean hasBlockRequest(RVMThread t) {
-      return t.shouldBlockForHandshake;
-    }
-
-    @Override
-    boolean hasBlockRequest(RVMThread t, int token) {
-      return t.shouldBlockForHandshake;
-    }
-
-    @Override
-    void clearBlockRequest(RVMThread t) {
-      t.shouldBlockForHandshake = false;
-    }
-  }
-
-  public static final HandshakeBlockAdapter handshakeBlockAdapter = new HandshakeBlockAdapter();
-
-  @Uninterruptible
-  @NonMoving
-  public static class GCBlockAdapter extends BlockAdapter {
-    @Override
-    boolean isBlocked(RVMThread t) {
-      return t.isBlockedForGC;
-    }
-
-    @Override
-    void setBlocked(RVMThread t, boolean value) {
-      t.isBlockedForGC = value;
-    }
-
-    @Override
-    int requestBlock(RVMThread t) {
-      if (!t.isBlockedForGC) {
-        t.shouldBlockForGC = true;
-      }
-      return 0;
-    }
-
-    @Override
-    boolean hasBlockRequest(RVMThread t) {
-      return t.shouldBlockForGC;
-    }
-
-    @Override
-    boolean hasBlockRequest(RVMThread t, int token) {
-      return t.shouldBlockForGC;
-    }
-
-    @Override
-    void clearBlockRequest(RVMThread t) {
-      t.shouldBlockForGC = false;
-    }
-  }
-
-  public static final GCBlockAdapter gcBlockAdapter = new GCBlockAdapter();
-
-  static final BlockAdapter[] blockAdapters = new BlockAdapter[] {
-    suspendBlockAdapter, handshakeBlockAdapter, gcBlockAdapter };
-
-  /**
-   * An enumeration that describes the different manners in which a thread might
-   * be voluntarily waiting.
-   */
-  protected static enum Waiting {
-    /** The thread is not waiting at all. In fact it's running. */
-    RUNNABLE,
-    /** The thread is waiting without a timeout. */
-    WAITING,
-    /** The thread is waiting with a timeout. */
-    TIMED_WAITING
-  }
-
-  /**
-   * Accounting of whether or not a thread is waiting (in the Java thread state
-   * sense), and if so, how it's waiting.
-   * <p>
-   * Invariant: the RVM runtime does not ever use this field for any purpose
-   * other than updating it so that the java.lang.Thread knows the state. Thus,
-   * if you get sloppy with this field, the worst case outcome is that some Java
-   * program that queries the thread state will get something other than what it
-   * may or may not have expected.
-   */
-  protected Waiting waiting;
-
-  /**
-   * Exception to throw in this thread at the earliest possible point.
-   */
-  Throwable asyncThrowable;
-
-  /**
-   * Has the thread been interrupted?
-   */
-  boolean hasInterrupt;
-
-  /**
-   * Should the next executed yieldpoint be taken? Can be true for a variety of
-   * reasons. See RVMThread.yieldpoint
-   * <p>
-   * To support efficient sampling of only prologue/epilogues we also encode
-   * some extra information into this field. 0 means that the yieldpoint should
-   * not be taken. >0 means that the next yieldpoint of any type should be taken
-   * <0 means that the next prologue/epilogue yieldpoint should be taken
-   * <p>
-   * Note the following rules:
-   * <ol>
-   * <li>If takeYieldpoint is set to 0 or -1 it is perfectly safe to set it to
-   * 1; this will have almost no effect on the system. Thus, setting
-   * takeYieldpoint to 1 can always be done without acquiring locks.</li>
-   * <li>Setting takeYieldpoint to any value other than 1 should be done while
-   * holding the thread's monitor().</li>
-   * <li>The exception to rule (2) above is that the yieldpoint itself sets
-   * takeYieldpoint to 0 without holding a lock - but this is done after it
-   * ensures that the yieldpoint is deferred by setting yieldpointRequestPending
-   * to true.
-   * </ol>
-   */
-  @Entrypoint
-  public int takeYieldpoint;
-
-  /**
-   * How many times has the "timeslice" expired? This is only used for profiling
-   * and OSR (in particular base-to-opt OSR).
-   */
-  public int timeSliceExpired;
-
-  /** Is a running thread permitted to ignore the next park request */
-  private boolean parkingPermit;
-
-  /*
-   * JNI fields
-   */
-
-  /**
-   * Cached JNI environment for this thread
-   */
-  @Entrypoint
-  @Untraced
-  private JNIEnvironment jniEnv;
-  @SuppressWarnings("unused")
-  private JNIEnvironment jniEnvShadow;
-
-  /** Used by GC to determine collection success */
-  private boolean physicalAllocationFailed;
-
-  /** Used by GC to determine collection success */
-  private int collectionAttempt;
-
-  /** The OOME to throw */
-  private static OutOfMemoryError outOfMemoryError;
-
-  /*
-   * Enumerate different types of yield points for sampling
-   */
-  public static final int PROLOGUE = 0;
-
-  public static final int BACKEDGE = 1;
-
-  public static final int EPILOGUE = 2;
-
-  public static final int NATIVE_PROLOGUE = 3;
-
-  public static final int NATIVE_EPILOGUE = 4;
-
-  public static final int OSROPT = 5;
-
-  /*
-   * Fields used for on stack replacement
-   */
-
-  /**
-   * Only used by OSR when VM.BuildForAdaptiveSystem. Declared as an Object to
-   * cut link to adaptive system. Ugh.
-   */
-  public final Object /* OnStackReplacementEvent */onStackReplacementEvent;
-
-  /**
-   * The flag indicates whether this thread is waiting for on stack replacement
-   * before being rescheduled.
-   */
-  // flags should be packaged or replaced by other solutions
-  public boolean isWaitingForOsr = false;
-
-  /**
-   * Before call new instructions, we need a bridge to recover register states
-   * from the stack frame.
-   */
-  public CodeArray bridgeInstructions = null;
-
-  /** Foo frame pointer offset */
-  public Offset fooFPOffset = Offset.zero();
-
-  /** Thread switch frame pointer offset */
-  public Offset tsFPOffset = Offset.zero();
-
-  /**
-   * Flag to synchronize with osr organizer, the trigger sets osr requests the
-   * organizer clear the requests
-   */
-  public boolean requesting_osr = false;
-
-  /**
-   * Flag to indicate that the last OSR request is done.
-   */
-  public boolean osr_done = false;
-
-  /**
-   * The number of processors to use.
-   */
-  public static int availableProcessors = -1;
-
-  /**
-   * Thread handle. Currently stores pthread_t, which we assume to be no larger
-   * than a pointer-sized word.
-   */
-  public Word pthread_id;
-
-  /**
-   * Scratch area for use for gpr <=> fpr transfers by PPC baseline compiler.
-   * Used to transfer x87 to SSE registers on IA32
-   */
-  @SuppressWarnings({ "unused" })
-  // accessed via EntryPoints
-  private double scratchStorage;
-
-  /**
-   * Current index of this thread in the threads array. This may be changed by
-   * another thread, but only while the acctLock is held.
-   */
-  private int threadIdx;
-
-  /**
-   * Is the system in the process of shutting down (has System.exit been called)
-   */
-  private static boolean systemShuttingDown = false;
-
-  /**
-   * Flag set by external signal to request debugger activation at next thread
-   * switch. See also: RunBootImage.C
-   */
-  public static volatile boolean debugRequested;
-
-  public volatile boolean asyncDebugRequestedForThisThread;
-
-  /**
-   * The latch for reporting profile data.
-   */
-  public static Latch doProfileReport;
-
-  /** Number of times dump stack has been called recursively */
-  protected int inDumpStack = 0;
-
-  /** Is this a "registered mutator?" */
-  public boolean activeMutatorContext = false;
-
-  /** Lock used for dumping stack and such. */
-  public static Monitor dumpLock;
-
-  /** In dump stack and dying */
-  protected static boolean exitInProgress = false;
-
-  private static boolean worldStopped;
-
-  /** Extra debug from traces */
-  protected static final boolean traceDetails = false;
-
-  /** Toggle display of frame pointer address in stack dump */
-  private static final boolean SHOW_FP_IN_STACK_DUMP = true;
-
-  /** Index of thread in which "VM.boot()" runs */
-  public static final int PRIMORDIAL_THREAD_INDEX = 1;
-
-  /** Maximum number of RVMThread's that we can support. */
-  public static final int LOG_MAX_THREADS = 10;
-
-  public static final int MAX_THREADS = 1 << LOG_MAX_THREADS;
-
-  /**
-   * thread array - all threads are stored in this array according to their
-   * threadSlot.
-   */
-  public static RVMThread[] threadBySlot = new RVMThread[MAX_THREADS];
-
-  /**
-   * Per-thread monitors. Note that this array is statically initialized. It
-   * starts out all null. When a new thread slot is allocated, a monitor is
-   * added for that slot.
-   * <p>
-   * Question: what is the outcome, if any, of taking a yieldpoint while holding
-   * this lock?
-   * <ol>
-   * <li>If there is a GC request we will wait on this condition variable and
-   * thus release it. Someone else might then acquire the lock before realizing
-   * that there is a GC request and then do bad things.</li>
-   * <li>The yieldpoint might acquire another thread's monitor. Thus, two
-   * threads may get into lock inversion with each other.</li>
-   * <li>???</li>
-   * </ol>
-   */
-  private static final NoYieldpointsMonitor[] monitorBySlot = new NoYieldpointsMonitor[MAX_THREADS];
-
-  private static final Monitor[] communicationLockBySlot = new Monitor[MAX_THREADS];
-
-  /**
-   * Lock (mutex) used for creating and destroying threads as well as thread
-   * accounting.  This mutex should not be held while thread monitors (see monitorBySlot)
-   * are held.  Use this mutex only to protect accesses to:
-   * <ul>
-   * <li>the global thread lists, such as threadBySlot, aboutToTerminate, threads, and
-   *     freeLots</li>
-   * <li>threadIdx field of RVMThread</li>
-   * <li>numThreads, numActiveThreads, numActiveDaemons static fields of RVMThread</li>
-   * </ul>
-   */
-  public static NoYieldpointsMonitor acctLock;
-
-  /**
-   * Lock (mutex) used for servicing debug requests.
-   */
-  public static NoYieldpointsMonitor debugLock;
-
-  /**
-   * Lock used for generating debug output.
-   */
-  private static NoYieldpointsMonitor outputLock;
-
-  /**
-   * Thread slots of threads that are about to terminate.  This must be
-   * an int array because it's accessed from code that cannot have
-   * barriers.
-   */
-  private static final int[] aboutToTerminate = new int[MAX_THREADS];
-
-  /**
-   * Number of threads that are about to terminate.
-   */
-  private static int aboutToTerminateN;
-
-  /**
-   * Free thread slots
-   */
-  private static final int[] freeSlots = new int[MAX_THREADS];
-
-  /**
-   * Number of free thread slots.
-   */
-  private static int freeSlotN;
-
-  /**
-   * When there are no thread slots on the free list, this is the next one to
-   * use.
-   */
-  public static int nextSlot = 2;
-
-  /**
-   * Number of threads in the system (some of which may not be active).
-   */
-  public static int numThreads;
-
-  /**
-   * Packed and unordered array or active threads. Only entries in the range 0
-   * to numThreads-1 (inclusive) are defined. Note that it should be possible to
-   * scan this array without locking and get all of the threads - but only if
-   * you scan downward and place a memory fence between loads.
-   * <p>
-   * Note further that threads remain in this array even after the Java
-   * libraries no longer consider the thread to be active.
-   */
-  public static final RVMThread[] threads = new RVMThread[MAX_THREADS];
-
-  /**
-   * Preallocated array for use in handshakes. Protected by handshakeLock.
-   */
-  public static final RVMThread[] handshakeThreads = new RVMThread[MAX_THREADS];
-
-  /**
-   * Preallocated array for use in debug requested. Protected by debugLock.
-   */
-  public static final RVMThread[] debugThreads = new RVMThread[MAX_THREADS];
-
-  /**
-   * Number of active threads in the system.
-   */
-  private static int numActiveThreads;
-
-  /**
-   * Number of active daemon threads.
-   */
-  private static int numActiveDaemons;
-
-  /*
-   * TuningFork instrumentation support
-   */
-  /**
-   * The Feedlet instance for this thread to use to make addEvent calls.
-   */
-  public Feedlet feedlet;
-
-  /**
-   * Get a NoYieldpointsCondLock for a given thread slot.
-   */
-  static NoYieldpointsMonitor monitorForSlot(int slot) {
-    NoYieldpointsMonitor result = monitorBySlot[slot];
-    if (VM.VerifyAssertions)
-      VM._assert(result != null);
-    return result;
-  }
-
-  /**
-   * Get the NoYieldpointsCondLock for this thread.
-   */
-  public NoYieldpointsMonitor monitor() {
-    return monitorForSlot(threadSlot);
-  }
-
-  public Monitor communicationLockForSlot(int slot) {
-    Monitor result = communicationLockBySlot[slot];
-    if (VM.VerifyAssertions)
-      VM._assert(result != null);
-    return result;
-  }
-
-  public Monitor communicationLock() {
-    return communicationLockForSlot(threadSlot);
-  }
-
-  /**
-   * Initialize the threading subsystem for the boot image.
-   */
-  @Interruptible
-  public static void init() {
-    // Enable us to dump a Java Stack from the C trap handler to aid in
-    // debugging things that
-    // show up as recursive use of hardware exception registers (eg the
-    // long-standing lisp bug)
-    BootRecord.the_boot_record.dumpStackAndDieOffset =
-      Entrypoints.dumpStackAndDieMethod.getOffset();
-    Lock.init();
-  }
-
-  public void assertAcceptableStates(int expected) {
-    if (VM.VerifyAssertions) {
-      int curStatus=getExecStatus();
-      if (curStatus!=expected) {
-        VM.sysWriteln("FATAL ERROR: unexpected thread state.");
-        VM.sysWriteln("Expected: ",expected);
-        VM.sysWriteln("Observed: ",curStatus);
-        VM._assert(curStatus==expected);
-      }
-    }
-  }
-
-  public void assertAcceptableStates(int expected1,int expected2) {
-    if (VM.VerifyAssertions) {
-      int curStatus=getExecStatus();
-      if (curStatus!=expected1 &&
-          curStatus!=expected2) {
-        VM.sysWriteln("FATAL ERROR: unexpected thread state.");
-        VM.sysWriteln("Expected: ",expected1);
-        VM.sysWriteln("      or: ",expected2);
-        VM.sysWriteln("Observed: ",curStatus);
-        VM._assert(curStatus==expected1 ||
-                   curStatus==expected2);
-      }
-    }
-  }
-
-  public void assertUnacceptableStates(int unexpected) {
-    if (VM.VerifyAssertions) {
-      int curStatus=getExecStatus();
-      if (curStatus==unexpected) {
-        VM.sysWriteln("FATAL ERROR: unexpected thread state.");
-        VM.sysWriteln("Unexpected: ",unexpected);
-        VM.sysWriteln("  Observed: ",curStatus);
-        VM._assert(curStatus!=unexpected);
-      }
-    }
-  }
-
-  public void assertUnacceptableStates(int unexpected1,int unexpected2) {
-    if (VM.VerifyAssertions) {
-      int curStatus=getExecStatus();
-      if (curStatus==unexpected1 ||
-          curStatus==unexpected2) {
-        VM.sysWriteln("FATAL ERROR: unexpected thread state for thread", threadSlot);
-        VM.sysWriteln("Unexpected: ",unexpected1);
-        VM.sysWriteln("       and: ",unexpected2);
-        VM.sysWriteln("  Observed: ",curStatus);
-        VM._assert(curStatus!=unexpected1 &&
-                   curStatus!=unexpected2);
-      }
-    }
-  }
-
-  static void bind(int cpuId) {
-    if (VM.VerifyAssertions) VM._assert(sysCall.sysThreadBindSupported()==1);
-    sysCall.sysThreadBind(cpuId);
-  }
-
-  static void bindIfRequested() {
-    if (VM.forceOneCPU>=0) {
-      if (traceBind) {
-        VM.sysWriteln("binding thread to CPU: ",VM.forceOneCPU);
-      }
-      bind(VM.forceOneCPU);
-    }
-  }
-
-  /**
-   * Boot the threading subsystem.
-   */
-  @Interruptible
-  // except not really, since we don't enable yieldpoints yet
-  public static void boot() {
-    outOfMemoryError = new OutOfMemoryError();
-    dumpLock = new Monitor();
-    acctLock = new NoYieldpointsMonitor();
-    debugLock = new NoYieldpointsMonitor();
-    outputLock = new NoYieldpointsMonitor();
-    softHandshakeDataLock = new Monitor();
-    handshakeLock = new Monitor();
-    doProfileReport = new Latch(false);
-    monitorBySlot[getCurrentThread().threadSlot] = new NoYieldpointsMonitor();
-    communicationLockBySlot[getCurrentThread().threadSlot] = new Monitor();
-    sysCall.sysCreateThreadSpecificDataKeys();
-    sysCall.sysStashVMThread(getCurrentThread());
-
-    if (traceAcct) {
-      VM.sysWriteln("boot thread at ",Magic.objectAsAddress(getCurrentThread()));
-    }
-
-    bindIfRequested();
-
-    threadingInitialized = true;
-    // Always run timer thread, so we can respond to debug requests
-    new TimerThread().start();
-    if (VM.BuildForAdaptiveSystem) {
-      ObjectHolder.boot();
-    }
-
-    FinalizerThread.boot();
-    getCurrentThread().enableYieldpoints();
-    if (traceAcct) VM.sysWriteln("RVMThread booted");
-  }
-
-  /**
-   * Add this thread to the termination watchlist. Called by terminating threads
-   * before they finish terminating.
-   */
-  private void addAboutToTerminate() {
-    monitor().lockNoHandshake();
-    isAboutToTerminate = true;
-    activeMutatorContext = false;
-    monitor().broadcast();
-
-    handleHandshakeRequest();
-    deinitMutator();
-
-    // WARNING! DANGER! Since we've set isAboutToTerminate to true, when we
-    // release this lock the GC will:
-    // 1) No longer scan the thread's stack (though it will *see* the
-    // thread's stack and mark the stack itself as live, without scanning
-    // it).
-    // 2) No longer include the thread in any mutator phases ... hence the
-    // need to ensure that the mutator context is flushed above.
-    // 3) No longer attempt to block the thread.
-    // Moreover, we can no longer do anything that leads to write barriers
-    // or allocation.
-    monitor().unlock();
-
-    softRendezvous();
-
-    acctLock.lockNoHandshake();
-    aboutToTerminate[aboutToTerminateN++] = threadSlot;
-    acctLock.unlock();
-  }
-
-  /**
-   * Method called after processing a list of threads, or before starting a new
-   * thread.  This does two things.  First, it guarantees that the thread slots
-   * used by any dead threads are freed.  Second, it guarantees that each thread
-   * deregisters itself from GC.  Thus, it is essential that after requesting
-   * things like mutator flushes, you call this, to ensure that any threads that
-   * had died before or during the mutator flush request do the Right Thing.
-   */
-  @NoCheckStore
-  public static void processAboutToTerminate() {
-    if (!neverKillThreads) {
-      restart: while(true) {
-        int notKilled = 0;
-        acctLock.lockNoHandshake();
-        for (int i = 0; i < aboutToTerminateN; ++i) {
-          RVMThread t = threadBySlot[aboutToTerminate[i]];
-          if (t.getExecStatus() == TERMINATED) {
-            aboutToTerminate[i--] = aboutToTerminate[--aboutToTerminateN];
-            acctLock.unlock();
-            t.releaseThreadSlot();
-            continue restart;
-          } else {
-            notKilled++;
-          }
-        }
-        acctLock.unlock();
-        if (notKilled > 0 && traceAboutToTerminate) {
-          VM.sysWriteln("didn't kill ", notKilled, " threads");
-        }
-        break;
-      }
-    }
-  }
-
-  /**
-   * Find a thread slot not in use by any other live thread and bind the given
-   * thread to it. The thread's threadSlot field is set accordingly.
-   */
-  @Interruptible
-  void assignThreadSlot() {
-    if (!VM.runningVM) {
-      // primordial thread
-      threadSlot = 1;
-      threadBySlot[1] = this;
-      threads[0] = this;
-      threadIdx = 0;
-      numThreads = 1;
-    } else {
-      processAboutToTerminate();
-      acctLock.lockNoHandshake();
-      if (freeSlotN > 0) {
-        threadSlot = freeSlots[--freeSlotN];
-      } else {
-        if (nextSlot == threads.length) {
-          VM.sysFail("too many threads");
-        }
-        threadSlot = nextSlot++;
-      }
-      acctLock.unlock();
-      // before we actually use this slot, ensure that there is a monitor
-      // for it. note that if the slot doesn't have a monitor, then we
-      // "own" it since we allocated it above but haven't done anything
-      // with it (it's not assigned to a thread, so nobody else can touch
-      // it)
-      if (monitorBySlot[threadSlot] == null) {
-        monitorBySlot[threadSlot] = new NoYieldpointsMonitor();
-      }
-      if (communicationLockBySlot[threadSlot] == null) {
-        Monitor m = new Monitor();
-        handshakeLock.lockWithHandshake();
-        communicationLockBySlot[threadSlot] = m;
-        handshakeLock.unlock();
-      }
-      Magic.sync(); /*
-                     * make sure that nobody sees the thread in any of the
-                     * tables until the thread slot is inited
-                     */
-
-      acctLock.lockNoHandshake();
-      threadBySlot[threadSlot] = this;
-
-      threadIdx = numThreads++;
-      threads[threadIdx] = this;
-
-      acctLock.unlock();
-    }
-    lockingId = threadSlot << ThinLockConstants.TL_THREAD_ID_SHIFT;
-    if (traceAcct) {
-      VM.sysWriteln("Thread #", threadSlot, " at ", Magic.objectAsAddress(this));
-      VM.sysWriteln("stack at ", Magic.objectAsAddress(stack), " up to ", Magic.objectAsAddress(stack).plus(stack.length));
-    }
-  }
-
-  /**
-   * Release a thread's slot in the threads array.
-   */
-  @NoCheckStore
-  void releaseThreadSlot() {
-    acctLock.lockNoHandshake();
-    RVMThread replacementThread = threads[numThreads - 1];
-    threads[threadIdx] = replacementThread;
-    replacementThread.threadIdx = threadIdx;
-    threadIdx = -1;
-    Magic.sync(); /*
-                   * make sure that if someone is processing the threads array
-                   * without holding the acctLock (which is definitely legal)
-                   * then they see the replacementThread moved to the new index
-                   * before they see the numThreads decremented (otherwise they
-                   * would miss replacementThread; but with the current
-                   * arrangement at worst they will see it twice)
-                   */
-    threads[--numThreads] = null;
-    threadBySlot[threadSlot] = null;
-    freeSlots[freeSlotN++] = threadSlot;
-    acctLock.unlock();
-  }
-
-   /**
-    * Create a new RVM Thread
-    *
-    * @param stack The stack on which to execute the thread.
-    * @param thread The corresponding java.lang.Thread.
-    * @param name The name of the thread
-    * @param daemon True if this is a daemon thread.
-    * @param systemThread True if this is a system thread.
-    * @param priority The threads execution priority.
-    */
-   public RVMThread(byte[] stack, Thread thread, String name, boolean daemon, SystemThread systemThread, int priority) {
-    this.stack = stack;
-
-    this.daemon = daemon;
-    this.priority = priority;
-    this.systemThread = systemThread;
-
-    this.contextRegisters = this.contextRegistersShadow = new Registers();
-    this.contextRegistersSave = this.contextRegistersSaveShadow = new Registers();
-    this.exceptionRegisters = this.exceptionRegistersShadow = new Registers();
-
-    if (VM.runningVM) {
-      feedlet = TraceEngine.engine.makeFeedlet(name, name);
-    }
-
-    if (VM.VerifyAssertions) VM._assert(stack != null);
-
-    // put self in list of threads known to scheduler and garbage collector
-    if (!VM.runningVM) {
-      if (VM.VerifyAssertions) VM._assert(name != null);
-      this.name = name;
-      // create primordial thread (in boot image)
-      assignThreadSlot();
-
-      if (trace)
-        trace("RVMThread create: ", name);
-      if (trace)
-        trace("daemon: ", daemon ? "true" : "false");
-      if (trace)
-        trace("RVMThread", "create");
-
-      initMutator(threadSlot);
-      this.activeMutatorContext = true;
-      // Remember the boot thread
-      this.execStatus = IN_JAVA;
-      this.waiting = Waiting.RUNNABLE;
-      // assign final field
-      onStackReplacementEvent = null;
-    } else {
-      // create a normal (ie. non-primordial) thread
-
-      // set up wrapper Thread if one exists
-      this.thread = thread;
-      // Set thread type
-
-      this.execStatus = NEW;
-      this.waiting = Waiting.RUNNABLE;
-
-      stackLimit = Magic.objectAsAddress(stack).plus(STACK_SIZE_GUARD);
-
-      // get instructions for method to be executed as thread startoff
-      CodeArray instructions = Entrypoints.threadStartoffMethod.getCurrentEntryCodeArray();
-
-      VM.disableGC();
-
-      // initialize thread registers
-      Address ip = Magic.objectAsAddress(instructions);
-      Address sp = Magic.objectAsAddress(stack).plus(stack.length);
-
-      // Initialize the a thread stack as if "startoff" method had been called
-      // by an empty baseline-compiled "sentinel" frame with one local variable.
-      Configuration.archHelper.initializeStack(contextRegisters, ip, sp);
-
-      VM.enableGC();
-
-      assignThreadSlot();
-      this.name = name == null ? "Thread-" + threadSlot : name;
-      initMutator(threadSlot);
-      activeMutatorContext = true;
-      if (traceAcct) {
-        VM.sysWriteln("registered mutator for ", threadSlot);
-      }
-
-      initializeJNIEnv();
-
-      if (VM.BuildForAdaptiveSystem) {
-        onStackReplacementEvent = new OnStackReplacementEvent();
-      } else {
-        onStackReplacementEvent = null;
-      }
-
-      if (thread == null) {
-        // create wrapper Thread if doesn't exist
-        this.thread = java.lang.JikesRVMSupport.createThread(this, name);
-      }
-    }
-  }
-
-  /**
-   * Create a thread with default stack and with the given name.
-   */
-  public RVMThread(SystemThread systemThread, String name) {
-    this(MemoryManager.newStack(STACK_SIZE_NORMAL), null, // java.lang.Thread
-        name, true, // daemon
-        systemThread,
-        Thread.NORM_PRIORITY);
-  }
-
-  /**
-   * Create a thread with the given stack and name. Used by
-   * {@link org.jikesrvm.mm.mminterface.CollectorThread} and the
-   * boot image writer for the boot thread.
-   */
-  public RVMThread(SystemThread systemThread, byte[] stack, String name) {
-    this(stack, null, // java.lang.Thread
-        name, true, // daemon
-        systemThread,
-        Thread.NORM_PRIORITY);
-  }
-
-  /**
-   * Create a thread with ... called by java.lang.VMThread.create. System thread
-   * isn't set.
-   */
-  public RVMThread(Thread thread, long stacksize, String name, boolean daemon, int priority) {
-    this(MemoryManager.newStack((stacksize <= 0) ? STACK_SIZE_NORMAL : (int) stacksize), thread, name, daemon, null, priority);
-  }
-
-  /**
-   * Check if the thread has block requests (for example, for suspension and GC).  If
-   * it does, clear the requests and marked the thread as blocked for that request.
-   * If there were any block requests, do a broadcast() on the thread's monitor().
-   * This is an internal method and should only be called from code that implements
-   * thread blocking.  The monitor() lock must be held for this method to work properly.
-   */
-  private void acknowledgeBlockRequests() {
-    boolean hadSome = false;
-    if (VM.VerifyAssertions)
-      VM._assert(blockAdapters != null);
-    for (int i = 0; i < blockAdapters.length; ++i) {
-      if (blockAdapters[i].hasBlockRequest(this)) {
-        blockAdapters[i].setBlocked(this, true);
-        blockAdapters[i].clearBlockRequest(this);
-        hadSome = true;
-      }
-    }
-    if (hadSome) {
-      monitor().broadcast();
-    }
-  }
-
-  /**
-   * Checks if the thread system has acknowledged that the thread is supposed
-   * to be blocked. This will return true if the thread is actually blocking, or
-   * if the thread is running native code but is guaranteed to block before
-   * returning to Java.  Only call this method when already holding the monitor(),
-   * for two reasons:
-   * <ol>
-   * <li>This method does not acquire the monitor() lock even though it needs
-   * to have it acquired given the data structures that it is accessing.
-   * <li>You will typically want to call this method to decide if you need to
-   * take action under the assumption that the thread is blocked (or not
-   * blocked). So long as you hold the lock the thread cannot change state from
-   * blocked to not blocked.
-   * </ol>
-   *
-   * @return if the thread is supposed to be blocked
-   */
-  public boolean isBlocked() {
-    for (int i = 0; i < blockAdapters.length; ++i) {
-      if (blockAdapters[i].isBlocked(this)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Checks if the thread is executing Java code. A thread is executing Java
-   * code if its <code>execStatus</code> is <code>IN_JAVA</code> or
-   * <code>IN_JAVA_TO_BLOCK</code>, and if it is not
-   * <code>aboutToTerminate</code>, and if it is not blocked. Only call this
-   * method when already holding the monitor(), and probably only after calling
-   * setBlockedExecStatus(), for two reasons:
-   * <ol>
-   * <li>This method does not acquire the monitor() lock even though it needs
-   * to have it acquired given the data structures that it is accessing.
-   * <li>You will typically want to call this method to decide if you need to
-   * take action under the assumption that the thread is running Java (or not
-   * running Java). So long as you hold the lock - and you have called
-   * setBlockedExecStatus() - the thread cannot change state from running-Java
-   * to not-running-Java.
-   * </ol>
-   *
-   * @return if the thread is running Java
-   */
-  public boolean isInJava() {
-    return !isBlocking && !isAboutToTerminate &&
-      (getExecStatus() == IN_JAVA || getExecStatus() == IN_JAVA_TO_BLOCK);
-  }
-
-  /**
-   * Should the thread by eligible for sampling by the timer thread?
-   * Heuristically, we use timer-based sampling the in the adaptive system
-   * to determine where the program is spending time (and thus what to optimize).
-   * This doesn't have to be a 100% accurate, but it must be non-blocking
-   * and also closely approximate whether or not the thread is executing.
-   * For now, approximate just as being in JAVA.
-   * As a future item, we may want to actually correctly attribute time
-   * spent in native code to the top native method on the frame when the timer
-   * goes off.  This will require work in the JNI enter/exit sequence to deal with
-   * timer samples appropriately.
-   */
-  public boolean shouldBeSampled() {
-    return execStatus == IN_JAVA;
-  }
-
-  /** A variant of checkBlock() that does not save the thread state. */
-  @NoInline
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
-  private void checkBlockNoSaveContext() {
-    assertUnacceptableStates(NEW, TERMINATED);
-    if (VM.VerifyAssertions) VM._assert(!isAboutToTerminate);
-    if (VM.VerifyAssertions) VM._assert(!isBlocking);
-
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot, " in checkBlockNoSaveContext");
-    // NB: anything this method calls CANNOT change the contextRegisters
-    // or the JNI env. as well, this code will be running concurrently
-    // with stop-the-world GC!
-    monitor().lockNoHandshake();
-    isBlocking = true;
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot,
-          " acquired lock and has notified everyone that we're blocked");
-
-    // deal with requests that would require a soft handshake rendezvous
-    handleHandshakeRequest();
-    // check if a soft handshake has been requested, and if so, clear the
-    // request
-    boolean commitSoftRendezvous = softRendezvousCheckAndClear();
-    if (commitSoftRendezvous) {
-      // if a soft handshake had been requested, we need to acknowledge it.
-      // but to acknowledge it we cannot be holding the monitor() lock.
-      // it turns out that at this point in the code it is perfectly safe
-      // to release it, because:
-      // 1) callers of this method expect that it may, in all likelihood,
-      // release the monitor() lock if they were holding it, since it
-      // calls wait()
-      // 2) if the block requests get cleared when we release the lock,
-      // we won't call wait, since we reacquire the lock prior to checking
-      // for block requests.
-      int recCount = monitor().unlockCompletely();
-      softRendezvousCommit();
-      monitor().relockNoHandshake(recCount);
-    }
-
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot,
-                    " has acknowledged soft handshakes");
-
-    boolean hadReallyBlocked=false;
-
-    for (;;) {
-      // deal with block requests
-      acknowledgeBlockRequests();
-      // are we blocked?
-      if (!isBlocked()) {
-        break;
-      }
-      if (traceReallyBlock) {
-        hadReallyBlocked=true;
-        VM.sysWriteln("Thread #", threadSlot,
-                      " is really blocked with status ", getExecStatus());
-        VM.sysWriteln("Thread #", threadSlot,
-            " has fp = ", Magic.getFramePointer());
-        if (dumpStackOnBlock) {
-          dumpStack();
-        }
-      }
-      // what if a GC request comes while we're here for a suspend()
-      // request?
-      // answer: we get awoken, reloop, and acknowledge the GC block
-      // request.
-      monitor().waitNoHandshake();
-
-      if (traceBlock)
-        VM.sysWriteln("Thread #", threadSlot,
-            " has awoken; checking if we're still blocked");
-    }
-
-    if (traceBlock || (traceReallyBlock && hadReallyBlocked))
-      VM.sysWriteln("Thread #", threadSlot, " is unblocking");
-
-    // we're about to unblock, so indicate to the world that we're running
-    // again.
-    setExecStatus(IN_JAVA);
-    // let everyone know that we're back to executing code
-    isBlocking = false;
-    // deal with requests that came up while we were blocked.
-    handleHandshakeRequest();
-    monitor().unlock();
-
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot, " is unblocked");
-  }
-
-  /**
-   * Check if the thread is supposed to block, and if so, block it. This method
-   * will ensure that soft handshake requests are acknowledged or else
-   * inhibited, that any blocking request is handled, that the execution state
-   * of the thread (<code>execStatus</code>) is set to <code>IN_JAVA</code>
-   * once all blocking requests are cleared, and that other threads are notified
-   * that this thread is in the middle of blocking by setting the appropriate
-   * flag (<code>isBlocking</code>). Note that this thread acquires the
-   * monitor(), though it may release it completely either by calling wait() or
-   * by calling unlockCompletely(). Thus, although it isn't generally a problem
-   * to call this method while holding the monitor() lock, you should only do so
-   * if the loss of atomicity is acceptable.
-   * <p>
-   * Generally, this method should be called from the following four places:
-   * <ol>
-   * <li>The block() method, if the thread is requesting to block itself.
-   * Currently such requests only come when a thread calls suspend(). Doing so
-   * has unclear semantics (other threads may call resume() too early causing
-   * the well-known race) but must be supported because it's still part of the
-   * JDK. Why it's safe: the block() method needs to hold the monitor() for the
-   * time it takes it to make the block request, but does not need to continue
-   * to hold it when it calls checkBlock(). Thus, the fact that checkBlock()
-   * breaks atomicity is not a concern.
-   * <li>The yieldpoint. One of the purposes of a yieldpoint is to periodically
-   * check if the current thread should be blocked. This is accomplished by
-   * calling checkBlock(). Why it's safe: the yieldpoint performs several
-   * distinct actions, all of which individually require the monitor() lock -
-   * but the monitor() lock does not have to be held contiguously. Thus, the
-   * loss of atomicity from calling checkBlock() is fine.
-   * <li>The "WithHandshake" methods of HeavyCondLock. These methods allow you to
-   * block on a mutex or condition variable while notifying the system that you
-   * are not executing Java code. When these blocking methods return, they check
-   * if there had been a request to block, and if so, they call checkBlock().
-   * Why it's safe: This is subtle. Two cases exist. The first case is when a
-   * WithHandshake method is called on a HeavyCondLock instance that is not a thread
-   * monitor(). In this case, it does not matter that checkBlock() may acquire
-   * and then completely release the monitor(), since the user was not holding
-   * the monitor(). However, this will break if the user is <i>also</i> holding
-   * the monitor() when calling the WithHandshake method on a different lock. This case
-   * should never happen because no other locks should ever be acquired when the
-   * monitor() is held. Additionally: there is the concern that some other locks
-   * should never be held while attempting to acquire the monitor(); the
-   * HeavyCondLock ensures that checkBlock() is only called when that lock
-   * itself is released. The other case is when a WithHandshake method is called on the
-   * monitor() itself. This should only be done when using <i>your own</i>
-   * monitor() - that is the monitor() of the thread your are running on. In
-   * this case, the WithHandshake methods work because: (i) lockWithHandshake() only calls
-   * checkBlock() on the initial lock entry (not on recursive entry), so
-   * atomicity is not broken, and (ii) waitWithHandshake() and friends only call
-   * checkBlock() after wait() returns - at which point it is safe to release
-   * and reacquire the lock, since there cannot be a race with broadcast() once
-   * we have committed to not calling wait() again.
-   * <li>Any code following a potentially-blocking native call. Case (3) above
-   * is somewhat subsumed in this except that it is special due to the fact that
-   * it's blocking on VM locks. So, this case refers specifically to JNI. The
-   * JNI epilogues will call leaveJNIBlocked(), which calls a variant of this
-   * method.
-   * </ol>
-   */
-  @NoInline
-  @NoOptCompile
-  @BaselineSaveLSRegisters
-  @Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
-  void checkBlock() {
-    saveThreadState();
-    checkBlockNoSaveContext();
-  }
-
-  /**
-   * Internal method for transitioning a thread from IN_JAVA or IN_JAVA_TO_BLOCK to
-   * either BLOCKED_IN_NATIVE or BLOCKED_IN_JNI, depending on the value of the jni
-   * parameter.  It is always safe to conservatively call this method when transitioning
-   * to native code, though it is faster to call either enterNative(),
-   * enterJNIFromCallIntoNative(), or enterJNIFromJNIFunctionCall().
-   * <p>
-   * This method takes care of all bookkeeping and notifications required when a
-   * a thread that has been requested to block instead decides to run native code.
-   * Threads enter native code never need to block, since they will not be executing
-   * any Java code.  However, such threads must ensure that any system services (like
-   * GC) that are waiting for this thread to stop are notified that the thread has
-   * instead chosen to exit Java.  As well, any requests to perform a sot handshake
-   * must be serviced and acknowledged.
-   */
-  private void enterNativeBlockedImpl(boolean jni) {
-    if (traceReallyBlock)
-      VM.sysWriteln("Thread #", threadSlot, " entering native blocked.");
-    // NB: anything this method calls CANNOT change the contextRegisters
-    // or the JNI env. as well, this code will be running concurrently
-    // with stop-the-world GC!
-    boolean commitSoftRendezvous;
-    monitor().lockNoHandshake();
-    if (jni) {
-      jniEnteredBlocked++;
-      setExecStatus(BLOCKED_IN_JNI);
-    } else {
-      nativeEnteredBlocked++;
-      setExecStatus(BLOCKED_IN_NATIVE);
-    }
-    acknowledgeBlockRequests();
-    handleHandshakeRequest();
-    commitSoftRendezvous = softRendezvousCheckAndClear();
-    monitor().unlock();
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot,
-          " done with the locking part of native entry.");
-    if (commitSoftRendezvous)
-      softRendezvousCommit();
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot, " done enter native blocked.");
-  }
-
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
-  private void leaveNativeBlockedImpl() {
-    checkBlockNoSaveContext();
-  }
-
-  private void enterNativeBlocked() {
-    assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
-    enterNativeBlockedImpl(false);
-    assertAcceptableStates(IN_NATIVE,BLOCKED_IN_NATIVE);
-  }
-
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
-  private void leaveNativeBlocked() {
-    assertAcceptableStates(IN_NATIVE,BLOCKED_IN_NATIVE);
-    leaveNativeBlockedImpl();
-    assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
-  }
-
-  private void enterJNIBlocked() {
-    assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
-    enterNativeBlockedImpl(true);
-    assertAcceptableStates(IN_JNI,BLOCKED_IN_JNI);
-  }
-
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
-  private void leaveJNIBlocked() {
-    assertAcceptableStates(IN_JNI,BLOCKED_IN_JNI);
-    leaveNativeBlockedImpl();
-    assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
-  }
-
-  @Entrypoint
-  public static void enterJNIBlockedFromJNIFunctionCall() {
-    RVMThread t=getCurrentThread();
-    if (traceReallyBlock) {
-      VM.sysWriteln("Thread #",t.getThreadSlot(), " in enterJNIBlockedFromJNIFunctionCall");
-      VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
-    }
-    t.enterJNIBlocked();
-  }
-
-  @Entrypoint
-  public static void enterJNIBlockedFromCallIntoNative() {
-    RVMThread t=getCurrentThread();
-    if (traceReallyBlock) {
-      VM.sysWriteln("Thread #",t.getThreadSlot(), " in enterJNIBlockedFromCallIntoNative");
-      VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
-    }
-    t.enterJNIBlocked();
-  }
-
-  @Entrypoint
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise will not block")
-  static void leaveJNIBlockedFromJNIFunctionCall() {
-    RVMThread t = getCurrentThread();
-    if (traceReallyBlock) {
-      VM.sysWriteln("Thread #", t.getThreadSlot(),
-          " in leaveJNIBlockedFromJNIFunctionCall");
-      VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
-      VM.sysWriteln("state = ", t.getExecStatus());
-      VM.sysWriteln("jtoc = ", Magic.getJTOC());
-    }
-    t.leaveJNIBlocked();
-  }
-
-  /**
-   * Called when JNI code tried to transition from  IN_JNI to IN_JAVA but failed
-   */
-  @Entrypoint
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise will not block")
-  public static void leaveJNIBlockedFromCallIntoNative() {
-    RVMThread t = getCurrentThread();
-    if (traceReallyBlock) {
-      VM.sysWriteln("Thread #", t.getThreadSlot(),
-          " in leaveJNIBlockedFromCallIntoNative");
-      VM.sysWriteln("state = ", t.getExecStatus());
-      VM.sysWriteln("jtoc = ", Magic.getJTOC());
-    }
-    t.leaveJNIBlocked();
-  }
-
-  private int setBlockedExecStatus() {
-    int oldState, newState;
-    do {
-      oldState = getExecStatus();
-      if (oldState == IN_JAVA) {
-        newState = IN_JAVA_TO_BLOCK;
-      } else if (oldState == IN_NATIVE) {
-        newState = BLOCKED_IN_NATIVE;
-      } else if (oldState == IN_JNI) {
-        newState = BLOCKED_IN_JNI;
-      } else {
-        newState = oldState;
-      }
-      /*
-       * use the CAS to assert that we observed what we
-       * thought we observed
-       */
-    } while (!(attemptFastExecStatusTransition(oldState,newState)));
-    return newState;
-  }
-
-  /**
-   * Attempt to block the thread, and return the state it is in after the
-   * attempt. If we're blocking ourselves, this will always return IN_JAVA. If
-   * the thread signals to us the intention to die as we are trying to block it,
-   * this will return TERMINATED. NOTE: the thread's execStatus will not
-   * actually be TERMINATED at that point yet.
-   * <p>
-   * Note that this method is ridiculously dangerous, especially if you pass
-   * asynchronous==false.  Waiting for another thread to stop is not in itself
-   * interruptible - so if you ask another thread to block and they ask you
-   * to block, you might deadlock.
-   */
-  @Unpreemptible("Only blocks if the receiver is the current thread, or if asynchronous is set to false and the thread is not already blocked")
-  int block(BlockAdapter ba, boolean asynchronous) {
-    int result;
-    if (traceBlock)
-      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-          " is requesting that thread #", threadSlot, " blocks.");
-    monitor().lockNoHandshake();
-    int token = ba.requestBlock(this);
-    if (getCurrentThread() == this) {
-      if (traceBlock)
-        VM.sysWriteln("Thread #", threadSlot, " is blocking.");
-      checkBlock();
-      result = getExecStatus();
-    } else {
-      if (traceBlock)
-        VM.sysWriteln("Thread #", threadSlot, " is being told to block.");
-      if (isAboutToTerminate) {
-        if (traceBlock)
-          VM.sysWriteln("Thread #", threadSlot,
-              " is terminating, returning as if blocked in TERMINATED state.");
-        result = TERMINATED;
-      } else {
-        takeYieldpoint = 1;
-        // CAS the execStatus field
-        int newState = setBlockedExecStatus();
-        result = newState;
-        if (traceReallyBlock)
-          VM.sysWriteln("Thread #", getCurrentThreadSlot(),
-              " is blocking thread #", threadSlot, " which is in state ",
-              newState);
-        // this broadcast serves two purposes: notifies threads that are
-        // IN_JAVA but waiting on monitor() that they should awake and
-        // acknowledge the block request; or notifies anyone
-        // waiting for this thread to block that the thread is
-        // BLOCKED_IN_NATIVE or BLOCKED_IN_JNI. in the latter case the
-        // broadcast() happens _before_ the setting of the flags that the
-        // other threads would be awaiting, but that is fine, since we're
-        // still holding the lock anyway.
-        monitor().broadcast();
-        if (newState == IN_JAVA_TO_BLOCK) {
-          if (!asynchronous) {
-            if (traceBlock)
-              VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-                  " is waiting for thread #", threadSlot, " to block.");
-            while (ba.hasBlockRequest(this, token) && !ba.isBlocked(this) && !isAboutToTerminate) {
-              if (traceBlock)
-                VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-                    " is calling wait until thread #", threadSlot, " blocks.");
-              // will this deadlock when the thread dies?
-              if (VM.VerifyAssertions) {
-                // do a timed wait, and assert that the thread did not disappear
-                // into native in the meantime
-                monitor().timedWaitRelativeNoHandshake(1000L * 1000L * 1000L); // 1 sec
-                if (traceReallyBlock) {
-                  VM.sysWriteln("Thread #", threadSlot, "'s status is ",
-                                getExecStatus());
-                }
-                assertUnacceptableStates(IN_NATIVE);
-              } else {
-                monitor().waitNoHandshake();
-              }
-              if (traceBlock)
-                VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-                    " has returned from the wait call.");
-            }
-            if (isAboutToTerminate) {
-              result = TERMINATED;
-            } else {
-              result=getExecStatus();
-            }
-          }
-        } else if (newState == BLOCKED_IN_NATIVE || newState == BLOCKED_IN_JNI) {
-          // we own the thread for now - it cannot go back to executing Java
-          // code until we release the lock. before we do so we change its
-          // state accordingly and tell anyone who is waiting.
-          if (traceBlock)
-            VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-                " has seen thread #", threadSlot,
-                " in native; changing its status accordingly.");
-          ba.clearBlockRequest(this);
-          ba.setBlocked(this, true);
-        }
-      }
-    }
-    monitor().unlock();
-    if (traceReallyBlock)
-      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-          " is done telling thread #", threadSlot, " to block.");
-    return result;
-  }
-
-  public boolean blockedFor(BlockAdapter ba) {
-    monitor().lockNoHandshake();
-    boolean result = ba.isBlocked(this);
-    monitor().unlock();
-    return result;
-  }
-
-  @UninterruptibleNoWarn("Never blocks; only asynchronously notifies the receiver to do so")
-  public int asyncBlock(BlockAdapter ba) {
-    if (VM.VerifyAssertions)
-      VM._assert(getCurrentThread() != this);
-    return block(ba, true);
-  }
-
-  @Unpreemptible("May block if the receiver is the current thread or if the receiver is not yet blocked; otherwise does not perform actions that lead to blocking")
-  public int block(BlockAdapter ba) {
-    return block(ba, false);
-  }
-
-  @Unpreemptible
-  public void beginPairWith(RVMThread other) {
-    if (traceBlock) VM.sysWriteln("attempting to pair ",threadSlot," with ",other.threadSlot);
-    Monitor.lockWithHandshake(
-      communicationLock(),Word.fromIntSignExtend(threadSlot),
-      other.communicationLock(),Word.fromIntSignExtend(other.threadSlot));
-  }
-
-  public void endPairWith(RVMThread other) {
-    communicationLock().unlock();
-    other.communicationLock().unlock();
-    if (traceBlock) VM.sysWriteln("unpairing ",threadSlot," from ",other.threadSlot);
-  }
-
-  @Unpreemptible
-  public void beginPairWithCurrent() {
-    beginPairWith(getCurrentThread());
-  }
-
-  public void endPairWithCurrent() {
-    endPairWith(getCurrentThread());
-  }
-
-  @Unpreemptible
-  private int safeBlock(BlockAdapter ba, boolean asynchronous) {
-    if (VM.VerifyAssertions)
-      VM._assert(getCurrentThread() != this);
-    beginPairWithCurrent();
-    int result=block(ba,asynchronous);
-    endPairWithCurrent();
-    return result;
-  }
-
-  @Unpreemptible
-  public int safeAsyncBlock(BlockAdapter ba) {
-    return safeBlock(ba, true);
-  }
-
-  @Unpreemptible
-  public int safeBlock(BlockAdapter ba) {
-    if (getCurrentThread()==this) {
-      return block(ba,false);
-    } else {
-      return safeBlock(ba, false);
-    }
-  }
-
-  @Unpreemptible
-  public void beginPairHandshake() {
-    beginPairWithCurrent();
-    block(handshakeBlockAdapter);
-  }
-
-  @Uninterruptible
-  public void endPairHandshake() {
-    unblock(handshakeBlockAdapter);
-    endPairWithCurrent();
-  }
-
-  /**
-   * Save the current thread state.  Call this prior to calling enterNative().  You must
-   * be in a method that is marked BaselineSaveLSRegisters.
-   */
-  @NoInline
-  public static void saveThreadState() {
-    Address curFP=Magic.getFramePointer();
-    getCurrentThread().contextRegisters.setInnermost(Magic.getReturnAddressUnchecked(curFP),
-                                                     Magic.getCallerFramePointer(curFP));
-  }
-
-  /**
-   * Indicate that we'd like the current thread to be executing privileged code that
-   * does not require synchronization with the GC.  This call may be made on a thread
-   * that is IN_JAVA or IN_JAVA_TO_BLOCK, and will result in the thread being either
-   * IN_NATIVE or BLOCKED_IN_NATIVE.  In the case of an
-   * IN_JAVA_TO_BLOCK-&gt;BLOCKED_IN_NATIVE transition, this call will acquire the
-   * thread's lock and send out a notification to any threads waiting for this thread
-   * to reach a safepoint.  This notification serves to notify them that the thread
-   * is in GC-safe code, but will not reach an actual safepoint for an indetermined
-   * amount of time.  This is significant, because safepoints may perform additional
-   * actions (such as handling handshake requests, which may include things like
-   * mutator flushes and running isync) that IN_NATIVE code will not perform until
-   * returning to IN_JAVA by way of a leaveNative() call.
-   */
-  @NoInline // so we can get the fp
-  public static void enterNative() {
-    RVMThread t = getCurrentThread();
-    if (ALWAYS_LOCK_ON_STATE_TRANSITION) {
-      t.enterNativeBlocked();
-    } else {
-      int oldState, newState;
-      do {
-        oldState = t.getExecStatus();
-        if (oldState == IN_JAVA) {
-          newState = IN_NATIVE;
-        } else {
-          t.assertAcceptableStates(IN_JAVA_TO_BLOCK);
-          t.enterNativeBlocked();
-          return;
-        }
-      } while (!(t.attemptFastExecStatusTransition(oldState, newState)));
-    }
-    // NB this is not a correct assertion, as there is a race.  we could succeed in
-    // CASing the status to IN_NATIVE, but then someone else could asynchronosly
-    // set it to whatever they want.
-    //if (VM.VerifyAssertions)
-    //  VM._assert(t.execStatus == IN_NATIVE);
-  }
-
-  /**
-   * Attempt to transition from IN_JNI or IN_NATIVE to IN_JAVA, fail if execStatus is
-   * anything but IN_JNI or IN_NATIVE.
-   *
-   * @return true if thread transitioned to IN_JAVA, otherwise false
-   */
-  public static boolean attemptLeaveNativeNoBlock() {
-    if (ALWAYS_LOCK_ON_STATE_TRANSITION)
-      return false;
-    RVMThread t = getCurrentThread();
-    int oldState, newState;
-    do {
-      oldState = t.getExecStatus();
-      if (oldState == IN_NATIVE || oldState == IN_JNI) {
-        newState = IN_JAVA;
-      } else {
-        t.assertAcceptableStates(BLOCKED_IN_NATIVE,BLOCKED_IN_JNI);
-        return false;
-      }
-    } while (!(t.attemptFastExecStatusTransition(oldState, newState)));
-    return true;
-  }
-
-  /**
-   * Leave privileged code.  This is valid for threads that are either IN_NATIVE,
-   * IN_JNI, BLOCKED_IN_NATIVE, or BLOCKED_IN_JNI, and always results in the thread
-   * being IN_JAVA.  If the thread was previously BLOCKED_IN_NATIVE or BLOCKED_IN_JNI,
-   * the thread will block until notified that it can run again.
-   */
-  @Unpreemptible("May block if the thread was asked to do so; otherwise does no actions that would lead to blocking")
-  public static void leaveNative() {
-    if (!attemptLeaveNativeNoBlock()) {
-      if (traceReallyBlock) {
-        VM.sysWriteln("Thread #", getCurrentThreadSlot(),
-            " is leaving native blocked");
-      }
-      getCurrentThread().leaveNativeBlocked();
-    }
-  }
-
-  public static void enterJNIFromCallIntoNative() {
-    // FIXME: call these in PPC instead of doing it in machine code...
-    getCurrentThread().observeExecStatus();
-    if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JAVA,
-        RVMThread.IN_JNI)) {
-      RVMThread.enterJNIBlockedFromCallIntoNative();
-    }
-  }
-
-  @Unpreemptible
-  public static void leaveJNIFromCallIntoNative() {
-    // FIXME: call these in PPC instead of doing it in machine code...
-    getCurrentThread().observeExecStatus();
-    if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JNI,
-        RVMThread.IN_JAVA)) {
-      RVMThread.leaveJNIBlockedFromCallIntoNative();
-    }
-  }
-
-  public static void enterJNIFromJNIFunctionCall() {
-    // FIXME: call these instead of doing it in machine code...  currently this
-    // is never called.
-    getCurrentThread().observeExecStatus();
-    if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JAVA,
-        RVMThread.IN_JNI)) {
-      RVMThread.enterJNIBlockedFromJNIFunctionCall();
-    }
-  }
-
-  @Unpreemptible
-  public static void leaveJNIFromJNIFunctionCall() {
-    // FIXME: call these instead of doing it in machine code...  currently this
-    // is never called.
-    getCurrentThread().observeExecStatus();
-    if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JNI,
-        RVMThread.IN_JAVA)) {
-      RVMThread.leaveJNIBlockedFromJNIFunctionCall();
-    }
-  }
-
-  public void unblock(BlockAdapter ba) {
-    if (traceBlock)
-      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-          " is requesting that thread #", threadSlot, " unblocks.");
-    monitor().lockNoHandshake();
-    ba.clearBlockRequest(this);
-    ba.setBlocked(this, false);
-    monitor().broadcast();
-    monitor().unlock();
-    if (traceBlock)
-      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-          " is done requesting that thread #", threadSlot, " unblocks.");
-  }
-
-  private void handleDebugRequestForThread() {
-    monitor().lockNoHandshake();
-    dumpLock.lockNoHandshake();
-    extDump();
-    if (!isAboutToTerminate) {
-      setBlockedExecStatus();
-      if (isInJava()) {
-        asyncDebugRequestedForThisThread = true;
-        takeYieldpoint = 1;
-        VM.sysWriteln("(stack trace will follow if thread is not lost...)");
-      } else {
-        if (contextRegisters != null) {
-          dumpStack(contextRegisters.getInnermostFramePointer());
-        } else {
-          VM.sysWriteln("(cannot dump stack trace; thread is not running in Java but has no contextRegisters)");
-        }
-      }
-    }
-    dumpLock.unlock();
-    monitor().unlock();
-  }
-
-  @NoCheckStore
-  public static void checkDebugRequest() {
-    if (debugRequested) {
-      debugLock.lockNoHandshake();
-      if (debugRequested) {
-        debugRequested = false;
-        VM.sysWriteln("=== Debug requested - attempting safe VM dump ===");
-        dumpAcct();
-        reportThreadTransitionCounts();
-
-        // FIXME: this code runs concurrently to GC and has no way of stopping
-        // it.  hence it is dangerous.  leaving it as-is for now, since it's
-        // only meant to be used for debugging.
-
-        VM.sysWriteln("Timer ticks = ", timerTicks);
-        doProfileReport.openNoHandshake();
-        // snapshot the threads
-        acctLock.lockNoHandshake();
-        int numDebugThreads = numThreads;
-        for (int i = 0; i < numThreads; ++i) {
-          debugThreads[i] = threads[i];
-        }
-        acctLock.unlock();
-        // do the magic
-        for (int i = 0; i < numDebugThreads; ++i) {
-          debugThreads[i].handleDebugRequestForThread();
-          debugThreads[i] = null;
-        }
-      }
-      debugLock.unlock();
-    }
-  }
-
-  void timerTick() {
-    if (shouldBeSampled()) {
-      timeSliceExpired++;
-      takeYieldpoint=1;
-    }
-  }
-
-  /** Are we allowed to take yieldpoints? */
-  @Inline
-  public boolean yieldpointsEnabled() {
-    return yieldpointsEnabledCount == 1;
-  }
-
-  /** Enable yieldpoints on this thread. */
-  public void enableYieldpoints() {
-    ++yieldpointsEnabledCount;
-    if (VM.VerifyAssertions)
-      VM._assert(yieldpointsEnabledCount <= 1);
-    if (yieldpointsEnabled() && yieldpointRequestPending) {
-      takeYieldpoint = 1;
-      yieldpointRequestPending = false;
-    }
-  }
-
-  /** Disable yieldpoints on this thread. */
-  public void disableYieldpoints() {
-    --yieldpointsEnabledCount;
-  }
-
-  /**
-   * Fail if yieldpoints are disabled on this thread
-   */
-  public void failIfYieldpointsDisabled() {
-    if (!yieldpointsEnabled()) {
-      VM.sysWrite("No yieldpoints on thread ", threadSlot);
-      VM.sysWrite(" with addr ", Magic.objectAsAddress(this));
-      VM.sysWriteln();
-      VM.sysFail("Yieldpoints are disabled on this thread!");
-    }
-  }
-
-  /**
-   * @return The currently executing thread
-   */
-  @Uninterruptible
-  public static RVMThread getCurrentThread() {
-    return ThreadLocalState.getCurrentThread();
-  }
-
-  /**
-   * @return the unique slot of the currently executing thread
-   */
-  public static int getCurrentThreadSlot() {
-    return getCurrentThread().threadSlot;
-  }
-
-  /**
-   * @return the slot of this thread
-   */
-  public int getThreadSlot() {
-    return threadSlot;
-  }
-
-  /**
-   * Called during booting to give the boot thread a java.lang.Thread
-   */
-  @Interruptible
-  public void setupBootJavaThread() {
-    thread = java.lang.JikesRVMSupport.createThread(this,
-        "Jikes_RVM_Boot_Thread");
-  }
-
-  /**
-   * String representation of thread
-   */
-  @Override
-  public String toString() {
-    return name;
-  }
-
-  /**
-   * Get the current java.lang.Thread.
-   */
-  public Thread getJavaLangThread() {
-    return thread;
-  }
-
-  /**
-   * Get current thread's JNI environment.
-   */
-  public JNIEnvironment getJNIEnv() {
-    return jniEnv;
-  }
-
-  /** Get the disable GC depth */
-  public int getDisableGCDepth() {
-    return disableGCDepth;
-  }
-
-  /** Modify the disable GC depth */
-  public void setDisableGCDepth(int d) {
-    disableGCDepth = d;
-  }
-
-  /** Are allocations allowed by this thread? */
-  public boolean getDisallowAllocationsByThisThread() {
-    return disallowAllocationsByThisThread;
-  }
-
-  /** Disallow allocations by this thread */
-  public void setDisallowAllocationsByThisThread() {
-    disallowAllocationsByThisThread = true;
-  }
-
-  /** Allow allocations by this thread */
-  public void clearDisallowAllocationsByThisThread() {
-    disallowAllocationsByThisThread = false;
-  }
-
-  /**
-   * Initialize JNI environment for system threads. Called by VM.finishBooting
-   */
-  @Interruptible
-  public void initializeJNIEnv() {
-    this.jniEnv = this.jniEnvShadow = new JNIEnvironment();
-  }
-
-  /**
-   * Indicate whether the stack of this Thread contains any C frame (used in
-   * RuntimeEntrypoints.deliverHardwareException for stack resize)
-   *
-   * @return false during the prolog of the first Java to C transition true
-   *         afterward
-   */
-  public boolean hasNativeStackFrame() {
-    return jniEnv != null && jniEnv.hasNativeStackFrame();
-  }
-
-  /*
-   * Starting and ending threads
-   */
-
-  /**
-   * Method to be executed when this thread starts running. Calls
-   * java.lang.Thread.run but system threads can override directly.
-   */
-  @Interruptible
-  @Entrypoint
-  public void run() {
-    try {
-      synchronized (thread) {
-        Throwable t = java.lang.JikesRVMSupport.getStillBorn(thread);
-        if (t != null) {
-          java.lang.JikesRVMSupport.setStillBorn(thread, null);
-          throw t;
-        }
-      }
-      thread.run();
-    } catch (Throwable t) {
-      if (traceAcct) {
-        VM.sysWriteln("Thread ",getThreadSlot()," exiting with exception.");
-      }
-      try {
-        Thread.UncaughtExceptionHandler handler;
-        handler = thread.getUncaughtExceptionHandler();
-        handler.uncaughtException(thread, t);
-      } catch (Throwable ignore) {
-      }
-    }
-  }
-
-  /**
-   * Begin execution of current thread by calling its "run" method. This method
-   * is at the bottom of all created method's stacks.
-   */
-  @Interruptible
-  @SuppressWarnings({ "unused" })
-  // Called by back-door methods.
-  private static void startoff() {
-    bindIfRequested();
-
-    sysCall.sysSetupHardwareTrapHandler();
-
-    RVMThread currentThread = getCurrentThread();
-
-    /*
-     * get pthread_id from the operating system and store into RVMThread field
-     */
-    currentThread.pthread_id = sysCall.sysGetThreadId();
-    currentThread.enableYieldpoints();
-    sysCall.sysStashVMThread(currentThread);
-    if (traceAcct) {
-      VM.sysWriteln("Thread #", currentThread.threadSlot, " with pthread id ",
-          currentThread.pthread_id, " running!");
-    }
-
-    if (trace) {
-      VM.sysWriteln("Thread.startoff(): about to call ", currentThread.toString(), ".run()");
-    }
-
-    try {
-      if (currentThread.systemThread != null) {
-        currentThread.systemThread.run();
-      } else {
-        currentThread.run();
-      }
-    } finally {
-      if (trace) {
-        VM.sysWriteln("Thread.startoff(): finished ", currentThread.toString(), ".run()");
-      }
-      currentThread.terminate();
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-    }
-  }
-
-  /**
-   * Start execution of 'this' by putting it on the appropriate queue of an
-   * unspecified virtual processor.
-   */
-  @Interruptible
-  public void start() {
-    // N.B.: cannot hit a yieldpoint between setting execStatus and starting the
-    // thread!!
-    setExecStatus(IN_JAVA);
-    acctLock.lockNoHandshake();
-    numActiveThreads++;
-    if (daemon) {
-      numActiveDaemons++;
-    }
-    acctLock.unlock();
-    if (traceAcct)
-      VM.sysWriteln("Thread #", threadSlot, " starting!");
-    sysCall.sysThreadCreate(Magic.objectAsAddress(this),
-        contextRegisters.ip, contextRegisters.getInnermostFramePointer());
-  }
-
-  /**
-   * Terminate execution of current thread by abandoning all references to it
-   * and resuming execution in some other (ready) thread.
-   */
-  @Interruptible
-  public void terminate() {
-    if (traceAcct)
-      VM.sysWriteln("in terminate() for Thread #", threadSlot);
-    if (VM.VerifyAssertions)
-      VM._assert(getCurrentThread() == this);
-    boolean terminateSystem = false;
-    if (traceTermination) {
-      VM.disableGC();
-      VM.sysWriteln("[ BEGIN Verbosely dumping stack at time of thread termination");
-      dumpStack();
-      VM.sysWriteln("END Verbosely dumping stack at time of creating thread termination ]");
-      VM.enableGC();
-    }
-
-    // allow java.lang.Thread.exit() to remove this thread from ThreadGroup
-    java.lang.JikesRVMSupport.threadDied(thread);
-
-    TraceEngine.engine.removeFeedlet(feedlet);
-
-    if (VM.VerifyAssertions) {
-      if (Lock.countLocksHeldByThread(getLockingId()) > 0) {
-        VM.sysWriteln("Error, thread terminating holding a lock");
-        RVMThread.dumpVirtualMachine();
-      }
-    }
-
-    if (traceAcct)
-      VM.sysWriteln("doing accounting...");
-    acctLock.lockNoHandshake();
-
-    // if the thread terminated because of an exception, remove
-    // the mark from the exception register object, or else the
-    // garbage collector will attempt to relocate its ip field.
-    exceptionRegisters.inuse = false;
-
-    numActiveThreads -= 1;
-    if (daemon) {
-      numActiveDaemons -= 1;
-    }
-    if (traceAcct)
-      VM.sysWriteln("active = ", numActiveThreads, ", daemons = ",
-          numActiveDaemons);
-    if ((numActiveDaemons == numActiveThreads) && (VM.mainThread != null) && VM.mainThread.launched) {
-      // no non-daemon thread remains and the main thread was launched
-      terminateSystem = true;
-    }
-    if (terminateSystem) {
-      if (systemShuttingDown == false) {
-        systemShuttingDown = true;
-      } else {
-        terminateSystem = false;
-      }
-    }
-    if (traceTermination) {
-      VM.sysWriteln("Thread.terminate: myThread.daemon = ", daemon);
-      VM.sysWriteln("  RVMThread.numActiveThreads = ",
-          RVMThread.numActiveThreads);
-      VM.sysWriteln("  RVMThread.numActiveDaemons = ",
-          RVMThread.numActiveDaemons);
-      VM.sysWriteln("  terminateSystem = ", terminateSystem);
-    }
-
-    acctLock.unlock();
-
-    if (traceAcct)
-      VM.sysWriteln("done with accounting.");
-
-    if (terminateSystem) {
-      if (traceAcct)
-        VM.sysWriteln("terminating system.");
-      if (uncaughtExceptionCount > 0)
-      /* Use System.exit so that any shutdown hooks are run. */{
-        if (VM.TraceExceptionDelivery) {
-          VM.sysWriteln("Calling sysExit due to uncaught exception.");
-        }
-        callSystemExit(VM.EXIT_STATUS_DYING_WITH_UNCAUGHT_EXCEPTION);
-      } else if (thread instanceof MainThread) {
-        MainThread mt = (MainThread) thread;
-        if (!mt.launched) {
-          /*
-           * Use System.exit so that any shutdown hooks are run. It is possible
-           * that shutdown hooks may be installed by static initializers which
-           * were run by classes initialized before we attempted to run the main
-           * thread. (As of this writing, 24 January 2005, the Classpath
-           * libraries do not do such a thing, but there is no reason why we
-           * should not support this.) This was discussed on
-           * jikesrvm-researchers on 23 Jan 2005 and 24 Jan 2005.
-           */
-          callSystemExit(VM.EXIT_STATUS_MAIN_THREAD_COULD_NOT_LAUNCH);
-        }
-      }
-      /* Use System.exit so that any shutdown hooks are run. */
-      callSystemExit(0);
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-    }
-
-    if (traceAcct)
-      VM.sysWriteln("making joinable...");
-
-    // this works.  we use synchronized because we cannot use the thread's
-    // monitor().  see comment in join().  this is fine, because we're still
-    // "running" from the standpoint of GC.
-    synchronized (this) {
-      isJoinable = true;
-      notifyAll();
-    }
-    if (traceAcct)
-      VM.sysWriteln("Thread #", threadSlot, " is joinable.");
-
-    if (traceAcct)
-      VM.sysWriteln("making joinable...");
-
-    // Switch to uninterruptible portion of termination
-    terminateUnpreemptible();
-  }
-
-  /**
-   * Call System.exit() with the correct security status.
-   *
-   * @param exitStatus
-   */
-  @Interruptible
-  private void callSystemExit(final int exitStatus) {
-    AccessController.doPrivileged(new PrivilegedAction<Object>() {
-      @Override
-      public Object run() {
-        System.exit(exitStatus);
-        return null;
-      }
-    });
-  }
-
-  /**
-   * Unpreemptible portion of thread termination. Unpreemptible to avoid a dead
-   * thread from being scheduled.
-   */
-  @Unpreemptible
-  private void terminateUnpreemptible() {
-    // return cached free lock
-    if (traceAcct)
-      VM.sysWriteln("returning cached lock...");
-
-    if (cachedFreeLock != null) {
-      if (Lock.trace) {
-        VM.sysWriteln("Thread #", threadSlot, ": about to free lock ",
-            Magic.objectAsAddress(cachedFreeLock));
-      }
-      if (VM.VerifyAssertions)
-        VM._assert(cachedFreeLock.mutex.latestContender != this);
-      Lock.returnLock(cachedFreeLock);
-      cachedFreeLock = null;
-    }
-
-    if (traceAcct)
-      VM.sysWriteln("adding to aboutToTerminate...");
-
-    addAboutToTerminate();
-    // NB we can no longer do anything that would lead to write barriers or
-    // GC
-
-    if (traceAcct) {
-      VM.sysWriteln("acquireCount for my monitor: ", monitor().acquireCount);
-      VM.sysWriteln("timer ticks: ", timerTicks);
-      VM.sysWriteln("yieldpoints taken: ", yieldpointsTaken);
-      VM.sysWriteln("yieldpoints taken fully: ", yieldpointsTakenFully);
-    }
-    if (traceAcct)
-      VM.sysWriteln("finishing thread termination...");
-
-    finishThreadTermination();
-  }
-
-  /** Uninterruptible final portion of thread termination. */
-  void finishThreadTermination() {
-    sysCall.sysThreadTerminate();
-    if (VM.VerifyAssertions)
-      VM._assert(VM.NOT_REACHED);
-  }
-
-  /*
-   * Support for yieldpoints
-   */
-
-  /**
-   * Yieldpoint taken in prologue.
-   */
-  @BaselineSaveLSRegisters
-  // Save all non-volatile registers in prologue
-  @NoOptCompile
-  @NoInline
-  // We should also have a pragma that saves all non-volatiles in opt compiler,
-  // BaselineExecuctionStateExtractor.java, should then restore all
-  // non-volatiles before stack replacement
-  // TODO fix this -- related to SaveVolatile
-  @Entrypoint
-  @Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
-  public static void yieldpointFromPrologue() {
-    Address fp = Magic.getFramePointer();
-    yieldpoint(PROLOGUE, fp);
-  }
-
-  /**
-   * Yieldpoint taken on backedge.
-   */
-  @BaselineSaveLSRegisters
-  // Save all non-volatile registers in prologue
-  @NoOptCompile
-  @NoInline
-  // We should also have a pragma that saves all non-volatiles in opt compiler,
-  // BaselineExecuctionStateExtractor.java, should then restore all
-  // non-volatiles before stack replacement
-  // TODO fix this -- related to SaveVolatile
-  @Entrypoint
-  @Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
-  public static void yieldpointFromBackedge() {
-    Address fp = Magic.getFramePointer();
-    yieldpoint(BACKEDGE, fp);
-  }
-
-  /**
-   * The return barrier.
-   * <p>
-   * The following code implements return barriers as described
-   * for Lisp by Yuasa
-   *
-   * http://www.yuasa.kuis.kyoto-u.ac.jp/~yuasa/ilc2002/index.html
-   * http://dx.doi.org/10.1109/ISORC.2005.45
-   *
-   * and for Jikes RVM by Kumar et al
-   *
-   * http://dx.doi.org/10.1145/2398857.2384639
-   * <p>
-   * This code is executed when a method returns into a frame that
-   * has been hijacked by the return barrier mechanism.   The return
-   * barrier trampoline will save state, execute this method, and
-   * then upon return from this method will transparently return into
-   * the frame that had been hijacked.
-   * <p>
-   * In this default implementation, the barrier reinstalls itself
-   * in the caller's frame thus incrementally moving the barrier down
-   * the stack.
-   * <p>
-   * The execution of this method is fragile.  It is generally safest
-   * to call some other method from here that does the substantive work
-   * of the barrier.
-   */
-  @Entrypoint
-  @Uninterruptible
-  @Unpreemptible
-  public static void returnBarrier() {
-    /* reinstall the barrier in the caller's frame */
-    if (DEBUG_STACK_TRAMPOLINE) {
-      VM.sysWriteln(getCurrentThread().getId(), " T0: ", getCurrentThread().trampolineRegisters.gprs.get(BaselineConstants.T0_int).toAddress());
-      VM.sysWriteln(getCurrentThread().getId(), " T1: ", getCurrentThread().trampolineRegisters.gprs.get(BaselineConstants.T1_int).toAddress());
-      VM.sysWriteln(getCurrentThread().getId(), " nf: ", getCurrentThread().hijackedReturnCallerFp);
-      VM.sysWriteln(getCurrentThread().getId(), " lf: ", getCurrentThread().hijackedReturnCalleeFp);
-      VM.sysWriteln(getCurrentThread().getId(), " fp: ", Magic.getFramePointer());
-      VM.sysWriteln(getCurrentThread().getId(), " np: ", Magic.getCallerFramePointer(Magic.getFramePointer()));
-    }
-    /* reinstall the barrier in the specified frame */
-    getCurrentThread().installStackTrampolineBridge(getCurrentThread().hijackedReturnCallerFp);
-  }
-
-  /**
-   * Install the stack trampoline bridge at a given frame, hijacking
-   * that frame, saving the hijacked return address and callee fp
-   * in thread-local state to allow execution of the hijacked frame
-   * later.
-   *
-   * @param targetFp The frame to be hijacked.
-   */
-  @Uninterruptible
-  public void installStackTrampolineBridge(Address targetFp) {
-    Address trampoline = getStackTrampolineBridgeIP();
-    if (trampoline.isZero()) {
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-      else
-        VM.sysWriteln("Warning: attempt to install stack trampoline without bridge instructions - nothing done.  See RVMThread.");
-    } else if (trampoline.NE(Magic.getReturnAddressUnchecked(targetFp))) {
-      /* install the trampoline at fp or the next suitable frame after fp */
-      while (true) {
-        if (Magic.getCallerFramePointer(targetFp).EQ(ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
-          /* if we're at the bottom of the stack, then do not install anything */
-          hijackedReturnAddress = Address.zero();
-          hijackedReturnCalleeFp = Address.zero();
-          return;
-        }
-        int cmid = Magic.getCompiledMethodID(targetFp);
-        if (cmid == ArchitectureSpecific.ArchConstants.INVISIBLE_METHOD_ID) {
-          /* skip invisible methods */
-          targetFp = Magic.getCallerFramePointer(targetFp);
-        } else {
-          CompiledMethod calleeCM = CompiledMethods.getCompiledMethod(cmid);
-          if (calleeCM.getCompilerType() == CompiledMethod.TRAP ||
-              calleeCM.getMethod().getDeclaringClass().hasBridgeFromNativeAnnotation()) {
-            /* skip traps and native bridges */
-            targetFp = Magic.getCallerFramePointer(targetFp);
-          } else
-            break;
-        }
-      }
-      hijackedReturnAddress = Magic.getReturnAddressUnchecked(targetFp);
-      hijackedReturnCalleeFp = targetFp;
-      hijackedReturnCallerFp = Magic.getCallerFramePointer(targetFp);
-      if (VM.VerifyAssertions) VM._assert(trampoline.NE(hijackedReturnAddress));
-      if (DEBUG_STACK_TRAMPOLINE) dumpFrame(targetFp);
-      Magic.setReturnAddress(targetFp, trampoline);
-      if (DEBUG_STACK_TRAMPOLINE) {
-        dumpFrame(targetFp);
-        VM.sysWriteln(getId(), " Installing trampoline at: ", targetFp);
-        VM.sysWriteln(getId(), " Trampoline: ", trampoline);
-        VM.sysWriteln(getId(), " Hijacked return address: ", hijackedReturnAddress);
-        VM.sysWriteln(getId(), " Callee fp: ", hijackedReturnCalleeFp);
-        VM.sysWriteln(getId(), " Caller fp: ", hijackedReturnCallerFp);
-        dumpStack(hijackedReturnCalleeFp);
-      }
-    }
-  }
-
-  /**
-   * de-install the stack trampoline (disabling return barriers).
-   */
-  @Uninterruptible
-  public void deInstallStackTrampoline() {
-    if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("deinstalling trampoline: ", framePointer);
-    if (!hijackedReturnCalleeFp.isZero()) {
-      if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("need to reinstall: ", hijackedReturnAddress);
-      hijackedReturnCalleeFp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET).store(hijackedReturnAddress);
-      hijackedReturnCalleeFp = Address.zero();
-      hijackedReturnCallerFp = ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
-    }
-  }
-
-  /** @return the address of the stack trampoline bridge code */
-  @Inline
-  private Address getStackTrampolineBridgeIP() { return Magic.objectAsAddress(stackTrampolineBridgeInstructions); }
-
-  /** @return the hijacked return address */
-  @Inline
-  public Address getTrampolineHijackedReturnAddress() { return hijackedReturnAddress; }
-
-  /**
-   * Determine whether a given method is the stack trampoline
-   *
-   * @param ip the code to be checked
-   * @return <code>true</code> if the code is the stack trampoline.
-   */
-  @Inline
-  public static boolean isTrampolineIP(Address ip) { return getCurrentThread().getStackTrampolineBridgeIP().EQ(ip); }
-
-  /**
-   * Given a frame that has been hijacked by the stack trampoline,
-   * return the real (hijacked) return address.
-   *
-   * @param hijackedFp a frame that has been hijacked by the stack trampoline
-   * @return the return address for the frame that was hijacked.
-   */
-  @Uninterruptible
-  public static Address getHijackedReturnAddress(Address hijackedFp) {
-    if (VM.VerifyAssertions) VM._assert(isTrampolineIP(Magic.getReturnAddressUnchecked(hijackedFp)));
-    RVMThread t = getCurrentThread();
-      if (!t.hijackedReturnCalleeFp.EQ(hijackedFp)) {
-        for (int tid = 0; tid < nextSlot; tid++) {
-          t = threadBySlot[tid];
-          if (t != null && t.hijackedReturnCalleeFp.EQ(hijackedFp))
-            break;
-        }
-      }
-      return t.hijackedReturnAddress;
-  }
-
-  /**
-   * Dump the specified frame in a format useful for debugging the stack
-   * trampoline
-   *
-   * @param fp The frame to be dumped.
-   */
-  private static void dumpFrame(Address fp) {
-    Address sp = fp.minus(40);
-    VM.sysWriteln("--");
-    Address nextFp = Magic.getCallerFramePointer(fp);
-    while (sp.LE(nextFp)) {
-      VM.sysWrite("["); VM.sysWrite(sp); VM.sysWrite("]");
-      if (sp.EQ(fp) || sp.EQ(nextFp)) VM.sysWrite("* ");
-      else if (sp.EQ(fp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET)) || sp.EQ(nextFp.plus(STACKFRAME_RETURN_ADDRESS_OFFSET))) VM.sysWrite("R ");
-      else if (sp.EQ(fp.plus(STACKFRAME_METHOD_ID_OFFSET)) || sp.EQ(nextFp.plus(STACKFRAME_METHOD_ID_OFFSET))) VM.sysWrite("M ");
-      else VM.sysWrite(" ");
-      VM.sysWriteln(sp.loadInt());
-      sp = sp.plus(4);
-    }
-  }
-
-  /**
-   * @return the caller of the frame in which the trampoline is installed (STACKFRAME_SENTINEL_FP by default)
-   */
-  public Address getNextUnencounteredFrame() {
-    return hijackedReturnCallerFp.EQ(ArchitectureSpecific.StackframeLayoutConstants.STACKFRAME_SENTINEL_FP) ? hijackedReturnCallerFp : Magic.getCallerFramePointer(hijackedReturnCallerFp);
-  }
-
-  /**
-   * Yieldpoint taken in epilogue.
-   */
-  @BaselineSaveLSRegisters
-  // Save all non-volatile registers in prologue
-  @NoOptCompile
-  @NoInline
-  // We should also have a pragma that saves all non-volatiles in opt compiler,
-  // BaselineExecutionStateExtractor.java, should then restore all non-volatiles
-  // before stack replacement
-  // TODO fix this -- related to SaveVolatile
-  @Entrypoint
-  @Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
-  public static void yieldpointFromEpilogue() {
-    Address fp = Magic.getFramePointer();
-    yieldpoint(EPILOGUE, fp);
-  }
-
-  /*
-   * Support for suspend/resume
-   */
-
-  /**
-   * Suspend execution of current thread until it is resumed. Call only if
-   * caller has appropriate security clearance.
-   */
-  @UnpreemptibleNoWarn("Exceptions may possibly cause yields")
-  public void suspend() {
-    if (false) VM.sysWriteln("Thread #",getCurrentThreadSlot()," suspending Thread #",getThreadSlot());
-    ObjectModel.genericUnlock(thread);
-    Throwable rethrow = null;
-    try {
-      observeExecStatus();
-      if (execStatus != IN_JAVA && execStatus != IN_JAVA_TO_BLOCK &&
-          execStatus != IN_NATIVE && execStatus != BLOCKED_IN_NATIVE &&
-          execStatus != BLOCKED_IN_JNI && execStatus != IN_JNI) {
-        throw new IllegalThreadStateException(
-          "Cannot suspend a thread that is not running.");
-      }
-      block(suspendBlockAdapter);
-    } catch (Throwable t) {
-      rethrow = t;
-    }
-    ObjectModel.genericLock(thread);
-    if (rethrow != null)
-      RuntimeEntrypoints.athrow(rethrow);
-  }
-
-  /**
-   * Resume execution of a thread that has been suspended. Call only if caller
-   * has appropriate security clearance.
-   */
-  @Interruptible
-  public void resume() {
-    unblock(suspendBlockAdapter);
-  }
-
-  public static void yieldNoHandshake() {
-    sysCall.sysThreadYield();
-  }
-
-  @UnpreemptibleNoWarn
-  public static void yieldWithHandshake() {
-    getCurrentThread().checkBlock();
-    sysCall.sysThreadYield();
-  }
-  /**
-   * Suspend execution of current thread for specified number of seconds (or
-   * fraction).
-   */
-  @Interruptible
-  public static void sleep(long ns) throws InterruptedException {
-    RVMThread t = getCurrentThread();
-    t.waiting = Waiting.TIMED_WAITING;
-    long atStart = sysCall.sysNanoTime();
-    long whenEnd = atStart + ns;
-    t.monitor().lockNoHandshake();
-    while (!t.hasInterrupt && t.asyncThrowable == null &&
-        sysCall.sysNanoTime() < whenEnd) {
-      t.monitor().timedWaitAbsoluteWithHandshake(whenEnd);
-    }
-    boolean throwInterrupt = false;
-    Throwable throwThis = null;
-    if (t.hasInterrupt) {
-      t.hasInterrupt = false;
-      throwInterrupt = true;
-    }
-    if (t.asyncThrowable != null) {
-      throwThis = t.asyncThrowable;
-      t.asyncThrowable = null;
-    }
-    t.monitor().unlock();
-    t.waiting = Waiting.RUNNABLE;
-    if (throwThis != null) {
-      RuntimeEntrypoints.athrow(throwThis);
-    }
-    if (throwInterrupt) {
-      throw new InterruptedException("sleep interrupted");
-    }
-  }
-
-  /**
-   * Suspend execution of current thread for specified number of seconds (or
-   * fraction).
-   */
-  @Interruptible
-  public static void sleep(long millis, int ns) throws InterruptedException {
-    sleep(ns + millis * 1000L * 1000L);
-  }
-
-  /*
-   * Wait and notify support
-   */
-
-  @Interruptible
-  void waitImpl(Object o, boolean hasTimeout, long whenWakeupNanos) {
-    boolean throwInterrupt = false;
-    Throwable throwThis = null;
-    if (asyncThrowable != null) {
-      throwThis = asyncThrowable;
-      asyncThrowable = null;
-    } else if (!ObjectModel.holdsLock(o, this)) {
-      throw new IllegalMonitorStateException("waiting on " + o);
-    } else if (hasInterrupt) {
-      throwInterrupt = true;
-      hasInterrupt = false;
-    } else {
-      waiting = hasTimeout ? Waiting.TIMED_WAITING : Waiting.WAITING;
-      // get lock for object
-      Lock l = ObjectModel.getHeavyLock(o, true);
-
-      // release the lock
-      l.mutex.lock();
-      // this thread is supposed to own the lock on o
-      if (VM.VerifyAssertions) VM._assert(l.getOwnerId() == getLockingId());
-      RVMThread toAwaken = l.entering.dequeue();
-      waitObject = l.getLockedObject();
-      waitCount = l.getRecursionCount();
-      l.setOwnerId(0);
-      l.waiting.enqueue(this);
-      l.mutex.unlock();
-
-      // if there was a thread waiting, awaken it
-      if (toAwaken != null) {
-        // is this where the problem is coming from?
-        toAwaken.monitor().lockedBroadcastNoHandshake();
-      }
-      // block
-      monitor().lockNoHandshake();
-      while (l.waiting.isQueued(this) && !hasInterrupt && asyncThrowable == null &&
-             (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
-        if (hasTimeout) {
-          monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
-        } else {
-          monitor().waitWithHandshake();
-        }
-      }
-      // figure out if anything special happened while we were blocked
-      if (hasInterrupt) {
-        throwInterrupt = true;
-        hasInterrupt = false;
-      }
-      if (asyncThrowable != null) {
-        throwThis = asyncThrowable;
-        asyncThrowable = null;
-      }
-      monitor().unlock();
-      if (l.waiting.isQueued(this)) {
-        l.mutex.lock();
-        l.waiting.remove(this); /*
-                                 * in case we got here due to an interrupt or a
-                                 * stop() rather than a notify
-                                 */
-        l.mutex.unlock();
-        // Note that the above must be done before attempting to acquire
-        // the lock, since acquiring the lock may require queueing the thread.
-        // But we cannot queue the thread if it is already on another
-        // queue.
-      }
-      // reacquire the lock, restoring the recursion count
-      ObjectModel.genericLock(o);
-      waitObject = null;
-      if (waitCount != 1) { // reset recursion count
-        Lock l2 = ObjectModel.getHeavyLock(o, true);
-        l2.setRecursionCount(waitCount);
-      }
-      waiting = Waiting.RUNNABLE;
-    }
-    // check if we should exit in a special way
-    if (throwThis != null) {
-      RuntimeEntrypoints.athrow(throwThis);
-    }
-    if (throwInterrupt) {
-      RuntimeEntrypoints.athrow(new InterruptedException("sleep interrupted"));
-    }
-  }
-
-  /**
-   * Support for Java {@link java.lang.Object#wait()} synchronization primitive.
-   *
-   * @param o
-   *          the object synchronized on
-   */
-  @Interruptible
-  /* only loses control at expected points -- I think -dave */
-  public static void wait(Object o) {
-    getCurrentThread().waitImpl(o, false, 0);
-  }
-
-  /**
-   * Support for Java {@link java.lang.Object#wait()} synchronization primitive.
-   *
-   * @param o
-   *          the object synchronized on
-   * @param millis
-   *          the number of milliseconds to wait for notification
-   */
-  @Interruptible
-  public static void wait(Object o, long millis) {
-    long currentNanos = sysCall.sysNanoTime();
-    getCurrentThread().waitImpl(o, true, currentNanos + millis * 1000 * 1000);
-  }
-
-  /**
-   * Support for RTSJ- and pthread-style absolute wait.
-   *
-   * @param o
-   *          the object synchronized on
-   * @param whenNanos
-   *          the absolute time in nanoseconds when we should wake up
-   */
-  @Interruptible
-  public static void waitAbsoluteNanos(Object o, long whenNanos) {
-    getCurrentThread().waitImpl(o, true, whenNanos);
-  }
-
-  @UnpreemptibleNoWarn("Possible context when generating exception")
-  public static void raiseIllegalMonitorStateException(String msg, Object o) {
-    throw new IllegalMonitorStateException(msg + (o == null ? "<null>" : o.toString()));
-  }
-
-  /**
-   * Support for Java {@link java.lang.Object#notify()} synchronization
-   * primitive.
-   *
-   * @param o the object synchronized on
-   */
-  @Interruptible
-  public static void notify(Object o) {
-    if (STATS)
-      notifyOperations++;
-    Lock l = ObjectModel.getHeavyLock(o, false);
-    if (l == null)
-      return;
-    // the reason for locking: when inflating a lock we *first* install it in the status
-    // word and *then* initialize its state.  but fortunately, we do so while holding
-    // the lock's mutex.  thus acquiring the lock's mutex is the only way to ensure that
-    // we see the lock's state after initialization.
-    l.mutex.lock();
-    int owner=l.getOwnerId();
-    l.mutex.unlock();
-    int me=getCurrentThread().getLockingId();
-    if (owner != me) {
-      raiseIllegalMonitorStateException("notifying (expected lock to be held by "+me+"("+getCurrentThread().getLockingId()+") but was held by "+owner+"("+l.getOwnerId()+")) ", o);
-    }
-    l.mutex.lock();
-    RVMThread toAwaken = l.waiting.dequeue();
-    l.mutex.unlock();
-    if (toAwaken != null) {
-      toAwaken.monitor().lockedBroadcastNoHandshake();
-    }
-  }
-
-  /**
-   * Support for Java synchronization primitive.
-   *
-   * @param o the object synchronized on
-   * @see java.lang.Object#notifyAll
-   */
-  @Interruptible
-  public static void notifyAll(Object o) {
-    if (STATS)
-      notifyAllOperations++;
-    Lock l = ObjectModel.getHeavyLock(o, false);
-    if (l == null)
-      return;
-    l.mutex.lock();
-    int owner=l.getOwnerId();
-    l.mutex.unlock();
-    if (owner != getCurrentThread().getLockingId()) {
-      raiseIllegalMonitorStateException("notifying all (expected lock to be held by "+getCurrentThread().getLockingId()+" but was held by "+l.getOwnerId()+") ", o);
-    }
-    for (;;) {
-      l.mutex.lock();
-      RVMThread toAwaken = l.waiting.dequeue();
-      l.mutex.unlock();
-      if (toAwaken == null)
-        break;
-      toAwaken.monitor().lockedBroadcastNoHandshake();
-    }
-  }
-
-  public void stop(Throwable cause) {
-    monitor().lockNoHandshake();
-    asyncThrowable = cause;
-    takeYieldpoint = 1;
-    monitor().broadcast();
-    monitor().unlock();
-  }
-
-  /*
-   * Park and unpark support
-   */
-  @Interruptible
-  public void park(boolean isAbsolute, long time) throws Throwable {
-    if (parkingPermit) {
-      // fast path
-      parkingPermit = false;
-      Magic.sync();
-      return;
-    }
-    // massive retardation. someone might be holding the java.lang.Thread lock.
-    boolean holdsLock = holdsLock(thread);
-    if (holdsLock)
-      ObjectModel.genericUnlock(thread);
-    boolean hasTimeout;
-    long whenWakeupNanos;
-    hasTimeout = (time != 0);
-    if (isAbsolute) {
-      whenWakeupNanos = time;
-    } else {
-      whenWakeupNanos = sysCall.sysNanoTime() + time;
-    }
-    Throwable throwThis = null;
-    monitor().lockNoHandshake();
-    waiting = hasTimeout ? Waiting.TIMED_WAITING : Waiting.WAITING;
-    while (!parkingPermit && !hasInterrupt && asyncThrowable == null &&
-           (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
-      if (hasTimeout) {
-        monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
-      } else {
-        monitor().waitWithHandshake();
-      }
-    }
-    waiting = Waiting.RUNNABLE;
-    parkingPermit = false;
-    if (asyncThrowable != null) {
-      throwThis = asyncThrowable;
-      asyncThrowable = null;
-    }
-    monitor().unlock();
-
-    if (holdsLock)
-      ObjectModel.genericLock(thread);
-
-    if (throwThis != null) {
-      throw throwThis;
-    }
-  }
-
-  @Interruptible
-  public void unpark() {
-    monitor().lockNoHandshake();
-    parkingPermit = true;
-    monitor().broadcast();
-    monitor().unlock();
-  }
-
-  /**
-   * Get this thread's id for use in lock ownership tests. This is just the
-   * thread's slot as returned by {@link #getThreadSlot()}, shifted appropriately
-   * so it can be directly used in the ownership tests.
-   */
-  public int getLockingId() {
-    return lockingId;
-  }
-
-  @Uninterruptible
-  public static class SoftHandshakeVisitor {
-    /**
-     * Set whatever flags need to be set to signal that the given thread should
-     * perform some action when it acknowledges the soft handshake. If not
-     * interested in this thread, return false; otherwise return true. Returning
-     * true will cause a soft handshake request to be put through.
-     * <p>
-     * This method is called with the thread's monitor() held, but while the
-     * thread may still be running. This method is not called on mutators that
-     * have indicated that they are about to terminate.
-     */
-    public boolean checkAndSignal(RVMThread t) {
-      return true;
-    }
-
-    /**
-     * Called when it is determined that the thread is stuck in native. While
-     * this method is being called, the thread cannot return to running Java
-     * code. As such, it is safe to perform actions "on the thread's behalf".
-     */
-    public void notifyStuckInNative(RVMThread t) {
-    }
-
-    /**
-     * Check whether to include the specified thread in the soft handshake.
-     *
-     * @param t The thread to check for inclusion
-     * @return True if the thread should be included.
-     */
-    public boolean includeThread(RVMThread t) {
-      return true;
-    }
-  }
-
-  @NoCheckStore
-  public static int snapshotHandshakeThreads(SoftHandshakeVisitor v) {
-    // figure out which threads to consider
-    acctLock.lockNoHandshake(); /* get a consistent view of which threads are live. */
-
-    int numToHandshake = 0;
-    for (int i = 0; i < numThreads; ++i) {
-      RVMThread t = threads[i];
-      if (t != RVMThread.getCurrentThread() && !t.ignoreHandshakesAndGC() && v.includeThread(t)) {
-        handshakeThreads[numToHandshake++] = t;
-      }
-    }
-    acctLock.unlock();
-    return numToHandshake;
-  }
-
-  /**
-   * Tell each thread to take a yieldpoint and wait until all of them have done
-   * so at least once. Additionally, call the visitor on each thread when making
-   * the yieldpoint request; the purpose of the visitor is to set any additional
-   * fields as needed to make specific requests to the threads that yield. Note
-   * that the visitor's <code>visit()</code> method is called with both the
-   * thread's monitor held, and the <code>softHandshakeDataLock</code> held.
-   * <p>
-   * Currently we only use this mechanism for code patch isync requests on PPC,
-   * but this mechanism is powerful enough to be used by sliding-views style
-   * concurrent GC.
-   */
-  @NoCheckStore
-  @Unpreemptible("Does not perform actions that lead to blocking, but may wait for threads to rendezvous with the soft handshake")
-  public static void softHandshake(SoftHandshakeVisitor v) {
-    handshakeLock.lockWithHandshake(); /*
-                                        * prevent multiple (soft or hard) handshakes
-                                        * from proceeding concurrently
-                                        */
-
-    int numToHandshake = snapshotHandshakeThreads(v);
-    if (VM.VerifyAssertions)
-      VM._assert(softHandshakeLeft == 0);
-
-    // in turn, check if each thread needs a handshake, and if so,
-    // request one
-    for (int i = 0; i < numToHandshake; ++i) {
-      RVMThread t = handshakeThreads[i];
-      handshakeThreads[i] = null; // help GC
-      t.monitor().lockNoHandshake();
-      boolean waitForThisThread = false;
-      if (!t.isAboutToTerminate && v.checkAndSignal(t)) {
-        // CAS the execStatus field
-        t.setBlockedExecStatus();
-        // Note that at this point if the thread tries to either enter or
-        // exit Java code, it will be diverted into either
-        // enterNativeBlocked() or checkBlock(), both of which cannot do
-        // anything until they acquire the monitor() lock, which we now
-        // hold. Thus, the code below can, at its leisure, examine the
-        // thread's state and make its decision about what to do, fully
-        // confident that the thread's state is blocked from changing.
-        if (t.isInJava()) {
-          // the thread is currently executing Java code, so we must ensure
-          // that it either:
-          // 1) takes the next yieldpoint and rendezvous with this soft
-          // handshake request (see yieldpoint), or
-          // 2) performs the rendezvous when leaving Java code
-          // (see enterNativeBlocked, checkBlock, and addAboutToTerminate)
-          // either way, we will wait for it to get there before exiting
-          // this call, since the caller expects that after softHandshake()
-          // returns, no thread will be running Java code without having
-          // acknowledged.
-          t.softHandshakeRequested = true;
-          t.takeYieldpoint = 1;
-          waitForThisThread = true;
-        } else {
-          // the thread is not in Java code (it may be blocked or it may be
-          // in native), so we don't have to wait for it since it will
-          // do the Right Thing before returning to Java code. essentially,
-          // the thread cannot go back to running Java without doing whatever
-          // was requested because:
-          // A) we've set the execStatus to blocked, and
-          // B) we're holding its lock.
-          v.notifyStuckInNative(t);
-        }
-      }
-      t.monitor().unlock();
-
-      // NOTE: at this point the thread may already decrement the
-      // softHandshakeLeft counter, causing it to potentially go negative.
-      // this is unlikely and completely harmless.
-
-      if (waitForThisThread) {
-        softHandshakeDataLock.lockNoHandshake();
-        softHandshakeLeft++;
-        softHandshakeDataLock.unlock();
-      }
-    }
-
-    // wait for all threads to reach the handshake
-    softHandshakeDataLock.lockNoHandshake();
-    if (VM.VerifyAssertions)
-      VM._assert(softHandshakeLeft >= 0);
-    while (softHandshakeLeft > 0) {
-      // wait and tell the world that we're off in native land. this way
-      // if someone tries to block us at this point (suspend() or GC),
-      // they'll know not to wait for us.
-      softHandshakeDataLock.waitWithHandshake();
-    }
-    if (VM.VerifyAssertions)
-      VM._assert(softHandshakeLeft == 0);
-    softHandshakeDataLock.unlock();
-
-    processAboutToTerminate();
-
-    handshakeLock.unlock();
-  }
-
-  /**
-   * Check and clear the need for a soft handshake rendezvous.  This method
-   * cannot do anything that leads to a write barrier or allocation.
-   */
-  public boolean softRendezvousCheckAndClear() {
-    boolean result = false;
-    monitor().lockNoHandshake();
-    if (softHandshakeRequested) {
-      softHandshakeRequested = false;
-      result = true;
-    }
-    monitor().unlock();
-    return result;
-  }
-
-  /**
-   * Commit the soft handshake rendezvous.  This method cannot do anything
-   * that leads to a write barrier or allocation.
-   */
-  public void softRendezvousCommit() {
-    softHandshakeDataLock.lockNoHandshake();
-    softHandshakeLeft--;
-    if (softHandshakeLeft == 0) {
-      softHandshakeDataLock.broadcast();
-    }
-    softHandshakeDataLock.unlock();
-  }
-
-  /**
-   * Rendezvous with a soft handshake request. Can only be called when the
-   * thread's monitor is held.
-   */
-  public void softRendezvous() {
-    if (softRendezvousCheckAndClear())
-      softRendezvousCommit();
-  }
-
-  /**
-   * Handle requests that required a soft handshake. May be called after we
-   * acknowledged the soft handshake. Thus - this is for actions in which it is
-   * sufficient for the thread to acknowledge that it plans to act upon the
-   * request in the immediate future, rather than that the thread acts upon the
-   * request prior to acknowledging.
-   * <p>
-   * This is almost always called with the monitor() lock held, but that's
-   * not guaranteed.  If you need that lock, you can grab it (since it's a
-   * recursive lock).  But you should avoid grabbing other sorts of locks since
-   * that might cause deadlock.
-   */
-  void handleHandshakeRequest() {
-    // Process request for code-patch memory sync operation
-    if (VM.BuildForPowerPC && codePatchSyncRequested) {
-      codePatchSyncRequested = false;
-      // Q: Is this sufficient? Ask Steve why we don't need to sync
-      // icache/dcache. --dave
-      // A: Yes, this is sufficient. We (Filip and Dave) talked about it and
-      // agree that remote processors only need to execute isync. --Filip
-      // make sure not get stale data
-      Magic.isync();
-    }
-    // process memory management requests
-    if (flushRequested && activeMutatorContext) {
-      MemoryManager.flushMutatorContext();
-      flushRequested = false;
-    }
-    // not really a "soft handshake" request but we handle it here anyway
-    if (asyncDebugRequestedForThisThread) {
-      asyncDebugRequestedForThisThread = false;
-      dumpLock.lockNoHandshake();
-      VM.sysWriteln("Handling async stack trace request...");
-      dump();
-      VM.sysWriteln();
-      dumpStack();
-      dumpLock.unlock();
-    }
-  }
-
-  /**
-   * Stop all mutator threads. This is current intended to be run by a single thread.
-   *
-   * Fixpoint until there are no threads that we haven't blocked. Fixpoint is needed to
-   * catch the (unlikely) case that a thread spawns another thread while we are waiting.
-   */
-  @NoCheckStore
-  @Unpreemptible
-  public static void blockAllMutatorsForGC() {
-    RVMThread.handshakeLock.lockNoHandshake();
-    while (true) {
-      // (1) Find all the threads that need to be blocked for GC
-      RVMThread.acctLock.lockNoHandshake();
-      int numToHandshake = 0;
-      for (int i = 0; i < RVMThread.numThreads; i++) {
-        RVMThread t = RVMThread.threads[i];
-        if (!t.isCollectorThread() && !t.ignoreHandshakesAndGC()) {
-          RVMThread.handshakeThreads[numToHandshake++] = t;
-        }
-      }
-      RVMThread.acctLock.unlock();
-
-      // (2) Remove any threads that have already been blocked from the list.
-      for (int i = 0; i < numToHandshake; i++) {
-        RVMThread t = RVMThread.handshakeThreads[i];
-        t.monitor().lockNoHandshake();
-        if (t.blockedFor(RVMThread.gcBlockAdapter) || RVMThread.notRunning(t.asyncBlock(RVMThread.gcBlockAdapter))) {
-          // Already blocked or not running, remove.
-          RVMThread.handshakeThreads[i--] = RVMThread.handshakeThreads[--numToHandshake];
-          RVMThread.handshakeThreads[numToHandshake] = null; // help GC
-        }
-        t.monitor().unlock();
-      }
-
-      // (3) Quit trying to block threads if all threads are either blocked
-      //     or not running (a thread is "not running" if it is NEW or TERMINATED;
-      //     in the former case it means that the thread has not had start()
-      //     called on it while in the latter case it means that the thread
-      //     is either in the TERMINATED state or is about to be in that state
-      //     real soon now, and will not perform any heap-related work before
-      //     terminating).
-      if (numToHandshake == 0) break;
-
-      // (4) Request a block for GC from all other threads.
-      for (int i = 0; i < numToHandshake; i++) {
-        if (false) VM.sysWriteln("Waiting for ", RVMThread.handshakeThreads[i].getThreadSlot(), " to block.");
-        RVMThread t = RVMThread.handshakeThreads[i];
-        RVMThread.observeExecStatusAtSTW(t.block(RVMThread.gcBlockAdapter));
-        RVMThread.handshakeThreads[i] = null; // help GC
-      }
-    }
-    RVMThread.handshakeLock.unlock();
-
-    // Deal with terminating threads to ensure that all threads are either dead to MMTk or stopped above.
-    RVMThread.processAboutToTerminate();
-  }
-
-  /**
-   * Unblock all mutators blocked for GC.
-   */
-  @NoCheckStore
-  @Unpreemptible
-  public static void unblockAllMutatorsForGC() {
-    RVMThread.handshakeLock.lockNoHandshake();
-    RVMThread.acctLock.lockNoHandshake();
-    int numToHandshake = 0;
-    for (int i = 0; i < RVMThread.numThreads; i++) {
-      RVMThread t = RVMThread.threads[i];
-      if (!t.isCollectorThread() && !t.ignoreHandshakesAndGC()) {
-        RVMThread.handshakeThreads[numToHandshake++] = t;
-      }
-    }
-    RVMThread.acctLock.unlock();
-    for (int i = 0; i < numToHandshake; i++) {
-      RVMThread.handshakeThreads[i].unblock(RVMThread.gcBlockAdapter);
-      RVMThread.handshakeThreads[i] = null; // Help GC
-    }
-    RVMThread.handshakeLock.unlock();
-  }
-
-  @Uninterruptible
-  public static class HardHandshakeVisitor {
-    public boolean includeThread(RVMThread t) {
-      return true;
-    }
-  }
-
-  @Uninterruptible
-  @NonMoving
-  static class AllButGCHardHandshakeVisitor extends HardHandshakeVisitor {
-    @Override
-    public boolean includeThread(RVMThread t) {
-      return !t.isCollectorThread();
-    }
-  }
-
-  public static final AllButGCHardHandshakeVisitor allButGC=
-    new AllButGCHardHandshakeVisitor();
-
-  static long totalSuspendTime;
-  static long totalResumeTime;
-
-  @Unpreemptible
-  @NoCheckStore
-  public static void hardHandshakeSuspend(BlockAdapter ba,
-                                          HardHandshakeVisitor hhv) {
-    long before=sysCall.sysNanoTime();
-
-    RVMThread current=getCurrentThread();
-
-    handshakeLock.lockWithHandshake();
-    int numLockedLocks=0;
-    for (int i=0;i<nextSlot;++i) {
-      Monitor l=communicationLockBySlot[i];
-      if (l!=null) {
-        l.lockWithHandshake();
-        numLockedLocks++;
-      }
-    }
-
-    // fixpoint until there are no threads that we haven't blocked.
-    // fixpoint is needed in case some thread spawns another thread
-    // while we're waiting.  that is unlikely but possible.
-    for (;;) {
-      acctLock.lockNoHandshake();
-      int numToHandshake=0;
-      for (int i=0;i<numThreads;++i) {
-        RVMThread t=threads[i];
-        if (t!=current &&
-            !t.ignoreHandshakesAndGC() &&
-            hhv.includeThread(t)) {
-          handshakeThreads[numToHandshake++]=t;
-        }
-      }
-      acctLock.unlock();
-
-      for (int i=0;i<numToHandshake;++i) {
-        RVMThread t=handshakeThreads[i];
-        t.monitor().lockNoHandshake();
-        if (t.blockedFor(ba) ||
-            notRunning(t.asyncBlock(ba))) {
-          // already blocked or not running, remove
-          handshakeThreads[i--]=handshakeThreads[--numToHandshake];
-          handshakeThreads[numToHandshake]=null; // help GC
-        }
-        t.monitor().unlock();
-      }
-      // quit trying to block threads if all threads are either blocked
-      // or not running (a thread is "not running" if it is NEW or TERMINATED;
-      // in the former case it means that the thread has not had start()
-      // called on it while in the latter case it means that the thread
-      // is either in the TERMINATED state or is about to be in that state
-      // real soon now, and will not perform any heap-related stuff before
-      // terminating).
-      if (numToHandshake==0) break;
-      for (int i=0;i<numToHandshake;++i) {
-        RVMThread t=handshakeThreads[i];
-        observeExecStatusAtSTW(t.block(ba));
-        handshakeThreads[i]=null; // help GC
-      }
-    }
-    worldStopped=true;
-
-    processAboutToTerminate(); /*
-                                * ensure that any threads that died while
-                                * we were stopping the world notify us
-                                * that they had stopped.
-                                */
-
-    int numUnlockedLocks=0;
-    for (int i=0;i<nextSlot;++i) {
-      Monitor l=communicationLockBySlot[i];
-      if (l!=null) {
-        l.unlock();
-        numUnlockedLocks++;
-      }
-    }
-    if (VM.VerifyAssertions) VM._assert(numLockedLocks==numUnlockedLocks);
-    handshakeLock.unlock();
-
-    if (false) {
-      long after=sysCall.sysNanoTime();
-      totalSuspendTime+=after-before;
-      VM.sysWriteln("Stopping the world took ",(after-before)," ns (",totalSuspendTime," ns total)");
-    }
-  }
-
-  @NoCheckStore
-  @Unpreemptible
-  public static void hardHandshakeResume(BlockAdapter ba,
-                                         HardHandshakeVisitor hhv) {
-    long before=sysCall.sysNanoTime();
-
-    handshakeLock.lockWithHandshake();
-
-    RVMThread current=getCurrentThread();
-    worldStopped=false;
-    acctLock.lockNoHandshake();
-    int numToHandshake=0;
-    for (int i=0;i<numThreads;++i) {
-      RVMThread t=threads[i];
-      if (t!=current &&
-          !t.ignoreHandshakesAndGC() &&
-          hhv.includeThread(t)) {
-        handshakeThreads[numToHandshake++]=t;
-      }
-    }
-    acctLock.unlock();
-    for (int i=0;i<numToHandshake;++i) {
-      handshakeThreads[i].unblock(ba);
-      handshakeThreads[i]=null; // help GC
-    }
-
-    handshakeLock.unlock();
-
-    if (false) {
-      long after=sysCall.sysNanoTime();
-      totalResumeTime+=after-before;
-      VM.sysWriteln("Resuming the world took ",(after-before)," ns (",totalResumeTime," ns total)");
-    }
-  }
-
-  @Unpreemptible
-  public static void hardHandshakeSuspend() {
-    hardHandshakeSuspend(handshakeBlockAdapter,allButGC);
-  }
-
-  @Unpreemptible
-  public static void hardHandshakeResume() {
-    hardHandshakeResume(handshakeBlockAdapter,allButGC);
-  }
-
-  public static boolean worldStopped() {
-    return worldStopped;
-  }
-
-  /**
-   * Process a taken yieldpoint.
-   */
-  @Unpreemptible("May block if the thread was asked to do so but otherwise does not perform actions that may lead to blocking")
-  public static void yieldpoint(int whereFrom, Address yieldpointServiceMethodFP) {
-    RVMThread t = getCurrentThread();
-    boolean wasAtYieldpoint = t.atYieldpoint;
-    t.atYieldpoint = true;
-    t.yieldpointsTaken++;
-    // If thread is in critical section we can't do anything right now, defer
-    // until later
-    // we do this without acquiring locks, since part of the point of disabling
-    // yieldpoints is to ensure that locks are not "magically" acquired
-    // through unexpected yieldpoints. As well, this makes code running with
-    // yieldpoints disabled more predictable. Note furthermore that the only
-    // race here is setting takeYieldpoint to 0. But this is perfectly safe,
-    // since we are guaranteeing that a yieldpoint will run after we emerge from
-    // the no-yieldpoints code. At worst, setting takeYieldpoint to 0 will be
-    // lost (because some other thread sets it to non-0), but in that case we'll
-    // just come back here and reset it to 0 again.
-    if (!t.yieldpointsEnabled()) {
-      if (VM.VerifyAssertions)
-        VM._assert(!t.yieldToOSRRequested);
-      if (traceBlock && !wasAtYieldpoint) {
-        VM.sysWriteln("Thread #", t.threadSlot, " deferring yield!");
-        dumpStack();
-      }
-      t.yieldpointRequestPending = true;
-      t.takeYieldpoint = 0;
-      t.atYieldpoint = false;
-      return;
-    }
-    t.yieldpointsTakenFully++;
-
-    Throwable throwThis = null;
-    t.monitor().lockNoHandshake();
-
-    int takeYieldpointVal = t.takeYieldpoint;
-    if (takeYieldpointVal != 0) {
-      t.takeYieldpoint = 0;
-      // do two things: check if we should be blocking, and act upon
-      // handshake requests. This also has the effect of reasserting that
-      // we are in fact IN_JAVA (as opposed to IN_JAVA_TO_BLOCK).
-      t.checkBlock();
-
-      // Process timer interrupt event
-      if (t.timeSliceExpired != 0) {
-        t.timeSliceExpired = 0;
-
-        if (t.yieldForCBSCall || t.yieldForCBSMethod) {
-          /*
-           * CBS Sampling is still active from previous quantum. Note that fact,
-           * but leave all the other CBS parameters alone.
-           */
-        } else {
-          if (VM.CBSCallSamplesPerTick > 0) {
-            t.yieldForCBSCall = true;
-            t.takeYieldpoint = -1;
-            t.firstCBSCallSample++;
-            t.firstCBSCallSample = t.firstCBSCallSample % VM.CBSCallSampleStride;
-            t.countdownCBSCall = t.firstCBSCallSample;
-            t.numCBSCallSamples = VM.CBSCallSamplesPerTick;
-          }
-
-          if (VM.CBSMethodSamplesPerTick > 0) {
-            t.yieldForCBSMethod = true;
-            t.takeYieldpoint = -1;
-            t.firstCBSMethodSample++;
-            t.firstCBSMethodSample = t.firstCBSMethodSample % VM.CBSMethodSampleStride;
-            t.countdownCBSMethod = t.firstCBSMethodSample;
-            t.numCBSMethodSamples = VM.CBSMethodSamplesPerTick;
-          }
-        }
-
-        if (VM.BuildForAdaptiveSystem) {
-          RuntimeMeasurements.takeTimerSample(whereFrom,
-              yieldpointServiceMethodFP);
-        }
-        if (VM.BuildForAdaptiveSystem) {
-          OSRListener
-              .checkForOSRPromotion(whereFrom, yieldpointServiceMethodFP);
-        }
-      }
-
-      if (t.yieldForCBSCall) {
-        if (!(whereFrom == BACKEDGE || whereFrom == OSROPT)) {
-          if (--t.countdownCBSCall <= 0) {
-            if (VM.BuildForAdaptiveSystem) {
-              // take CBS sample
-              RuntimeMeasurements.takeCBSCallSample(whereFrom,
-                  yieldpointServiceMethodFP);
-            }
-            t.countdownCBSCall = VM.CBSCallSampleStride;
-            t.numCBSCallSamples--;
-            if (t.numCBSCallSamples <= 0) {
-              t.yieldForCBSCall = false;
-            }
-          }
-        }
-        if (t.yieldForCBSCall) {
-          t.takeYieldpoint = -1;
-        }
-      }
-
-      if (t.yieldForCBSMethod) {
-        if (--t.countdownCBSMethod <= 0) {
-          if (VM.BuildForAdaptiveSystem) {
-            // take CBS sample
-            RuntimeMeasurements.takeCBSMethodSample(whereFrom,
-                yieldpointServiceMethodFP);
-          }
-          t.countdownCBSMethod = VM.CBSMethodSampleStride;
-          t.numCBSMethodSamples--;
-          if (t.numCBSMethodSamples <= 0) {
-            t.yieldForCBSMethod = false;
-          }
-        }
-        if (t.yieldForCBSMethod) {
-          t.takeYieldpoint = 1;
-        }
-      }
-
-      if (VM.BuildForAdaptiveSystem && t.yieldToOSRRequested) {
-        t.yieldToOSRRequested = false;
-        OSRListener.handleOSRFromOpt(yieldpointServiceMethodFP);
-      }
-
-      // what is the reason for this? and what was the reason for doing
-      // a thread switch following the suspension in the OSR trigger code?
-      // ... it seems that at least part of the point here is that if a
-      // thread switch was desired for other reasons, then we need to ensure
-      // that between when this runs and when the glue code runs there will
-      // be no interleaved GC; obviously if we did this before the thread
-      // switch then there would be the possibility of interleaved GC.
-      if (VM.BuildForAdaptiveSystem && t.isWaitingForOsr) {
-        PostThreadSwitch.postProcess(t);
-      }
-      if (t.asyncThrowable != null) {
-        throwThis = t.asyncThrowable;
-        t.asyncThrowable = null;
-      }
-    }
-    t.monitor().unlock();
-    t.atYieldpoint = false;
-    if (throwThis != null) {
-      throwFromUninterruptible(throwThis);
-    }
-  }
-
-  @Unpreemptible
-  private static void throwFromUninterruptible(Throwable e) {
-    RuntimeEntrypoints.athrow(e);
-  }
-
-  /**
-   * Change the size of the currently executing thread's stack.
-   *
-   * @param newSize
-   *          new size (in bytes)
-   * @param exceptionRegisters
-   *          register state at which stack overflow trap was encountered (null
-   *          --> normal method call, not a trap)
-   */
-  @Unpreemptible("May block due to allocation")
-  public static void resizeCurrentStack(int newSize,
-      Registers exceptionRegisters) {
-    if (!getCurrentThread().hijackedReturnAddress.isZero()) {
-      /* stack resizing currently unsupported with return barrier */
-      VM.sysFail("system error: resizing stack while return barrier enabled (currently unsupported)");
-    }
-    if (traceAdjustments)
-      VM.sysWrite("Thread: resizeCurrentStack\n");
-    if (MemoryManager.gcInProgress()) {
-      VM.sysFail("system error: resizing stack while GC is in progress");
-    }
-    byte[] newStack = MemoryManager.newStack(newSize);
-    getCurrentThread().disableYieldpoints();
-    transferExecutionToNewStack(newStack, exceptionRegisters);
-    getCurrentThread().enableYieldpoints();
-    if (traceAdjustments) {
-      RVMThread t = getCurrentThread();
-      VM.sysWrite("Thread: resized stack ", t.getThreadSlot());
-      VM.sysWrite(" to ", t.stack.length / 1024);
-      VM.sysWrite("k\n");
-    }
-  }
-
-  @NoInline
-  @BaselineNoRegisters
-  // this method does not do a normal return and hence does not execute epilogue
-  // --> non-volatiles not restored!
-  private static void transferExecutionToNewStack(byte[] newStack,
-      Registers exceptionRegisters) {
-    // prevent opt compiler from inlining a method that contains a magic
-    // (returnToNewStack) that it does not implement.
-
-    RVMThread myThread = getCurrentThread();
-    byte[] myStack = myThread.stack;
-
-    // initialize new stack with live portion of stack we're
-    // currently running on
-    //
-    // lo-mem hi-mem
-    // |<---myDepth----|
-    // +----------+---------------+
-    // | empty | live |
-    // +----------+---------------+
-    // ^myStack ^myFP ^myTop
-    //
-    // +-------------------+---------------+
-    // | empty | live |
-    // +-------------------+---------------+
-    // ^newStack ^newFP ^newTop
-    //
-    Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
-    Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
-
-    Address myFP = Magic.getFramePointer();
-    Offset myDepth = myTop.diff(myFP);
-    Address newFP = newTop.minus(myDepth);
-
-    // The frame pointer addresses the top of the frame on powerpc and
-    // the bottom
-    // on intel. if we copy the stack up to the current
-    // frame pointer in here, the
-    // copy will miss the header of the intel frame. Thus we make another
-    // call
-    // to force the copy. A more explicit way would be to up to the
-    // frame pointer
-    // and the header for intel.
-    Offset delta = copyStack(newStack);
-
-    // fix up registers and save areas so they refer
-    // to "newStack" rather than "myStack"
-    //
-    if (exceptionRegisters != null) {
-      adjustRegisters(exceptionRegisters, delta);
-    }
-    adjustStack(newStack, newFP, delta);
-
-    // install new stack
-    //
-    myThread.stack = newStack;
-    myThread.stackLimit = Magic.objectAsAddress(newStack)
-        .plus(STACK_SIZE_GUARD);
-
-    // return to caller, resuming execution on new stack
-    // (original stack now abandoned)
-    //
-    if (VM.BuildForPowerPC) {
-      Magic.returnToNewStack(Magic.getCallerFramePointer(newFP));
-    } else if (VM.BuildForIA32) {
-      Magic.returnToNewStack(newFP);
-    }
-
-    if (VM.VerifyAssertions)
-      VM._assert(VM.NOT_REACHED);
-  }
-
-  /**
-   * This (suspended) thread's stack has been moved. Fixup register and memory
-   * references to reflect its new position.
-   *
-   * @param delta
-   *          displacement to be applied to all interior references
-   */
-  public void fixupMovedStack(Offset delta) {
-    if (traceAdjustments)
-      VM.sysWrite("Thread: fixupMovedStack\n");
-
-    if (!contextRegisters.getInnermostFramePointer().isZero()) {
-      adjustRegisters(contextRegisters, delta);
-    }
-    if ((exceptionRegisters.inuse) &&
-        (exceptionRegisters.getInnermostFramePointer().NE(Address.zero()))) {
-      adjustRegisters(exceptionRegisters, delta);
-    }
-    if (!contextRegisters.getInnermostFramePointer().isZero()) {
-      adjustStack(stack, contextRegisters.getInnermostFramePointer(), delta);
-    }
-    stackLimit = stackLimit.plus(delta);
-  }
-
-  /**
-   * A thread's stack has been moved or resized. Adjust registers to reflect new
-   * position.
-   *
-   * @param registers
-   *          registers to be adjusted
-   * @param delta
-   *          displacement to be applied
-   */
-  private static void adjustRegisters(Registers registers, Offset delta) {
-    if (traceAdjustments)
-      VM.sysWrite("Thread: adjustRegisters\n");
-
-    // adjust FP
-    //
-    Address newFP = registers.getInnermostFramePointer().plus(delta);
-    Address ip = registers.getInnermostInstructionAddress();
-    registers.setInnermost(ip, newFP);
-    if (traceAdjustments) {
-      VM.sysWrite(" fp=");
-      VM.sysWrite(registers.getInnermostFramePointer());
-    }
-
-    // additional architecture specific adjustments
-    // (1) frames from all compilers on IA32 need to update ESP
-    int compiledMethodId = Magic.getCompiledMethodID(registers
-        .getInnermostFramePointer());
-    if (compiledMethodId != INVISIBLE_METHOD_ID) {
-      if (VM.BuildForIA32) {
-        Configuration.archHelper.adjustESP(registers, delta, traceAdjustments);
-      }
-      if (traceAdjustments) {
-        CompiledMethod compiledMethod = CompiledMethods
-            .getCompiledMethod(compiledMethodId);
-        VM.sysWrite(" method=");
-        VM.sysWrite(compiledMethod.getMethod());
-        VM.sysWrite("\n");
-      }
-    }
-  }
-
-  /**
-   * A thread's stack has been moved or resized. Adjust internal pointers to
-   * reflect new position.
-   *
-   * @param stack
-   *          stack to be adjusted
-   * @param fp
-   *          pointer to its innermost frame
-   * @param delta
-   *          displacement to be applied to all its interior references
-   */
-  private static void adjustStack(byte[] stack, Address fp, Offset delta) {
-    if (traceAdjustments)
-      VM.sysWrite("Thread: adjustStack\n");
-
-    while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
-      // adjust FP save area
-      //
-      Magic.setCallerFramePointer(fp, Magic.getCallerFramePointer(fp).plus(
-          delta));
-      if (traceAdjustments) {
-        VM.sysWrite(" fp=", fp.toWord());
-      }
-
-      // advance to next frame
-      //
-      fp = Magic.getCallerFramePointer(fp);
-    }
-  }
-
-  /**
-   * Initialize a new stack with the live portion of the stack we're currently
-   * running on.
-   *
-   * <pre>
-   *  lo-mem                                        hi-mem
-   *                           |&lt;---myDepth----|
-   *                 +----------+---------------+
-   *                 |   empty  |     live      |
-   *                 +----------+---------------+
-   *                  &circ;myStack   &circ;myFP           &circ;myTop
-   *       +-------------------+---------------+
-   *       |       empty       |     live      |
-   *       +-------------------+---------------+
-   *        &circ;newStack           &circ;newFP          &circ;newTop
-   * </pre>
-   */
-  private static Offset copyStack(byte[] newStack) {
-    RVMThread myThread = getCurrentThread();
-    byte[] myStack = myThread.stack;
-
-    Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
-    Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
-    Address myFP = Magic.getFramePointer();
-    Offset myDepth = myTop.diff(myFP);
-    Address newFP = newTop.minus(myDepth);
-
-    // before copying, make sure new stack isn't too small
-    //
-    if (VM.VerifyAssertions) {
-      VM._assert(newFP.GE(Magic.objectAsAddress(newStack)
-          .plus(STACK_SIZE_GUARD)));
-    }
-
-    Memory.memcopy(newFP, myFP, myDepth.toWord().toExtent());
-
-    return newFP.diff(myFP);
-  }
-
-  /**
-   * Set the "isDaemon" status of this thread. Although a java.lang.Thread can
-   * only have setDaemon invoked on it before it is started, Threads can become
-   * daemons at any time. Note: making the last non daemon a daemon will
-   * terminate the VM.
-   * <p>
-   * Note: This method might need to be uninterruptible so it is final, which is
-   * why it isn't called setDaemon.
-   * <p>
-   * Public so that java.lang.Thread can use it.
-   */
-  public void makeDaemon(boolean on) {
-    if (daemon == on) {
-      // nothing to do
-    } else {
-      daemon = on;
-      if (getExecStatus() == NEW) {
-        // thread will start as a daemon
-      } else {
-        boolean terminateSystem = false;
-        acctLock.lockNoHandshake();
-        numActiveDaemons += on ? 1 : -1;
-        if (numActiveDaemons == numActiveThreads) {
-          terminateSystem = true;
-        }
-        acctLock.unlock();
-        if (terminateSystem) {
-          if (VM.TraceThreads) {
-            trace("Thread", "last non Daemon demonized");
-          }
-          VM.sysExit(0);
-          if (VM.VerifyAssertions)
-            VM._assert(VM.NOT_REACHED);
-        }
-      }
-    }
-  }
-
-  /**
-   * Dump information for all threads, via {@link VM#sysWrite(String)}. Each
-   * thread's info is newline-terminated.
-   *
-   * @param verbosity Ignored.
-   */
-  public static void dumpAll(int verbosity) {
-    for (int i = 0; i < numThreads; i++) {
-      RVMThread t = threads[i];
-      if (t == null)
-        continue;
-      VM.sysWrite("Thread ");
-      VM.sysWriteInt(t.threadSlot);
-      VM.sysWrite(":  ");
-      VM.sysWriteHex(Magic.objectAsAddress(t));
-      VM.sysWrite("   ");
-      t.dump(verbosity);
-      // Compensate for t.dump() not newline-terminating info.
-      VM.sysWriteln();
-    }
-  }
-
-  /** @return The value of {@link #isBootThread} */
-  public boolean isBootThread() {
-    return this == bootThread;
-  }
-
-  /** @return Is this the MainThread ? */
-  private boolean isMainThread() {
-    return thread instanceof MainThread;
-  }
-
-  /** Is this a system thread? */
-  public boolean isSystemThread() {
-    return systemThread != null;
-  }
-
-  /** Get the collector thread this RVMTHread is running */
-  public CollectorThread getCollectorThread() {
-    if (VM.VerifyAssertions) VM._assert(isCollectorThread());
-    return (CollectorThread)systemThread;
-  }
-
-  /** Returns the value of {@link #daemon}. */
-  public boolean isDaemonThread() {
-    return daemon;
-  }
-
-  /**
-   * Should this thread run concurrently with STW GC and ignore handshakes?
-   */
-  public boolean ignoreHandshakesAndGC() {
-    if (systemThread == null) return false;
-    return systemThread instanceof TimerThread;
-  }
-
-  /** Is the thread started and not terminated */
-  public boolean isAlive() {
-    monitor().lockNoHandshake();
-    observeExecStatus();
-    boolean result = execStatus != NEW && execStatus != TERMINATED && !isAboutToTerminate;
-    monitor().unlock();
-    return result;
-  }
-
-  /**
-   * Sets the name of the thread
-   *
-   * @param name the new name for the thread
-   * @see java.lang.Thread#setName(String)
-   */
-  public void setName(String name) {
-    this.name = name;
-  }
-
-  /**
-   * Gets the name of the thread
-   *
-   * @see java.lang.Thread#getName()
-   */
-  public String getName() {
-    return name;
-  }
-
-  /**
-   * Does the currently running Thread hold the lock on an obj?
-   *
-   * @param obj
-   *          the object to check
-   * @return whether the thread holds the lock
-   * @see java.lang.Thread#holdsLock(Object)
-   */
-  public boolean holdsLock(Object obj) {
-    RVMThread mine = getCurrentThread();
-    return ObjectModel.holdsLock(obj, mine);
-  }
-
-  /**
-   * Was this thread interrupted?
-   *
-   * @return whether the thread has been interrupted
-   * @see java.lang.Thread#isInterrupted()
-   */
-  public boolean isInterrupted() {
-    return hasInterrupt;
-  }
-
-  /**
-   * Clear the interrupted status of this thread
-   *
-   * @see java.lang.Thread#interrupted()
-   */
-  public void clearInterrupted() {
-    hasInterrupt = false;
-  }
-
-  /**
-   * Interrupt this thread
-   *
-   * @see java.lang.Thread#interrupt()
-   */
-  @Interruptible
-  public void interrupt() {
-    monitor().lockNoHandshake();
-    hasInterrupt = true;
-    monitor().broadcast();
-    monitor().unlock();
-  }
-
-  /**
-   * Get the priority of the thread
-   *
-   * @return the thread's priority
-   * @see java.lang.Thread#getPriority()
-   */
-  public int getPriority() {
-    return priority;
-  }
-
-  /**
-   * Set the priority of the thread
-   *
-   * @param priority
-   * @see java.lang.Thread#getPriority()
-   */
-  public void setPriority(int priority) {
-    this.priority = priority;
-    // @TODO this should be calling a syscall
-  }
-
-  /**
-   * Get the state of the thread in a manner compatible with the Java API
-   *
-   * @return thread state
-   * @see java.lang.Thread#getState()
-   */
-  @Interruptible
-  public Thread.State getState() {
-    monitor().lockNoHandshake();
-    try {
-      observeExecStatus();
-      switch (execStatus) {
-      case NEW:
-        return Thread.State.NEW;
-      case IN_JAVA:
-      case IN_NATIVE:
-      case IN_JNI:
-      case IN_JAVA_TO_BLOCK:
-      case BLOCKED_IN_NATIVE:
-      case BLOCKED_IN_JNI:
-        if (isAboutToTerminate) {
-          return Thread.State.TERMINATED;
-        }
-        switch (waiting) {
-        case RUNNABLE:
-          return Thread.State.RUNNABLE;
-        case WAITING:
-          return Thread.State.WAITING;
-        case TIMED_WAITING:
-          return Thread.State.TIMED_WAITING;
-        default:
-          VM.sysFail("Unknown waiting value: " + waiting);
-          return null;
-        }
-      case TERMINATED:
-        return Thread.State.TERMINATED;
-      default:
-        VM.sysFail("Unknown value of execStatus: " + execStatus);
-        return null;
-      }
-    } finally {
-      monitor().unlock();
-    }
-  }
-
-  /**
-   * Wait for the thread to die or for the timeout to occur
-   *
-   * @param ms
-   *          milliseconds to wait
-   * @param ns
-   *          nanoseconds to wait
-   */
-  @Interruptible
-  public void join(long ms, int ns) throws InterruptedException {
-    RVMThread myThread = getCurrentThread();
-    if (VM.VerifyAssertions)
-      VM._assert(myThread != this);
-    if (traceBlock)
-      VM.sysWriteln("Joining on Thread #", threadSlot);
-    // this uses synchronized because we cannot have one thread acquire
-    // another thread's lock using the WithHandshake scheme, as that would result
-    // in a thread holding two threads' monitor()s.  using synchronized
-    // turns out to be just fine - see comment in terminate().
-    synchronized (this) {
-      if (ms == 0 && ns == 0) {
-        while (!isJoinable) {
-          wait(this);
-          if (traceBlock)
-            VM.sysWriteln("relooping in join on Thread #", threadSlot);
-        }
-      } else {
-        long startNano = Time.nanoTime();
-        long whenWakeup = startNano + ms * 1000L * 1000L + ns;
-        while (!isJoinable) {
-          waitAbsoluteNanos(this, whenWakeup);
-          if (Time.nanoTime() >= whenWakeup) {
-            break;
-          }
-          if (traceBlock)
-            VM.sysWriteln("relooping in join on Thread #", threadSlot);
-        }
-      }
-    }
-  }
-
-  /**
-   * Count the stack frames of this thread
-   */
-  @Interruptible
-  public int countStackFrames() {
-    if (!isSuspended) {
-      throw new IllegalThreadStateException(
-          "Thread.countStackFrames called on non-suspended thread");
-    }
-    throw new UnimplementedError();
-  }
-
-  /**
-   * @return the length of the stack
-   */
-  public int getStackLength() {
-    return stack.length;
-  }
-
-  /**
-   * @return the stack
-   */
-  public byte[] getStack() {
-    return stack;
-  }
-
-  /**
-   * @return the thread's exception registers
-   */
-  public Registers getExceptionRegisters() {
-    return exceptionRegisters;
-  }
-
-  /**
-   * @return the thread's context registers (saved registers when thread is
-   *         suspended by green-thread scheduler).
-   */
-  public Registers getContextRegisters() {
-    return contextRegisters;
-  }
-
-  /** Set the initial attempt. */
-  public void reportCollectionAttempt() {
-    collectionAttempt++;
-  }
-
-  /** Set the initial attempt. */
-  public int getCollectionAttempt() {
-    return collectionAttempt;
-  }
-
-  /** Resets the attempts. */
-  public void resetCollectionAttempts() {
-    collectionAttempt = 0;
-  }
-
-  /** Get the physical allocation failed flag. */
-  public boolean physicalAllocationFailed() {
-    return physicalAllocationFailed;
-  }
-
-  /** Set the physical allocation failed flag. */
-  public void setPhysicalAllocationFailed() {
-    physicalAllocationFailed = true;
-  }
-
-  /** Clear the physical allocation failed flag. */
-  public void clearPhysicalAllocationFailed() {
-    physicalAllocationFailed = false;
-  }
-
-  /**
-   * Returns the outstanding OutOfMemoryError.
-   */
-  public static OutOfMemoryError getOutOfMemoryError() {
-    return outOfMemoryError;
-  }
-
-  /**
-   * Number of active threads in the system.
-   */
-  public static int getNumActiveThreads() {
-    return numActiveThreads;
-  }
-
-  /**
-   * Number of active daemon threads.
-   */
-  public static int getNumActiveDaemons() {
-    return numActiveDaemons;
-  }
-
-  @Interruptible
-  public void handleUncaughtException(Throwable exceptionObject) {
-    uncaughtExceptionCount++;
-
-    handlePossibleRecursiveException();
-    VM.enableGC();
-    if (thread == null) {
-      VM.sysWrite("Exception in the primordial thread \"", getName(),
-          "\" while booting: ");
-    } else {
-      // This is output like that of the Sun JDK.
-      VM.sysWrite("Exception in thread \"", getName(), "\": ");
-    }
-    if (exceptionObject instanceof OutOfMemoryError) {
-      VM.sysWriteln("   <<No stacktrace available>>");
-    } else if (VM.fullyBooted) {
-      exceptionObject.printStackTrace();
-    }
-    getCurrentThread().terminate();
-    if (VM.VerifyAssertions)
-      VM._assert(VM.NOT_REACHED);
-  }
-
-  /** Handle the case of exception handling triggering new exceptions. */
-  private void handlePossibleRecursiveException() {
-    if (uncaughtExceptionCount > 1 &&
-        uncaughtExceptionCount <= VM.maxSystemTroubleRecursionDepth + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite) {
-      VM.sysWrite("We got an uncaught exception while (recursively) handling ");
-      VM.sysWrite(uncaughtExceptionCount - 1);
-      VM.sysWrite(" uncaught exception");
-      if (uncaughtExceptionCount - 1 != 1) {
-        VM.sysWrite("s");
-      }
-      VM.sysWriteln(".");
-    }
-    if (uncaughtExceptionCount > VM.maxSystemTroubleRecursionDepth) {
-      dumpVirtualMachine();
-      VM.dieAbruptlyRecursiveSystemTrouble();
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-    }
-  }
-
-  private static void dumpThread(RVMThread t) {
-    if (t == null) {
-      VM.sysWrite("none");
-    } else {
-      VM.sysWrite(t.threadSlot, "(", t.getExecStatus());
-      if (t.isAboutToTerminate) {
-        VM.sysWrite("T");
-      }
-      if (t.isBlocking) {
-        VM.sysWrite("B");
-      }
-      if (t.isJoinable) {
-        VM.sysWrite("J");
-      }
-      if (t.atYieldpoint) {
-        VM.sysWrite("Y");
-      }
-      VM.sysWrite(")");
-    }
-  }
-
-  private static void dumpThreadArray(RVMThread[] array, int bound) {
-    for (int i = 0; i < bound; ++i) {
-      if (i != 0) {
-        VM.sysWrite(", ");
-      }
-      VM.sysWrite(i, ":");
-      dumpThread(array[i]);
-    }
-  }
-
-  private static void dumpThreadSlotArray(int[] array, int bound) {
-    for (int i = 0; i < bound; ++i) {
-      if (i != 0) {
-        VM.sysWrite(", ");
-      }
-      VM.sysWrite(i, ":");
-      int threadSlot=array[i];
-      VM.sysWrite(threadSlot, ",");
-      dumpThread(threadBySlot[array[i]]);
-    }
-  }
-
-  private static void dumpThreadArray(String name, RVMThread[] array, int bound) {
-    VM.sysWrite(name);
-    VM.sysWrite(": ");
-    dumpThreadArray(array, bound);
-    VM.sysWriteln();
-  }
-
-  private static void dumpThreadSlotArray(String name, int[] array, int bound) {
-    VM.sysWrite(name);
-    VM.sysWrite(": ");
-    dumpThreadSlotArray(array, bound);
-    VM.sysWriteln();
-  }
-
-  public static void dumpAcct() {
-    acctLock.lockNoHandshake();
-    dumpLock.lockNoHandshake();
-    VM.sysWriteln("====== Begin Thread Accounting Dump ======");
-    dumpThreadArray("threadBySlot", threadBySlot, nextSlot);
-    dumpThreadSlotArray("aboutToTerminate", aboutToTerminate, aboutToTerminateN);
-    VM.sysWrite("freeSlots: ");
-    for (int i = 0; i < freeSlotN; ++i) {
-      if (i != 0) {
-        VM.sysWrite(", ");
-      }
-      VM.sysWrite(i, ":", freeSlots[i]);
-    }
-    VM.sysWriteln();
-    dumpThreadArray("threads", threads, numThreads);
-    VM.sysWriteln("====== End Thread Accounting Dump ======");
-    dumpLock.unlock();
-    acctLock.unlock();
-  }
-
-  public void extDump() {
-    dump();
-    VM.sysWriteln();
-    VM.sysWriteln("acquireCount for my monitor: ", monitor().acquireCount);
-    VM.sysWriteln("yieldpoints taken: ", yieldpointsTaken);
-    VM.sysWriteln("yieldpoints taken fully: ", yieldpointsTakenFully);
-    VM.sysWriteln("native entered blocked: ", nativeEnteredBlocked);
-    VM.sysWriteln("JNI entered blocked: ", jniEnteredBlocked);
-  }
-
-  /**
-   * Dump this thread's identifying information, for debugging, via
-   * {@link VM#sysWrite(String)}. We do not use any spacing or newline
-   * characters. Callers are responsible for space-separating or
-   * newline-terminating output.
-   */
-  public void dump() {
-    dump(0);
-  }
-
-  /**
-   * Dump this thread's identifying information, for debugging, via
-   * {@link VM#sysWrite(String)}. We pad to a minimum of leftJustify
-   * characters. We do not use any spacing characters. Callers are responsible
-   * for space-separating or newline-terminating output.
-   *
-   * @param leftJustify
-   *          minimum number of characters emitted, with any extra characters
-   *          being spaces.
-   */
-  public void dumpWithPadding(int leftJustify) {
-    char[] buf = Services.grabDumpBuffer();
-    int len = dump(buf);
-    VM.sysWrite(buf, len);
-    for (int i = leftJustify - len; i > 0; i--) {
-      VM.sysWrite(" ");
-    }
-    Services.releaseDumpBuffer();
-  }
-
-  /**
-   * Dump this thread's identifying information, for debugging, via
-   * {@link VM#sysWrite(String)}. We do not use any spacing or newline
-   * characters. Callers are responsible for space-separating or
-   * newline-terminating output.
-   *
-   * This function avoids write barriers and allocation.
-   *
-   * @param verbosity
-   *          Ignored.
-   */
-  public void dump(int verbosity) {
-    char[] buf = Services.grabDumpBuffer();
-    int len = dump(buf);
-    VM.sysWrite(buf, len);
-    Services.releaseDumpBuffer();
-  }
-
-  /**
-   * Dump this thread's info, for debugging. Copy the info about it into a
-   * destination char array. We do not use any spacing or newline characters.
-   *
-   * This function may be called during GC; it avoids write barriers and
-   * allocation.
-   *
-   * For this reason, we do not throw an <code>IndexOutOfBoundsException</code>.
-   *
-   * @param dest
-   *          char array to copy the source info into.
-   * @param offset
-   *          Offset into <code>dest</code> where we start copying
-   *
-   * @return 1 plus the index of the last character written. If we were to write
-   *         zero characters (which we won't) then we would return
-   *         <code>offset</code>. This is intended to represent the first
-   *         unused position in the array <code>dest</code>. However, it also
-   *         serves as a pseudo-overflow check: It may have the value
-   *         <code>dest.length</code>, if the array <code>dest</code> was
-   *         completely filled by the call, or it may have a value greater than
-   *         <code>dest.length</code>, if the info needs more than
-   *         <code>dest.length - offset</code> characters of space.
-   *
-   * -1 if <code>offset</code> is negative.
-   */
-  public int dump(char[] dest, int offset) {
-    offset = Services.sprintf(dest, offset, getThreadSlot()); // id
-    if (daemon) {
-      offset = Services.sprintf(dest, offset, "-daemon"); // daemon thread?
-    }
-    if (isBootThread()) {
-      offset = Services.sprintf(dest, offset, "-Boot"); // Boot (Primordial)
-      // thread
-    }
-    if (isSystemThread()) {
-      offset = Services.sprintf(dest, offset, "-system"); // System Thread
-    }
-    if (isMainThread()) {
-      offset = Services.sprintf(dest, offset, "-main"); // Main Thread
-    }
-    if (isCollectorThread()) {
-      offset = Services.sprintf(dest, offset, "-collector"); // gc thread?
-    }
-    offset = Services.sprintf(dest, offset, "-");
-    offset = Services.sprintf(dest, offset, getExecStatus());
-    offset = Services.sprintf(dest, offset, "-");
-    offset = Services.sprintf(dest, offset, java.lang.JikesRVMSupport
-        .getEnumName(waiting));
-    if (hasInterrupt || asyncThrowable != null) {
-      offset = Services.sprintf(dest, offset, "-interrupted");
-    }
-    if (isAboutToTerminate) {
-      offset = Services.sprintf(dest, offset, "-terminating");
-    }
-    return offset;
-  }
-
-  /**
-   * Dump this thread's info, for debugging. Copy the info about it into a
-   * destination char array. We do not use any spacing or newline characters.
-   * <p>
-   * This is identical to calling {@link #dump(char[],int)} with an
-   * <code>offset</code> of zero.
-   */
-  public int dump(char[] dest) {
-    return dump(dest, 0);
-  }
-
-  /** Dump statistics gather on operations */
-  static void dumpStats() {
-    VM.sysWrite("FatLocks: ");
-    VM.sysWrite(waitOperations);
-    VM.sysWrite(" wait operations\n");
-    VM.sysWrite("FatLocks: ");
-    VM.sysWrite(timedWaitOperations);
-    VM.sysWrite(" timed wait operations\n");
-    VM.sysWrite("FatLocks: ");
-    VM.sysWrite(notifyOperations);
-    VM.sysWrite(" notify operations\n");
-    VM.sysWrite("FatLocks: ");
-    VM.sysWrite(notifyAllOperations);
-  }
-
-  /**
-   * Print out message in format "[j] (cez#td) who: what", where: j = java
-   * thread id z* = RVMThread.getCurrentThread().yieldpointsEnabledCount (0
-   * means yieldpoints are enabled outside of the call to debug) t* =
-   * numActiveThreads d* = numActiveDaemons * parenthetical values, printed only
-   * if traceDetails = true)
-   * <p>
-   * We serialize against a mutex to avoid intermingling debug output from
-   * multiple threads.
-   */
-  public static void trace(String who, String what) {
-    outputLock.lockNoHandshake();
-    VM.sysWrite("[");
-    RVMThread t = getCurrentThread();
-    t.dump();
-    VM.sysWrite("] ");
-    if (traceDetails) {
-      VM.sysWrite("(");
-      VM.sysWriteInt(numActiveDaemons);
-      VM.sysWrite("/");
-      VM.sysWriteInt(numActiveThreads);
-      VM.sysWrite(") ");
-    }
-    VM.sysWrite(who);
-    VM.sysWrite(": ");
-    VM.sysWrite(what);
-    VM.sysWrite("\n");
-    outputLock.unlock();
-  }
-
-  /**
-   * Print out message in format "p[j] (cez#td) who: what howmany", where: p =
-   * processor id j = java thread id c* = java thread id of the owner of
-   * threadCreationMutex (if any) e* = java thread id of the owner of
-   * threadExecutionMutex (if any) t* = numActiveThreads d* = numActiveDaemons *
-   * parenthetical values, printed only if traceDetails = true)
-   * <p>
-   * We serialize against a mutex to avoid intermingling debug output from
-   * multiple threads.
-   */
-  public static void trace(String who, String what, int howmany) {
-    _trace(who, what, howmany, false);
-  }
-
-  // same as trace, but prints integer value in hex
-  //
-  public static void traceHex(String who, String what, int howmany) {
-    _trace(who, what, howmany, true);
-  }
-
-  public static void trace(String who, String what, Address addr) {
-    outputLock.lockNoHandshake();
-    VM.sysWrite("[");
-    getCurrentThread().dump();
-    VM.sysWrite("] ");
-    if (traceDetails) {
-      VM.sysWrite("(");
-      VM.sysWriteInt(numActiveDaemons);
-      VM.sysWrite("/");
-      VM.sysWriteInt(numActiveThreads);
-      VM.sysWrite(") ");
-    }
-    VM.sysWrite(who);
-    VM.sysWrite(": ");
-    VM.sysWrite(what);
-    VM.sysWrite(" ");
-    VM.sysWriteHex(addr);
-    VM.sysWrite("\n");
-    outputLock.unlock();
-  }
-
-  private static void _trace(String who, String what, int howmany, boolean hex) {
-    outputLock.lockNoHandshake();
-    VM.sysWrite("[");
-    // VM.sysWriteInt(RVMThread.getCurrentThread().getThreadSlot());
-    getCurrentThread().dump();
-    VM.sysWrite("] ");
-    if (traceDetails) {
-      VM.sysWrite("(");
-      VM.sysWriteInt(numActiveDaemons);
-      VM.sysWrite("/");
-      VM.sysWriteInt(numActiveThreads);
-      VM.sysWrite(") ");
-    }
-    VM.sysWrite(who);
-    VM.sysWrite(": ");
-    VM.sysWrite(what);
-    VM.sysWrite(" ");
-    if (hex) {
-      VM.sysWriteHex(howmany);
-    } else {
-      VM.sysWriteInt(howmany);
-    }
-    VM.sysWrite("\n");
-    outputLock.unlock();
-  }
-
-  /**
-   * Print interesting scheduler information, starting with a stack traceback.
-   * <p>
-   * Note: the system could be in a fragile state when this method is called, so
-   * we try to rely on as little runtime functionality as possible (eg. use no
-   * bytecodes that require RuntimeEntrypoints support).
-   */
-  public static void traceback(String message) {
-    if (VM.runningVM) {
-      outputLock.lockNoHandshake();
-    }
-    VM.sysWriteln(message);
-    tracebackWithoutLock();
-    if (VM.runningVM) {
-      outputLock.unlock();
-    }
-  }
-
-  public static void traceback(String message, int number) {
-    if (VM.runningVM) {
-      outputLock.lockNoHandshake();
-    }
-    VM.sysWriteln(message, number);
-    tracebackWithoutLock();
-    if (VM.runningVM) {
-      outputLock.unlock();
-    }
-  }
-
-  static void tracebackWithoutLock() {
-    if (VM.runningVM) {
-      VM.sysWriteln("Thread #", getCurrentThreadSlot());
-      dumpStack(Magic.getCallerFramePointer(Magic.getFramePointer()));
-    } else {
-      dumpStack();
-    }
-  }
-
-  /**
-   * Dump stack of calling thread, starting at callers frame
-   */
-  @UninterruptibleNoWarn("Never blocks")
-  public static void dumpStack() {
-    if (VM.runningVM) {
-      VM.sysWriteln("Dumping stack for Thread #", getCurrentThreadSlot());
-      dumpStack(Magic.getFramePointer());
-    } else {
-      StackTraceElement[] elements = (new Throwable(
-          "--traceback from Jikes RVM's RVMThread class--")).getStackTrace();
-      for (StackTraceElement element : elements) {
-        System.err.println(element.toString());
-      }
-    }
-  }
-
-  /**
-   * Dump state of a (stopped) thread's stack.
-   *
-   * @param fp address of starting frame. first frame output is the calling
-   * frame of passed frame
-   */
-  public static void dumpStack(Address fp) {
-    if (VM.VerifyAssertions) {
-      VM._assert(VM.runningVM);
-    }
-    Address ip = Magic.getReturnAddress(fp);
-    fp = Magic.getCallerFramePointer(fp);
-    dumpStack(ip, fp);
-  }
-
-  /**
-   * Dump state of a (stopped) thread's stack.
-   *
-   * @param ip instruction pointer for first frame to dump
-   * @param fp frame pointer for first frame to dump
-   */
-  public static void dumpStack(Address ip, Address fp) {
-    boolean b = Monitor.lockNoHandshake(dumpLock);
-    RVMThread t = getCurrentThread();
-    ++t.inDumpStack;
-    if (t.inDumpStack > 1 &&
-        t.inDumpStack <= VM.maxSystemTroubleRecursionDepth + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite) {
-      VM.sysWrite("RVMThread.dumpStack(): in a recursive call, ");
-      VM.sysWrite(t.inDumpStack);
-      VM.sysWriteln(" deep.");
-    }
-    if (t.inDumpStack > VM.maxSystemTroubleRecursionDepth) {
-      VM.dieAbruptlyRecursiveSystemTrouble();
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-    }
-
-    if (!isAddressValidFramePointer(fp)) {
-      VM.sysWrite("Bogus looking frame pointer: ", fp);
-      VM.sysWriteln(" not dumping stack");
-    } else {
-      try {
-        VM.sysWriteln("-- Stack --");
-        while (Magic.getCallerFramePointer(fp).NE(
-            StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
-
-          // if code is outside of RVM heap, assume it to be native code,
-          // skip to next frame
-          if (!MemoryManager.addressInVM(ip)) {
-            showMethod("native frame", fp);
-            ip = Magic.getReturnAddress(fp);
-            fp = Magic.getCallerFramePointer(fp);
-          } else {
-
-            int compiledMethodId = Magic.getCompiledMethodID(fp);
-            VM.sysWrite("("); VM.sysWrite(fp); VM.sysWrite(" "); VM.sysWrite(compiledMethodId); VM.sysWrite(")");
-            if (compiledMethodId == StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
-              showMethod("invisible method", fp);
-            } else {
-              // normal java frame(s)
-              CompiledMethod compiledMethod = CompiledMethods
-                  .getCompiledMethod(compiledMethodId);
-              if (compiledMethod == null) {
-                showMethod(compiledMethodId, fp);
-              } else if (compiledMethod.getCompilerType() == CompiledMethod.TRAP) {
-                showMethod("hardware trap", fp);
-              } else {
-                RVMMethod method = compiledMethod.getMethod();
-                Offset instructionOffset = compiledMethod
-                    .getInstructionOffset(ip);
-                int lineNumber = compiledMethod
-                    .findLineNumberForInstruction(instructionOffset);
-                boolean frameShown = false;
-                if (VM.BuildForOptCompiler && compiledMethod.getCompilerType() == CompiledMethod.OPT) {
-                  OptCompiledMethod optInfo = (OptCompiledMethod) compiledMethod;
-                  // Opt stack frames may contain multiple inlined methods.
-                  OptMachineCodeMap map = optInfo.getMCMap();
-                  int iei = map.getInlineEncodingForMCOffset(instructionOffset);
-                  if (iei >= 0) {
-                    int[] inlineEncoding = map.inlineEncoding;
-                    int bci = map.getBytecodeIndexForMCOffset(instructionOffset);
-                    for (; iei >= 0; iei = OptEncodedCallSiteTree.getParent(iei, inlineEncoding)) {
-                      int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
-                      method = MemberReference.getMemberRef(mid).asMethodReference().getResolvedMember();
-                      lineNumber = ((NormalMethod) method).getLineNumberForBCIndex(bci);
-                      showMethod(method, lineNumber, fp);
-                      if (iei > 0) {
-                        bci = OptEncodedCallSiteTree.getByteCodeOffset(iei, inlineEncoding);
-                      }
-                    }
-                    frameShown = true;
-                  }
-                }
-                if (!frameShown) {
-                  showMethod(method, lineNumber, fp);
-                }
-              }
-            }
-            ip = Magic.getReturnAddress(fp);
-            fp = Magic.getCallerFramePointer(fp);
-          }
-          if (!isAddressValidFramePointer(fp)) {
-            VM.sysWrite("Bogus looking frame pointer: ", fp);
-            VM.sysWriteln(" end of stack dump");
-            break;
-          }
-        } // end while
-      } catch (Throwable th) {
-        VM.sysWriteln("Something bad killed the stack dump. The last frame pointer was: ", fp);
-      }
-    }
-    --t.inDumpStack;
-
-    Monitor.unlock(b, dumpLock);
-  }
-
-  /**
-   * Return true if the supplied address could be a valid frame pointer. To
-   * check for validity we make sure the frame pointer is in one of the spaces;
-   * <ul>
-   * <li>LOS (For regular threads)</li>
-   * <li>Immortal (For threads allocated in immortal space such as collectors)</li>
-   * <li>Boot (For the boot thread)</li>
-   * </ul>
-   *
-   * <p>
-   * or it is {@link StackframeLayoutConstants#STACKFRAME_SENTINEL_FP}. The
-   * STACKFRAME_SENTINEL_FP is possible when the thread has been created but has
-   * yet to be scheduled.
-   * </p>
-   *
-   * @param address
-   *          the address.
-   * @return true if the address could be a frame pointer, false otherwise.
-   */
-  private static boolean isAddressValidFramePointer(final Address address) {
-    if (address.EQ(Address.zero()))
-      return false; // Avoid hitting assertion failure in MMTk
-    else
-      return address.EQ(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP) || MemoryManager.mightBeFP(address);
-  }
-
-  private static void showPrologue(Address fp) {
-    VM.sysWrite("   at ");
-    if (SHOW_FP_IN_STACK_DUMP) {
-      VM.sysWrite("[");
-      VM.sysWrite(fp);
-      VM.sysWrite(", ");
-      VM.sysWrite(Magic.getReturnAddress(fp));
-      VM.sysWrite("] ");
-    }
-  }
-
-  /**
-   * Show a method where getCompiledMethod returns null
-   *
-   * @param compiledMethodId
-   * @param fp
-   */
-  private static void showMethod(int compiledMethodId, Address fp) {
-    showPrologue(fp);
-    VM.sysWrite(
-        "<unprintable normal Java frame: CompiledMethods.getCompiledMethod(",
-        compiledMethodId, ") returned null>\n");
-  }
-
-  /**
-   * Show a method that we can't show (ie just a text description of the stack
-   * frame
-   *
-   * @param name
-   * @param fp
-   */
-  private static void showMethod(String name, Address fp) {
-    showPrologue(fp);
-    VM.sysWrite("<");
-    VM.sysWrite(name);
-    VM.sysWrite(">\n");
-  }
-
-  /**
-   * Helper function for {@link #dumpStack(Address,Address)}. Print a stack
-   * frame showing the method.
-   */
-  private static void showMethod(RVMMethod method, int lineNumber, Address fp) {
-    showPrologue(fp);
-    if (method == null) {
-      VM.sysWrite("<unknown method>");
-    } else {
-      VM.sysWrite(method.getDeclaringClass().getDescriptor());
-      VM.sysWrite(" ");
-      VM.sysWrite(method.getName());
-      VM.sysWrite(method.getDescriptor());
-    }
-    if (lineNumber > 0) {
-      VM.sysWrite(" at line ");
-      VM.sysWriteInt(lineNumber);
-    }
-    VM.sysWrite("\n");
-  }
-
-  /**
-   * Dump state of a (stopped) thread's stack and exit the virtual machine.
-   *
-   * @param fp
-   *          address of starting frame Returned: doesn't return. This method is
-   *          called from RunBootImage.C when something goes horrifically wrong
-   *          with exception handling and we want to die with useful
-   *          diagnostics.
-   */
-  @Entrypoint
-  public static void dumpStackAndDie(Address fp) {
-    if (!exitInProgress) {
-      // This is the first time I've been called, attempt to exit "cleanly"
-      exitInProgress = true;
-      dumpStack(fp);
-      VM.sysExit(VM.EXIT_STATUS_DUMP_STACK_AND_DIE);
-    } else {
-      // Another failure occurred while attempting to exit cleanly.
-      // Get out quick and dirty to avoid hanging.
-      sysCall.sysExit(VM.EXIT_STATUS_RECURSIVELY_SHUTTING_DOWN);
-    }
-  }
-
-  /**
-   * Is it safe to start forcing garbage collects for stress testing?
-   */
-  public static boolean safeToForceGCs() {
-    return gcEnabled();
-  }
-
-  /**
-   * Is it safe to start forcing garbage collects for stress testing?
-   */
-  public static boolean gcEnabled() {
-    return threadingInitialized && getCurrentThread().yieldpointsEnabled();
-  }
-
-  /**
-   * Set up the initial thread and processors as part of boot image writing
-   *
-   * @return the boot thread
-   */
-  @Interruptible
-  public static RVMThread setupBootThread() {
-    if (VM.VerifyAssertions) VM._assert(bootThread == null);
-    BootThread bt = new BootThread();
-    bootThread = bt.getRVMThread();
-    bootThread.feedlet = TraceEngine.engine.makeFeedlet(
-        "Jikes RVM boot thread",
-        "Thread used to execute the initial boot sequence of Jikes RVM");
-    numActiveThreads++;
-    numActiveDaemons++;
-    return bootThread;
-  }
-
-  /**
-   * Dump state of virtual machine.
-   */
-  public static void dumpVirtualMachine() {
-    boolean b = Monitor.lockNoHandshake(dumpLock);
-    getCurrentThread().disableYieldpoints();
-    VM.sysWrite("\n-- Threads --\n");
-    for (int i = 0; i < numThreads; ++i) {
-      RVMThread t = threads[i];
-      if (t != null) {
-        t.dumpWithPadding(30);
-        VM.sysWrite("\n");
-      }
-    }
-    VM.sysWrite("\n");
-
-    VM.sysWrite("\n-- Locks in use --\n");
-    Lock.dumpLocks();
-
-    VM.sysWriteln("Dumping stack of active thread\n");
-    dumpStack();
-
-    VM.sysWriteln("Attempting to dump the stack of all other live threads");
-    VM.sysWriteln("This is somewhat risky since if the thread is running we're going to be quite confused");
-    for (int i = 0; i < numThreads; ++i) {
-      RVMThread thr = threads[i];
-      if (thr != null && thr != RVMThread.getCurrentThread() && thr.isAlive()) {
-        thr.dump();
-        // PNT: FIXME: this won't work so well since the context registers
-        // don't tend to have sane values
-        if (thr.contextRegisters != null && !thr.ignoreHandshakesAndGC())
-          dumpStack(thr.contextRegisters.getInnermostFramePointer());
-      }
-    }
-    getCurrentThread().enableYieldpoints();
-    Monitor.unlock(b, dumpLock);
-  }
-
-  public static Feedlet getCurrentFeedlet() {
-    return getCurrentThread().feedlet;
-  }
-
-  ////////////////////////// VM.countThreadTransitions support //////////////////////////
-
-  static final int[] sloppyExecStatusHistogram =
-    new int[LAST_EXEC_STATUS];
-  static final int[] statusAtSTWHistogram =
-    new int[LAST_EXEC_STATUS];
-  static final int[] execStatusTransitionHistogram =
-    new int[LAST_EXEC_STATUS*LAST_EXEC_STATUS];
-
-  public static void reportThreadTransitionCounts() {
-    VM.sysWriteln("Thread Transition Counts:");
-    dump1DHisto("Sloppy Exec Status Histogram",sloppyExecStatusHistogram);
-    dump1DHisto("Status At Stop-the-world Histogram",statusAtSTWHistogram);
-    VM.sysWriteln("  Exec Status Transition Histogram:");
-    for (int fromI=0;fromI<LAST_EXEC_STATUS;++fromI) {
-      for (int toI=0;toI<LAST_EXEC_STATUS;++toI) {
-        int val=
-          execStatusTransitionHistogram[
-            transitionHistogramIndex(fromI,toI)];
-        if (val!=0) {
-          VM.sysWriteln("    ",fromI,"->",toI," ",val);
-        }
-      }
-    }
-  }
-
-  static void dump1DHisto(String name,int[] histo) {
-    VM.sysWriteln("  ",name,":");
-    for (int i=0;i<LAST_EXEC_STATUS;++i) {
-      if (histo[i]!=0) {
-        VM.sysWriteln("    ",i," ",histo[i]);
-      }
-    }
-  }
-
-  void observeExecStatus() {
-    sloppyExecStatusHistogram[execStatus]++;
-  }
-
-  public static void observeExecStatusAtSTW(int execStatus) {
-    statusAtSTWHistogram[execStatus]++;
-  }
-
-  // FIXME: add histograms for states returned from various calls to block()
-  // currently we just do it for the block() call in GC STW.
-
-  static int transitionHistogramIndex(int oldState,int newState) {
-    return oldState+newState*LAST_EXEC_STATUS;
-  }
-
-  static void observeStateTransition(int oldState,int newState) {
-    execStatusTransitionHistogram[transitionHistogramIndex(oldState,newState)]++;
-    sloppyExecStatusHistogram[oldState]++;
-    sloppyExecStatusHistogram[newState]++;
-  }
+	
+	/**
+	 * Replace the execution of the current thread with some stolen work.
+	 */
+	@Interruptible
+	public static void wsSteal(java.lang.Thread victim) {
+		wsSteal(JikesRVMSupport.getThread(victim));
+	}
+
+	@Unpreemptible
+	private void wsCheckShadowStack(int length) {
+		if (wsShadowStack == null || wsShadowStack.length < length) {
+			wsShadowStack = MemoryManager.newStack(length);
+		}
+	}
+
+	/**
+	 * Replace the execution of the current thread with some stolen work.
+	 */
+	@Unpreemptible
+	public static void wsSteal(RVMThread victim) {
+		RVMThread.getCurrentThread().wsStealInternal(victim);
+	}
+
+	@Unpreemptible
+	public static void wsSteal_retbarrier(RVMThread victim) {
+		RVMThread.getCurrentThread().wsStealInternal_retbarrier(victim);
+	}
+	
+	public Address stackTop() {
+		return stackTop(stack);
+	}
+
+	public Address stackTop(byte[] stack) {
+		return Magic.objectAsAddress(stack).plus(stack.length);
+	}
+
+	// debugging support
+	final protected static boolean wsDebugTrace = false;
+	private RVMThread wsDebugMyCurrentVictim = null;
+	private boolean wsDebugRBAlreadyInstalled = false;
+	// debugging support
+	@UnpreemptibleNoWarn
+	public static void dumpWSDetailsWhileDeliveringHardwareException() {
+		RVMThread me = getCurrentThread();
+		if(me.wsDebugMyCurrentVictim != null) {
+			VM.sysWriteln("============================================================================================================");
+			VM.sysWriteln("Trying to dump details of current work-stealing... Though it might be dangerous..");
+			VM.sysWriteln("My victim was thread ",me.wsDebugMyCurrentVictim.getId());
+			VM.sysWriteln("Did I installed a return barrier = ",me.iInstalledABarrier);
+			VM.sysWriteln("Did I found a pre-installed return barrier = ",me.wsDebugRBAlreadyInstalled);
+			if((!me.iInstalledABarrier && !me.wsDebugRBAlreadyInstalled) || !RVMThread.victimCanBeReleasedAfterRBarrierIsInstalled) {
+				VM.sysWriteln("First Trying to dump the original stack of victim");
+				dumpStack(me.wsDebugMyCurrentVictim.getContextRegisters().getInnermostInstructionAddress(), me.wsDebugMyCurrentVictim.getContextRegisters().getInnermostFramePointer());
+			}
+			if(me.iInstalledABarrier || me.wsDebugRBAlreadyInstalled) {
+				VM.sysWriteln("Dumping the hijacked addresses w.r.t return barrier at the victim: ");
+				VM.sysWriteln("Hijacked return address: ", me.wsDebugMyCurrentVictim.hijackedReturnAddress);
+				VM.sysWriteln("Callee fp: ", me.wsDebugMyCurrentVictim.hijackedReturnCalleeFp);
+				VM.sysWriteln("Caller fp: ", me.wsDebugMyCurrentVictim.hijackedReturnCallerFp);
+			}
+			if(me.iInstalledABarrier || me.wsDebugRBAlreadyInstalled) {
+				VM.sysWriteln("Now Trying to dump the cloned stack of victim");
+				dumpStack(me.wsDebugMyCurrentVictim.victimYieldIPOnNewStack, me.wsDebugMyCurrentVictim.victimYieldFpOnNewStack);
+			}
+			if(me.wsFrameCopier.debugStackFrameProcessing) {
+				VM.sysWriteln("Hardware Exception was actually generated inside StackFrameCopier.copyStack(.....)");
+				VM.sysWriteln("The fp being scanned was = ",me.wsFrameCopier.debugScanFp);
+				VM.sysWriteln("The ip being scanned was = ",me.wsFrameCopier.debugScanIp);
+			}
+			VM.sysWriteln("DONE dumping details of current work-stealing....");
+			VM.sysWriteln("============================================================================================================");
+		}
+	}
+	
+	@UnpreemptibleNoWarn
+	@Inline
+	private boolean wsSafeToAttemptSteal() {
+		boolean safe = false;
+		wsLock().lockNoHandshake();
+		safe = !workstealingInProgress;
+		if(safe) {
+			workstealingInProgress = true;
+			if(!RVMThread.thiefCanInitiateStealFromAPreInstalledBarrier) wsReturnBarrierUninstalled = true;
+			if(wsDebugTrace) {
+				VM.sysWriteln(getCurrentThread().getId(),": Grabbed victim W-",getId());
+			}
+			final boolean barrierPreInstalled = thiefCanInitiateStealFromAPreInstalledBarrier && !wsReturnBarrierUninstalled;
+			if(barrierPreInstalled) {
+				/*
+				 * In this case, we can safely decide here if we really need to start
+				 * steal from this barrier. If there are no more continuations left
+				 * in the continuation list, then no need to use this barrier. Mark
+				 * it unusable and start stealing by yielding the victim.
+				 */
+				final boolean startStealFromBarrier = indexInContList < fpsInContList;
+				if(startStealFromBarrier) {
+					wsSafeToReturnFromBarrier = false;
+					if(wsDebugTrace) {
+						getCurrentThread().wsDebugRBAlreadyInstalled = true;
+						VM.sysWriteln(getCurrentThread().getId(),": RBarrier preinstalled on W-",getId());
+					}
+				}
+				else {
+					wsReturnBarrierUninstalled = true;
+					wsSafeToReturnFromBarrier = true;
+					if(wsDebugTrace) {
+						getCurrentThread().wsDebugRBAlreadyInstalled = true;
+						VM.sysWriteln(getCurrentThread().getId(),": RBarrier preinstalled But of no use on W-",getId());
+					}
+				}
+			}
+			fpsInContList = 0;
+			indexInContList = 0;
+		}
+		wsLock().unlock();
+		return safe;
+	}
+	
+	@UnpreemptibleNoWarn
+	@Inline
+	private void wsFinishedStealing(boolean markBarrierUnusable) {
+		wsLock().lockNoHandshake();
+		workstealingInProgress = false;
+		if(markBarrierUnusable) {
+			wsSafeToReturnFromBarrier = true;
+			wsReturnBarrierUninstalled = true;
+			if(wsDebugTrace) {
+				VM.sysWriteln(getCurrentThread().getId(),": Marking the barrier unsuable and uninstalled for W-",getId());
+			}
+		}
+		if(wsWaitingInsideBarrier) {
+			if(wsDebugTrace) {
+				VM.sysWriteln(getCurrentThread().getId(),": Stealing done and broadcasting to come out of barrier to W-",getId());
+			}
+			// unlock victim from wait inside barrier
+			wsLock().broadcast();
+		}
+		else {
+			if(wsDebugTrace) {
+				VM.sysWriteln(getCurrentThread().getId(),": Stealing done but no broadcast to vicitm W-",getId());
+			}
+		}
+		wsLock().unlock();
+	}
+	
+	@UnpreemptibleNoWarn
+	private void wsStealInternal(RVMThread victim) {
+		if (VM.VerifyAssertions) VM._assert(wsStealHead == null);
+		if (VM.VerifyAssertions) VM._assert(this != victim);
+		if (VM.VerifyAssertions) VM._assert(!wsFlag);
+
+		if(!victim.wsSafeToAttemptSteal()) return;
+		
+		final long startStealCPUCycles = Magic.getTimeBase();
+
+		findAttempts++;
+		
+		// Synchronize with victim
+		victim.beginPairHandshake();
+		
+		if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = victim;
+		
+		if (!victim.wsFlag) {
+			// Nothing to steal!
+			if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+			victim.endPairHandshake();
+			victim.wsFinishedStealing(false);
+			totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+			return;
+		}
+
+		// Container for steal/join info.
+		WS.StealInfo steal = new WS.StealInfo();
+		WS.FinishInfo finish = new WS.FinishInfo();
+
+		// Ensure stack size now the victim is stopped, should rarely run.
+		wsCheckShadowStack(victim.stack.length);
+
+		// Copy the context registers from the victim.
+		Address ip, fp;
+		contextRegisters.clear();
+		victim.monitor().lockNoHandshake();
+		if (victim.getExecStatus() == RVMThread.BLOCKED_IN_JNI) {
+			ip = Address.zero();
+			fp = victim.getJNIEnv().topJavaFP();
+		} else {
+			ip = victim.getContextRegisters().getInnermostInstructionAddress();
+			fp = victim.getContextRegisters().getInnermostFramePointer();
+		}
+		victim.monitor().unlock();
+		contextRegisters.setInnermost(ip,fp);
+
+		// Search the victim for potential steals
+		int found = victim.wsFindSteal(contextRegisters, steal, finish);
+		if (found <= 1) victim.wsFlag = false;
+		if (found == 0) {
+			// Nothing to steal!
+			if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+			victim.endPairHandshake();
+			victim.wsFinishedStealing(false);
+			totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+			return;
+		}
+		if(createContinuationDistribution) {
+			victim.continuationsDistribution(found);
+		}
+		// New head of our join info is the victims old head.
+		wsStealHead = steal.prev();
+		wsFinishHead = steal.finish;
+
+		// work out how much 
+		Address newTop = stackTop(wsShadowStack);
+		Address vicTop = victim.stackTop();
+		Offset offset = newTop.diff(vicTop);
+		Address newFP = newTop.minus(steal.fpOffset);
+
+		// fix up the stack and registers while walking the real stack
+		contextRegisters.inuse = true;
+		wsFrameCopier.copyStack(fp, ip, victim, this, contextRegisters, steal.fpOffset,
+				-1, offset, vicTop);
+		adjustRegisters(contextRegisters, offset);
+		if (VM.VerifyAssertions) {
+			Address testFp = newFP;
+			while (testFp.NE(ArchConstants.STACKFRAME_SENTINEL_FP)) {
+				VM._assert(testFp.GE(Magic.objectAsAddress(wsShadowStack)));
+				VM._assert(testFp.LT(stackTop(wsShadowStack)));
+				testFp = Magic.getCallerFramePointer(testFp);
+			}
+		}
+
+		// install new stack
+		byte[] temp = stack;
+		stack = wsShadowStack;
+		wsShadowStack = temp;
+
+		// jump into new stack by throwing an exception
+		VM.disableGC();
+		WS.incFinish(steal.finish);
+
+		int compiledMethodId = Magic.getCompiledMethodID(newFP);
+		CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+		Address catchBlockStart = compiledMethod.getInstructionAddress(true, steal.cbOffset);
+		contextRegisters.setInnermost(catchBlockStart, newFP);
+
+		totalSteals++;
+
+		if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+		victim.endPairHandshake();
+		totalSuccessStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+		victim.wsFinishedStealing(false);
+		stackLimit = Magic.objectAsAddress(stack).plus(STACK_SIZE_GUARD);
+		compiledMethod.getExceptionDeliverer().deliverException(compiledMethod, catchBlockStart, wsContinuation, contextRegisters);
+	}
+	
+	@UnpreemptibleNoWarn
+	private void wsStealInternal_retbarrier(RVMThread victim) {
+		if (VM.VerifyAssertions) VM._assert(wsStealHead == null);
+		if (VM.VerifyAssertions) VM._assert(this != victim);
+		if (VM.VerifyAssertions) VM._assert(!wsFlag);
+
+		if(wsDebugTrace) {
+			VM.sysWriteln(this.getId(),": Stealing from W-",victim.getId());
+		}
+		
+		if(!victim.wsSafeToAttemptSteal()) return;
+		
+		final long startStealCPUCycles = Magic.getTimeBase();
+		findAttempts++;
+		
+		// check if return barrier is already installed
+		// No need to take wsLock(), as we have already told victim not
+		// to unwind from barrier (if any present)
+		final boolean barrierPreInstalled = thiefCanInitiateStealFromAPreInstalledBarrier && !victim.wsReturnBarrierUninstalled;
+		
+		/*
+		 * ensure that the victim is stopped inside @BaselineSaveLSRegisters frame
+		 * so that thief can safely copy its frame and process callee save registers
+		 * offline.
+		 */
+		boolean wsSafeToInstallRBarrierInVictim = true;
+		
+		if(!barrierPreInstalled) {
+			if(RVMThread.wsDebugTrace) {
+				VM.sysWriteln(this.getId(),": Attempting pairing with W-",victim.getId());
+			}
+			
+			wsSafeToInstallRBarrierInVictim = victim.wsBeginPairHandshake();
+			victim.deInstallStackTrampoline();
+			
+			if(RVMThread.wsDebugTrace) {
+				VM.sysWriteln(this.getId(),": Pairing done with W-",victim.getId());
+			}
+		}
+
+		if(RVMThread.wsDebugTrace) {
+			VM.sysWriteln(this.getId(),": Pairing done with W-",victim.getId());
+			wsDebugRBAlreadyInstalled = false;
+			wsDebugMyCurrentVictim = victim;
+		}
+		
+		// Ensure stack size now the victim is stopped, should rarely run.
+		wsCheckShadowStack_retbarrier(victim);
+
+		if (!victim.wsFlag) {
+			if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+			if(wsDebugTrace) {
+				VM.sysWriteln(this.getId(),": wsFlag was false, releasing W-",victim.getId());
+			}
+			// Nothing to steal!
+			if(!barrierPreInstalled) {
+				victim.endPairHandshake();
+				totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+			}
+			// No need to sum time for failed steal in case barrierPreInstalled
+			// because the only time lost by victim is what it waits inside
+			// handshake function inside the barrier. That place has its
+			// own timer hence no need for timing victim loss here.
+			victim.wsFinishedStealing(true);
+			return;
+		}
+
+		if(wsDebugTrace) {
+			VM.sysWriteln(this.getId(),": Start searching continuation in W-",victim.getId());
+		}
+		
+		// Container for steal/join info.
+		WS.StealInfo steal = new WS.StealInfo();
+		WS.FinishInfo finish = new WS.FinishInfo();
+
+		// Copy the context registers from the victim.
+		Address ip, fp;
+		contextRegisters.clear();
+		boolean victimBlockedInJNI = false;
+		if(!barrierPreInstalled) { 
+			victim.monitor().lockNoHandshake();
+			if (victim.getExecStatus() == RVMThread.BLOCKED_IN_JNI) {
+				ip = Address.zero();
+				fp = victim.getJNIEnv().topJavaFP();
+				victimBlockedInJNI = true;
+				if(wsDebugTrace) {
+					VM.sysWriteln(this.getId(),": Found blocked in JNI W-",victim.getId());
+				}
+				
+			} else {
+				ip = victim.getContextRegisters().getInnermostInstructionAddress();
+				fp = victim.getContextRegisters().getInnermostFramePointer();
+			}
+			victim.wsSafeToReturnFromBarrier = false;
+			victim.monitor().unlock();
+		}
+		else {
+			fp = victim.victimYieldFpOnNewStack;
+			ip = victim.victimYieldIPOnNewStack;
+			preInstalledBarriers++;
+		}
+		
+		contextRegisters.setInnermost(ip,fp);
+
+		Address vicTop = barrierPreInstalled ? victim.stackTop(victim.wsGetClonedStack()) : victim.stackTop();
+		// Search the victim for potential steals
+		int found = (victimBlockedInJNI || !wsSafeToInstallRBarrierInVictim) ? victim.wsFindSteal(contextRegisters, steal, finish) : victim.wsFindSteal_retBarrier(steal, finish, vicTop, barrierPreInstalled, startStealCPUCycles);
+				
+		if(wsDebugTrace) {
+			VM.sysWriteln(victim.getId(),": Total available continuations = ",found);
+		}
+		
+		if (found <= 1 && !barrierPreInstalled) {
+			/*
+			 * If we started the steal from a return barrier and we discover
+			 * that found <=1 then it does not mean wsFlag=false for this victim.
+			 * There may be continuations available above the barrier, which can
+			 * be stolen by yielding the victim.
+			 */
+			victim.wsFlag = false;
+		}
+		if (found == 0) {
+			if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+			//Nothing to steal means there was no return barrier installed
+			if(wsDebugTrace) {
+				VM.sysWriteln(this.getId(),": Nothing to steal, releasing W-",victim.getId());
+			}
+			if(!barrierPreInstalled) {
+				victim.wsSafeToReturnFromBarrier = true;
+				victim.endPairHandshake();
+				totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+			}
+			// No need to sum time for failed steal in case barrierPreInstalled
+			// because the only time lost by victim is what it waits inside
+			// handshake function inside the barrier. That place has its
+			// own timer hence no need for timing victim loss here.
+			
+			victim.wsFinishedStealing(true);
+			return;
+		}
+		if(createContinuationDistribution) {
+			victim.continuationsDistribution(found);
+		}
+		
+		// update variables if I installed a barrier
+		if(iInstalledABarrier) {
+			vicTop =  victim.stackTop(victim.wsGetClonedStack());
+			fp = victim.victimYieldFpOnNewStack;
+			ip = victim.victimYieldIPOnNewStack;
+		}
+
+		// New head of our join info is the victims old head.
+		wsStealHead = steal.prev();
+		wsFinishHead = steal.finish;
+
+		// work out how much 
+		Address newTop = stackTop(wsShadowStack);
+		Offset offset = newTop.diff(vicTop);
+		Address newFP = newTop.minus(steal.fpOffset);
+
+		// fix up the stack and registers while walking the real stack
+		contextRegisters.inuse = true;
+
+		if(wsDebugTrace) {
+			VM.sysWriteln(this.getId(),": Start processing frames from W-",victim.getId());
+		}
+		
+		wsFrameCopier.copyStack(fp, ip, victim, this, contextRegisters, steal.fpOffset, 
+				-1, offset, vicTop);
+		
+		if(wsDebugTrace) {
+			VM.sysWriteln(this.getId(),": Done processing stolen frames from W-",victim.getId());
+		}
+		
+		WS.incFinish(steal.finish);
+
+		final boolean canReleaseNow = (iInstalledABarrier || barrierPreInstalled) && RVMThread.victimCanBeReleasedAfterRBarrierIsInstalled;
+
+		if(canReleaseNow) {
+			final boolean isBarrierUnusable = (found == 1) && (iInstalledABarrier||barrierPreInstalled);
+			victim.wsFinishedStealing(isBarrierUnusable);
+			if(wsDebugTrace) {
+				VM.sysWriteln(this.getId(),": Releasing from barrier by marking workstealing done for W-",victim.getId());
+			}
+			iInstalledABarrier = false;
+		}
+		
+		adjustRegisters(contextRegisters, offset);
+		
+		if (VM.VerifyAssertions) {
+			Address testFp = newFP;
+			while (testFp.NE(ArchConstants.STACKFRAME_SENTINEL_FP)) {
+				VM._assert(testFp.GE(Magic.objectAsAddress(wsShadowStack)));
+				VM._assert(testFp.LT(stackTop(wsShadowStack)));
+				testFp = Magic.getCallerFramePointer(testFp);
+			}
+		}
+
+		// install new stack
+		byte[] temp = stack;
+		stack = wsShadowStack;
+		wsShadowStack = temp;
+
+		// jump into new stack by throwing an exception
+		VM.disableGC();
+
+		if(wsDebugTrace) {
+			wsDebugMyCurrentVictim = null;
+			VM.sysWriteln(this.getId(),": Stealing Done from W-",victim.getId());
+		}
+		
+		int compiledMethodId = Magic.getCompiledMethodID(newFP);
+		CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+		Address catchBlockStart = compiledMethod.getInstructionAddress(true, steal.cbOffset);
+		
+		totalSteals++;
+
+		if(!canReleaseNow) {
+			victim.endPairHandshake();
+			totalSuccessStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles); 
+			victim.wsFinishedStealing(false);
+		}
+
+		if(wsDebugTrace) {
+			VM.sysWriteln(this.getId(),": Throwing exception to start continuation");
+		}
+		
+		contextRegisters.setInnermost(catchBlockStart, newFP);	//return barrier
+		stackLimit = Magic.objectAsAddress(stack).plus(STACK_SIZE_GUARD);
+		compiledMethod.getExceptionDeliverer().deliverException(compiledMethod, catchBlockStart, wsContinuation, contextRegisters);
+	}
+
+	/**
+	 * Implement join functionality. This is always run by the victim, and there are basically two paths here.
+	 * 
+	 * 1) The victim stops and decrements the finish.
+	 * 2) Control is returned to the victim to push some result into the finish state (after which it calls completeJoin). 
+	 */
+	@Inline
+	@Unpreemptible
+	public void wsJoinInternal(Address fp, Address ip) {
+		// Medium-path check for unnecessary join call.
+		Offset fpOffset = stackTop().diff(fp);
+		if (wsStealHead == null || !wsStealHead.matches(fpOffset)) {
+			return;
+		}
+
+		int compiledMethodId = Magic.getCompiledMethodID(fp);
+		CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+		Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+		Offset cbOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, RVMType.WSContinuationType, true);
+		if (!wsStealHead.matches(fpOffset, cbOffset)) {
+			// Another check just to make sure we are doing the right thing
+			return;
+		}
+
+		cbOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, RVMType.WSJoinType, true);
+		if (cbOffset.sGE(Offset.zero())) {
+			// This join wants to return data to the finish.
+			wsInJoin = true;
+			wsJoin.finish = wsStealHead.finish;
+			RuntimeEntrypoints.athrow(wsJoin);
+		}
+		wsCompleteJoinInternal();
+	}
+
+	@NoInline
+	@UnpreemptibleNoWarn
+	public void wsCompleteFinishInternal() {
+		ObjectModel.genericUnlock_internal(wsFinishHead);
+		wsInJoin = false;
+		wsFlag = false;
+		wsStealHead = null;
+		wsFinishHead = null;
+		wsSpecialNVMap = 0;
+		if(RVMThread.wsRetBarrier) {
+			resetTramoplineInfo_unlocked();
+			WS.searchForWork_retbarrier();
+		}
+		else {
+			WS.searchForWork();
+		}
+	}
+
+	@NoInline
+	@UnpreemptibleNoWarn
+	public void wsCompleteJoinInternal() {
+		WS.StealInfo steal = wsStealHead;
+		if (WS.decFinish(steal.finish)) {
+			// We are going to run the finish...
+			VM.disableGC();
+			Magic.saveThreadState(contextRegisters);
+			Address fp = contextRegisters.getInnermostFramePointer();
+			Address top = stackTop();
+			// Search for the right frame.
+
+			while (top.diff(fp).NE(wsFinishHead.fpOffset)) {
+				if (VM.VerifyAssertions) VM._assert(fp.NE(STACKFRAME_SENTINEL_FP));
+				int compiledMethodId = Magic.getCompiledMethodID(fp);
+				if (compiledMethodId == INVISIBLE_METHOD_ID) {
+					contextRegisters.unwindStackFrame();
+				} else {
+					CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+					ExceptionDeliverer exceptionDeliverer = compiledMethod.getExceptionDeliverer();
+					exceptionDeliverer.unwindStackFrame(compiledMethod, contextRegisters);
+				}
+				fp = contextRegisters.getInnermostFramePointer();
+			}
+
+			int compiledMethodId = Magic.getCompiledMethodID(fp);
+			CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+			Address catchBlockStart = compiledMethod.getInstructionAddress(true, wsFinishHead.cbOffset);
+			contextRegisters.setInnermost(catchBlockStart, fp);
+			contextRegisters.inuse = true;
+			stackLimit = Magic.objectAsAddress(stack).plus(STACK_SIZE_GUARD);
+			wsFinish.data = wsFinishHead;
+			wsInJoin = false;
+			wsSpecialNVMap = 0;
+			wsStealHead = wsFinishHead.steal;
+			wsFinishHead = wsFinishHead.prev();
+			compiledMethod.getExceptionDeliverer().deliverException(compiledMethod, catchBlockStart, wsFinish, contextRegisters);
+			// Not reached
+		}
+		wsInJoin = false;
+		wsFlag = false;
+		wsStealHead = null;
+		wsFinishHead = null;
+		wsSpecialNVMap = 0;
+		if(wsRetBarrier) {
+			resetTramoplineInfo_unlocked();
+			WS.searchForWork_retbarrier();
+		}
+		else {
+			WS.searchForWork();
+		}
+	}
+
+	@UnpreemptibleNoWarn
+	@Inline
+	public Address getAddressValueOnClonedStack(final Address fp) {
+		if(fp.isZero()) return fp;
+		else return stackTop(wsVictimShadowStack).minus(stackTop().diff(fp));
+	}
+	
+	@UnpreemptibleNoWarn
+	@Inline
+	private Address getAddressValueOnMainStack(final Address fp) {
+		return stackTop().minus(stackTop(wsVictimShadowStack).diff(fp));
+	}
+	
+	/**
+	 * Search through a potential victim's stack, and find:
+	 *
+	 *   1) The oldest continuation that can be stolen
+	 *   2) The enclosing finish for this continuation.
+	 * 
+	 * The passed JoinInfo and FinishInfo classes are populated
+	 * accordingly if a steal is found.
+	 *
+	 * @param top
+	 * @param registers
+	 * @param info
+	 * @return
+	 */
+	@UnpreemptibleNoWarn
+	@Inline
+	private int wsFindSteal(Registers registers, WS.StealInfo steal, WS.FinishInfo finish) {
+		int found = 0;
+		boolean skip = wsInJoin;
+		Address fp = registers.getInnermostFramePointer();
+		Address top = stackTop();
+		Offset stealCBOffset = Offset.zero();
+		Offset stealFPOffset = Offset.zero();
+		Offset finishCBOffset = Offset.zero();
+		Offset finishFPOffset = Offset.zero();
+		Address prevFp = Address.zero();
+		Address stealPrevFp = Address.zero();
+		Address finishPrevFp = Address.zero();
+
+		boolean foundStolen = false;
+		boolean foundFinish = true;
+		while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+			Offset fpOffset = top.diff(fp);
+			int compiledMethodId = Magic.getCompiledMethodID(fp);
+			if (compiledMethodId != INVISIBLE_METHOD_ID) {
+				CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+				if (compiledMethod.getCompilerType() == CompiledMethod.OPT || compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
+					// Process each normal stack frame.
+					// First we search for the oldest unstolen continuation. Once we hit an already stolen continuation or reach the end we are done.
+					// We also need to know the enclosing finish block.
+					// We need to try and find the outermost finish block for each method to make sure. 
+
+					Address ip = registers.getInnermostInstructionAddress();
+					Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+
+					Offset currentIPOffset = ipOffset;
+					Offset finishIPOffset = ipOffset;
+
+					// Search for a continuation to steal.
+					if (!foundStolen) {
+						while (true) {
+							Offset catchBlock = compiledMethod.findCatchBlockForInstruction(currentIPOffset, RVMType.WSContinuationType, true);
+							if (catchBlock.sLT(Offset.zero())) break;
+							if (wsStealHead != null && wsStealHead.find(fpOffset, catchBlock) != null) {
+								// This continuation has already been stolen, so we discard the current state. 
+								foundStolen = true;
+								break;
+							}
+							// This continuation has not been stolen, so we update info to reflect it.
+							if (!skip) {
+								finishIPOffset = currentIPOffset;
+								stealCBOffset = catchBlock;
+								stealFPOffset = fpOffset;
+								stealPrevFp = prevFp;
+								found++;
+								foundFinish = false;
+							}
+							skip = false;
+							// Advance into the catch block
+							currentIPOffset = catchBlock.plus(1);
+						}
+					}
+
+					// Search for an enclosing finish.
+					if (!foundFinish) {
+						Offset catchBlock = compiledMethod.findCatchBlockForInstruction(finishIPOffset, RVMType.WSFinishType, true);
+						if (catchBlock.sGE(Offset.zero())) {
+							// We found a finish block.
+							finishCBOffset = catchBlock;
+							finishFPOffset = fpOffset;
+							finishPrevFp = prevFp;
+							foundFinish = true;
+							if (foundStolen) {
+								// We know the continuation we are stealing, and we have found the first finish.
+								break;
+							}
+						}
+					}
+				}
+			}
+			registers.unwindStackFrame();
+			prevFp = fp;
+			fp = registers.getInnermostFramePointer();
+		}
+		if (found > 0) {
+			// Find the finish object to use.
+			if (foundFinish) {
+				// Look for an existing finish.
+				if (wsFinishHead != null) {
+					steal.finish = wsFinishHead.find(finishFPOffset, finishCBOffset);
+				}
+				if (steal.finish == null) {
+					// We are the first to use this finish.
+					finish.set(finishFPOffset, finishCBOffset);
+					finish.setPrev(wsFinishHead);
+					steal.finish = finish;
+					wsFinishHead = finish;
+
+					WS.installJoinInstructions(top.minus(finishFPOffset), finishPrevFp);
+				}
+			} else {
+				// We must be delivering back to a parent finish.
+				steal.finish = wsFinishHead;
+			}
+			WS.installJoinInstructions(top.minus(stealFPOffset), stealPrevFp);
+			steal.set(stealFPOffset, stealCBOffset);
+			steal.setPrev(wsStealHead);
+			wsStealHead = steal;
+			if (VM.VerifyAssertions) VM._assert(steal.finish != null);
+		}
+		return found;
+	}
+	
+	@UnpreemptibleNoWarn
+	@Inline
+	private void saveContinuation(final Address fp, final boolean mainStack) {
+		if(fpsInContList == RVMThread.ARRAY_OF_CONTINUATIONS_MAXSIZE) {
+			// reset index
+			fpsInContList = RVMThread.ON_OVERFLOW_RESTART_INDEX_IN_ARRAY_OF_CONTINUATIONS;
+		}
+		final Address fpStore = mainStack ? getAddressValueOnMainStack(fp) : fp;
+		array_of_continuations.set(fpsInContList++, fpStore);
+	}
+	
+	@UnpreemptibleNoWarn
+	@Inline
+	private int wsFindSteal_retBarrier(WS.StealInfo steal, WS.FinishInfo finish, Address top, boolean initiateStealFromBarrier, long startStealCPUCycles) {
+		Address fp = initiateStealFromBarrier ? getAddressValueOnClonedStack(hijackedReturnCallerFp) : this.contextRegisters.getInnermostFramePointer();
+		Address ip = initiateStealFromBarrier ? hijackedReturnAddress : this.contextRegisters.getInnermostInstructionAddress();
+		
+		int found = 0;
+		boolean skip = wsInJoin;
+		Offset stealCBOffset = Offset.zero();
+		Offset stealFPOffset = Offset.zero();
+		Offset finishCBOffset = Offset.zero();
+		Offset finishFPOffset = Offset.zero();
+		
+		Address stealPrevFp = initiateStealFromBarrier ? getAddressValueOnClonedStack(hijackedReturnCalleeFp) : Address.zero();
+		
+		Address finishPrevFp = stealPrevFp;
+		Address prevFp = stealPrevFp;
+
+		boolean foundStolen = false;
+		boolean foundFinish = true;
+		
+		Address prevJavaFrameFp = Address.zero();
+		boolean firstContinuationFound = false;
+		boolean barrierInstalled = false;
+		
+		while (Magic.getCallerFramePointer(fp).NE(STACKFRAME_SENTINEL_FP)) {
+			final Offset fpOffset = top.diff(fp);
+			final int compiledMethodId = Magic.getCompiledMethodID(fp);
+			if (compiledMethodId != INVISIBLE_METHOD_ID) {
+				final CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+				if (compiledMethod.getCompilerType() == CompiledMethod.OPT || compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
+					// Process each normal stack frame.
+					// First we search for the oldest unstolen continuation. Once we hit an already stolen continuation or reach the end we are done.
+					// We also need to know the enclosing finish block.
+					// We need to try and find the outermost finish block for each method to make sure. 
+					final Offset ipOffset = compiledMethod.getInstructionOffset(ip);	// it has debug info
+
+					Offset currentIPOffset = ipOffset;
+					Offset finishIPOffset = ipOffset;
+					// Search for a continuation to steal.
+					if (!foundStolen) {
+						while (true) {
+							final Offset catchBlock = compiledMethod.findCatchBlockForInstruction(currentIPOffset, RVMType.WSContinuationType, true);
+							if (catchBlock.sLT(Offset.zero())) break;
+							if (wsStealHead != null && wsStealHead.find(fpOffset, catchBlock) != null) {
+								// This continuation has already been stolen, so we discard the current state. 
+								foundStolen = true;
+								break;
+							}
+							// This continuation has not been stolen, so we update info to reflect it.
+							if (!skip) {
+								if(initiateStealFromBarrier) {
+									if(!prevJavaFrameFp.isZero()) {
+										saveContinuation(prevJavaFrameFp, true);
+									}
+								}
+								else {
+									if(!prevJavaFrameFp.isZero() && firstContinuationFound) {
+										saveContinuation(prevJavaFrameFp, false);
+									}
+									//install return barrier for the callee of the newest continuation on victim stack
+									else if(!prevJavaFrameFp.isZero() && !firstContinuationFound) {
+										firstContinuationFound = true;
+									}
+								}
+								finishIPOffset = currentIPOffset;
+								stealCBOffset = catchBlock;
+								stealFPOffset = fpOffset;
+								stealPrevFp = prevFp;
+								found++;
+								foundFinish = false;
+							}
+							skip = false;
+							// Advance into the catch block
+							currentIPOffset = catchBlock.plus(1);
+						}
+					}
+
+					// Search for an enclosing finish.
+					if (!foundFinish) {
+						Offset catchBlock = compiledMethod.findCatchBlockForInstruction(finishIPOffset, RVMType.WSFinishType, true);
+						if (catchBlock.sGE(Offset.zero())) {
+							// We found a finish block.
+							finishCBOffset = catchBlock;
+							finishFPOffset = fpOffset;
+							finishPrevFp = prevFp;
+							foundFinish = true;
+						}
+					}
+					if(!initiateStealFromBarrier && firstContinuationFound && !barrierInstalled) {
+						final RVMThread me = getCurrentThread();
+						me.iInstalledABarrier = true;
+						barrierInstalled = true;
+						wsReturnBarrierUninstalled = false;
+						if(wsDebugTrace) {
+							VM.sysWriteln(getCurrentThread().getId(),": Cloning stack of W-",getId());
+						}
+						victimYieldFpOnNewStack = wsCloneVictimStack(this, this.contextRegisters.getInnermostFramePointer());
+						//keep a copy of the gprs obtained by stackwalk of only the topmost frame of this yielded victim
+						if(wsDebugTrace) {
+							VM.sysWriteln(getCurrentThread().getId(),": Going to install return barrier in W-",getId());
+						}
+						wsInstallStackTrampolineBridge(prevJavaFrameFp);
+						thiefInstalledBarriers++;
+						if(wsDebugTrace) {
+							VM.sysWriteln(getCurrentThread().getId(),": Installed rbarrier in W-",getId());
+						}
+						if(RVMThread.victimCanBeReleasedAfterRBarrierIsInstalled) {
+							endPairHandshake();
+						}
+						me.totalSuccessStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+					}
+					prevJavaFrameFp = fp;
+					if(foundStolen && foundFinish) break;
+				}
+				else {
+					prevJavaFrameFp = Address.zero();
+				}
+			}
+			ip = RVMThread.getReturnAddress(fp);
+			prevFp = fp;
+			fp = Magic.getCallerFramePointer(prevFp);
+		}
+
+		if (found > 0) {
+			// Notify the victim to awake if its waiting inside return barrier
+			if(initiateStealFromBarrier || barrierInstalled) {
+				if(wsDebugTrace) {
+					VM.sysWriteln(getCurrentThread().getId(),": Send broadcast to release from barrier to W-",getId());
+				}
+				wsUnlockFromReturnBarrier();
+			}
+			
+			// Find the finish object to use.
+			if (foundFinish) {
+				// Look for an existing finish.
+				if (wsFinishHead != null) {
+					steal.finish = wsFinishHead.find(finishFPOffset, finishCBOffset);
+				}
+				if (steal.finish == null) {
+					// We are the first to use this finish.
+					finish.set(finishFPOffset, finishCBOffset);
+					finish.setPrev(wsFinishHead);
+					steal.finish = finish;
+					wsFinishHead = finish;
+					if (VM.VerifyAssertions) VM._assert(finishPrevFp.GE(stealPrevFp));	//return barrier
+					if(!initiateStealFromBarrier) WS.installJoinInstructions(top.minus(finishFPOffset), finishPrevFp, this);
+					else WS.installJoinInstructions(stackTop().minus(finishFPOffset), getAddressValueOnMainStack(finishPrevFp), this);
+				}
+			} else {
+				// We must be delivering back to a parent finish.
+				steal.finish = wsFinishHead;
+			}
+			
+			if(!initiateStealFromBarrier) {
+				WS.installJoinInstructions(top.minus(stealFPOffset), stealPrevFp, this);
+				// install join instruction in the coloned stack as well
+				final Address retAddress = stealPrevFp.EQ(hijackedReturnCalleeFp) ? hijackedReturnAddress : RVMThread.getReturnAddress(stealPrevFp);
+				Magic.setReturnAddress(getAddressValueOnClonedStack(stealPrevFp), retAddress);
+				steal.set(stealFPOffset, stealCBOffset, stealPrevFp);
+			}
+			else {
+				final Address stealPrevFpOnMainStack = getAddressValueOnMainStack(stealPrevFp);
+				WS.installJoinInstructions(stackTop().minus(stealFPOffset), stealPrevFpOnMainStack, this);
+				final Address retAddress = stealPrevFpOnMainStack.EQ(hijackedReturnCalleeFp) ? hijackedReturnAddress : RVMThread.getReturnAddress(stealPrevFpOnMainStack);
+				Magic.setReturnAddress(stealPrevFp, retAddress);
+				steal.set(stealFPOffset, stealCBOffset, stealPrevFpOnMainStack);
+			}
+			
+			steal.setPrev(wsStealHead);
+			wsStealHead = steal;
+			if (VM.VerifyAssertions) VM._assert(steal.finish != null);
+		}
+
+		return found;
+	}
 }
diff -r ab5908222258 tools/bootImageRunner/cmdLine.h
--- a/tools/bootImageRunner/cmdLine.h	Fri Mar 21 09:33:02 2014 +0530
+++ b/tools/bootImageRunner/cmdLine.h	Fri Mar 21 09:37:25 2014 +0530
@@ -38,7 +38,7 @@
 static const int VMCLASSES_INDEX               = OPT_INDEX+1;
 static const int PROCESSORS_INDEX              = VMCLASSES_INDEX+1;
 
-static const int numNonstandardArgs      = PROCESSORS_INDEX+1;
+static const int numNonstandardArgs      = PROCESSORS_INDEX+11;
 
 static const char* nonStandardArgs[numNonstandardArgs] = {
    "-X",
@@ -59,6 +59,16 @@
    "-X:opt",
    "-X:vmClasses=",
    "-X:availableProcessors=",
+   "-Xws:pinAuto=",
+   "-Xws:pinMap=",
+   "-Xws:pinLog=",
+   "-Xws:pinSocketCPU=",
+   "-Xws:pinMapSys=",
+   "-Xws:perfEvent=",
+   "-Xws:pinMapGC=",
+   "-Xws:retBarrier=",
+   "-Xws:procs=",
+   "-Xws:stats=",
 };
 
 // a NULL-terminated list.
@@ -93,6 +103,29 @@
    "  -Xbootclasspath/a:<cp>     (a)ppend specified classpath to bootclasspath",
    "  -X:availableProcessors=<n> desired level of application parallelism (set",
    "                             -X:gc:threads to control gc parallelism)",
+   "#====================================================================================",
+   "#============== WORK-STEALING SPECIFIC OPTIONS ======================================",
+   "#====================================================================================",
+   "#1. THREAD PINNING SPECIFIC......",
+   "  -Xws:pinAuto=<true/false>  Pin work-stealing threads to core id",
+   "  -Xws:pinMap=<0:2:4:6...>   Provide cpu map to pin the worker-stealing threads",
+   "  -Xws:pinLog=<true/false>   Print cpu id on which each work-stealing threads are running",
+   "				 (printing is done at the launch and end of application)",
+   "  -Xws:pinSocketCPU=<1:8>    Provide number of sockets and number of cpus available",
+   "				 (format is num_sockets:num_cpus_per_socket)",
+   "  -Xws:pinMapSys=<0:2...>    Provide set of cpus where system threads should run",
+   "                             This also includes GC threads if they are not pinned separately",
+   "  -Xws:pinMapGC=<0:1...>     Provide set of cpus where GC threads should run",
+   "                             map should be for each and every GC threads",
+   "#2. LINUX PERF EVENTS COUNTERS...",
+   "  -Xws:perfEvent=<true>      True if want to measure per thread performance counter events", 
+   "#3. NORMAL USAGE...",
+   "  -Xws:retBarrier=<true>     Use return barrier to reduce the steal time",
+   "                             default option is false",
+   "  -Xws:procs=<number>        Total work-stealing worker threads",
+   "  -Xws:stats=<true>     	 Display work-stealing statistics. Useful in a large project",
+   "				 where you dont know where exactly main method is being called.",
+   "                             The default option is false",
    NULL                         /* End of messages */
 };
 
diff -r ab5908222258 tools/bootImageRunner/sys.C
--- a/tools/bootImageRunner/sys.C	Fri Mar 21 09:33:02 2014 +0530
+++ b/tools/bootImageRunner/sys.C	Fri Mar 21 09:37:25 2014 +0530
@@ -47,6 +47,10 @@
 #include <utime.h>
 #include <setjmp.h>
 
+#ifndef RVM_FOR_MACOS
+#include <linux/unistd.h>
+#endif
+
 #ifdef RVM_WITH_PERFEVENT
 #include <perfmon/pfmlib_perf_event.h>
 #include <err.h>
@@ -62,6 +66,7 @@
 #include <asm/ioctls.h>
 #endif
 
+//#define _GNU_SOURCE         /* See feature_test_macros(7) */
 # include <sched.h>
 
 /* OSX/Darwin */
@@ -110,6 +115,11 @@
 #include "InterfaceDeclarations.h"
 #include "bootImageRunner.h"    // In tools/bootImageRunner.
 
+#ifdef RVM_WITH_LIBNUMA
+#include <numa.h>
+#include <numaif.h>
+#endif
+
 #ifdef RVM_FOR_HARMONY
 #ifdef RVM_FOR_LINUX
 #define LINUX
@@ -542,6 +552,110 @@
 #endif
 } // extern "C"
 
+/*
+ * Per thread performance counter support using the linux perf event system.
+ */
+extern "C" {
+#ifndef RVM_WITH_PERFEVENT
+void sysPerfEventInit_thread(int events) {}
+void sysPerfEventCreate_thread(int id, const char *eventName) {}
+void sysPerfEventOpen_thread(int id, void*tid, int *fds) {}
+void sysPerfEventClose_thread(int id, int *fds) {}
+void sysPerfEventEnable_thread(int *fds, int numEvents) {}
+void sysPerfEventDisable_thread(int *fds, int numEvents) {}
+void sysPerfEventRead_thread(int id, int *fds, uint64_t *values) {}
+#else
+static int perfVerbose = 0;
+static struct perf_event_attr *perf_event_attrs_thread;
+extern "C" Word sysGetThreadId();
+
+void sysPerfEventInit_thread(int numEvents)
+{
+  int ret = pfm_initialize();
+  if (ret != PFM_SUCCESS) {
+    errx(1, "error in pfm_initialize: %s", pfm_strerror(ret));
+  }
+
+  perf_event_attrs_thread = (struct perf_event_attr *)calloc(numEvents, sizeof(struct perf_event_attr));
+  if (!perf_event_attrs_thread) {
+    errx(1, "error allocating perf_event_attrs_thread");
+  }
+  for(int i=0; i < numEvents; i++) {
+    perf_event_attrs_thread[i].size = sizeof(struct perf_event_attr);
+  }
+ // enabled = 1;
+}
+
+void sysPerfEventCreate_thread(int id, const char *eventName)
+{
+  struct perf_event_attr *pe = (perf_event_attrs_thread + id);
+  int ret = pfm_get_perf_event_encoding(eventName, PFM_PLM3, pe, NULL, NULL);
+  if (ret != PFM_SUCCESS) {
+    errx(1, "error creating event %d '%s': %s\n", id, eventName, pfm_strerror(ret));
+  }
+  pe->read_format = PERF_FORMAT_TOTAL_TIME_ENABLED | PERF_FORMAT_TOTAL_TIME_RUNNING;
+  pe->disabled = 1;
+  pe->inherit = 0;
+}
+
+void sysPerfEventClose_thread(int id, int *fds) {
+  close(fds[id]);
+}
+
+void sysPerfEventOpen_thread(int id, void* tid, int *fds) {
+  struct perf_event_attr *pe = (perf_event_attrs_thread + id);
+  fds[id] = perf_event_open(pe, 0, -1, -1, 0);
+  if (fds[id] == -1) {
+    err(1, "error in perf_event_open for event %d", id);
+  }
+  if(perfVerbose)
+    printf("Create Counter %d at fd %d for thread %d\n", id, fds[id],sysGetThreadId());
+}
+
+void sysPerfEventEnable_thread(int *fds, int numEvents)
+{
+	int i;
+	for(i=0; i< numEvents; i++) {
+		if (ioctl(fds[i], PERF_EVENT_IOC_ENABLE, 0)) {
+			err(1, "error enabling perf event");
+		}
+	}
+}
+
+void sysPerfEventDisable_thread(int *fds, int numEvents)
+{
+	int i;
+	for(i=0; i< numEvents; i++) {
+		if (ioctl(fds[i], PERF_EVENT_IOC_DISABLE, 0)) {
+			err(1, "error disabling perf event");
+		}
+	}
+}
+
+void sysPerfEventRead_thread(int id, int *fds, uint64_t *values)
+{
+  if (fds[id] < 0) {
+	  printf("ERROR: reading event %d\n",id);
+	  return;
+  }
+  memset(values, 0, sizeof(uint64_t) * 3);
+  size_t expectedBytes = 3 * sizeof(uint64_t);
+  int ret = read(fds[id], values, expectedBytes);
+  if (ret < 0) {
+    err(1, "error reading event: %s", strerror(errno));
+  }
+  if (ret != expectedBytes) {
+    errx(1, "read of perf event did not return 3 64-bit values");
+  }
+  if(perfVerbose)
+    printf("Counter %d at fd %d: value %lld\n",sysGetThreadId(),fds[id], values[0]);
+  close(fds[id]);
+  fds[id] = -1;
+}
+#endif
+} // extern "C"
+
+
 //------------------------//
 // Filesystem operations. //
 //------------------------//
@@ -1052,6 +1166,82 @@
 #endif
 }
 
+/*
+ * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+ * From here---->
+ */
+
+extern "C" {
+#ifndef RVM_WITH_LIBNUMA
+int sysCheckNUMAnode(void* memory) { return -1;}
+#else
+int sysCheckNUMAnode(void* memory) {
+  int status[1];
+  int ret_code;
+  status[0]=-1;
+  ret_code=move_pages(0 /*self memory */, 1, &memory, NULL, status, 0);
+  if(ret_code != 0) {
+    fprintf(stderr,"sysCheckNUMAnode failed (errno=%d)\n",ret_code);
+    exit(1);
+  }
+  return status[0];
+}
+#endif
+}
+
+#ifndef RVM_FOR_MACOS
+static cpu_set_t ws_sysThread_cpuset;
+#endif
+
+extern "C" void
+wsIniatilizeSysThreadBindMask(int cpuMask) {
+#ifndef RVM_FOR_MACOS
+	static int first = 0;
+	if(first == 0) {
+		CPU_ZERO(&ws_sysThread_cpuset);
+		first = 1;
+	}
+	CPU_SET( cpuMask, &ws_sysThread_cpuset );
+#endif
+}
+
+extern "C" void
+wsThreadBindMaskSet( int cpuMask ) {
+#ifndef RVM_FOR_HARMONY || RVM_FOR_MACOS
+#ifdef RVM_FOR_LINUX
+	cpu_set_t cpuset;
+	CPU_ZERO(&cpuset);
+	CPU_SET( cpuMask, &cpuset );
+	pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);
+#endif
+#endif
+}
+
+extern "C" void
+sysThreadBindMaskSet() {
+#ifndef RVM_FOR_HARMONY 
+#ifdef RVM_FOR_LINUX
+#ifndef RVM_FOR_MACOS
+	pthread_setaffinity_np(pthread_self(), sizeof(ws_sysThread_cpuset), &ws_sysThread_cpuset);
+#endif
+#endif
+#endif
+}
+
+extern "C" int
+sysGetCPU( ) {
+#ifndef RVM_FOR_HARMONY || RVM_FOR_MACOS
+#ifdef RVM_FOR_LINUX
+	return sched_getcpu();
+#endif
+#endif
+}
+
+/*
+ * Till Here <----
+ * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+ */
+
 /** jump buffer for primordial thread */
 jmp_buf primordial_jb;
 
@@ -1137,7 +1327,11 @@
 extern "C" Word
 sysGetThreadId()
 {
-    return (Word)getThreadId();
+#ifndef RVM_FOR_MACOS
+	return (Word)(pid_t)syscall(__NR_gettid);
+#else
+	return NULL;
+#endif
 }
 
 extern "C" void*
@@ -1785,6 +1979,9 @@
         int protection , int flags ,
         int fd , Offset offset)
 {
+  #ifdef RVM_WITH_LIBNUMA
+  numa_set_localalloc();
+  #endif
   void* res = mmap(start, (size_t)(length), protection, flags, fd, (off_t)offset);
   if (res == (void *) -1){
 #if RVM_FOR_32_ADDR
