From 798b939183145f4107800ec966ff559235b8971b Mon Sep 17 00:00:00 2001
From: Vivek Kumar <vivekk@iiitd.ac.in>
Date: Sat, 2 Mar 2019 10:09:43 +0530
Subject: [PATCH 1/1] support for featherlight code generation

Signed-off-by: Vivek Kumar <vivekk@iiitd.ac.in>
---
 src/Closeable.jrag | 74 +++++++++++++++++++++++++++++++++++++++++
 src/Steal.ast      |  3 ++
 src/Steal.flex     |  4 ++-
 src/Steal.jrag     | 98 +++++++++++++++++++++++++++++++++++++++++++++++++++---
 src/Steal.parser   | 10 ++++++
 5 files changed, 183 insertions(+), 6 deletions(-)
 create mode 100644 src/Closeable.jrag

diff --git a/src/Closeable.jrag b/src/Closeable.jrag
new file mode 100644
index 0000000..306bb58
--- /dev/null
+++ b/src/Closeable.jrag
@@ -0,0 +1,74 @@
+/*
+ *
+ * Vivek Kumar, (vk.aries@gmail.com)
+ * http://vivkumar.github.io/
+ * December 2018
+ *
+ */
+
+aspect Closeable {
+  /*
+   * This implementation is to find the set of Objects inside a block
+   * of code inside finish_abort, using which "close()" method has
+   * been called. 
+   * It is assumed that these Objects are of Closeable type in Java.
+   * It is assumed that there cannot be more than one close() statement in single line.
+   * It is assumed that every statement has tokens separated by white spaces.
+   */
+
+  public boolean TypeDecl.insideSyncStealAbort= false;
+
+  /* This code is not being used but left so as to help future developement
+
+  syn lazy java.util.Set<String> Stmt.grabCloseables();
+  syn lazy Boolean Expr.grabCloseables();
+  // Default value if the child class does not override this method.
+  eq Stmt.grabCloseables() = null;
+  eq Expr.grabCloseables() = false;
+
+  syn java.util.Set<String> Block.grabCloseables() {
+    java.util.Set<String> total_methods_inBlock = new java.util.TreeSet<String>();
+    for(int i=0; i<getNumStmt(); i++) {
+      java.util.Set<String> total_methods_inStmt = getStmt(i).grabCloseables();
+      if(total_methods_inStmt != null) {
+        total_methods_inBlock.addAll(total_methods_inStmt);
+      }
+    }
+    return total_methods_inBlock;
+  }
+
+  syn java.util.Set<String> ExprStmt.grabCloseables() {
+    String expr = getExpr().toString();
+    // parse this string as arrays to find the object on which close() has been called
+    if(expr.contains(".close()")) {
+      java.util.Set<String> set = new java.util.TreeSet<String>();
+      String object = expr.replace(".close()", "");
+      set.add(object); 
+      // We don't expect more than one call to close() in a single statement 
+      // hence its safe to return as soon as one close() has been found in this statement.
+      return set;
+    }
+    return null;
+  }
+  
+  */
+
+  refine PrettyPrint
+  public void ExprStmt.toString(StringBuffer s) {
+    String expr = getExpr().toString();
+    // parse this string as arrays to find the object on which close() has been called
+    if(false && hostType().insideSyncStealAbort && expr.contains(".close()")) {
+      String cloeableObject = expr.replace(".close()", "");
+      // We don't expect more than one call to close() in a single statement
+      // hence its safe to return as soon as one close() has been found in this statement.
+      s.append(indent());
+      s.append("if(cloeableObject instanceof java.io.Closeable)");
+      s.append(indent());
+      s.append("org.jikesrvm.scheduler.WS.addCloseable(" + cloeableObject + ");");
+      s.append(";");
+    }
+    s.append(indent());
+    getExpr().toString(s); 
+    s.append(";"); 
+  }
+}
diff --git a/src/Steal.ast b/src/Steal.ast
index ba9dd4e..59f3c83 100644
--- a/src/Steal.ast
+++ b/src/Steal.ast
@@ -20,3 +20,6 @@
 
 StealBlock: Stmt ::= Block;
 SyncStealBlock: Stmt ::= Block;
+SyncStealAbortBlock: Stmt ::= Block;
+AbortStmt: Stmt ::= ;
+
diff --git a/src/Steal.flex b/src/Steal.flex
index eb2d98a..59e6725 100644
--- a/src/Steal.flex
+++ b/src/Steal.flex
@@ -18,6 +18,8 @@
  *
  */
 <YYINITIAL> {
-  "async"                     { return sym(Terminals.STEAL); }
+  "async"                  { return sym(Terminals.STEAL); }
   "finish"                 { return sym(Terminals.SYNCSTEAL); }
+  "finish_abort"           { return sym(Terminals.SYNCSTEALABORT); }
+  "abort"                  { return sym(Terminals.ABORT); }
 }
diff --git a/src/Steal.jrag b/src/Steal.jrag
index ef633fd..9128e42 100644
--- a/src/Steal.jrag
+++ b/src/Steal.jrag
@@ -20,6 +20,54 @@
 
 aspect Steal {
 
+  public void AbortStmt.toString(StringBuffer s) {
+    s.append(indent());
+    s.append("org.jikesrvm.scheduler.WS.abort();");
+    s.append(indent());
+  }
+
+  public void SyncStealAbortBlock.toString(StringBuffer s) {
+    hostType().insideSyncStealAbort = true;
+    // If the child block is of StealBlock type then don't perform the
+    // try-catch block code printing. It will be done from inside the SetalBlock
+    // to help print the cases where there are AssignExprs returning
+    // values, which needs to be stored as partial results.
+    if(!(getBlock().getChild(0).getChild(0) instanceof StealBlock)) {
+      s.append(indent());
+      s.append("try {");
+      s.append(indent());
+      s.append("org.jikesrvm.scheduler.WS.allocateFinishAbort();");
+      s.append(indent());
+      s.append("try {");
+      getBlock().toString(s);
+      s.append(indent());
+      s.append("org.jikesrvm.scheduler.WS.finish();");
+      s.append(indent());
+      s.append("} catch(org.jikesrvm.scheduler.WS.Finish _$$f) {}");
+      s.append(indent());
+      s.append("} catch(org.jikesrvm.scheduler.WS.AbortAtFailure _aaf) {");
+      s.append(indent());
+      s.append("org.jikesrvm.scheduler.WS.wsAcceptAbortAtFailure();");
+      s.append(indent());
+      s.append("} catch(org.jikesrvm.scheduler.WS.AbortAtSuccess _aas) {");
+      s.append(indent());
+      //s.append("org.jikesrvm.scheduler.WS.applyCloseable();");
+      //s.append(indent());
+      s.append("org.jikesrvm.scheduler.WS.wsAcceptAbortAtSuccess();");
+      s.append(indent());
+      s.append("}");
+    }
+    else {
+      // When there is StealBlock inside SyncStealBlock, then there
+      // cannot be any other statements inside the SyncStealBlock.
+      if(getBlock().getChild(0).getNumChild() != 1) {
+        throw new Error("Semantic Error(Line "+getBlock().sourceLineNumber()+"): This finish block contains a steal block, hence no other type of statements should be included");
+      }
+      getBlock().toString(s);
+    }
+    hostType().insideSyncStealAbort = false;
+  }
+
   public void SyncStealBlock.toString(StringBuffer s) {
     // If the child block is of StealBlock type then don't perform the
     // try-catch block code printing. It will be done from inside the SetalBlock
@@ -62,6 +110,7 @@ aspect Steal {
 	// which will have to be stored as partial results.
 	
 	final boolean enclosedWithSyncStealBlock = getParent().getParent().getParent() instanceof SyncStealBlock;
+	final boolean enclosedWithSyncStealAbortBlock = getParent().getParent().getParent() instanceof SyncStealAbortBlock;
 	boolean returningExprs = false;
 	boolean finishFirstBlock = false;
 	java.util.Map<Integer, Access> retVarMap = new java.util.HashMap<Integer, Access>();
@@ -82,6 +131,14 @@ aspect Steal {
 		
 	if(enclosedWithSyncStealBlock) {
 	  s.append("try {");
+  }
+
+  if(enclosedWithSyncStealAbortBlock) {
+	  s.append("try {");
+    	  s.append(indent());
+          s.append("org.jikesrvm.scheduler.WS.allocateFinishAbort();");
+          s.append(indent());
+	  s.append("try {");
 	}
 	
 	// If the steal block is over a for loop, then the for loop
@@ -177,7 +234,11 @@ aspect Steal {
 		dcFor.append(indent());
 		dcFor.append("org.jikesrvm.scheduler.WS.join();");
 		dcFor.append(indent());
-		dcFor.append("} catch (org.jikesrvm.scheduler.WS.Continuation c) {}");
+		dcFor.append("} catch (org.jikesrvm.scheduler.WS.Continuation c) {");
+		dcFor.append(indent());
+		dcFor.append("org.jikesrvm.scheduler.RVMThread.getCurrentThread().canAbortIfRequired();");
+		dcFor.append(indent());
+		dcFor.append("}");
 		dcFor.append(indent());
 		dcFor.append(dcFor_name);
 		dcFor.append("(");
@@ -245,9 +306,14 @@ aspect Steal {
 	    s.append(indent());
 	    s.append("org.jikesrvm.scheduler.WS.join();");
 	    s.append(indent());
-	    s.append("} catch(org.jikesrvm.scheduler.WS.Continuation _$$c) {");
-	    s.append(indent());
-	    s.append("}");
+	    //s.append("} catch(org.jikesrvm.scheduler.WS.Continuation _$$c) {");
+		  s.append("} catch (org.jikesrvm.scheduler.WS.Continuation c) {");
+		  s.append(indent());
+		  s.append("org.jikesrvm.scheduler.RVMThread.getCurrentThread().canAbortIfRequired();");
+		  s.append(indent());
+		  s.append("}");
+	    // s.append(indent());
+	    // s.append("}");
 	    if(returningExprs) {
 	      // Find the returning variable from this expression
 	      if(node instanceof ExprStmt) {
@@ -305,6 +371,23 @@ aspect Steal {
       s.append("} catch(org.jikesrvm.scheduler.WS.Finish _$$f) {");
 	}
 	
+	if(enclosedWithSyncStealAbortBlock) {
+      s.append(indent());
+      s.append("org.jikesrvm.scheduler.WS.finish();");
+      s.append(indent());
+      s.append("} catch(org.jikesrvm.scheduler.WS.Finish _$$f) {}");
+      s.append(indent());
+      s.append("} catch(org.jikesrvm.scheduler.WS.AbortAtFailure _aaf) {");
+      s.append(indent());
+      s.append("org.jikesrvm.scheduler.WS.wsAcceptAbortAtFailure();");
+      s.append(indent());
+      s.append("} catch(org.jikesrvm.scheduler.WS.AbortAtSuccess _aas) {");
+      s.append(indent());
+      s.append("org.jikesrvm.scheduler.WS.wsAcceptAbortAtSuccess();");
+      s.append(indent());
+      s.append("}");
+	}
+
 	if(returningExprs) {
 	  s.append(indent());
       s.append("for(org.jikesrvm.scheduler.WS.FinishData _$$fd: _$$f.data) {");
@@ -438,9 +521,14 @@ aspect Steal {
 	s.append(indent());
 	s.append("org.jikesrvm.scheduler.WS.join();");
 	s.append(indent());
-	s.append("} catch(org.jikesrvm.scheduler.WS.Continuation _$$c) {");
+	//s.append("} catch(org.jikesrvm.scheduler.WS.Continuation _$$c) {");
+	s.append("} catch (org.jikesrvm.scheduler.WS.Continuation c) {");
+	s.append(indent());
+	s.append("org.jikesrvm.scheduler.RVMThread.getCurrentThread().canAbortIfRequired();");
 	s.append(indent());
 	s.append("}");
+	//s.append(indent());
+	//s.append("}");
 	s.append(indent());
 	s.append("}");
   }
diff --git a/src/Steal.parser b/src/Steal.parser
index fb3e8ab..9aea52d 100644
--- a/src/Steal.parser
+++ b/src/Steal.parser
@@ -18,6 +18,10 @@
  *
  */
 
+SyncStealAbortBlock syncsteal_abort_block_statement =
+    SYNCSTEALABORT block.b                      {: return new SyncStealAbortBlock(b); :}
+  ;
+
 SyncStealBlock syncsteal_block_statement =
     SYNCSTEAL block.b                           {: return new SyncStealBlock(b); :}
   ;
@@ -26,7 +30,13 @@ StealBlock steal_block_statement =
     STEAL block.b                               {: return new StealBlock(b); :}
   ;
 
+AbortStmt abort_statement =
+    ABORT SEMICOLON                             {: return new AbortStmt(); :}
+  ; 
+
 Stmt statement =
     syncsteal_block_statement.s                 {: return s; :}
+  | syncsteal_abort_block_statement.s           {: return s; :}
   | steal_block_statement.s                     {: return s; :}
+  | abort_statement.s                           {: return s; :}
   ;
-- 
2.7.4

