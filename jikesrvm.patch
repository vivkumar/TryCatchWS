From 0f49ac80c8913ce08c0e9d9a02a54ae61ddcb21b Mon Sep 17 00:00:00 2001
From: Vivek Kumar <vivekk@iiitd.ac.in>
Date: Fri, 1 Mar 2019 17:38:56 +0530
Subject: [PATCH 1/1] featherlight implementation

Signed-off-by: Vivek Kumar <vivekk@iiitd.ac.in>
---
 .../jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java  |   52 +-
 .../jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java  |   19 +
 MMTk/src/org/mmtk/plan/Plan.java                   |    8 +
 .../org/mmtk/utility/statistics/EventCounter.java  |    7 +
 MMTk/src/org/mmtk/utility/statistics/Stats.java    |    8 +-
 MMTk/src/org/mmtk/vm/Statistics.java               |    6 +
 bin/buildit                                        |    2 +
 build.xml                                          |   20 +-
 .../ia32-assembler-opt/GenerateAssembler.java      |   24 +
 rvm/src-generated/ia32-assembler-opt/Magic.fake    |    1 +
 rvm/src-generated/ia32-assembler/Assembler.in      |   56 +
 .../vm-configuration/HeapLayoutConstants.template  |    4 +-
 rvm/src/org/jikesrvm/VM.java                       |   90 +-
 rvm/src/org/jikesrvm/classloader/RVMType.java      |   15 +
 .../org/jikesrvm/classloader/TypeReference.java    |    8 +
 .../baseline/AbstractBaselineGCMapIterator.java    |    2 +-
 .../compilers/baseline/BaselineCompiledMethod.java |    6 +-
 .../compilers/baseline/BaselineCompiler.java       |    2 +-
 .../baseline/ia32/ArchBridgeDataExtractor.java     |    4 +-
 .../baseline/ia32/BaselineExceptionDeliverer.java  |    2 +-
 .../baseline/ia32/BaselineGCMapIterator.java       |   32 +-
 .../baseline/ppc/BaselineGCMapIterator.java        |   10 +
 .../jikesrvm/compilers/common/CompiledMethod.java  |   79 +-
 .../jikesrvm/compilers/common/ExceptionTable.java  |   13 +-
 .../common/HardwareTrapCompiledMethod.java         |    4 +-
 .../common/HardwareTrapGCMapIterator.java          |   13 +
 .../compilers/opt/driver/OptimizingCompiler.java   |    2 +-
 rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java |    5 +
 .../compilers/opt/mir2mc/ia32/AssemblerBase.java   |    1 +
 .../opt/runtimesupport/OptCompiledMethod.java      |    8 +-
 .../runtimesupport/OptGenericGCMapIterator.java    |   29 +
 .../org/jikesrvm/ia32/OutOfLineMachineCode.java    |   15 +-
 rvm/src/org/jikesrvm/jni/JNICompiledMethod.java    |    4 +-
 rvm/src/org/jikesrvm/jni/JNIFunctions.java         |    4 +-
 rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java     |    2 +-
 .../org/jikesrvm/jni/ia32/JNIGCMapIterator.java    |    8 +
 rvm/src/org/jikesrvm/jni/ppc/JNICompiler.java      |    3 +-
 rvm/src/org/jikesrvm/jni/ppc/JNIGCMapIterator.java |   10 +
 .../org/jikesrvm/mm/mminterface/GCMapIterator.java |    4 +
 .../mm/mminterface/GCMapIteratorGroup.java         |   33 +
 rvm/src/org/jikesrvm/objectmodel/ObjectModel.java  |   21 +
 rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java  |    2 +-
 rvm/src/org/jikesrvm/runtime/BootRecord.java       |   14 +
 rvm/src/org/jikesrvm/runtime/CommandLineArgs.java  |   78 +-
 rvm/src/org/jikesrvm/runtime/Entrypoints.java      |    8 +
 rvm/src/org/jikesrvm/runtime/Magic.java            |   17 +
 .../org/jikesrvm/runtime/RuntimeEntrypoints.java   |   21 +-
 rvm/src/org/jikesrvm/runtime/SysCall.java          |   37 +
 rvm/src/org/jikesrvm/scheduler/MainThread.java     |   16 +
 rvm/src/org/jikesrvm/scheduler/ParallelForWS.java  |   50 +
 rvm/src/org/jikesrvm/scheduler/RVMThread.java      | 9856 ++++++++++++--------
 .../org/jikesrvm/scheduler/StackFrameCopier.java   |  235 +
 rvm/src/org/jikesrvm/scheduler/WS.java             |  793 ++
 tools/bootloader/main.c                            |   47 +-
 tools/bootloader/sys.h                             |   19 +
 tools/bootloader/sysMemory.c                       |    3 +
 tools/bootloader/sysPerfEvent.c                    |   94 +
 tools/bootloader/sysThread.c                       |   71 +-
 58 files changed, 8069 insertions(+), 3928 deletions(-)
 create mode 100644 rvm/src/org/jikesrvm/scheduler/ParallelForWS.java
 create mode 100755 rvm/src/org/jikesrvm/scheduler/StackFrameCopier.java
 create mode 100755 rvm/src/org/jikesrvm/scheduler/WS.java

diff --git a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java
index ea65606..0986abf 100644
--- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java
+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ScanThread.java
@@ -37,6 +37,8 @@ import org.vmmagic.pragma.Untraced;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.ObjectReference;
 import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.WordArray;
+import org.jikesrvm.ia32.RegisterConstants;
 
 /**
  * Class that supports scanning thread stacks for references during
@@ -143,10 +145,40 @@ import org.vmmagic.unboxed.Offset;
     AbstractRegisters regs = thread.getContextRegisters();
     Address gprs = Magic.objectAsAddress(regs.getGPRs());
 
-    Address ip = regs.getInnermostInstructionAddress();
-    Address fp = regs.getInnermostFramePointer();
+    Address ip_main = regs.getInnermostInstructionAddress();
+    Address fp_main = regs.getInnermostFramePointer();
+    /*
+     * While performing work-stealing with return barrier, thieves
+     * create a snapshot of victim's thread stack. This cloned stack
+     * contains references to live objects as long as the victim
+     * has return barrier installed on its main stack.
+     *
+     * If we do not scan the cloned stack, then we may loose references
+     * to live objects as it may be collected after scanning only the main
+     * stack. Hence, we have to make sure we compute the roots by scanning
+     * both the cloned and main stack as long as return barrier is installed
+     * on victim's main stack
+     *
+     * As seen on NQueens and UTS benchmarks (which performs GC), there is
+     * very insignificant change in the gc time due to scanning cloned stack
+     * as well.
+     */
+    if(thread.wsMaintainsClonedStackAlso()) {
+      if(false) {
+        // Also scan the wsShadowStack
+        WordArray gprs_actual = regs.getGPRs();
+        // initialize it from the backup gprs
+        regs.clear();
+        thread.wsSetInnermost();
+        // UNTESTED CODE JavaTryCatchWS
+        scanThread(thread, trace, processCodeLocations, gprs, Address.zero(),newRootsSufficient);
+      }
+      else{
+        thread.deInstallStackTrampoline_fromGC();
+      }
+    }
     regs.clear();
-    regs.setInnermost(ip,fp);
+    regs.setInnermost(ip_main,fp_main);
 
     scanThread(thread, trace, processCodeLocations, gprs, Address.zero(), newRootsSufficient);
   }
@@ -313,6 +345,15 @@ import org.vmmagic.unboxed.Offset;
     // TODO implement this if necessary. It was previously only implemented for
     // AIX which is no longer supported.
 
+    if (thread.wsSpecialNVMap != 0) {
+      for(int i=0; i < RegisterConstants.NONVOLATILE_GPRS.length; i++) {
+        int reg = RegisterConstants.NONVOLATILE_GPRS[i].value();
+        if ((thread.wsSpecialNVMap & (1 << reg)) != 0) {
+          reportDelayedRootEdge(trace, iteratorGroup.getRegisterLocation(reg));
+        }
+      }
+    }
+
     if (verbosity >= 2) Log.writeln("--- End Of Stack Scan ---\n");
   }
 
@@ -411,10 +452,13 @@ import org.vmmagic.unboxed.Offset;
       }
 
       /* reinstall the return barrier if necessary (and verbosity indicates that this is a regular scan) */
+      
+      /** JikesRVM Try-CatchWS -- untested code, so commenting...
       if (reinstallReturnBarrier && verbosity == DEFAULT_VERBOSITY) {
-        thread.installStackTrampolineBridge(fp);
+        thread.wsinstallStackTrampolineBridge(fp);
         reinstallReturnBarrier = false;
       }
+      */
     }
     return fp;
   }
diff --git a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
index 1ebaeb4..690bcf0 100644
--- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
@@ -15,6 +15,7 @@ package org.jikesrvm.mm.mmtk;
 import org.mmtk.utility.statistics.PerfEvent;
 import org.jikesrvm.runtime.Time;
 import static org.jikesrvm.runtime.SysCall.sysCall;
+import org.jikesrvm.scheduler.WS;
 
 import org.vmmagic.pragma.*;
 
@@ -85,5 +86,23 @@ public final class Statistics extends org.mmtk.vm.Statistics {
   public void perfEventRead(int id, long[] values) {
     sysCall.sysPerfEventRead(id, values);
   }
+
+  /**
+   * Work stealing harness calls
+   */
+  @Override
+  public void wsHarnessBegin() {
+    WS.harnessBegin();
+  }
+
+  @Override
+  public void wsHarnessEnd() {
+    WS.harnessEnd();
+  }
+
+  @Override
+  public void wsUpdateStealRatioExternally(int steals, int pushes) {
+    WS.updateStealRatioExternally(steals, pushes);
+  }
 }
 
diff --git a/MMTk/src/org/mmtk/plan/Plan.java b/MMTk/src/org/mmtk/plan/Plan.java
index ad67245..98790a7 100644
--- a/MMTk/src/org/mmtk/plan/Plan.java
+++ b/MMTk/src/org/mmtk/plan/Plan.java
@@ -756,6 +756,14 @@ public abstract class Plan {
    */
   protected static boolean insideHarness = false;
 
+  /*
+   * Java Try-CatchWS
+   */
+  @Interruptible
+  public static void updateStealRatioExternally(int steals, int pushes) {
+    VM.statistics.wsUpdateStealRatioExternally(steals, pushes);
+  }
+
   /**
    * Generic hook to allow benchmarks to be harnessed.  A plan may use
    * this to perform certain actions prior to the commencement of a
diff --git a/MMTk/src/org/mmtk/utility/statistics/EventCounter.java b/MMTk/src/org/mmtk/utility/statistics/EventCounter.java
index 622cc90..cc2e10d 100644
--- a/MMTk/src/org/mmtk/utility/statistics/EventCounter.java
+++ b/MMTk/src/org/mmtk/utility/statistics/EventCounter.java
@@ -92,6 +92,13 @@ public class EventCounter extends Counter {
   }
 
   /**
+   * to be used for jikesrvm work-stealing logs
+   */
+  public void wsInc(long value) {
+    if (running) currentCount += value;
+  }
+
+  /**
    * Increment the event counter by <code>value</code>
    *
    * @param value The amount by which the counter should be incremented.
diff --git a/MMTk/src/org/mmtk/utility/statistics/Stats.java b/MMTk/src/org/mmtk/utility/statistics/Stats.java
index d15c00d..a354aae 100644
--- a/MMTk/src/org/mmtk/utility/statistics/Stats.java
+++ b/MMTk/src/org/mmtk/utility/statistics/Stats.java
@@ -42,7 +42,7 @@ public class Stats {
   public static final boolean GATHER_MARK_CONS_STATS = false;
 
   /** Maximum number of gc/mutator phases that can be counted */
-  static final int MAX_PHASES = 1 << 12;
+  static final int MAX_PHASES = 1 << 17; // To avoid the MAX_PHASE errors in Integrate and Matmul application
   /** Maximum number of counters that can be in operation */
   static final int MAX_COUNTERS = 100;
 
@@ -135,6 +135,9 @@ public class Stats {
         counter[c].start();
     }
 
+    // work-stealing harness hook
+    VM.statistics.wsHarnessBegin();
+
     if (Options.xmlStats.getValue()) {
       Xml.begin();
       Xml.openTag("mmtk-stats");
@@ -147,6 +150,8 @@ public class Stats {
    */
   @Interruptible
   public static void stopAll() {
+    // work-stealing harness hook
+    VM.statistics.wsHarnessEnd();
     stopAllCounters();
     Stats.printStats();
     if (Options.xmlStats.getValue()) {
@@ -213,6 +218,7 @@ public class Stats {
     Plan.totalTime.printTotal();
     Log.writeln(" ms");
     Log.writeln("------------------------------ End MMTk Statistics -----------------------------");
+    Log.writeln("===== TEST PASSED in 0 msec =====");
   }
 
   /**
diff --git a/MMTk/src/org/mmtk/vm/Statistics.java b/MMTk/src/org/mmtk/vm/Statistics.java
index 624d912..1fd587c 100644
--- a/MMTk/src/org/mmtk/vm/Statistics.java
+++ b/MMTk/src/org/mmtk/vm/Statistics.java
@@ -82,4 +82,10 @@ public abstract class Statistics {
    * read (3 64-bit values).
    */
   public abstract void perfEventRead(int counter, long[] values);
+  /**
+   * Work stealing harness calls
+   */
+  public abstract void wsHarnessBegin();
+  public abstract void wsHarnessEnd();
+  public abstract void wsUpdateStealRatioExternally(int steals, int pushes);
 }
diff --git a/bin/buildit b/bin/buildit
index 0ea937f..97c52a8 100755
--- a/bin/buildit
+++ b/bin/buildit
@@ -78,6 +78,8 @@ Building Options:
      --m32, --m64     Force use of 32- or 64-bit addressing in the build
  -c, --cross-to       Crossbuild to target host (or copy post build).
      --with-perfevent Build with perf event support
+     --with-libnuma   Build with NUMA support
+     --for-macos      Build for MacOSX
  -a, --with-acheck    Build with align checks, implies --x87 --processors 1
  -g, --gdb-symbols    Build with gdb symbols
  -q, --quick          Quick build (not 100% safe - doesn't regenerate source)
diff --git a/build.xml b/build.xml
index f497854..6601458 100644
--- a/build.xml
+++ b/build.xml
@@ -435,7 +435,17 @@ Check to make sure all required properties are specified. This includes properti
       <equals arg1="${config.include.perfevent}" arg2="true"/>
     </condition>
 
-    <property name="filter" value="${arch.filter} ${os.filter} ${addr.filter} ${gctrace.filter} ${gcspy.filter} ${alignment-checking.filter} ${perfevent.filter} ${classlib.filter}"/>
+<!--
+    <condition property="libnuma.filter" value="-DRVM_WITH_LIBNUMA=1" else="">
+      <equals arg1="${config.include.libnuma}" arg2="true"/>
+    </condition>
+-->
+    <condition property="macos.filter" value="-DRVM_FOR_MACOS=1" else="">
+      <equals arg1="${config.include.macos}" arg2="true"/>
+    </condition>
+
+    <property name="filter" value="${arch.filter} ${os.filter} ${addr.filter} ${gctrace.filter} ${gcspy.filter} ${alignment-checking.filter} ${perfevent.filter} ${macos.filter} ${classlib.filter}"/>
+
   </target>
 
   <!-- **************************************************************************** -->
@@ -1879,6 +1889,12 @@ const char *rvm_target_configuration = "${target.file}";
       <equals arg1="${config.include.perfevent}" arg2="true"/>
     </condition>
 
+<!--
+    <condition property="libnuma.lib" value="-lnuma" else="">
+      <equals arg1="${config.include.libnuma}" arg2="true"/>
+    </condition>
+-->
+
     <condition property="arch.includes" value="-I${bl.dir}/ia32">
       <equals arg1="${target.arch}" arg2="ia32"/>
     </condition>
@@ -2114,6 +2130,7 @@ config.bootimage.compiler=${config.bootimage.compiler}
 config.mmtk.plan=${config.mmtk.plan}
 config.include.aos=${config.include.aos}
 config.include.perfevent=${config.include.perfevent}
+<!-- config.include.libnuma=${config.include.libnuma} -->
 config.include.gcspy=${config.include.gcspy}
 config.include.gcspy-client=${config.include.gcspy-client}
 config.assertions=${config.assertions}
@@ -2172,6 +2189,7 @@ config.bootimage.compiler=${config.bootimage.compiler}
 config.mmtk.plan=${config.mmtk.plan}
 config.include.aos=${config.include.aos}
 config.include.perfevent=${config.include.perfevent}
+<!-- config.include.libnuma=${config.include.libnuma} -->
 config.include.gcspy=${config.include.gcspy}
 config.include.gcspy-client=${config.include.gcspy-client}
 config.assertions=${config.assertions}
diff --git a/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java b/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java
index f12c797..4ceafe9 100644
--- a/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java
+++ b/rvm/src-generated/ia32-assembler-opt/GenerateAssembler.java
@@ -13,6 +13,7 @@
 import java.io.*;
 import java.util.*;
 import java.lang.reflect.*;
+import org.jikesrvm.VM;
 
 /**
  * <P>
@@ -1222,9 +1223,32 @@ public class GenerateAssembler {
       emit(" */\n");
       emitTab(1);
       emit("private void do" + opcode + "(Instruction inst) {\n");
+      if (opcode.equals("CALL")) {
+        emitTab(2);
+        emit("boolean join = MIR_Call.getMethod(inst) != null && (MIR_Call.getMethod(inst).getMemberRef() == org.jikesrvm.runtime.Entrypoints.workStealingJoinMethod || MIR_Call.getMethod(inst).getMemberRef() == org.jikesrvm.runtime.Entrypoints.workStealingFinishMethod);\n");
+        emitTab(2);
+        emit("boolean recurse = isImm(MIR_Call.getTarget(inst)) && getImm(MIR_Call.getTarget(inst)) == 0;\n");
+        emitTab(2);
+        emit("int start = getMachineCodeIndex();\n");
+      }
+
       EmitterSet emitter = buildSetForOpcode(emitters, opcode);
       boolean[][] tp = new boolean[4][ArgumentType.values().length];
       emitter.emitSet(opcode, tp, 2);
+      if (opcode.equals("CALL")) {
+        emitTab(2);
+        emit("if (join) {\n");
+        emitTab(3);
+        emit("addJoinRegion(start, getMachineCodeIndex());\n");
+        emitTab(2);
+        emit("}\n");
+        emitTab(2);
+        emit("if (recurse) {\n");
+        emitTab(3);
+        emit("addRecursion(start);\n");
+        emitTab(2);
+        emit("}\n");
+      }
       emitTab(1);
       emit("}\n\n");
     }
diff --git a/rvm/src-generated/ia32-assembler-opt/Magic.fake b/rvm/src-generated/ia32-assembler-opt/Magic.fake
index 9d651a4..ad4ab95 100644
--- a/rvm/src-generated/ia32-assembler-opt/Magic.fake
+++ b/rvm/src-generated/ia32-assembler-opt/Magic.fake
@@ -18,4 +18,5 @@ import org.vmmagic.unboxed.Address;
 public class Magic {
   public static void setIntAtOffset(Object o, Offset x, int y) { }
   public static Address getTocPointer() { return Address.zero(); }
+  public static Address objectAsAddress(Object o) { return Address.zero(); }
 }
diff --git a/rvm/src-generated/ia32-assembler/Assembler.in b/rvm/src-generated/ia32-assembler/Assembler.in
index 9449f0e..5156b29 100644
--- a/rvm/src-generated/ia32-assembler/Assembler.in
+++ b/rvm/src-generated/ia32-assembler/Assembler.in
@@ -194,6 +194,35 @@ public class Assembler extends AbstractAssembler {
    * The lister object is used to print generated machine code.
    */
   protected final Lister lister;
+  public int [] joinRegions = new int[0];
+
+  protected void addJoinRegion(int start, int end) {
+    int[] newRegions = new int[joinRegions.length+2];
+    for(int i=0;i<joinRegions.length;i++) {
+      newRegions[i] = joinRegions[i];
+    }
+    joinRegions = newRegions;
+    joinRegions[joinRegions.length-2] = start;
+    joinRegions[joinRegions.length-1] = end - start;
+  }
+
+  public int [] recursions = new int[0];
+
+  protected void addRecursion(int start) {
+    int[] newRecursions = new int[recursions.length+1];
+    for(int i=0;i<recursions.length;i++) {
+      newRecursions[i] = recursions[i];
+    }
+    recursions = newRecursions;
+    recursions[recursions.length-1] = start;
+  }
+
+  public final void changeCALL_Imm(CodeArray code, int start, int imm) {
+    code.set(start+1, (byte) ((imm >>  0) & 0xFF));
+    code.set(start+2, (byte) ((imm >>  8) & 0xFF));
+    code.set(start+3, (byte) ((imm >> 16) & 0xFF));
+    code.set(start+4, (byte) ((imm >> 24) & 0xFF));
+  }
 
   /**
    * The array holding the generated binary code.
@@ -320,6 +349,26 @@ public class Assembler extends AbstractAssembler {
     return trimmed;
   }
 
+  public final CodeArray patchMachineCodeForWorkStealing(CodeArray slow) {
+    if (joinRegions.length == 0) {
+      return slow;
+    }
+    // Generate a fast version without join calls, that recurses to itself.
+    for(int i=0; i<joinRegions.length; i+=2) {
+      replaceWithNOP(joinRegions[i], joinRegions[i+1]);
+    }
+
+    CodeArray fast = getMachineCodes();
+
+    // Change the slow version to recurse to the fast version.
+    int delta = Magic.objectAsAddress(fast).diff(Magic.objectAsAddress(slow)).toInt();
+    for(int i=0; i<recursions.length; i++) {
+      changeCALL_Imm(slow, recursions[i], delta - (recursions[i] + 5));
+    }
+
+    return fast;
+  }
+
   public final Lister getLister() {
     return lister;
   }
@@ -2534,6 +2583,13 @@ public class Assembler extends AbstractAssembler {
     if (lister != null) lister.OP(miStart, "SAHF");
   }
 
+  public final void replaceWithNOP (int start, int length) {
+    int oldMi = mi;
+    mi = start;
+    emitNOP(length);
+    mi = oldMi;
+  }
+
   /**
    * Generate a move sign extended from register. That is,
    * <PRE>
diff --git a/rvm/src-generated/vm-configuration/HeapLayoutConstants.template b/rvm/src-generated/vm-configuration/HeapLayoutConstants.template
index 9c896ca..58996b3 100644
--- a/rvm/src-generated/vm-configuration/HeapLayoutConstants.template
+++ b/rvm/src-generated/vm-configuration/HeapLayoutConstants.template
@@ -61,7 +61,9 @@ public final class HeapLayoutConstants {
    * is not set and the boot image data size is greater than or equal to this amount
    * of bytes.
    */
-  public static final int BOOT_IMAGE_DATA_SIZE_LIMIT = (int) (1.0f * (56 << 20) * dataSizeAdjustment());
+  //public static final int BOOT_IMAGE_DATA_SIZE_LIMIT = (int) (1.0f * (56 << 20) * dataSizeAdjustment());
+  // For TryCatchWS, 56Mb size was failing so randomply kept 64Mb size
+  public static final int BOOT_IMAGE_DATA_SIZE_LIMIT = (int) (1.0f * (64 << 20) * dataSizeAdjustment());
 
   /**
    * Limit for boot image code size: fail the build if
diff --git a/rvm/src/org/jikesrvm/VM.java b/rvm/src/org/jikesrvm/VM.java
index a37648a..3070b1a 100644
--- a/rvm/src/org/jikesrvm/VM.java
+++ b/rvm/src/org/jikesrvm/VM.java
@@ -178,7 +178,7 @@ public class VM extends Properties {
 
     // get pthread_id from OS and store into vm_processor field
     //
-    RVMThread.getCurrentThread().pthread_id = sysCall.sysGetThreadId();
+    RVMThread.getCurrentThread().thread_id = sysCall.sysGetThreadId();
     RVMThread.getCurrentThread().priority_handle = sysCall.sysGetThreadPriorityHandle();
     RVMThread.availableProcessors = SysCall.sysCall.sysNumProcessors();
 
@@ -923,7 +923,7 @@ public class VM extends Properties {
   @NoInline
   /* don't waste code space inlining these --dave */
   public static void write(long value) {
-    write(value, true);
+    write(value, false);
   }
 
   /**
@@ -1051,6 +1051,22 @@ public class VM extends Properties {
   }
 
   @NoInline
+  public static void sysWriteln(int a, String b, String c, String d, long e, String f, long g, String h, long i) {
+    swLock();
+    write(a);
+    write(b);
+    write(c);
+    write(d);
+    write(e);
+    write(f);
+    write(g);
+    write(h);
+    write(i);
+    write("\n");
+    swUnlock();
+  }
+
+  @NoInline
   public static void sysWrite(RVMMember m) {
     swLock();
     write(m);
@@ -1527,6 +1543,17 @@ public class VM extends Properties {
     swUnlock();
   }
   @NoInline
+  public static void sysWriteln(Address a1, Address a2, Address a3) {
+   swLock();
+   write(a1);
+   write(" ");
+   write(a2);
+   write(" ");
+   write(a3);
+   writeln();
+   swUnlock();
+  }
+  @NoInline
   public static void sysWriteln(String s1, Address a1,Address a2) {
     swLock();
     write(s1);
@@ -1621,6 +1648,16 @@ public class VM extends Properties {
   }
 
   @NoInline
+  public static void sysWriteln(Offset o1, String s, Offset o2) {
+    swLock();
+    write(o1);
+    write(s);
+    write(o2);
+    writeln();
+    swUnlock();
+  }
+
+  @NoInline
   public static void sysWrite(String s1, String s2, String s3) {
     swLock();
     write(s1);
@@ -1899,6 +1936,55 @@ public class VM extends Properties {
   }
 
   @NoInline
+  public static void sysWriteln(String s1, Offset o1, String s2, Offset o2) {
+    swLock();
+    write(s1);
+    write(o1);
+    write(s2);
+    write(o2);
+    writeln();
+    swUnlock();
+  }
+ 
+  @NoInline
+  public static void sysWriteln(Offset o, String s1, Offset o1, String s2, Offset o2) {
+    swLock();
+    write(o);
+    write(s1);
+    write(o1);
+    write(s2);
+    write(o2);
+    writeln();
+    swUnlock();
+  }
+
+  @NoInline
+  public static void sysWriteln(int i1, String s1, Offset o, String s2, int i2) {
+    swLock();
+    write(i1);
+    write(s1);
+    write(o);
+    write(s2);
+    write(i2);
+    writeln();
+    swUnlock();
+  }
+
+  @NoInline
+  public static void sysWriteln(int i1, int i2, Offset o1, Offset o2) {
+    swLock();
+    write(i1);
+    write(" ");
+    write(i2);
+    write(" ");
+    write(o1);
+    write(" ");
+    write(o2);
+    writeln();
+    swUnlock();
+  }
+
+  @NoInline
   public static void sysWrite(String s1, double d, String s2) {
     swLock();
     write(s1);
diff --git a/rvm/src/org/jikesrvm/classloader/RVMType.java b/rvm/src/org/jikesrvm/classloader/RVMType.java
index e3c5379..2434530 100644
--- a/rvm/src/org/jikesrvm/classloader/RVMType.java
+++ b/rvm/src/org/jikesrvm/classloader/RVMType.java
@@ -135,6 +135,13 @@ public abstract class RVMType extends AnnotatedElement {
   public static final RVMClass IMTType;
   public static final RVMClass FunctionTableType;
   public static final RVMClass LinkageTripletTableType;
+  public static final RVMClass WSAbortAtFailureType;
+  public static final RVMClass WSAbortAtSuccessType;
+  public static final RVMClass WSContinuationType;
+  public static final RVMClass WSFinishType;
+  public static final RVMClass WSJoinType;
+  public static final RVMClass WSFinishFirstType;
+  public static final RVMClass RVMThreadType;
 
   static {
     // Primitive types
@@ -180,6 +187,14 @@ public abstract class RVMType extends AnnotatedElement {
     JavaIoSerializableType = TypeReference.JavaIoSerializable.resolve().asClass();
     JavaLangRefReferenceType = TypeReference.JavaLangRefReference.resolve().asClass();
     JavaLangRefReferenceReferenceField = JavaLangRefReferenceType.findDeclaredField(Atom.findAsciiAtom("_referent"));
+    // WorkStealing
+    WSAbortAtSuccessType = TypeReference.WSAbortAtSuccess.resolve().asClass();
+    WSAbortAtFailureType = TypeReference.WSAbortAtFailure.resolve().asClass();
+    WSContinuationType = TypeReference.WSContinuation.resolve().asClass();
+    WSJoinType =  TypeReference.WSJoin.resolve().asClass();
+    WSFinishFirstType =  TypeReference.WSFinishFirst.resolve().asClass();
+    WSFinishType =  TypeReference.WSFinish.resolve().asClass();
+    RVMThreadType = TypeReference.RVMThread.resolve().asClass();
   }
 
   /**
diff --git a/rvm/src/org/jikesrvm/classloader/TypeReference.java b/rvm/src/org/jikesrvm/classloader/TypeReference.java
index 1a114fb..be6be93 100644
--- a/rvm/src/org/jikesrvm/classloader/TypeReference.java
+++ b/rvm/src/org/jikesrvm/classloader/TypeReference.java
@@ -172,6 +172,14 @@ public final class TypeReference {
   public static final TypeReference BaselineSaveLSRegisters = findOrCreate(org.vmmagic.pragma.BaselineSaveLSRegisters.class);
   public static final TypeReference ReferenceFieldsVary = findOrCreate(org.vmmagic.pragma.ReferenceFieldsVary.class);
 
+  public static final TypeReference WSAbortAtSuccess = findOrCreate(org.jikesrvm.scheduler.WS.AbortAtSuccess.class);
+  public static final TypeReference WSAbortAtFailure = findOrCreate(org.jikesrvm.scheduler.WS.AbortAtFailure.class);
+  public static final TypeReference WSContinuation = findOrCreate(org.jikesrvm.scheduler.WS.Continuation.class);
+  public static final TypeReference WSJoin = findOrCreate(org.jikesrvm.scheduler.WS.Join.class);
+  public static final TypeReference WSFinish = findOrCreate(org.jikesrvm.scheduler.WS.Finish.class);
+  public static final TypeReference WSFinishFirst = findOrCreate(org.jikesrvm.scheduler.WS.FinishFirst.class);
+  public static final TypeReference RVMThread = findOrCreate(org.jikesrvm.scheduler.RVMThread.class);
+
 
   public static final TypeReference ReferenceMaps =
       findOrCreate(org.jikesrvm.compilers.baseline.ReferenceMaps.class);
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/AbstractBaselineGCMapIterator.java b/rvm/src/org/jikesrvm/compilers/baseline/AbstractBaselineGCMapIterator.java
index 2496b16..ccf7a2d 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/AbstractBaselineGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/AbstractBaselineGCMapIterator.java
@@ -70,7 +70,7 @@ public abstract class AbstractBaselineGCMapIterator extends GCMapIterator {
     bridgeData.cleanupPointers();
   }
 
-  @Override
+  //@Override  -->TryCatchwS
   public final int getType() {
     return CompiledMethod.BASELINE;
   }
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java
index 20b50c9..6fd0d7d 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiledMethod.java
@@ -134,11 +134,11 @@ public abstract class BaselineCompiledMethod extends CompiledMethod {
    */
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
     if (eTable == null) {
-      return -1;
+      return Offset.fromIntSignExtend(-1);
     } else {
-      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType);
+      return ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType, exactType);
     }
   }
 
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java
index d202783..e3df5d2 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/BaselineCompiler.java
@@ -337,7 +337,7 @@ public abstract class BaselineCompiler extends TemplateCompilerFramework {
         ((BaselineCompiledMethod) compiledMethod).setLockAcquisitionOffset(lockOffset);
       }
       ((BaselineCompiledMethod) compiledMethod).encodeMappingInfo(refMaps, bcMap);
-      compiledMethod.compileComplete(instructions);
+      compiledMethod.compileComplete(instructions, instructions);
       if (edgeCounterIdx > 0) {
         EdgeCounts.allocateCounters(method, edgeCounterIdx);
       }
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/ia32/ArchBridgeDataExtractor.java b/rvm/src/org/jikesrvm/compilers/baseline/ia32/ArchBridgeDataExtractor.java
index 742956d..aabc785 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/ia32/ArchBridgeDataExtractor.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/ia32/ArchBridgeDataExtractor.java
@@ -56,7 +56,9 @@ class ArchBridgeDataExtractor extends AbstractBridgeDataExtractor {
 
   @Override
   protected final void setupArchitectureSpecificDynamicBridgeMapping(Address fp) {
-    Address ip = Magic.getReturnAddressUnchecked(fp);
+    // Commenting for TryCatchWS
+    // Address ip = Magic.getReturnAddressUnchecked(fp); 
+    Address ip = Magic.getReturnAddress(fp);
     fp = Magic.getCallerFramePointer(fp);
     int callingCompiledMethodId = Magic.getCompiledMethodID(fp);
     CompiledMethod callingCompiledMethod = CompiledMethods.getCompiledMethod(callingCompiledMethodId);
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java
index 53e8662..005954b 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineExceptionDeliverer.java
@@ -104,7 +104,7 @@ public final class BaselineExceptionDeliverer extends ExceptionDeliverer {
                   0)) - BYTES_IN_ADDRESS).loadAddress());
         }
         if (ObjectModel.holdsLock(lock, RVMThread.getCurrentThread())) {
-          ObjectModel.genericUnlock(lock);
+          ObjectModel.genericUnlock_internal(lock);
         }
       }
     }
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java
index 6bee64f..d06c9e1 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineGCMapIterator.java
@@ -34,6 +34,9 @@ import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.AddressArray;
 import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.AddressArray;
+import org.jikesrvm.scheduler.RVMThread;
+
 
 /**
  * Iterator for stack frame  built by the Baseline compiler.
@@ -74,7 +77,7 @@ public final class BaselineGCMapIterator extends AbstractBaselineGCMapIterator {
    *          processing instance specific information i.e JSR return address
    *          values
    */
-  @Override
+  //@Override
   public void setupIterator(CompiledMethod compiledMethod, Offset instructionOffset, Address fp) {
     currentCompiledMethod = (ArchBaselineCompiledMethod) compiledMethod;
     currentMethod = (NormalMethod) currentCompiledMethod.getMethod();
@@ -157,6 +160,27 @@ public final class BaselineGCMapIterator extends AbstractBaselineGCMapIterator {
   }
 
   @Override
+  public final int getNVRegistersSaved() {
+    int result = (1 << EDI.value()) | (1 << EBX.value());
+    if (currentMethod.hasBaselineSaveLSRegistersAnnotation()) {
+      result |= 1 << EBP.value();
+    }
+    return result;
+  }
+
+  public final int getNVObjectMap() {
+    if (currentCompiledMethod.hasCounterArray()) {
+      return 1 << EBX.value();
+    }
+    return 0;
+  }
+
+  /**
+   * Get location of next reference. A zero return indicates that no more
+   * references exist.
+   */
+
+  //@Override
   public Address getNextReferenceAddress() {
     if (!mapReader.isFinishedWithRegularMap()) {
       if (counterArrayBase) {
@@ -244,7 +268,11 @@ public final class BaselineGCMapIterator extends AbstractBaselineGCMapIterator {
     return Address.zero();
   }
 
-  @Override
+  /**
+   * Gets the location of the next return address after the current position. A
+   * zero return indicates that no more references exist
+   */
+  //@Override
   public Address getNextReturnAddressAddress() {
     if (!mapReader.currentMapIsForJSR()) {
       if (VM.TraceStkMaps || TRACE_ALL) {
diff --git a/rvm/src/org/jikesrvm/compilers/baseline/ppc/BaselineGCMapIterator.java b/rvm/src/org/jikesrvm/compilers/baseline/ppc/BaselineGCMapIterator.java
index cf55d09..b57671c 100644
--- a/rvm/src/org/jikesrvm/compilers/baseline/ppc/BaselineGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/compilers/baseline/ppc/BaselineGCMapIterator.java
@@ -43,6 +43,16 @@ import org.vmmagic.unboxed.Offset;
 @Uninterruptible
 public final class BaselineGCMapIterator extends AbstractBaselineGCMapIterator {
 
+  // This method is currently undefined for ppc as TryCatchWS is only supported for ia32
+  public int getNVRegistersSaved() {
+    return -1;
+  }
+
+  // This method is currently undefined for ppc as TryCatchWS is only supported for ia32
+  public int getNVObjectMap() {
+    return -1;
+  }
+
   /** Compiled method for the frame */
   protected ArchBaselineCompiledMethod currentCompiledMethod;
 
diff --git a/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java b/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java
index 8dd7cfc..1f83bdb 100644
--- a/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java
+++ b/rvm/src/org/jikesrvm/compilers/common/CompiledMethod.java
@@ -28,9 +28,12 @@ import org.vmmagic.pragma.Unpreemptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.Offset;
 import org.vmmagic.unboxed.Word;
+import org.jikesrvm.ia32.RegisterConstants;
 
 /**
  * A method that has been compiled into machine code by one of our compilers.
+ * We implement SynchronizedObject because we need to synchronize
+ * on the CompiledMethod object as part of the invalidation protocol.
  */
 public abstract class CompiledMethod {
 
@@ -85,6 +88,11 @@ public abstract class CompiledMethod {
   protected CodeArray instructions;
 
   /**
+   * The compiled machine code for said method.
+   */
+  protected CodeArray joinInstructions;
+
+  /**
    * the offset of instructions in JTOC, for osr-special compiled
    * method only. all osr-ed method is treated like static.
    * TODO: OSR redesign: put in subclass?  Stick somewhere else?
@@ -203,8 +211,10 @@ public abstract class CompiledMethod {
     if (getCompilerType() == JNI || getCompilerType() == TRAP) {
       return Offset.zero();
     } else {
-      Offset offset = ip.diff(Magic.objectAsAddress(instructions));
-      int max = (instructions.length() + 1) << ArchConstants.getLogInstructionWidth();
+      CodeArray base = instructions;
+      if (inJoinInstructions(ip)) base = joinInstructions;
+      Offset offset = ip.diff(Magic.objectAsAddress(base));
+      int max = (base.length() + 1) << RegisterConstants.LG_INSTRUCTION_WIDTH;
       if (!offset.toWord().LT(Word.fromIntZeroExtend(max))) {
         if (RVMThread.isTrampolineIP(ip)) {
           ip = RVMThread.getCurrentThread().getTrampolineHijackedReturnAddress();
@@ -212,7 +222,7 @@ public abstract class CompiledMethod {
           if (offset.toWord().LT(Word.fromIntZeroExtend(max)))
             return offset;
         }
-        Address instructionStart = Magic.objectAsAddress(instructions);
+        Address instructionStart = Magic.objectAsAddress(base);
         VM.sysWriteln();
         VM.sysWriteln("In thread ",RVMThread.getCurrentThreadSlot()," getInstructionOffset: ip is not within compiled code for method: ",ip);
         VM.sysWrite("\tsupposed method is ");
@@ -254,6 +264,17 @@ public abstract class CompiledMethod {
   }
 
   /**
+   * Return the address of the instruction at offset offset in the method's instruction stream.
+   * @param offset the offset of the desired instruction (as returned by getInstructionOffset)
+   * @return Address of the specified instruction
+   */
+  @Uninterruptible
+  public final Address getInstructionAddress(boolean inJoin, Offset offset) {
+    Address startAddress = Magic.objectAsAddress(inJoin ? joinInstructions : instructions);
+    return startAddress.plus(offset);
+  }
+
+  /**
    * Return the code array for this method that contains the given offset.
    * @param offset the offset of the desired instruction (as returned by getInstructionOffset)
    * @return CodeArray that contains the specified instruction
@@ -263,13 +284,8 @@ public abstract class CompiledMethod {
     return instructions;
   }
 
-  /**
-   * Does the code for the compiled method contain the given return address?
-   * @param ip a return address
-   * @return {@code true} if it belongs to this method's code, {@code false} otherwise.
-   */
   @Uninterruptible
-  public final boolean containsReturnAddress(Address ip) {
+  private static final boolean inRange(Address ip, CodeArray instructions) {
     Address beg = Magic.objectAsAddress(instructions);
     Address end = beg.plus(instructions.length() << ArchConstants.getLogInstructionWidth());
 
@@ -281,12 +297,38 @@ public abstract class CompiledMethod {
   }
 
   /**
+   * Does the code for the compiled method contain the given return address?
+   * @param ip a return address
+   * @return {@code true} if it belongs to this method's code, {@code false} otherwise.
+   */
+  @Uninterruptible
+  public final boolean containsReturnAddress(Address ip) {
+    return inRange(ip, instructions) || inJoinInstructions(ip);
+  }
+
+  @Uninterruptible
+  public final boolean inJoinInstructions(Address ip) {
+    return joinInstructions != null && inRange(ip, joinInstructions);
+  }
+
+  @Uninterruptible
+  public final boolean hasJoinInstructions() {
+    return joinInstructions != null && joinInstructions != instructions;
+  }
+
+  @Uninterruptible
+  public final Offset joinDelta() {
+    return Magic.objectAsAddress(joinInstructions).diff(Magic.objectAsAddress(instructions));
+  }
+
+  /**
    * Records that the compilation is complete.
    *
    * @param code the method's code
    */
-  public final void compileComplete(CodeArray code) {
+  public final void compileComplete(CodeArray code, CodeArray joinCode) {
     instructions = code;
+    joinInstructions = joinCode;
     flags |= COMPILED;
   }
 
@@ -363,7 +405,7 @@ public abstract class CompiledMethod {
   }
 
   public final double getCompilationTime() {
-    return compilationTime;
+    return (double)compilationTime;
   }
 
   public final void setCompilationTime(double ct) {
@@ -412,7 +454,7 @@ public abstract class CompiledMethod {
   /**
    * Find "catch" block for a machine instruction of
    * this method that might be guarded
-   * against specified class of exceptions by a "try" block.<p>
+   * against specified class of exceptions by a "try" block.
    *
    * Notes:
    * <ul>
@@ -440,11 +482,15 @@ public abstract class CompiledMethod {
    * (-1 --&gt; no catch block)
    */
   @Unpreemptible
-  public abstract int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType);
+  public abstract Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType);
 
   /**
    * Fetch symbolic reference to a method that's called by one of
    * this method's instructions.<p>
+   * this method's instructions.
+   * @param dynamicLink place to put return information
+   * @param instructionOffset offset of machine instruction from start of
+   * this method, in bytes
    *
    * Notes:
    * <ul>
@@ -464,9 +510,6 @@ public abstract class CompiledMethod {
    * GC disabled when called by GCMapIterator.
    * </ul>
    *
-   * @param dynamicLink place to put return information
-   * @param instructionOffset offset of machine instruction from start of
-   * this method, in bytes
    */
   @Uninterruptible
   public abstract void getDynamicLink(DynamicLink dynamicLink, Offset instructionOffset);
@@ -475,6 +518,10 @@ public abstract class CompiledMethod {
    * Find source line number corresponding to one of this method's
    * machine instructions.
    *
+   * @param instructionOffset of machine instruction from start of this method, in bytes
+   * @return source line number
+   *  (0 == no line info available, 1 == first line of source file)
+   *  
    * <p> Usage note: "instructionOffset" must point to the
    * instruction <em> following </em> the actual instruction
    * whose line number is sought.
diff --git a/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java b/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java
index f86771d..fa21212 100644
--- a/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java
+++ b/rvm/src/org/jikesrvm/compilers/common/ExceptionTable.java
@@ -20,6 +20,8 @@ import org.jikesrvm.util.Services;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.pragma.Unpreemptible;
 import org.vmmagic.unboxed.Offset;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
+import org.vmmagic.pragma.UnpreemptibleNoWarn;
 
 /**
  * Encoding of try ranges in the final machinecode and the
@@ -42,10 +44,11 @@ public abstract class ExceptionTable {
    * @param eTable the encoded exception table to search
    * @param instructionOffset the offset of the instruction after the PEI.
    * @param exceptionType the type of exception that was raised
+   * @param exactType only match exact exception types.
    * @return the machine code offset of the catch block.
    */
   @Unpreemptible
-  public static int findCatchBlockForInstruction(int[] eTable, Offset instructionOffset, RVMType exceptionType) {
+  public static Offset findCatchBlockForInstruction(int[] eTable, Offset instructionOffset, RVMType exceptionType, boolean exactType) {
     for (int i = 0, n = eTable.length; i < n; i += 4) {
       // note that instructionOffset points to the instruction after the PEI
       // so the range check here must be "offset >  beg && offset <= end"
@@ -56,16 +59,16 @@ public abstract class ExceptionTable {
           instructionOffset.sLE(Offset.fromIntSignExtend(eTable[i + TRY_END]))) {
         RVMType lhs = RVMType.getType(eTable[i + EX_TYPE]);
         if (lhs == exceptionType) {
-          return eTable[i + CATCH_START];
-        } else if (lhs.isInitialized()) {
+          return Offset.fromIntSignExtend(eTable[i + CATCH_START]);
+        } else if (!exactType && lhs.isInitialized()) {
           TIB rhsTIB = exceptionType.getTypeInformationBlock();
           if (DynamicTypeCheck.instanceOfClass(lhs.asClass(), rhsTIB)) {
-            return eTable[i + CATCH_START];
+            return Offset.fromIntSignExtend(eTable[i + CATCH_START]);
           }
         }
       }
     }
-    return -1;
+    return Offset.fromIntSignExtend(-1);
   }
 
   /**
diff --git a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java
index 2c314de..7ba9599 100644
--- a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java
+++ b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapCompiledMethod.java
@@ -56,8 +56,8 @@ final class HardwareTrapCompiledMethod extends CompiledMethod {
 
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
-    return -1;
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
+    return Offset.fromIntSignExtend(-1);
   }
 
   @Override
diff --git a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java
index 9c771fa..51b785a 100644
--- a/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/compilers/common/HardwareTrapGCMapIterator.java
@@ -21,6 +21,7 @@ import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.AddressArray;
 import org.vmmagic.unboxed.Offset;
 import org.vmmagic.unboxed.WordArray;
+import org.jikesrvm.ia32.RegisterConstants;
 
 /**
  * Iterator for stack frames inserted by hardware trap handler.
@@ -39,6 +40,18 @@ public final class HardwareTrapGCMapIterator extends GCMapIterator {
     this.framePtr = framePtr;
   }
 
+  public final int getNVRegistersSaved() {
+    int result = 0;
+    for (int i=0; i< RegisterConstants.NONVOLATILE_GPRS.length; i++) {
+      result |= (1 << RegisterConstants.NONVOLATILE_GPRS[i].value());
+    }
+    return result;
+  }
+
+  public final int getNVObjectMap() {
+    return 0;
+  }
+
   @Override
   public Address getNextReferenceAddress() {
     // update register locations, noting that the trap handler represented by this stackframe
diff --git a/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java b/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java
index 835cf50..4267d67 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/driver/OptimizingCompiler.java
@@ -181,7 +181,7 @@ public final class OptimizingCompiler implements Callbacks.StartupMonitor {
       // system a chance to eagerly compile any specialized version
       // that are pending.  TODO: use lazy compilation with specialization.
       SpecializationDatabase.doDeferredSpecializations();
-      ir.compiledMethod.compileComplete(ir.MIRInfo.machinecode);
+      ir.compiledMethod.compileComplete(ir.MIRInfo.fastmachinecode, ir.MIRInfo.machinecode);
       return ir.compiledMethod;
     } catch (OptimizingCompilerException e) {
       throw e;
diff --git a/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java b/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java
index f807f64..9883c0c 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/ir/MIRInfo.java
@@ -29,6 +29,11 @@ public final class MIRInfo {
   public CodeArray machinecode;
 
   /**
+   * The generated machinecodes produced by this compilation of 'method'
+   */
+  public CodeArray fastmachinecode;
+
+  /**
    * Estimate produced by FinalMIRExpansion and used by
    * Assembler to create code array; only meaningful on PowerPC
    */
diff --git a/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java b/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java
index 8ef6cdb..2d7b215 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/mir2mc/ia32/AssemblerBase.java
@@ -1280,6 +1280,7 @@ abstract class AssemblerBase extends Assembler {
     if (lister != null) lister.printListing();
 
     ir.MIRInfo.machinecode = getMachineCodes();
+    ir.MIRInfo.fastmachinecode = patchMachineCodeForWorkStealing(ir.MIRInfo.machinecode);
 
     return ir.MIRInfo.machinecode.length();
   }
diff --git a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java
index 077cdb6..257fc1d 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptCompiledMethod.java
@@ -81,13 +81,13 @@ public final class OptCompiledMethod extends CompiledMethod {
    */
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
     if (eTable == null) {
-      return -1;
+      return Offset.fromIntSignExtend(-1);
     } else {
-      int catchOffset = ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType);
+      Offset catchOffset = ExceptionTable.findCatchBlockForInstruction(eTable, instructionOffset, exceptionType, exactType);
       dealWithPossibleRemovalOfCatchBlockByTheOptCompiler(instructionOffset,
-          exceptionType, catchOffset);
+          exceptionType, catchOffset.toInt());
       return catchOffset;
     }
   }
diff --git a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java
index 35b2e7d..6060cb7 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/runtimesupport/OptGenericGCMapIterator.java
@@ -27,6 +27,7 @@ import org.vmmagic.unboxed.Offset;
 import org.vmmagic.unboxed.AddressArray;
 import static org.jikesrvm.compilers.opt.runtimesupport.OptGCMap.FIRST_GCMAP_REG;
 import static org.jikesrvm.compilers.opt.runtimesupport.OptGCMap.LAST_GCMAP_REG;
+import org.jikesrvm.ia32.RegisterConstants;
 
 /**
  * This class contains its architecture-independent code for iteration
@@ -180,6 +181,34 @@ public abstract class OptGenericGCMapIterator extends GCMapIterator {
     }
   }
 
+  public final int getNVRegistersSaved() {
+    int result = 0;
+    int frameOffset = compiledMethod.getUnsignedNonVolatileOffset();
+    if (frameOffset >= 0) {
+      int first = compiledMethod.getFirstNonVolatileGPR();
+      if (first >= 0) {
+        for (int i = first; i < RegisterConstants.NUM_NONVOLATILE_GPRS; i++) {
+          result |= (1 << RegisterConstants.NONVOLATILE_GPRS[i].value());
+        }
+      }
+    }
+    return result;
+  }
+
+  public final int getNVObjectMap() {
+    int result = 0;
+    if (mapIndex == OptGCMap.NO_MAP_ENTRY) {
+      return 0;
+    }
+    for(int i=0; i < RegisterConstants.NONVOLATILE_GPRS.length; i++) {
+      int reg = RegisterConstants.NONVOLATILE_GPRS[i].value();
+      if (map.registerIsSet(mapIndex, reg)) {
+        result |= (1 << reg);
+      }
+    }
+    return result;
+  }
+
   /**
    * Returns the next address that contains a reference
    * @return the value of the next reference
diff --git a/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java b/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java
index 5e082a8..af2d798 100644
--- a/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java
+++ b/rvm/src/org/jikesrvm/ia32/OutOfLineMachineCode.java
@@ -578,7 +578,7 @@ public abstract class OutOfLineMachineCode {
     Assembler asm = new Assembler(0);
 
     /* push the hijacked return address (which is held in thread-local state) */
-    asm.emitPUSH_RegDisp(TR, ArchEntrypoints.hijackedReturnAddressField.getOffset());
+    //asm.emitPUSH_RegDisp(TR, ArchEntrypoints.hijackedReturnAddressField.getOffset());
 
     /* push the GPRs and fp */
     for (int i = 0; i < NUM_GPRS; i++) {
@@ -595,6 +595,19 @@ public abstract class OutOfLineMachineCode {
       asm.emitPOP_Reg(ALL_GPRS[i]);
     }
 
+    /*
+     * When doing Try-Catch work-stealing, it might be the case that the victim is intended to
+     * return to an address A from the return barrier, but once it has branched into the
+     * return barrier it finds that now that return address A is no more valid
+     * as it has been stolen. Now in this case it should not return to A and instead
+     * return to some new address B. This change is possible only if the return address
+     * is PUSH at this point and not in the begining of this call --  generateStackTrampolineBridgeInstructions().
+     *
+     */
+
+    /* push the hijacked return address (which is held in thread-local state) */
+    asm.emitPUSH_RegDisp(TR, ArchEntrypoints.hijackedReturnAddressField.getOffset());
+
     /* pop the hijacked return address and return */
     asm.emitRET();
 
diff --git a/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java b/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java
index 114770e..6f252d0 100644
--- a/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java
+++ b/rvm/src/org/jikesrvm/jni/JNICompiledMethod.java
@@ -95,8 +95,8 @@ public final class JNICompiledMethod extends CompiledMethod {
 
   @Override
   @Unpreemptible
-  public int findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType) {
-    return -1;
+  public Offset findCatchBlockForInstruction(Offset instructionOffset, RVMType exceptionType, boolean exactType) {
+    return Offset.fromIntSignExtend(-1);
   }
 
   @Override
diff --git a/rvm/src/org/jikesrvm/jni/JNIFunctions.java b/rvm/src/org/jikesrvm/jni/JNIFunctions.java
index e7e1a57..a361266 100644
--- a/rvm/src/org/jikesrvm/jni/JNIFunctions.java
+++ b/rvm/src/org/jikesrvm/jni/JNIFunctions.java
@@ -5615,7 +5615,7 @@ public class JNIFunctions {
 
     try {
       Object obj = env.getJNIRef(objJREF);
-      ObjectModel.genericLock(obj);
+      ObjectModel.genericLock_internal(obj);
       return 0;
     } catch (Throwable unexpected) {
       if (traceJNI) unexpected.printStackTrace(System.err);
@@ -5635,7 +5635,7 @@ public class JNIFunctions {
 
     try {
       Object obj = env.getJNIRef(objJREF);
-      ObjectModel.genericUnlock(obj);
+      ObjectModel.genericUnlock_internal(obj);
       return 0;
     } catch (Throwable unexpected) {
       if (traceJNI) unexpected.printStackTrace(System.err);
diff --git a/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java b/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java
index 16f675a..f9dd3c7 100644
--- a/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java
+++ b/rvm/src/org/jikesrvm/jni/ia32/JNICompiler.java
@@ -668,7 +668,7 @@ public abstract class JNICompiler {
     }
 
     CodeArray code = asm.getMachineCodes();
-    cm.compileComplete(code);
+    cm.compileComplete(code, code);
     return cm;
   }
 
diff --git a/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java b/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java
index 7f8c73c..2b506e5 100644
--- a/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/jni/ia32/JNIGCMapIterator.java
@@ -55,6 +55,14 @@ public final class JNIGCMapIterator extends AbstractJNIGCMapIterator {
     super(registerLocations);
   }
 
+  public final int getNVRegistersSaved() {
+    return (1 << EDI.value()) | (1 << EBX.value()) | (1 << EBP.value());
+  }
+
+  public final int getNVObjectMap() {
+    return 0;
+  }
+
   @Override
   protected void setupIteratorForArchitecture() {
     // nothing to do for IA32
diff --git a/rvm/src/org/jikesrvm/jni/ppc/JNICompiler.java b/rvm/src/org/jikesrvm/jni/ppc/JNICompiler.java
index 83132b9..89635d2 100644
--- a/rvm/src/org/jikesrvm/jni/ppc/JNICompiler.java
+++ b/rvm/src/org/jikesrvm/jni/ppc/JNICompiler.java
@@ -457,7 +457,8 @@ public abstract class JNICompiler {
     asm.emitMTCTR(T1);                         // point LR to the exception delivery code
     asm.emitBCCTR();                           // then branch to the exception delivery code, does not return
 
-    cm.compileComplete(asm.getMachineCodes());
+    // TryCatchWS: Not sure about the fix but as TryCatchWS isn't supported for ppc yet commenting this line.
+    // cm.compileComplete(asm.getMachineCodes()); 
     return cm;
   }
 
diff --git a/rvm/src/org/jikesrvm/jni/ppc/JNIGCMapIterator.java b/rvm/src/org/jikesrvm/jni/ppc/JNIGCMapIterator.java
index 9c21e0d..0cf36d8 100644
--- a/rvm/src/org/jikesrvm/jni/ppc/JNIGCMapIterator.java
+++ b/rvm/src/org/jikesrvm/jni/ppc/JNIGCMapIterator.java
@@ -39,6 +39,16 @@ import org.vmmagic.unboxed.AddressArray;
 @Uninterruptible
 public final class JNIGCMapIterator extends AbstractJNIGCMapIterator {
 
+  // This method is currently undefined for ppc as TryCatchWS is only supported for ia32
+  public int getNVRegistersSaved() {
+    return -1;
+  }
+
+  // This method is currently undefined for ppc as TryCatchWS is only supported for ia32
+  public int getNVObjectMap() {
+    return -1;
+  }
+
   // non-volitile regs are saved at the end of the transition frame,
   // after the saved JTOC and SP, and preceeded by a GC flag.
   //
diff --git a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java
index c3e1670..37763bf 100644
--- a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java
+++ b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIterator.java
@@ -94,6 +94,10 @@ public abstract class GCMapIterator {
    */
   public abstract void cleanupPointers();
 
+  public abstract int getNVRegistersSaved();
+
+  public abstract int getNVObjectMap();
+
   /**
    * Get the type of this iterator (BASELINE, OPT, etc.).
    * Called from GCMapIteratorGroup to select which iterator
diff --git a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java
index e637025..b3d3425 100644
--- a/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java
+++ b/rvm/src/org/jikesrvm/mm/mminterface/GCMapIteratorGroup.java
@@ -22,6 +22,9 @@ import org.jikesrvm.scheduler.RVMThread;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.Address;
 import org.vmmagic.unboxed.AddressArray;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
+import org.jikesrvm.ia32.RegisterConstants;
 
 /**
  * Maintains a collection of compiler specific GCMapIterators that are used
@@ -80,6 +83,18 @@ public final class GCMapIteratorGroup {
     hardwareTrapIterator = new HardwareTrapGCMapIterator(registerLocations);
   }
 
+  @Uninterruptible
+  public void dump() {
+    VM.sysWrite("GCMapIteratorGroup: registerLocations:");
+    for(int i=0; i<RegisterConstants.NUM_GPRS; i++)  {
+      VM.sysWrite("[",i,"] = ");
+      VM.sysWrite(registerLocations.get(i));
+      VM.sysWrite(":",registerLocations.get(i).loadWord());
+      VM.sysWrite(" ");
+    }
+    VM.sysWriteln();
+  }
+
   /**
    * Prepare to scan a thread's stack for object references.
    * Called by collector threads when beginning to scan a threads stack.
@@ -110,6 +125,24 @@ public final class GCMapIteratorGroup {
   }
 
   /**
+   * Copy out the current register values from register location information.
+   *
+   * @param registerLocation Where to copy the values to.
+   */
+  @Uninterruptible
+  public void copyRegisterValues(Address registerLocation) {
+    for (int i = 0; i < RegisterConstants.NUM_GPRS; ++i) {
+      registerLocation.store(registerLocations.get(i).loadWord());
+      registerLocation = registerLocation.plus(BYTES_IN_ADDRESS);
+    }
+  }
+
+  @Uninterruptible
+  public Address getRegisterLocation(int reg) {
+    return registerLocations.get(reg);
+  }
+
+  /**
    * Select iterator for scanning for object references in a stackframe.
    * Called by collector threads while scanning a threads stack.
    *
diff --git a/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java b/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java
index a99047c..9d3cb5d 100644
--- a/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java
+++ b/rvm/src/org/jikesrvm/objectmodel/ObjectModel.java
@@ -36,6 +36,7 @@ import org.vmmagic.unboxed.Extent;
 import org.vmmagic.unboxed.ObjectReference;
 import org.vmmagic.unboxed.Offset;
 import org.vmmagic.unboxed.Word;
+import org.jikesrvm.scheduler.WS;
 
 /**
  * The interface to the object model definition accessible to the
@@ -552,6 +553,7 @@ public class ObjectModel {
   @Entrypoint
   @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
   public static void genericLock(Object o) {
+    WS.pauseStealOnThread();
     JavaHeader.genericLock(o);
   }
 
@@ -559,6 +561,25 @@ public class ObjectModel {
   @Unpreemptible("No preemption normally, but may raise exceptions")
   public static void genericUnlock(Object o) {
     JavaHeader.genericUnlock(o);
+    WS.resumeStealOnThread();
+  }
+
+  /**
+   * Generic lock - Work-Stealing Specific
+   */
+  @Entrypoint
+  @Unpreemptible("Become another thread when lock is contended, don't preempt in other cases")
+  public static void genericLock_internal(Object o) {
+    JavaHeader.genericLock(o);
+  }
+
+  /**
+   * Generic lock - Work-Stealing Specific
+   */
+  @Entrypoint
+  @Unpreemptible("No preemption normally, but may raise exceptions")
+  public static void genericUnlock_internal(Object o) {
+    JavaHeader.genericUnlock(o);
   }
 
   /**
diff --git a/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java b/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java
index fb42ae0..77965cd 100644
--- a/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java
+++ b/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java
@@ -80,7 +80,7 @@ public final class ArchEntrypoints {
   public static final RVMField trampolineRegistersField =
         EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "trampolineRegisters", "Lorg/jikesrvm/architecture/AbstractRegisters;");
   public static final RVMField hijackedReturnAddressField =
-    EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "hijackedReturnAddress", "Lorg/vmmagic/unboxed/Address;");
+    EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "hijackedReturnAddress_original", "Lorg/vmmagic/unboxed/Address;");
   public static final RVMField registersIPField =
       EntrypointHelper.getField("Lorg/jikesrvm/architecture/AbstractRegisters;", "ip", "Lorg/vmmagic/unboxed/Address;");
   public static final RVMField registersFPRsField = EntrypointHelper.getField("Lorg/jikesrvm/architecture/AbstractRegisters;", "fprs", "[D");
diff --git a/rvm/src/org/jikesrvm/runtime/BootRecord.java b/rvm/src/org/jikesrvm/runtime/BootRecord.java
index 95e2dde..3ed38a6 100644
--- a/rvm/src/org/jikesrvm/runtime/BootRecord.java
+++ b/rvm/src/org/jikesrvm/runtime/BootRecord.java
@@ -266,6 +266,11 @@ public class BootRecord {
   public Address sysNumProcessorsIP;
   public Address sysThreadBindSupportedIP;
   public Address sysThreadBindIP;
+  public Address sysThreadBindMaskSetIP;
+  public Address wsIniatilizeSysThreadBindMaskIP;
+  public Address wsThreadBindMaskSetIP;
+  public Address sysCheckNUMAnodeIP;
+  public Address sysGetCPUIP;
   public Address sysThreadCreateIP;
   public Address sysThreadYieldIP;
   public Address sysGetThreadIdIP;
@@ -407,4 +412,13 @@ public class BootRecord {
   public Address sysPerfEventDisableIP;
   public Address sysPerfEventReadIP;
 
+  // per thread perf event support
+  public Address sysPerfEventInit_threadIP;
+  public Address sysPerfEventCreate_threadIP;
+  public Address sysPerfEventOpen_threadIP;
+  public Address sysPerfEventClose_threadIP;
+  public Address sysPerfEventEnable_threadIP;
+  public Address sysPerfEventDisable_threadIP;
+  public Address sysPerfEventRead_threadIP;
+
 }
diff --git a/rvm/src/org/jikesrvm/runtime/CommandLineArgs.java b/rvm/src/org/jikesrvm/runtime/CommandLineArgs.java
index 600a9f7..2f5cf04 100644
--- a/rvm/src/org/jikesrvm/runtime/CommandLineArgs.java
+++ b/rvm/src/org/jikesrvm/runtime/CommandLineArgs.java
@@ -27,6 +27,7 @@ import org.jikesrvm.compilers.baseline.BaselineOptions;
 import org.jikesrvm.compilers.common.RuntimeCompiler;
 import org.jikesrvm.mm.mminterface.MemoryManager;
 import org.jikesrvm.scheduler.RVMThread;
+import org.jikesrvm.scheduler.WS;
 
 /**
  * Command line option processing iwth arbitrary prefix support.
@@ -83,7 +84,18 @@ public class CommandLineArgs {
     BOOTCLASSPATH_P_ARG,
     BOOTCLASSPATH_A_ARG,
     BOOTSTRAP_CLASSES_ARG,
-    AVAILABLE_PROCESSORS_ARG
+    AVAILABLE_PROCESSORS_ARG,
+    WS_PIN_MAP_APP_THREADS,
+    WS_AUTO_PIN_APP_THREAD,
+    WS_PIN_LOG,
+    WS_PIN_SOCKETS_HINT,
+    WS_PIN_MAP_SYSTEM_THREADS,
+    PER_THREAD_PERF_EVENTS,
+    WS_PIN_MAP_GC_THREADS,
+    WS_PROCS,
+    WS_AUTOGEN_WSTHREADS,
+    WS_RETURN_BARRIER,
+    WS_STATISTICS,
   }
 
   /** Represent a single command line prefix */
@@ -213,6 +225,18 @@ public class CommandLineArgs {
                                             new Prefix("-X:vm$", PrefixType.HELP_ARG),
                                             new Prefix("-X:vm:", PrefixType.ARG),
 
+					    new Prefix("-Xws:pinMap=", PrefixType.WS_PIN_MAP_APP_THREADS),
+                                            new Prefix("-Xws:pinAuto=", PrefixType.WS_AUTO_PIN_APP_THREAD),
+                                            new Prefix("-Xws:pinLog=", PrefixType.WS_PIN_LOG),
+                                            new Prefix("-Xws:pinSocketCPU=", PrefixType.WS_PIN_SOCKETS_HINT),
+                                            new Prefix("-Xws:pinMapSys=", PrefixType.WS_PIN_MAP_SYSTEM_THREADS),
+                                            new Prefix("-Xws:perfEvent=", PrefixType.PER_THREAD_PERF_EVENTS),
+                                            new Prefix("-Xws:pinMapGC=", PrefixType.WS_PIN_MAP_GC_THREADS),
+                                            new Prefix("-Xws:procs=", PrefixType.WS_PROCS),
+                                            new Prefix("-Xws:autoThreads=", PrefixType.WS_AUTOGEN_WSTHREADS),
+                                            new Prefix("-Xws:retBarrier=", PrefixType.WS_RETURN_BARRIER),
+                                            new Prefix("-Xws:stats=", PrefixType.WS_STATISTICS),
+
                                             /* Silently ignored */
                                             new Prefix("-Xverify", PrefixType.VERIFY_ARG),
 
@@ -691,6 +715,58 @@ public class CommandLineArgs {
             VM.sysExit(EXIT_STATUS_BOGUS_COMMAND_LINE_ARG);
           }
           break;
+        case WS_PIN_MAP_APP_THREADS:
+                final String[] map_ws = arg.split(":");
+                RVMThread.pin_map_workers = new int[map_ws.length];
+                RVMThread.ws_pinning_workers = true;
+                for(int xx=0; xx<map_ws.length; xx++) RVMThread.pin_map_workers[xx] = primitiveParseInt(map_ws[xx]);
+            break;
+        case WS_AUTO_PIN_APP_THREAD:
+                final String[] pinning = getArgs(PrefixType.WS_AUTO_PIN_APP_THREAD);
+                RVMThread.ws_pinning_workers = pinning[0].equals("true");
+            break;
+        case WS_PIN_LOG:
+                final String[] trace = getArgs(PrefixType.WS_PIN_LOG);
+                WS.pinLog = trace[0].equals("true");
+            break;
+        case WS_PIN_SOCKETS_HINT:
+                // cpuMap = <Total Sockets>:<Core Per Socket>
+                RVMThread.ws_pinning_workers = true;
+                final String[] sockets = arg.split(":");
+                RVMThread.sockets = primitiveParseInt(sockets[0]);
+                RVMThread.cpusPerSocket = primitiveParseInt(sockets[1]);
+            break;
+        case WS_PIN_MAP_SYSTEM_THREADS:
+                final String[] map_sys = arg.split(":");
+                RVMThread.pin_map_system = new int[map_sys.length];
+                RVMThread.ws_pinning_system = true;
+                for(int xx=0; xx<map_sys.length; xx++) RVMThread.pin_map_system[xx] = primitiveParseInt(map_sys[xx]);
+            break;
+        case WS_PIN_MAP_GC_THREADS:
+                final String[] map_gc = arg.split(":");
+                RVMThread.pin_map_gc = new int[map_gc.length];
+                RVMThread.ws_pinning_gc = true;
+                for(int xx=0; xx<map_gc.length; xx++) RVMThread.pin_map_gc[xx] = primitiveParseInt(map_gc[xx]);
+                break;
+        case PER_THREAD_PERF_EVENTS:
+        	final String[] perf_ws = getArgs(PrefixType.PER_THREAD_PERF_EVENTS);
+        	RVMThread.wsPerThreadPerf = perf_ws[0].equals("true");
+        	break;
+        case WS_PROCS:
+        	WS.wsProcs = primitiveParseInt(arg);
+        	break;
+        case WS_AUTOGEN_WSTHREADS:
+//        	final String[] autogen_ws = getArgs(PrefixType.WS_AUTOGEN_WSTHREADS);
+//        	RVMThread.autogenWSThread = autogen_ws[0].equals("true");
+        	break;
+        case WS_RETURN_BARRIER:
+        	final String[] useBarrier = getArgs(PrefixType.WS_RETURN_BARRIER);
+        	RVMThread.wsRetBarrier = useBarrier[0].equals("true");
+        	break;
+        case WS_STATISTICS:
+        	final String[] wsStats = getArgs(PrefixType.WS_STATISTICS);
+        	WS.stats = wsStats[0].equals("true");
+        	break;
       }
     }
   }
diff --git a/rvm/src/org/jikesrvm/runtime/Entrypoints.java b/rvm/src/org/jikesrvm/runtime/Entrypoints.java
index 330420e..a41eafe 100644
--- a/rvm/src/org/jikesrvm/runtime/Entrypoints.java
+++ b/rvm/src/org/jikesrvm/runtime/Entrypoints.java
@@ -19,6 +19,7 @@ import org.jikesrvm.VM;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.NormalMethod;
+import org.jikesrvm.classloader.MemberReference;
 
 /**
  * Fields and methods of the virtual machine that are needed by
@@ -255,6 +256,8 @@ public class Entrypoints {
   public static final RVMField lockThreadField =
       getField(org.jikesrvm.mm.mmtk.Lock.class, "thread", org.jikesrvm.scheduler.RVMThread.class);
   */
+  public static final RVMField wsFinishCountField = getField(org.jikesrvm.scheduler.WS.FinishInfo.class, "count", int.class);
+  public static final RVMField wsFinishDataField = getField(org.jikesrvm.scheduler.WS.FinishInfo.class, "data", org.jikesrvm.scheduler.WS.FinishData.class);
   public static final RVMField lockStateField = getField(org.jikesrvm.mm.mmtk.Lock.class, "state", int.class);
   public static final RVMField SQCFField = getField(org.mmtk.utility.deque.SharedDeque.class, "completionFlag", int.class);
   public static final RVMField SQNCField = getField(org.mmtk.utility.deque.SharedDeque.class, "numConsumers", int.class);
@@ -377,6 +380,11 @@ public class Entrypoints {
   public static final NormalMethod modifyCheckMethod =
       getMethod(org.jikesrvm.mm.mminterface.MemoryManager.class, "modifyCheck", "(Ljava/lang/Object;)V");
 
+  public static final MemberReference workStealingJoinMethod =
+    getMethod(org.jikesrvm.scheduler.WS.class, "join", "()V").getMemberRef();
+  public static final MemberReference workStealingFinishMethod =
+    getMethod(org.jikesrvm.scheduler.WS.class, "finish", "()V").getMemberRef();
+
   // used in boot image writer
   public static final RVMField debugRequestedField =
       getField(org.jikesrvm.scheduler.RVMThread.class, "debugRequested", boolean.class);
diff --git a/rvm/src/org/jikesrvm/runtime/Magic.java b/rvm/src/org/jikesrvm/runtime/Magic.java
index f4dc00a..318c7d4 100644
--- a/rvm/src/org/jikesrvm/runtime/Magic.java
+++ b/rvm/src/org/jikesrvm/runtime/Magic.java
@@ -188,6 +188,11 @@ public final class Magic {
     return getReturnAddress(fp, RVMThread.getCurrentThread());
   }
 
+  @Uninterruptible
+  public static Address getReturnAddress_debug(Address fp) {
+    return getReturnAddress_debug(fp, RVMThread.getCurrentThread());
+  }
+
   /**
    * Get return address for a frame in a specific thread
    *
@@ -204,6 +209,18 @@ public final class Magic {
       return ip;
   }
 
+  @Uninterruptible
+  public static Address getReturnAddress_debug(Address fp, RVMThread thread) {
+    Address ip = getReturnAddressLocation(fp).loadAddress();
+    if (RVMThread.isTrampolineIP(ip)) {
+      VM.sysWrite("<H>");
+      return thread.getTrampolineHijackedReturnAddress();
+    }
+    else{
+      return ip;
+    }
+  }
+
   /**
    * Sets return address for a frame.
    * @param fp its frame pointer
diff --git a/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java b/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java
index ab785ee..80d5e89 100644
--- a/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java
+++ b/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java
@@ -695,12 +695,16 @@ public class RuntimeEntrypoints {
   @Entrypoint
   @UnpreemptibleNoWarn
   static void deliverHardwareException(int trapCode, Word trapInfo) {
-    if (VM.verboseSignalHandling) VM.sysWriteln("delivering hardware exception");
+    if (/*VM.verboseSignalHandling*/true) VM.sysWriteln("delivering hardware exception");
     RVMThread myThread = RVMThread.getCurrentThread();
-    if (VM.verboseSignalHandling) VM.sysWriteln("we have a thread = ",Magic.objectAsAddress(myThread));
-    if (VM.verboseSignalHandling) VM.sysWriteln("it's in state = ",myThread.getExecStatus());
+    if (true) {
+      VM.sysWriteln("we have a thread = ",Magic.objectAsAddress(myThread));
+      VM.sysWriteln("The thread id = ",myThread.getId());
+    }
+    if (true) VM.sysWriteln("it's in state = ",myThread.getExecStatus());
+    RVMThread.dumpWSDetailsWhileDeliveringHardwareException();
     AbstractRegisters exceptionRegisters = myThread.getExceptionRegisters();
-    if (VM.verboseSignalHandling) VM.sysWriteln("we have exception registers = ",Magic.objectAsAddress(exceptionRegisters));
+    if (true) VM.sysWriteln("we have exception registers = ",Magic.objectAsAddress(exceptionRegisters));
 
     if ((trapCode == TRAP_STACK_OVERFLOW || trapCode == TRAP_JNI_STACK) &&
         myThread.getStack().length < (StackFrameLayout.getMaxStackSize() >> LOG_BYTES_IN_ADDRESS) &&
@@ -1024,7 +1028,7 @@ public class RuntimeEntrypoints {
    * @param exceptionRegisters register state corresponding to exception site
    */
   @Unpreemptible("Deliver exception trying to avoid preemption")
-  private static void deliverException(Throwable exceptionObject, AbstractRegisters exceptionRegisters) {
+  public static void deliverException(Throwable exceptionObject, AbstractRegisters exceptionRegisters) {
     if (VM.TraceExceptionDelivery) {
       VM.sysWriteln("RuntimeEntrypoints.deliverException() entered; just got an exception object.");
     }
@@ -1050,10 +1054,11 @@ public class RuntimeEntrypoints {
         CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
         ExceptionDeliverer exceptionDeliverer = compiledMethod.getExceptionDeliverer();
         Address ip = exceptionRegisters.getInnermostInstructionAddress();
+        boolean inJoin = compiledMethod.inJoinInstructions(ip);
         Offset ipOffset = compiledMethod.getInstructionOffset(ip);
-        int catchBlockOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, exceptionType);
+        Offset catchBlockOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, exceptionType, false);
 
-        if (catchBlockOffset >= 0) {
+        if (catchBlockOffset.sGE(Offset.zero())) {
           // found an appropriate catch block
           if (VM.TraceExceptionDelivery) {
             VM.sysWriteln("found one; delivering.");
@@ -1063,7 +1068,7 @@ public class RuntimeEntrypoints {
             if (RVMThread.DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("leapfrogged...");
             t.deInstallStackTrampoline();
           }
-          Address catchBlockStart = compiledMethod.getInstructionAddress(Offset.fromIntSignExtend(catchBlockOffset));
+          Address catchBlockStart = compiledMethod.getInstructionAddress(inJoin, catchBlockOffset);
           exceptionDeliverer.deliverException(compiledMethod, catchBlockStart, exceptionObject, exceptionRegisters);
           if (VM.VerifyAssertions) VM._assert(NOT_REACHED);
         }
diff --git a/rvm/src/org/jikesrvm/runtime/SysCall.java b/rvm/src/org/jikesrvm/runtime/SysCall.java
index 5ef6e19..7fb5e43 100644
--- a/rvm/src/org/jikesrvm/runtime/SysCall.java
+++ b/rvm/src/org/jikesrvm/runtime/SysCall.java
@@ -56,6 +56,23 @@ public abstract class SysCall {
     }
   }
 
+  /*
+   * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+   * From here---->
+   */
+  @SysCallTemplate
+  public abstract void wsThreadBindMaskSet(int cpuMask);
+  @SysCallTemplate
+  public abstract void sysThreadBindMaskSet();
+  @SysCallTemplate
+  public abstract void wsIniatilizeSysThreadBindMask(int cpuMask);
+  @SysCallTemplate
+  public abstract int sysGetCPU();
+  /*
+   * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+   * Till here <----
+   */
+
   // lowlevel write to console
   @SysCallTemplate
   public abstract void sysConsoleWriteChar(char v);
@@ -133,6 +150,26 @@ public abstract class SysCall {
   public abstract void sysSyncCache(Address address, int size);
 
   /*
+   * Interface to per thread performance events
+   */
+  @SysCallTemplate
+  public abstract int sysCheckNUMAnode(Address location);
+  @SysCallTemplate
+  public abstract int sysPerfEventInit_thread(int events);
+  @SysCallTemplate
+  public abstract int sysPerfEventCreate_thread(int id, byte[] name);
+  @SysCallTemplate
+  public abstract void sysPerfEventClose_thread(int id, int[] fds);
+  @SysCallTemplate
+  public abstract void sysPerfEventOpen_thread(int id, Word tid, int[] fds);
+  @SysCallTemplate
+  public abstract int sysPerfEventEnable_thread(int[] fds, int n);
+  @SysCallTemplate
+  public abstract void sysPerfEventDisable_thread(int[] fds, int n);
+  @SysCallTemplate
+  public abstract int sysPerfEventRead_thread(int id, int[] fds, long[] values);
+
+  /*
    * Interface to performance events
    */
   @SysCallTemplate
diff --git a/rvm/src/org/jikesrvm/scheduler/MainThread.java b/rvm/src/org/jikesrvm/scheduler/MainThread.java
index 9f7195c..4e6d901 100644
--- a/rvm/src/org/jikesrvm/scheduler/MainThread.java
+++ b/rvm/src/org/jikesrvm/scheduler/MainThread.java
@@ -147,6 +147,19 @@ public final class MainThread extends Thread {
 
     if (dbg) VM.sysWriteln("MainThread.run() starting ");
 
+    //Work-stealing
+    if(RVMThread.autogenWSThread && !RVMThread.wsThreadsLaunched) {
+      RVMThread.wsThreadsLaunched = true;
+      RVMThread.getCurrentThread().setWorkerAsVictim();
+      Runnable tRun = new Runnable() {
+        public void run() { WS.workerMain(); }
+      };
+      WS.register();
+      for(int i=0; i<WS.wsProcs-1; i++) {
+        new Thread(tRun).start();
+      }
+    }
+
     // Set up application class loader
     ClassLoader cl = RVMClassLoader.getApplicationClassLoader();
     setContextClassLoader(cl);
@@ -200,5 +213,8 @@ public final class MainThread extends Thread {
     // invoke "main" method with argument list
     Reflection.invoke(mainMethod, null, null, new Object[]{mainArgs}, true);
     if (dbg) VM.sysWriteln("  MainThread.run(): \"main\" method completed.]");
+    if(RVMThread.autogenWSThread && WS.stats) {
+      WS.dumpWSStatistics();
+    }
   }
 }
diff --git a/rvm/src/org/jikesrvm/scheduler/ParallelForWS.java b/rvm/src/org/jikesrvm/scheduler/ParallelForWS.java
new file mode 100644
index 0000000..8e42594
--- /dev/null
+++ b/rvm/src/org/jikesrvm/scheduler/ParallelForWS.java
@@ -0,0 +1,50 @@
+
+/*
+ * Authors: Vivek Kumar
+ */
+
+package org.jikesrvm.scheduler;
+
+public class ParallelForWS {
+	public interface Body {
+		void iters(int from, int to);
+	}
+	
+	public static void launch(Body body, int limit) throws Exception {
+		_$dcFor(0, limit, 1, WS.wsProcs, body);
+	}
+
+	private static void _$dcFor(int _$lower, int _$upper, int _$sliceNum, int procs, Body body) throws Exception {
+		if (_$sliceNum >> 2 < procs) {
+			int var0 = _$lower + _$upper >> 1;
+			int var1 = _$sliceNum << 1;
+			try {
+				WS.setFlag();
+				_$dcFor(_$lower, var0, var1, procs, body);
+				WS.join();
+			} catch (WS.Continuation c) {}
+			_$dcFor(var0, _$upper, var1, procs, body);
+		} else {
+			body.iters(_$lower, _$upper);
+		}
+	}
+
+	public static void launch_noThrowException(Body body, int limit) {
+		_$dcFor_noThrowException(0, limit, 1, WS.wsProcs, body);
+	}
+
+	private static void _$dcFor_noThrowException(int _$lower, int _$upper, int _$sliceNum, int procs, Body body) {
+		if (_$sliceNum >> 2 < procs) {
+			int var0 = _$lower + _$upper >> 1;
+			int var1 = _$sliceNum << 1;
+			try {
+				WS.setFlag();
+				_$dcFor_noThrowException(_$lower, var0, var1, procs, body);
+				WS.join();
+			} catch (WS.Continuation c) {}
+			_$dcFor_noThrowException(var0, _$upper, var1, procs, body);
+		} else {
+			body.iters(_$lower, _$upper);
+		}
+	}
+}
diff --git a/rvm/src/org/jikesrvm/scheduler/RVMThread.java b/rvm/src/org/jikesrvm/scheduler/RVMThread.java
index a7d70fc..6c6895f 100644
--- a/rvm/src/org/jikesrvm/scheduler/RVMThread.java
+++ b/rvm/src/org/jikesrvm/scheduler/RVMThread.java
@@ -21,7 +21,9 @@ import static org.jikesrvm.objectmodel.ThinLockConstants.TL_THREAD_ID_SHIFT;
 
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.util.Random;
 
+import org.jikesrvm.architecture.ArchConstants;
 import org.jikesrvm.VM;
 import org.jikesrvm.adaptive.OSRListener;
 import org.jikesrvm.adaptive.OnStackReplacementEvent;
@@ -47,6 +49,11 @@ import org.jikesrvm.objectmodel.ObjectModel;
 import org.jikesrvm.osr.ObjectHolder;
 import org.jikesrvm.runtime.BootRecord;
 import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.ExceptionDeliverer;
+import org.vmmagic.unboxed.AddressArray;
+//import org.jikesrvm.Constants;
+import org.jikesrvm.ia32.StackframeLayoutConstants;
+import org.jikesrvm.classloader.RVMType;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.runtime.Memory;
 import org.jikesrvm.runtime.RuntimeEntrypoints;
@@ -178,8 +185,8 @@ public final class RVMThread extends ThreadContext {
   private static final boolean tracePriority = false;
 
   /** Never kill threads.  Useful for testing bugs related to interaction of
-      thread death with for example MMTk.  For production, this should never
-      be set to true. */
+    thread death with for example MMTk.  For production, this should never
+    be set to true. */
   private static final boolean neverKillThreads = false;
 
   /** Generate statistics? */
@@ -293,37 +300,13 @@ public final class RVMThread extends ThreadContext {
   public static final int LAST_EXEC_STATUS = 8;
 
   private static final String[] READABLE_EXEC_STATUS =
-    {"NEW", "IN_JAVA", "IN_NATIVE", "IN_JNI", "IN_JAVA_TO_BLOCK",
-      "BLOCKED_IN_NATIVE", "BLOCKED_IN_JNI", "TERMINATED", "LAST_EXEC_STATUS"};
+  {"NEW", "IN_JAVA", "IN_NATIVE", "IN_JNI", "IN_JAVA_TO_BLOCK",
+    "BLOCKED_IN_NATIVE", "BLOCKED_IN_JNI", "TERMINATED", "LAST_EXEC_STATUS"};
 
   public static boolean notRunning(int state) {
     return state == NEW || state == TERMINATED;
   }
 
-  /** Registers used by return barrier trampoline */
-  @Entrypoint
-  private AbstractRegisters trampolineRegisters = ArchitectureFactory.createRegisters();
-
-  /** Return address of stack frame hijacked by return barrier */
-  @Entrypoint
-  private Address hijackedReturnAddress;
-
-  /** Callee frame pointer for stack frame hijacked by return barrier */
-  private Address hijackedReturnCalleeFp = Address.zero();
-
-  /** Caller frame pointer for stack frame hijacked by return barrier */
-  private Address hijackedReturnCallerFp = StackFrameLayout.getStackFrameSentinelFP();
-
-  /** @return the callee frame pointer for the stack frame hijacked by the return barrier */
-  public Address getHijackedReturnCalleeFp() {
-    return hijackedReturnCalleeFp;
-  }
-
-  /** debugging flag for return barrier trampoline */
-  public static final boolean DEBUG_STACK_TRAMPOLINE = false;
-
-  /** pointer to bridge code for return barrier trampoline */
-  public static CodeArray stackTrampolineBridgeInstructions;
 
   /**
    * Thread state. Indicates if the thread is running, and if so, what mode of
@@ -338,7 +321,7 @@ public final class RVMThread extends ThreadContext {
   }
 
   private boolean attemptFastExecStatusTransition(int oldState,
-                                                  int newState) {
+      int newState) {
     if (Synchronization.tryCompareAndSwap(
           this,
           Entrypoints.execStatusField.getOffset(),
@@ -468,7 +451,7 @@ public final class RVMThread extends ThreadContext {
    */
   public static long timerTicks;
 
-  private long yieldpointsTaken;
+  protected long yieldpointsTaken;
 
   private long yieldpointsTakenFully;
 
@@ -641,8 +624,8 @@ public final class RVMThread extends ThreadContext {
    * Place to save register state when this thread is not actually running.
    */
   @Entrypoint(fieldMayBeFinal = true)
-  @Untraced
-  public final AbstractRegisters contextRegisters;
+    @Untraced
+    public final AbstractRegisters contextRegisters;
   @SuppressWarnings("unused")
   @Entrypoint(fieldMayBeFinal = true)
   private final AbstractRegisters contextRegistersShadow;
@@ -651,8 +634,8 @@ public final class RVMThread extends ThreadContext {
    * Place to save register state when this thread is not actually running.
    */
   @Entrypoint(fieldMayBeFinal = true)
-  @Untraced
-  public final AbstractRegisters contextRegistersSave;
+    @Untraced
+    public final AbstractRegisters contextRegistersSave;
   @SuppressWarnings("unused")
   @Entrypoint(fieldMayBeFinal = true)
   private final AbstractRegisters contextRegistersSaveShadow;
@@ -662,8 +645,8 @@ public final class RVMThread extends ThreadContext {
    * software (RuntimeEntrypoints.athrow) trap handling.
    */
   @Entrypoint(fieldMayBeFinal = true)
-  @Untraced
-  private final AbstractRegisters exceptionRegisters;
+    @Untraced
+    private final AbstractRegisters exceptionRegisters;
   @SuppressWarnings("unused")
   @Entrypoint(fieldMayBeFinal = true)
   private final AbstractRegisters exceptionRegistersShadow;
@@ -975,7 +958,7 @@ public final class RVMThread extends ThreadContext {
 
   static final BlockAdapter[] blockAdapters = new BlockAdapter[] {
     suspendBlockAdapter, handshakeBlockAdapter, gcBlockAdapter,
-    stackTraceBlockAdapter };
+      stackTraceBlockAdapter };
 
   /**
    * An enumeration that describes the different manners in which a thread might
@@ -1123,6 +1106,68 @@ public final class RVMThread extends ThreadContext {
    */
   public boolean osr_done = false;
 
+  //per thread perf event support
+  private static boolean PER_THREAD_PERF_MONITORING = false;
+
+  protected int perfEventGroup = -1;
+  // for work-stealing threads
+  protected static final int PERF_EVENT_GROUP_WS = 3;
+  // for OSR_Organizer and Organizer threads
+  protected static final int PERF_EVENT_GROUP_ORGANIZERS = 2;
+  // for org.mmtk.plan.generational.immix.GenImmixCollector* threads
+  protected static final int PERF_EVENT_GROUP_GC = 1;
+  // for CompilationThread; TimerThread; FinalizerThread; 
+  protected static final int PERF_EVENT_GROUP_SYS = 0;
+
+  private static long[] perfEventTotals_ws;
+  private static long[] perfEventTotals_organizers;
+  private static long[] perfEventTotals_gc;
+  private static long[] perfEventTotals_sys;
+
+  public static boolean wsPerThreadPerf = false;
+
+  /*
+   * From Jikes 3.1.3 release, calling getBytes() on a string variable is
+   * generating ArrayIndexOutOfBoundsException in Thread.java: getThreadLocals(): Line 1076
+   * eg. perfEventNames[i].getBytes(). However, calling getBytes() with a string literal
+   * is working fine, eg. "LLC_MISSES".getBytes()
+   * 
+   * As a temporary work-around on this bug, for adding a new perf event:
+   * 1) add a corresponding entry inside RVMThread.perfEventNames and 
+   * 2) also an entry inside switch-case block inside the method 
+   * 	  RVMThread.getPerfEventByteArray(i).
+   * 
+   * If we have to measure the per thread perf event, we use the command line option 
+   * -Xws:perfEvents=true. By default its always false.
+   */
+  public static final String[] perfEventNames = {
+    // Add more Perf Events if necessary
+    "UNHALTED_CORE_CYCLES",
+    "LLC_MISSES",
+    "LLC_REFERENCES"
+      // Also add corresponding entry inside the method getPerfEventByteArray() below
+  };
+
+  private final static byte[] getPerfEventByteArray(int id) {
+    switch(id) {
+      case 0:
+        return "UNHALTED_CORE_CYCLES".concat("\0").getBytes();
+      case 1:
+        return "LLC_MISSES".concat("\0").getBytes();
+      case 2:
+        return "LLC_REFERENCES".concat("\0").getBytes();
+      default:
+        VM.sysFail("Error in fetching perfevent byte array");
+    }
+    return null;
+  }
+
+  private int[] perfEventFds;
+  private static long[][] perfEventperThread;
+  private static int perfEventThreadNum = 0;
+  private static String[] perfEventThreadName;
+  private long[] perfEventTemp = new long[3];
+
   /**
    * The number of processors to use.
    */
@@ -1132,7 +1177,7 @@ public final class RVMThread extends ThreadContext {
    * Thread handle. Currently stores pthread_t, which we assume to be no larger
    * than a pointer-sized word.
    */
-  public Word pthread_id;
+  public Word thread_id;
 
   /**
    * Thread priority handle.  Used when manipulating the threads priority.
@@ -1145,8 +1190,8 @@ public final class RVMThread extends ThreadContext {
    * Used to transfer x87 to SSE registers on IA32
    */
   @SuppressWarnings({ "unused" })
-  @Entrypoint
-  private double scratchStorage;
+    @Entrypoint
+    private double scratchStorage;
 
   /**
    * Current index of this thread in the threads array. This may be changed by
@@ -1352,6 +1397,11 @@ public final class RVMThread extends ThreadContext {
     return result;
   }
 
+  @Inline
+  public Monitor wsLock() {
+    return workStealingLockBySlot[threadSlot];
+  }
+
   public Monitor communicationLock() {
     return communicationLockForSlot(threadSlot);
   }
@@ -1392,8 +1442,8 @@ public final class RVMThread extends ThreadContext {
         VM.sysWriteln("      or: ",READABLE_EXEC_STATUS[expected2]);
         VM.sysWriteln("Observed: ",READABLE_EXEC_STATUS[curStatus]);
         VM._assert(curStatus == expected1 ||
-                   curStatus == expected2);
-      }
+            curStatus == expected2);
+          }
     }
   }
 
@@ -1419,8 +1469,8 @@ public final class RVMThread extends ThreadContext {
         VM.sysWriteln("       and: ",READABLE_EXEC_STATUS[unexpected2]);
         VM.sysWriteln("  Observed: ",READABLE_EXEC_STATUS[curStatus]);
         VM._assert(curStatus != unexpected1 &&
-                   curStatus != unexpected2);
-      }
+            curStatus != unexpected2);
+          }
     }
   }
 
@@ -1438,6 +1488,203 @@ public final class RVMThread extends ThreadContext {
     }
   }
 
+  @Unpreemptible
+  private void perfEventAttach() {
+    if(PER_THREAD_PERF_MONITORING) {
+      int n = perfEventNames.length;
+      perfEventTemp[0] = 0;
+      perfEventTemp[1] = 0;
+      perfEventTemp[2] = 0;
+      perfEventFds = new int[n];
+      if (n > 0) perfEventFds[0] = -1;
+      for (int i = 0; i < n; i++) {
+        sysCall.sysPerfEventOpen_thread(i, thread_id, perfEventFds);
+      }
+    }
+  }
+
+  @Unpreemptible
+  public static void perfEventStart() {
+    if(PER_THREAD_PERF_MONITORING) {
+      hardHandshakeSuspend();
+      for(int i=0; i<numThreads;i++) {
+        threads[i].perfEventEnable();
+      }
+      hardHandshakeResume();
+    }
+  }
+
+  @Unpreemptible
+  private void perfEventEnable() {
+    int n = perfEventNames.length;
+    sysCall.sysPerfEventEnable_thread(perfEventFds,n);
+  }
+
+  @Unpreemptible
+  private void perfEventDisable() {
+    int n = perfEventNames.length;
+    sysCall.sysPerfEventDisable_thread(perfEventFds,n);
+  }
+
+  @UninterruptibleNoWarn
+  private void perfEventDetach() {
+    int n = perfEventNames.length;
+
+    // assign groups to system threads
+    final String threadName = this.getName();
+    if(threadName.contains("Organizer") || threadName.contains("ControllerThread") || threadName.contains("CompilationThread") ) {
+      perfEventGroup = PERF_EVENT_GROUP_ORGANIZERS;
+    }
+    else if(threadName.contains("TimerThread") || threadName.contains("FinalizerThread")) { 
+      perfEventGroup = PERF_EVENT_GROUP_SYS;
+    }
+    else if(this.isCollectorThread()) {
+      perfEventGroup = PERF_EVENT_GROUP_GC;
+    }
+    if(perfEventGroup == -1) {
+      VM.sysWrite("ERROR (PerThreadPerfMon): Thread Group Not Assigned For Thread-");
+      VM.sysWriteln(threadName);
+      VM.sysFail("PerThreadGroup");
+    }
+
+    acctLock.lockNoHandshake();
+    for (int i = 0; i < n; i++) {
+      long val = perfEventRead(i);	
+      perfEventperThread[i][perfEventThreadNum] = val;
+      switch(perfEventGroup) {
+        case PERF_EVENT_GROUP_WS:
+          perfEventTotals_ws[i] += val;
+          break;
+        case PERF_EVENT_GROUP_ORGANIZERS:
+          perfEventTotals_organizers[i] += val;
+          break;
+        case PERF_EVENT_GROUP_GC:
+          perfEventTotals_gc[i] += val;
+          break;
+        case PERF_EVENT_GROUP_SYS:
+          perfEventTotals_sys[i] += val;
+          break;
+      }
+    }
+    String name = getName().replace(" ", "");
+    name += ".T" + perfEventThreadNum;
+    perfEventThreadName[perfEventThreadNum] = name;
+    ++perfEventThreadNum;
+    acctLock.unlock();
+  }
+
+  public long perfEventRead(int eventIndex) {
+    if(VM.VerifyAssertions) VM._assert(eventIndex >= 0 && eventIndex <= perfEventNames.length, "Invalid perfEventId");
+    sysCall.sysPerfEventRead_thread(eventIndex, perfEventFds, perfEventTemp);
+    if (perfEventTemp[1] != perfEventTemp[2]) {
+      // This thread has never run
+      if(this.systemThread == null) VM.sysFail("Counters overflowed");
+      return 0;
+    }
+    return perfEventTemp[0]; 
+  }
+
+  @Unpreemptible
+  public static void perfEventStop() {
+    if(PER_THREAD_PERF_MONITORING) {
+      hardHandshakeSuspend();
+      for(int i=0; i<numThreads;i++) {
+        threads[i].perfEventDetach();
+      }
+
+      int n = perfEventNames.length;
+      // Thread grouping
+      VM.sysWriteln("============================ Tabulate Statistics ============================");
+      // write names
+      VM.sysWrite("counters");
+      for (int i = 0; i < n; i++) {
+        for (int j = 0; j <= 3; j++){
+          String group = "";
+          switch(j) {
+            case PERF_EVENT_GROUP_WS:
+              group = "WSThreads";
+              break;
+            case PERF_EVENT_GROUP_ORGANIZERS:
+              group = "Organizers";
+              break;
+            case PERF_EVENT_GROUP_GC:
+              group = "GC";
+              break;
+            case PERF_EVENT_GROUP_SYS:
+              group = "System";
+              break;
+          }
+          VM.sysWrite(" ", perfEventNames[i], ".", group);
+        }
+      }
+      VM.sysWriteln();
+
+      // write values
+      VM.sysWrite(n);
+      for (int i = 0; i < n; i++) {
+        for (int j = 0; j <= 3; j++){
+          switch(j) {
+            case PERF_EVENT_GROUP_WS:
+              VM.sysWrite("   ", perfEventTotals_ws[i]);
+              break;
+            case PERF_EVENT_GROUP_ORGANIZERS:
+              VM.sysWrite("   ", perfEventTotals_organizers[i]);
+              break;
+            case PERF_EVENT_GROUP_GC:
+              VM.sysWrite("   ", perfEventTotals_gc[i]);
+              break;
+            case PERF_EVENT_GROUP_SYS:
+              VM.sysWrite("   ", perfEventTotals_sys[i]);
+              break;
+          }
+        }
+      }
+      VM.sysWriteln();
+      // till here
+
+      hardHandshakeResume();
+    }
+  }
+
+  @Unpreemptible
+  public static void perfEventStopAndPrintAll() {
+    if(PER_THREAD_PERF_MONITORING) {
+      hardHandshakeSuspend();
+      for(int i=0; i<numThreads;i++) {
+        threads[i].perfEventDetach();
+      }
+
+      int n = perfEventNames.length;
+      VM.sysWriteln("============================ Tabulate Statistics ============================");
+      VM.sysWrite("counters");
+
+      for (int i = 0; i < n; i++) {
+        for (int j = 0; j < perfEventThreadNum; j++){
+          VM.sysWrite(" ", perfEventNames[i], ".", perfEventThreadName[j]);
+        }
+        //total
+        VM.sysWrite("   ", perfEventNames[i], ".WSThreadsTotal");
+      }
+
+      VM.sysWriteln();
+      VM.sysWrite(n);
+
+      for (int i = 0; i < n; i++) {
+        for (int j = 0; j < perfEventThreadNum; j++){
+          VM.sysWrite(" ", perfEventperThread[i][j]);
+        }
+      }
+
+      for (int i = 0; i < n; i++) {
+        VM.sysWrite("   ", perfEventTotals_ws[i]);
+      }
+      VM.sysWriteln();
+
+      hardHandshakeResume();
+    }
+  }
+
+
   /**
    * Boot the threading subsystem.
    */
@@ -1454,8 +1701,32 @@ public final class RVMThread extends ThreadContext {
     doProfileReport = new Latch(false);
     monitorBySlot[getCurrentThread().threadSlot] = new NoYieldpointsMonitor();
     communicationLockBySlot[getCurrentThread().threadSlot] = new Monitor();
+    workStealingLockBySlot[getCurrentThread().threadSlot] = new Monitor();
+    lockForSpeculativeTask[getCurrentThread().threadSlot] = new Monitor();
+                if(ws_pinning_system) {
+                        for(int i=0; i<pin_map_system.length; i++) {
+                                sysCall.wsIniatilizeSysThreadBindMask(pin_map_system[i]);
+                        }
+                }
     sysCall.sysStashVMThread(getCurrentThread());
 
+    // Initialize perf event
+    if (wsPerThreadPerf) {
+                        PER_THREAD_PERF_MONITORING = true;
+                        int n = perfEventNames.length;
+                        sysCall.sysPerfEventInit_thread(n);
+                        perfEventperThread = new long[n][MAX_THREADS];
+                        perfEventTotals_ws = new long[n];
+                        perfEventTotals_organizers = new long[n];
+                        perfEventTotals_gc = new long[n];
+                        perfEventTotals_sys = new long[n];
+                        perfEventThreadName = new String[MAX_THREADS];
+                        for (int i = 0; i < n; i++) {
+                                sysCall.sysPerfEventCreate_thread(i, getPerfEventByteArray(i));
+                        }
+                        getCurrentThread().perfEventAttach();
+                }
+
     if (traceAcct) {
       VM.sysWriteln("boot thread at ",Magic.objectAsAddress(getCurrentThread()));
     }
@@ -1517,1400 +1788,1640 @@ public final class RVMThread extends ThreadContext {
   @NoCheckStore
   public static void processAboutToTerminate() {
     if (!neverKillThreads) {
-      restart: while (true) {
-        int notKilled = 0;
-        acctLock.lockNoHandshake();
-        for (int i = 0; i < aboutToTerminateN; ++i) {
-          RVMThread t = threadBySlot[aboutToTerminate[i]];
-          if (t.getExecStatus() == TERMINATED) {
-            aboutToTerminate[i--] = aboutToTerminate[--aboutToTerminateN];
-            acctLock.unlock();
-            t.releaseThreadSlot();
-            continue restart;
-          } else {
-            notKilled++;
-          }
-        }
-        acctLock.unlock();
-        if (notKilled > 0 && traceAboutToTerminate) {
-          VM.sysWriteln("didn't kill ", notKilled, " threads");
-        }
-        break;
-      }
+restart: while (true) {
+           int notKilled = 0;
+           acctLock.lockNoHandshake();
+           for (int i = 0; i < aboutToTerminateN; ++i) {
+             RVMThread t = threadBySlot[aboutToTerminate[i]];
+             if (t.getExecStatus() == TERMINATED) {
+               aboutToTerminate[i--] = aboutToTerminate[--aboutToTerminateN];
+               acctLock.unlock();
+               t.releaseThreadSlot();
+               continue restart;
+             } else {
+               notKilled++;
+             }
+           }
+           acctLock.unlock();
+           if (notKilled > 0 && traceAboutToTerminate) {
+             VM.sysWriteln("didn't kill ", notKilled, " threads");
+           }
+           break;
+}
     }
   }
 
-  /**
-   * Find a thread slot not in use by any other live thread and bind the given
-   * thread to it. The thread's threadSlot field is set accordingly.
-   */
-  @Interruptible
-  void assignThreadSlot() {
-    if (!VM.runningVM) {
-      // primordial thread
-      threadSlot = 1;
-      threadBySlot[1] = this;
-      threads[0] = this;
-      threadIdx = 0;
-      numThreads = 1;
+/**
+ * Find a thread slot not in use by any other live thread and bind the given
+ * thread to it. The thread's threadSlot field is set accordingly.
+ */
+@Interruptible
+void assignThreadSlot() {
+  if (!VM.runningVM) {
+    // primordial thread
+    threadSlot = 1;
+    threadBySlot[1] = this;
+    threads[0] = this;
+    threadIdx = 0;
+    numThreads = 1;
+  } else {
+    processAboutToTerminate();
+    acctLock.lockNoHandshake();
+    if (freeSlotN > 0) {
+      threadSlot = freeSlots[--freeSlotN];
     } else {
-      processAboutToTerminate();
-      acctLock.lockNoHandshake();
-      if (freeSlotN > 0) {
-        threadSlot = freeSlots[--freeSlotN];
-      } else {
-        if (nextSlot == threads.length) {
-          VM.sysFail("too many threads");
-        }
-        threadSlot = nextSlot++;
+      if (nextSlot == threads.length) {
+        VM.sysFail("too many threads");
       }
-      acctLock.unlock();
-      // before we actually use this slot, ensure that there is a monitor
-      // for it. note that if the slot doesn't have a monitor, then we
-      // "own" it since we allocated it above but haven't done anything
-      // with it (it's not assigned to a thread, so nobody else can touch
-      // it)
-      if (monitorBySlot[threadSlot] == null) {
-        monitorBySlot[threadSlot] = new NoYieldpointsMonitor();
-      }
-      if (communicationLockBySlot[threadSlot] == null) {
-        Monitor m = new Monitor();
-        handshakeLock.lockWithHandshake();
-        communicationLockBySlot[threadSlot] = m;
-        handshakeLock.unlock();
-      }
-      // TODO is this actually needed? The synchronization for locks
-      // should normally take care of required barriers and bar
-      // code movement
-      Magic.fence(); /*
-                     * make sure that nobody sees the thread in any of the
-                     * tables until the thread slot is inited
-                     */
-
-      acctLock.lockNoHandshake();
-      threadBySlot[threadSlot] = this;
-
-      threadIdx = numThreads++;
-      threads[threadIdx] = this;
-
-      acctLock.unlock();
+      threadSlot = nextSlot++;
     }
-    lockingId = threadSlot << TL_THREAD_ID_SHIFT;
-    if (traceAcct) {
-      VM.sysWriteln("Thread #", threadSlot, " at ", Magic.objectAsAddress(this));
-      VM.sysWriteln("stack at ", Magic.objectAsAddress(stack), " up to ", Magic.objectAsAddress(stack).plus(stack.length));
-    }
-  }
+    acctLock.unlock();
+    // before we actually use this slot, ensure that there is a monitor
+    // for it. note that if the slot doesn't have a monitor, then we
+    // "own" it since we allocated it above but haven't done anything
+    // with it (it's not assigned to a thread, so nobody else can touch
+    // it)
+    if (monitorBySlot[threadSlot] == null) {
+      monitorBySlot[threadSlot] = new NoYieldpointsMonitor();
+    }
+    if (communicationLockBySlot[threadSlot] == null) {
+      Monitor m = new Monitor();
+      Monitor m2 = new Monitor();
+      Monitor m3 = new Monitor();
+      handshakeLock.lockWithHandshake();
+      communicationLockBySlot[threadSlot] = m;
+      workStealingLockBySlot[threadSlot] = m2;
+      lockForSpeculativeTask[threadSlot] = m3;
+      handshakeLock.unlock();
+    }
+    // TODO is this actually needed? The synchronization for locks
+    // should normally take care of required barriers and bar
+    // code movement
+    Magic.fence(); /*
+                    * make sure that nobody sees the thread in any of the
+                    * tables until the thread slot is inited
+                    */
 
-  /**
-   * Release a thread's slot in the threads array.
-   */
-  @NoCheckStore
-  void releaseThreadSlot() {
     acctLock.lockNoHandshake();
-    RVMThread replacementThread = threads[numThreads - 1];
-    threads[threadIdx] = replacementThread;
-    replacementThread.threadIdx = threadIdx;
-    threadIdx = -1;
-    Magic.fence(); /*
-                   * make sure that if someone is processing the threads array
-                   * without holding the acctLock (which is definitely legal)
-                   * then they see the replacementThread moved to the new index
-                   * before they see the numThreads decremented (otherwise they
-                   * would miss replacementThread; but with the current
-                   * arrangement at worst they will see it twice)
-                   */
-    threads[--numThreads] = null;
-    threadBySlot[threadSlot] = null;
-    freeSlots[freeSlotN++] = threadSlot;
+    threadBySlot[threadSlot] = this;
+
+    threadIdx = numThreads++;
+    threads[threadIdx] = this;
+
     acctLock.unlock();
   }
+  lockingId = threadSlot << TL_THREAD_ID_SHIFT;
+  if (traceAcct) {
+    VM.sysWriteln("Thread #", threadSlot, " at ", Magic.objectAsAddress(this));
+    VM.sysWriteln("stack at ", Magic.objectAsAddress(stack), " up to ", Magic.objectAsAddress(stack).plus(stack.length));
+  }
+}
 
-   /**
-    * Create a new RVM Thread
-    *
-    * @param stack The stack on which to execute the thread.
-    * @param thread The corresponding java.lang.Thread.
-    * @param name The name of the thread
-    * @param daemon True if this is a daemon thread.
-    * @param systemThread True if this is a system thread.
-    * @param priority The threads execution priority.
-    */
-   public RVMThread(byte[] stack, Thread thread, String name, boolean daemon, SystemThread systemThread, int priority) {
-    this.stack = stack;
-
-    this.daemon = daemon;
-    this.priority = priority;
-    this.systemThread = systemThread;
-
-    this.contextRegisters = this.contextRegistersShadow = ArchitectureFactory.createRegisters();
-    this.contextRegistersSave = this.contextRegistersSaveShadow = ArchitectureFactory.createRegisters();
-    this.exceptionRegisters = this.exceptionRegistersShadow = ArchitectureFactory.createRegisters();
-
-    if (VM.runningVM) {
-      feedlet = TraceEngine.engine.makeFeedlet(name, name);
-    }
-
-    if (VM.VerifyAssertions) VM._assert(stack != null);
-
-    // put self in list of threads known to scheduler and garbage collector
-    if (!VM.runningVM) {
-      if (VM.VerifyAssertions) VM._assert(name != null);
-      this.name = name;
-      // create primordial thread (in boot image)
-      assignThreadSlot();
-
-      if (trace)
-        trace("RVMThread create: ", name);
-      if (trace)
-        trace("daemon: ", daemon ? "true" : "false");
-      if (trace)
-        trace("RVMThread", "create");
-
-      initMutator(threadSlot);
-      this.activeMutatorContext = true;
-      // Remember the boot thread
-      this.execStatus = IN_JAVA;
-      this.waiting = Waiting.RUNNABLE;
-      // assign final field
-      onStackReplacementEvent = null;
-    } else {
-      // create a normal (ie. non-primordial) thread
+/**
+ * Release a thread's slot in the threads array.
+ */
+@NoCheckStore
+void releaseThreadSlot() {
+  acctLock.lockNoHandshake();
+  RVMThread replacementThread = threads[numThreads - 1];
+  threads[threadIdx] = replacementThread;
+  replacementThread.threadIdx = threadIdx;
+  threadIdx = -1;
+  Magic.fence(); /*
+                  * make sure that if someone is processing the threads array
+                  * without holding the acctLock (which is definitely legal)
+                  * then they see the replacementThread moved to the new index
+                  * before they see the numThreads decremented (otherwise they
+                  * would miss replacementThread; but with the current
+                  * arrangement at worst they will see it twice)
+                  */
+  threads[--numThreads] = null;
+  threadBySlot[threadSlot] = null;
+  freeSlots[freeSlotN++] = threadSlot;
+  acctLock.unlock();
+}
 
-      // set up wrapper Thread if one exists
-      this.thread = thread;
-      // Set thread type
+/**
+ * Create a new RVM Thread
+ *
+ * @param stack The stack on which to execute the thread.
+ * @param thread The corresponding java.lang.Thread.
+ * @param name The name of the thread
+ * @param daemon True if this is a daemon thread.
+ * @param systemThread True if this is a system thread.
+ * @param priority The threads execution priority.
+ */
+public RVMThread(byte[] stack, Thread thread, String name, boolean daemon, SystemThread systemThread, int priority) {
+  this.stack = stack;
 
-      this.execStatus = NEW;
-      this.waiting = Waiting.RUNNABLE;
+  this.daemon = daemon;
+  this.priority = priority;
+  this.systemThread = systemThread;
 
-      stackLimit = Magic.objectAsAddress(stack).plus(StackFrameLayout.getStackSizeGuard());
+  this.contextRegisters = this.contextRegistersShadow = ArchitectureFactory.createRegisters();
+  this.contextRegistersSave = this.contextRegistersSaveShadow = ArchitectureFactory.createRegisters();
+  this.exceptionRegisters = this.exceptionRegistersShadow = ArchitectureFactory.createRegisters();
+  this.contextRegistersCopyAtStackWalk = ArchitectureFactory.createRegisters();
 
-      // get instructions for method to be executed as thread startoff
-      CodeArray instructions = Entrypoints.threadStartoffMethod.getCurrentEntryCodeArray();
+  if (VM.runningVM) {
+    feedlet = TraceEngine.engine.makeFeedlet(name, name);
+  }
 
-      VM.disableGC();
+  if (VM.VerifyAssertions) VM._assert(stack != null);
 
-      // initialize thread registers
-      Address ip = Magic.objectAsAddress(instructions);
-      Address sp = Magic.objectAsAddress(stack).plus(stack.length);
+  // put self in list of threads known to scheduler and garbage collector
+  if (!VM.runningVM) {
+    if (VM.VerifyAssertions) VM._assert(name != null);
+    this.name = name;
+    // create primordial thread (in boot image)
+    assignThreadSlot();
 
-      // Initialize the a thread stack as if "startoff" method had been called
-      // by an empty baseline-compiled "sentinel" frame with one local variable.
-      contextRegisters.initializeStack(ip, sp);
+    if (trace)
+      trace("RVMThread create: ", name);
+    if (trace)
+      trace("daemon: ", daemon ? "true" : "false");
+    if (trace)
+      trace("RVMThread", "create");
 
-      VM.enableGC();
+    initMutator(threadSlot);
+    this.activeMutatorContext = true;
+    // Remember the boot thread
+    this.execStatus = IN_JAVA;
+    this.waiting = Waiting.RUNNABLE;
+    // assign final field
+    onStackReplacementEvent = null;
+  } else {
+    // create a normal (ie. non-primordial) thread
 
-      assignThreadSlot();
-      this.name = name == null ? "Thread-" + threadSlot : name;
-      initMutator(threadSlot);
-      activeMutatorContext = true;
-      if (traceAcct) {
-        VM.sysWriteln("registered mutator for ", threadSlot);
-      }
+    // set up wrapper Thread if one exists
+    this.thread = thread;
+    // Set thread type
 
-      initializeJNIEnv();
+    this.execStatus = NEW;
+    this.waiting = Waiting.RUNNABLE;
 
-      if (VM.BuildForAdaptiveSystem) {
-        onStackReplacementEvent = new OnStackReplacementEvent();
-      } else {
-        onStackReplacementEvent = null;
-      }
+    stackLimit = Magic.objectAsAddress(stack).plus(StackFrameLayout.getStackSizeGuard());
 
-      if (thread == null) {
-        // create wrapper Thread if doesn't exist
-        this.thread = java.lang.JikesRVMSupport.createThread(this, name);
-      }
-    }
-  }
+    // get instructions for method to be executed as thread startoff
+    CodeArray instructions = Entrypoints.threadStartoffMethod.getCurrentEntryCodeArray();
 
-  /**
-   * Creates a thread with default stack and with the given name. The
-   * thread will be a daemon thread that runs at normal priority and is not
-   * associated with a {@link Thread} object.
-   *
-   * @param systemThread the associated system thread
-   * @param name human-readable name
-   */
-  public RVMThread(SystemThread systemThread, String name) {
-    this(MemoryManager.newStack(StackFrameLayout.getStackSizeNormal()), null, // java.lang.Thread
-        name, true, // daemon
-        systemThread,
-        Thread.NORM_PRIORITY);
-  }
+    VM.disableGC();
 
-  /**
-   * Create a thread with the given stack and name. Used by
-   * {@link org.jikesrvm.mm.mminterface.CollectorThread} and the
-   * boot image writer for the boot thread.
-   *
-   * @param systemThread the associated system thread
-   * @param stack the thread's stack
-   * @param name human-readable name of the thread
-   */
-  public RVMThread(SystemThread systemThread, byte[] stack, String name) {
-    this(stack, null, // java.lang.Thread
-        name, true, // daemon
-        systemThread,
-        Thread.NORM_PRIORITY);
-  }
+    // initialize thread registers
+    Address ip = Magic.objectAsAddress(instructions);
+    Address sp = Magic.objectAsAddress(stack).plus(stack.length);
 
-  /**
-   * Create a thread with ... called by java.lang.VMThread.create. System thread
-   * isn't set.
-   *
-   * @param thread the associated Java thread
-   * @param stacksize desired stack size in bytes, must be positive
-   * @param name human-readable name
-   * @param daemon whether the thread is a daemon
-   * @param priority the priority for the thread
-   */
-  public RVMThread(Thread thread, int stacksize, String name, boolean daemon, int priority) {
-    this(MemoryManager.newStack(stacksize), thread, name, daemon, null, priority);
-  }
+    // Initialize the a thread stack as if "startoff" method had been called
+    // by an empty baseline-compiled "sentinel" frame with one local variable.
+    contextRegisters.initializeStack(ip, sp);
 
-  /**
-   * Check if the thread has block requests (for example, for suspension and GC).  If
-   * it does, clear the requests and marked the thread as blocked for that request.
-   * If there were any block requests, do a broadcast() on the thread's monitor().
-   * This is an internal method and should only be called from code that implements
-   * thread blocking.  The monitor() lock must be held for this method to work properly.
-   */
-  private void acknowledgeBlockRequests() {
-    boolean hadSome = false;
-    if (VM.VerifyAssertions)
-      VM._assert(blockAdapters != null);
-    for (int i = 0; i < blockAdapters.length; ++i) {
-      if (blockAdapters[i].hasBlockRequest(this)) {
-        blockAdapters[i].setBlocked(this, true);
-        blockAdapters[i].clearBlockRequest(this);
-        hadSome = true;
-      }
-    }
-    if (hadSome) {
-      monitor().broadcast();
+    VM.enableGC();
+
+    assignThreadSlot();
+    this.name = name == null ? "Thread-" + threadSlot : name;
+    initMutator(threadSlot);
+    activeMutatorContext = true;
+    if (traceAcct) {
+      VM.sysWriteln("registered mutator for ", threadSlot);
     }
-  }
 
-  /**
-   * Checks if the thread system has acknowledged that the thread is supposed
-   * to be blocked. This will return true if the thread is actually blocking, or
-   * if the thread is running native code but is guaranteed to block before
-   * returning to Java.  Only call this method when already holding the monitor(),
-   * for two reasons:
-   * <ol>
-   * <li>This method does not acquire the monitor() lock even though it needs
-   * to have it acquired given the data structures that it is accessing.
-   * <li>You will typically want to call this method to decide if you need to
-   * take action under the assumption that the thread is blocked (or not
-   * blocked). So long as you hold the lock the thread cannot change state from
-   * blocked to not blocked.
-   * </ol>
-   *
-   * @return if the thread is supposed to be blocked
-   */
-  public boolean isBlocked() {
-    for (int i = 0; i < blockAdapters.length; ++i) {
-      if (blockAdapters[i].isBlocked(this)) {
-        return true;
-      }
+    initializeJNIEnv();
+
+    if (VM.BuildForAdaptiveSystem) {
+      onStackReplacementEvent = new OnStackReplacementEvent();
+    } else {
+      onStackReplacementEvent = null;
     }
-    return false;
-  }
 
-  /**
-   * Checks if the thread is executing Java code. A thread is executing Java
-   * code if its <code>execStatus</code> is <code>IN_JAVA</code> or
-   * <code>IN_JAVA_TO_BLOCK</code>, and if it is not
-   * <code>aboutToTerminate</code>, and if it is not blocked. Only call this
-   * method when already holding the monitor(), and probably only after calling
-   * setBlockedExecStatus(), for two reasons:
-   * <ol>
-   * <li>This method does not acquire the monitor() lock even though it needs
-   * to have it acquired given the data structures that it is accessing.
-   * <li>You will typically want to call this method to decide if you need to
-   * take action under the assumption that the thread is running Java (or not
-   * running Java). So long as you hold the lock - and you have called
-   * setBlockedExecStatus() - the thread cannot change state from running-Java
-   * to not-running-Java.
-   * </ol>
-   *
-   * @return if the thread is running Java
-   */
-  public boolean isInJava() {
-    return !isBlocking && !isAboutToTerminate &&
-      (getExecStatus() == IN_JAVA || getExecStatus() == IN_JAVA_TO_BLOCK);
+    if (thread == null) {
+      // create wrapper Thread if doesn't exist
+      this.thread = java.lang.JikesRVMSupport.createThread(this, name);
+    }
   }
+}
 
-  /**
-   * Checks whether the thread is in native code as understood by the JMX ThreadInfo.
-   * A thread is considered in native if it is executing JNI code.
-   * <p>
-   * Note: this method is NOT designed for internal use by the RVMThread class and
-   * must not be used for scheduling. For comparison see a method used for
-   * internal scheduling decisions such as {@link #isInJava()}.
-   *
-   * @return if the thread is running JNI code
-   */
-  boolean isInNativeAccordingToJMX() {
-    return !isAboutToTerminate &&
-        (getExecStatus() == IN_JNI || getExecStatus() == BLOCKED_IN_JNI);
-  }
+/**
+ * Creates a thread with default stack and with the given name. The
+ * thread will be a daemon thread that runs at normal priority and is not
+ * associated with a {@link Thread} object.
+ *
+ * @param systemThread the associated system thread
+ * @param name human-readable name
+ */
+public RVMThread(SystemThread systemThread, String name) {
+  this(MemoryManager.newStack(StackFrameLayout.getStackSizeNormal()), null, // java.lang.Thread
+      name, true, // daemon
+      systemThread,
+      Thread.NORM_PRIORITY);
+}
 
-  /**
-   * Should the thread by eligible for sampling by the timer thread?
-   * <p>
-   * Heuristically, we use timer-based sampling the in the adaptive system
-   * to determine where the program is spending time (and thus what to optimize).
-   * This doesn't have to be a 100% accurate, but it must be non-blocking
-   * and also closely approximate whether or not the thread is executing.
-   * For now, approximate just as being in JAVA.
-   * <p>
-   * As a future item, we may want to actually correctly attribute time
-   * spent in native code to the top native method on the frame when the timer
-   * goes off.  This will require work in the JNI enter/exit sequence to deal with
-   * timer samples appropriately.
-   *
-   * @return whether this thread should be sampled by the timer thread.
-   */
-  public boolean shouldBeSampled() {
-    return execStatus == IN_JAVA;
-  }
+/**
+ * Create a thread with the given stack and name. Used by
+ * {@link org.jikesrvm.mm.mminterface.CollectorThread} and the
+ * boot image writer for the boot thread.
+ *
+ * @param systemThread the associated system thread
+ * @param stack the thread's stack
+ * @param name human-readable name of the thread
+ */
+public RVMThread(SystemThread systemThread, byte[] stack, String name) {
+  this(stack, null, // java.lang.Thread
+      name, true, // daemon
+      systemThread,
+      Thread.NORM_PRIORITY);
+}
 
-  /** A variant of checkBlock() that does not save the thread state. */
-  @NoInline
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
-  private void checkBlockNoSaveContext() {
-    assertUnacceptableStates(NEW, TERMINATED);
-    if (VM.VerifyAssertions) VM._assert(!isAboutToTerminate);
-    if (VM.VerifyAssertions) VM._assert(!isBlocking);
+/**
+ * Create a thread with ... called by java.lang.VMThread.create. System thread
+ * isn't set.
+ *
+ * @param thread the associated Java thread
+ * @param stacksize desired stack size in bytes, must be positive
+ * @param name human-readable name
+ * @param daemon whether the thread is a daemon
+ * @param priority the priority for the thread
+ */
+public RVMThread(Thread thread, int stacksize, String name, boolean daemon, int priority) {
+  this(MemoryManager.newStack(stacksize), thread, name, daemon, null, priority);
+}
 
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot, " in checkBlockNoSaveContext");
-    // NB: anything this method calls CANNOT change the contextRegisters
-    // or the JNI env. as well, this code will be running concurrently
-    // with stop-the-world GC!
-    monitor().lockNoHandshake();
-    isBlocking = true;
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot,
-          " acquired lock and has notified everyone that we're blocked");
+/**
+ * Check if the thread has block requests (for example, for suspension and GC).  If
+ * it does, clear the requests and marked the thread as blocked for that request.
+ * If there were any block requests, do a broadcast() on the thread's monitor().
+ * This is an internal method and should only be called from code that implements
+ * thread blocking.  The monitor() lock must be held for this method to work properly.
+ */
+private void acknowledgeBlockRequests() {
+  boolean hadSome = false;
+  if (VM.VerifyAssertions)
+    VM._assert(blockAdapters != null);
+  for (int i = 0; i < blockAdapters.length; ++i) {
+    if (blockAdapters[i].hasBlockRequest(this)) {
+      blockAdapters[i].setBlocked(this, true);
+      blockAdapters[i].clearBlockRequest(this);
+      hadSome = true;
+    }
+  }
+  if (hadSome) {
+    monitor().broadcast();
+  }
+}
 
-    // deal with requests that would require a soft handshake rendezvous
-    handleHandshakeRequest();
-    // check if a soft handshake has been requested, and if so, clear the
-    // request
-    boolean commitSoftRendezvous = softRendezvousCheckAndClear();
-    if (commitSoftRendezvous) {
-      // if a soft handshake had been requested, we need to acknowledge it.
-      // but to acknowledge it we cannot be holding the monitor() lock.
-      // it turns out that at this point in the code it is perfectly safe
-      // to release it, because:
-      // 1) callers of this method expect that it may, in all likelihood,
-      // release the monitor() lock if they were holding it, since it
-      // calls wait()
-      // 2) if the block requests get cleared when we release the lock,
-      // we won't call wait, since we reacquire the lock prior to checking
-      // for block requests.
-      int recCount = monitor().unlockCompletely();
-      softRendezvousCommit();
-      monitor().relockNoHandshake(recCount);
+/**
+ * Checks if the thread system has acknowledged that the thread is supposed
+ * to be blocked. This will return true if the thread is actually blocking, or
+ * if the thread is running native code but is guaranteed to block before
+ * returning to Java.  Only call this method when already holding the monitor(),
+ * for two reasons:
+ * <ol>
+ * <li>This method does not acquire the monitor() lock even though it needs
+ * to have it acquired given the data structures that it is accessing.
+ * <li>You will typically want to call this method to decide if you need to
+ * take action under the assumption that the thread is blocked (or not
+ * blocked). So long as you hold the lock the thread cannot change state from
+ * blocked to not blocked.
+ * </ol>
+ *
+ * @return if the thread is supposed to be blocked
+ */
+public boolean isBlocked() {
+  for (int i = 0; i < blockAdapters.length; ++i) {
+    if (blockAdapters[i].isBlocked(this)) {
+      return true;
     }
+  }
+  return false;
+}
 
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot,
-                    " has acknowledged soft handshakes");
+/**
+ * Checks if the thread is executing Java code. A thread is executing Java
+ * code if its <code>execStatus</code> is <code>IN_JAVA</code> or
+ * <code>IN_JAVA_TO_BLOCK</code>, and if it is not
+ * <code>aboutToTerminate</code>, and if it is not blocked. Only call this
+ * method when already holding the monitor(), and probably only after calling
+ * setBlockedExecStatus(), for two reasons:
+ * <ol>
+ * <li>This method does not acquire the monitor() lock even though it needs
+ * to have it acquired given the data structures that it is accessing.
+ * <li>You will typically want to call this method to decide if you need to
+ * take action under the assumption that the thread is running Java (or not
+ * running Java). So long as you hold the lock - and you have called
+ * setBlockedExecStatus() - the thread cannot change state from running-Java
+ * to not-running-Java.
+ * </ol>
+ *
+ * @return if the thread is running Java
+ */
+public boolean isInJava() {
+  return !isBlocking && !isAboutToTerminate &&
+    (getExecStatus() == IN_JAVA || getExecStatus() == IN_JAVA_TO_BLOCK);
+}
 
-    boolean hadReallyBlocked = false;
+/**
+ * Checks whether the thread is in native code as understood by the JMX ThreadInfo.
+ * A thread is considered in native if it is executing JNI code.
+ * <p>
+ * Note: this method is NOT designed for internal use by the RVMThread class and
+ * must not be used for scheduling. For comparison see a method used for
+ * internal scheduling decisions such as {@link #isInJava()}.
+ *
+ * @return if the thread is running JNI code
+ */
+boolean isInNativeAccordingToJMX() {
+  return !isAboutToTerminate &&
+    (getExecStatus() == IN_JNI || getExecStatus() == BLOCKED_IN_JNI);
+}
 
-    for (;;) {
-      // deal with block requests
-      acknowledgeBlockRequests();
-      // are we blocked?
-      if (!isBlocked()) {
-        break;
-      }
-      if (traceReallyBlock) {
-        hadReallyBlocked = true;
-        VM.sysWriteln("Thread #", threadSlot,
-                      " is really blocked with status ",
-                      READABLE_EXEC_STATUS[getExecStatus()]);
-        VM.sysWriteln("Thread #", threadSlot,
-            " has fp = ", Magic.getFramePointer());
-        if (dumpStackOnBlock) {
-          dumpStack();
-        }
-      }
-      // what if a GC request comes while we're here for a suspend()
-      // request?
-      // answer: we get awoken, reloop, and acknowledge the GC block
-      // request.
-      monitor().waitNoHandshake();
+/**
+ * Should the thread by eligible for sampling by the timer thread?
+ * <p>
+ * Heuristically, we use timer-based sampling the in the adaptive system
+ * to determine where the program is spending time (and thus what to optimize).
+ * This doesn't have to be a 100% accurate, but it must be non-blocking
+ * and also closely approximate whether or not the thread is executing.
+ * For now, approximate just as being in JAVA.
+ * <p>
+ * As a future item, we may want to actually correctly attribute time
+ * spent in native code to the top native method on the frame when the timer
+ * goes off.  This will require work in the JNI enter/exit sequence to deal with
+ * timer samples appropriately.
+ *
+ * @return whether this thread should be sampled by the timer thread.
+ */
+public boolean shouldBeSampled() {
+  return execStatus == IN_JAVA;
+}
 
-      if (traceBlock)
-        VM.sysWriteln("Thread #", threadSlot,
-            " has awoken; checking if we're still blocked");
+/** A variant of checkBlock() that does not save the thread state. */
+@NoInline
+@Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
+private void checkBlockNoSaveContext() {
+  assertUnacceptableStates(NEW, TERMINATED);
+  if (VM.VerifyAssertions) VM._assert(!isAboutToTerminate);
+  if (VM.VerifyAssertions) VM._assert(!isBlocking);
+
+  if (traceBlock)
+    VM.sysWriteln("Thread #", threadSlot, " in checkBlockNoSaveContext");
+  // NB: anything this method calls CANNOT change the contextRegisters
+  // or the JNI env. as well, this code will be running concurrently
+  // with stop-the-world GC!
+  monitor().lockNoHandshake();
+  isBlocking = true;
+  if (traceBlock)
+    VM.sysWriteln("Thread #", threadSlot,
+        " acquired lock and has notified everyone that we're blocked");
+
+  // deal with requests that would require a soft handshake rendezvous
+  handleHandshakeRequest();
+  // check if a soft handshake has been requested, and if so, clear the
+  // request
+  boolean commitSoftRendezvous = softRendezvousCheckAndClear();
+  if (commitSoftRendezvous) {
+    // if a soft handshake had been requested, we need to acknowledge it.
+    // but to acknowledge it we cannot be holding the monitor() lock.
+    // it turns out that at this point in the code it is perfectly safe
+    // to release it, because:
+    // 1) callers of this method expect that it may, in all likelihood,
+    // release the monitor() lock if they were holding it, since it
+    // calls wait()
+    // 2) if the block requests get cleared when we release the lock,
+    // we won't call wait, since we reacquire the lock prior to checking
+    // for block requests.
+    int recCount = monitor().unlockCompletely();
+    softRendezvousCommit();
+    monitor().relockNoHandshake(recCount);
+  }
+
+  if (traceBlock)
+    VM.sysWriteln("Thread #", threadSlot,
+        " has acknowledged soft handshakes");
+
+  boolean hadReallyBlocked = false;
+
+  for (;;) {
+    // deal with block requests
+    acknowledgeBlockRequests();
+    // are we blocked?
+    if (!isBlocked()) {
+      break;
     }
-
-    if (traceBlock || (traceReallyBlock && hadReallyBlocked))
-      VM.sysWriteln("Thread #", threadSlot, " is unblocking");
-
-    // we're about to unblock, so indicate to the world that we're running
-    // again.
-    setExecStatus(IN_JAVA);
-    // let everyone know that we're back to executing code
-    isBlocking = false;
-    // deal with requests that came up while we were blocked.
-    handleHandshakeRequest();
-    monitor().unlock();
+    if (traceReallyBlock) {
+      hadReallyBlocked = true;
+      VM.sysWriteln("Thread #", threadSlot,
+          " is really blocked with status ",
+          READABLE_EXEC_STATUS[getExecStatus()]);
+      VM.sysWriteln("Thread #", threadSlot,
+          " has fp = ", Magic.getFramePointer());
+      if (dumpStackOnBlock) {
+        dumpStack();
+      }
+    }
+    // what if a GC request comes while we're here for a suspend()
+    // request?
+    // answer: we get awoken, reloop, and acknowledge the GC block
+    // request.
+    monitor().waitNoHandshake();
 
     if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot, " is unblocked");
+      VM.sysWriteln("Thread #", threadSlot,
+          " has awoken; checking if we're still blocked");
   }
 
-  /**
-   * Check if the thread is supposed to block, and if so, block it. This method
-   * will ensure that soft handshake requests are acknowledged or else
-   * inhibited, that any blocking request is handled, that the execution state
-   * of the thread (<code>execStatus</code>) is set to <code>IN_JAVA</code>
-   * once all blocking requests are cleared, and that other threads are notified
-   * that this thread is in the middle of blocking by setting the appropriate
-   * flag (<code>isBlocking</code>). Note that this thread acquires the
-   * monitor(), though it may release it completely either by calling wait() or
-   * by calling unlockCompletely(). Thus, although it isn't generally a problem
-   * to call this method while holding the monitor() lock, you should only do so
-   * if the loss of atomicity is acceptable.
-   * <p>
-   * Generally, this method should be called from the following four places:
-   * <ol>
-   * <li>The block() method, if the thread is requesting to block itself.
-   * Currently such requests only come when a thread calls suspend(). Doing so
-   * has unclear semantics (other threads may call resume() too early causing
-   * the well-known race) but must be supported because it's still part of the
-   * JDK. Why it's safe: the block() method needs to hold the monitor() for the
-   * time it takes it to make the block request, but does not need to continue
-   * to hold it when it calls checkBlock(). Thus, the fact that checkBlock()
-   * breaks atomicity is not a concern.
-   * <li>The yieldpoint. One of the purposes of a yieldpoint is to periodically
-   * check if the current thread should be blocked. This is accomplished by
-   * calling checkBlock(). Why it's safe: the yieldpoint performs several
-   * distinct actions, all of which individually require the monitor() lock -
-   * but the monitor() lock does not have to be held contiguously. Thus, the
-   * loss of atomicity from calling checkBlock() is fine.
-   * <li>The "WithHandshake" methods of HeavyCondLock. These methods allow you to
-   * block on a mutex or condition variable while notifying the system that you
-   * are not executing Java code. When these blocking methods return, they check
-   * if there had been a request to block, and if so, they call checkBlock().
-   * Why it's safe: This is subtle. Two cases exist. The first case is when a
-   * WithHandshake method is called on a HeavyCondLock instance that is not a thread
-   * monitor(). In this case, it does not matter that checkBlock() may acquire
-   * and then completely release the monitor(), since the user was not holding
-   * the monitor(). However, this will break if the user is <i>also</i> holding
-   * the monitor() when calling the WithHandshake method on a different lock. This case
-   * should never happen because no other locks should ever be acquired when the
-   * monitor() is held. Additionally: there is the concern that some other locks
-   * should never be held while attempting to acquire the monitor(); the
-   * HeavyCondLock ensures that checkBlock() is only called when that lock
-   * itself is released. The other case is when a WithHandshake method is called on the
-   * monitor() itself. This should only be done when using <i>your own</i>
-   * monitor() - that is the monitor() of the thread your are running on. In
-   * this case, the WithHandshake methods work because: (i) lockWithHandshake() only calls
-   * checkBlock() on the initial lock entry (not on recursive entry), so
-   * atomicity is not broken, and (ii) waitWithHandshake() and friends only call
-   * checkBlock() after wait() returns - at which point it is safe to release
-   * and reacquire the lock, since there cannot be a race with broadcast() once
-   * we have committed to not calling wait() again.
-   * <li>Any code following a potentially-blocking native call. Case (3) above
-   * is somewhat subsumed in this except that it is special due to the fact that
-   * it's blocking on VM locks. So, this case refers specifically to JNI. The
-   * JNI epilogues will call leaveJNIBlocked(), which calls a variant of this
-   * method.
-   * </ol>
-   */
-  @NoInline
-  @NoOptCompile
-  @BaselineSaveLSRegisters
-  @Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
-  void checkBlock() {
-    saveThreadState();
-    checkBlockNoSaveContext();
-  }
+  if (traceBlock || (traceReallyBlock && hadReallyBlocked))
+    VM.sysWriteln("Thread #", threadSlot, " is unblocking");
 
-  /**
-   * Internal method for transitioning a thread from IN_JAVA or IN_JAVA_TO_BLOCK to
-   * either BLOCKED_IN_NATIVE or BLOCKED_IN_JNI, depending on the value of the jni
-   * parameter.  It is always safe to conservatively call this method when transitioning
-   * to native code, though it is faster to call either enterNative(),
-   * enterJNIFromCallIntoNative(), or enterJNIFromJNIFunctionCall().
-   * <p>
-   * This method takes care of all bookkeeping and notifications required when a
-   * a thread that has been requested to block instead decides to run native code.
-   * Threads enter native code never need to block, since they will not be executing
-   * any Java code.  However, such threads must ensure that any system services (like
-   * GC) that are waiting for this thread to stop are notified that the thread has
-   * instead chosen to exit Java.  As well, any requests to perform a soft handshake
-   * must be serviced and acknowledged.
-   *
-   * @param jni whether this method is called for entering JNI or not
-   */
-  private void enterNativeBlockedImpl(boolean jni) {
-    if (traceReallyBlock)
-      VM.sysWriteln("Thread #", threadSlot, " entering native blocked.");
-    // NB: anything this method calls CANNOT change the contextRegisters
-    // or the JNI env. as well, this code will be running concurrently
-    // with stop-the-world GC!
-    boolean commitSoftRendezvous;
-    monitor().lockNoHandshake();
-    if (jni) {
-      jniEnteredBlocked++;
-      setExecStatus(BLOCKED_IN_JNI);
-    } else {
-      nativeEnteredBlocked++;
-      setExecStatus(BLOCKED_IN_NATIVE);
-    }
-    acknowledgeBlockRequests();
-    handleHandshakeRequest();
-    commitSoftRendezvous = softRendezvousCheckAndClear();
-    monitor().unlock();
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot,
-          " done with the locking part of native entry.");
-    if (commitSoftRendezvous)
-      softRendezvousCommit();
-    if (traceBlock)
-      VM.sysWriteln("Thread #", threadSlot, " done enter native blocked.");
-  }
+  // we're about to unblock, so indicate to the world that we're running
+  // again.
+  setExecStatus(IN_JAVA);
+  // let everyone know that we're back to executing code
+  isBlocking = false;
+  // deal with requests that came up while we were blocked.
+  handleHandshakeRequest();
+  monitor().unlock();
 
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
-  private void leaveNativeBlockedImpl() {
-    checkBlockNoSaveContext();
-  }
+  if (traceBlock)
+    VM.sysWriteln("Thread #", threadSlot, " is unblocked");
+}
 
-  private void enterNativeBlocked() {
-    assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
-    enterNativeBlockedImpl(false);
-    assertAcceptableStates(IN_NATIVE,BLOCKED_IN_NATIVE);
-  }
+/**
+ * Check if the thread is supposed to block, and if so, block it. This method
+ * will ensure that soft handshake requests are acknowledged or else
+ * inhibited, that any blocking request is handled, that the execution state
+ * of the thread (<code>execStatus</code>) is set to <code>IN_JAVA</code>
+ * once all blocking requests are cleared, and that other threads are notified
+ * that this thread is in the middle of blocking by setting the appropriate
+ * flag (<code>isBlocking</code>). Note that this thread acquires the
+ * monitor(), though it may release it completely either by calling wait() or
+ * by calling unlockCompletely(). Thus, although it isn't generally a problem
+ * to call this method while holding the monitor() lock, you should only do so
+ * if the loss of atomicity is acceptable.
+ * <p>
+ * Generally, this method should be called from the following four places:
+ * <ol>
+ * <li>The block() method, if the thread is requesting to block itself.
+ * Currently such requests only come when a thread calls suspend(). Doing so
+ * has unclear semantics (other threads may call resume() too early causing
+ * the well-known race) but must be supported because it's still part of the
+ * JDK. Why it's safe: the block() method needs to hold the monitor() for the
+ * time it takes it to make the block request, but does not need to continue
+ * to hold it when it calls checkBlock(). Thus, the fact that checkBlock()
+ * breaks atomicity is not a concern.
+ * <li>The yieldpoint. One of the purposes of a yieldpoint is to periodically
+ * check if the current thread should be blocked. This is accomplished by
+ * calling checkBlock(). Why it's safe: the yieldpoint performs several
+ * distinct actions, all of which individually require the monitor() lock -
+ * but the monitor() lock does not have to be held contiguously. Thus, the
+ * loss of atomicity from calling checkBlock() is fine.
+ * <li>The "WithHandshake" methods of HeavyCondLock. These methods allow you to
+ * block on a mutex or condition variable while notifying the system that you
+ * are not executing Java code. When these blocking methods return, they check
+ * if there had been a request to block, and if so, they call checkBlock().
+ * Why it's safe: This is subtle. Two cases exist. The first case is when a
+ * WithHandshake method is called on a HeavyCondLock instance that is not a thread
+ * monitor(). In this case, it does not matter that checkBlock() may acquire
+ * and then completely release the monitor(), since the user was not holding
+ * the monitor(). However, this will break if the user is <i>also</i> holding
+ * the monitor() when calling the WithHandshake method on a different lock. This case
+ * should never happen because no other locks should ever be acquired when the
+ * monitor() is held. Additionally: there is the concern that some other locks
+ * should never be held while attempting to acquire the monitor(); the
+ * HeavyCondLock ensures that checkBlock() is only called when that lock
+ * itself is released. The other case is when a WithHandshake method is called on the
+ * monitor() itself. This should only be done when using <i>your own</i>
+ * monitor() - that is the monitor() of the thread your are running on. In
+ * this case, the WithHandshake methods work because: (i) lockWithHandshake() only calls
+ * checkBlock() on the initial lock entry (not on recursive entry), so
+ * atomicity is not broken, and (ii) waitWithHandshake() and friends only call
+ * checkBlock() after wait() returns - at which point it is safe to release
+ * and reacquire the lock, since there cannot be a race with broadcast() once
+ * we have committed to not calling wait() again.
+ * <li>Any code following a potentially-blocking native call. Case (3) above
+ * is somewhat subsumed in this except that it is special due to the fact that
+ * it's blocking on VM locks. So, this case refers specifically to JNI. The
+ * JNI epilogues will call leaveJNIBlocked(), which calls a variant of this
+ * method.
+ * </ol>
+ */
+@NoInline
+@NoOptCompile
+@BaselineSaveLSRegisters
+@Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
+void checkBlock() {
+  saveThreadState();
+  checkBlockNoSaveContext();
+}
 
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
-  private void leaveNativeBlocked() {
-    assertAcceptableStates(IN_NATIVE,BLOCKED_IN_NATIVE);
-    leaveNativeBlockedImpl();
-    assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
-  }
+@NoInline
+@NoOptCompile
+@BaselineSaveLSRegisters
+@Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
+void wsWrapperCheckBlock() {
+  wsCheckBlock();
+}
 
-  private void enterJNIBlocked() {
-    assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
-    enterNativeBlockedImpl(true);
-    assertAcceptableStates(IN_JNI,BLOCKED_IN_JNI);
-  }
+@NoInline
+@NoOptCompile
+@BaselineNoRegisters
+@Unpreemptible("May block if asked to do so, but otherwise does not actions that would block")
+void wsCheckBlock() {
+  wsSafeToInstallRBarrier = true;
+  saveThreadState();
+  checkBlockNoSaveContext();
+}
 
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
-  private void leaveJNIBlocked() {
-    assertAcceptableStates(IN_JNI,BLOCKED_IN_JNI);
-    leaveNativeBlockedImpl();
-    assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
-  }
+/**
+ * Internal method for transitioning a thread from IN_JAVA or IN_JAVA_TO_BLOCK to
+ * either BLOCKED_IN_NATIVE or BLOCKED_IN_JNI, depending on the value of the jni
+ * parameter.  It is always safe to conservatively call this method when transitioning
+ * to native code, though it is faster to call either enterNative(),
+ * enterJNIFromCallIntoNative(), or enterJNIFromJNIFunctionCall().
+ * <p>
+ * This method takes care of all bookkeeping and notifications required when a
+ * a thread that has been requested to block instead decides to run native code.
+ * Threads enter native code never need to block, since they will not be executing
+ * any Java code.  However, such threads must ensure that any system services (like
+ * GC) that are waiting for this thread to stop are notified that the thread has
+ * instead chosen to exit Java.  As well, any requests to perform a soft handshake
+ * must be serviced and acknowledged.
+ *
+ * @param jni whether this method is called for entering JNI or not
+ */
+private void enterNativeBlockedImpl(boolean jni) {
+  if (traceReallyBlock)
+    VM.sysWriteln("Thread #", threadSlot, " entering native blocked.");
+  // NB: anything this method calls CANNOT change the contextRegisters
+  // or the JNI env. as well, this code will be running concurrently
+  // with stop-the-world GC!
+  boolean commitSoftRendezvous;
+  monitor().lockNoHandshake();
+  if (jni) {
+    jniEnteredBlocked++;
+    setExecStatus(BLOCKED_IN_JNI);
+  } else {
+    nativeEnteredBlocked++;
+    setExecStatus(BLOCKED_IN_NATIVE);
+  }
+  acknowledgeBlockRequests();
+  handleHandshakeRequest();
+  commitSoftRendezvous = softRendezvousCheckAndClear();
+  monitor().unlock();
+  if (traceBlock)
+    VM.sysWriteln("Thread #", threadSlot,
+        " done with the locking part of native entry.");
+  if (commitSoftRendezvous)
+    softRendezvousCommit();
+  if (traceBlock)
+    VM.sysWriteln("Thread #", threadSlot, " done enter native blocked.");
+}
 
-  @Entrypoint
-  public static void enterJNIBlockedFromJNIFunctionCall() {
-    RVMThread t = getCurrentThread();
-    if (traceReallyBlock) {
-      VM.sysWriteln("Thread #",t.getThreadSlot(), " in enterJNIBlockedFromJNIFunctionCall");
-      VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
-    }
-    t.enterJNIBlocked();
-  }
+@Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
+private void leaveNativeBlockedImpl() {
+  checkBlockNoSaveContext();
+}
 
-  @Entrypoint
-  public static void enterJNIBlockedFromCallIntoNative() {
-    RVMThread t = getCurrentThread();
-    if (traceReallyBlock) {
-      VM.sysWriteln("Thread #",t.getThreadSlot(), " in enterJNIBlockedFromCallIntoNative");
-      VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
-    }
-    t.enterJNIBlocked();
+private void enterNativeBlocked() {
+  assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
+  enterNativeBlockedImpl(false);
+  assertAcceptableStates(IN_NATIVE,BLOCKED_IN_NATIVE);
+}
+
+@Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
+private void leaveNativeBlocked() {
+  assertAcceptableStates(IN_NATIVE,BLOCKED_IN_NATIVE);
+  leaveNativeBlockedImpl();
+  assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
+}
+
+private void enterJNIBlocked() {
+  assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
+  enterNativeBlockedImpl(true);
+  assertAcceptableStates(IN_JNI,BLOCKED_IN_JNI);
+}
+
+@Unpreemptible("May block if the thread was asked to do so, but otherwise does no actions that would cause blocking")
+private void leaveJNIBlocked() {
+  assertAcceptableStates(IN_JNI,BLOCKED_IN_JNI);
+  leaveNativeBlockedImpl();
+  assertAcceptableStates(IN_JAVA,IN_JAVA_TO_BLOCK);
+}
+
+@Entrypoint
+public static void enterJNIBlockedFromJNIFunctionCall() {
+  RVMThread t = getCurrentThread();
+  if (traceReallyBlock) {
+    VM.sysWriteln("Thread #",t.getThreadSlot(), " in enterJNIBlockedFromJNIFunctionCall");
+    VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
   }
+  t.enterJNIBlocked();
+}
 
-  @Entrypoint
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise will not block")
-  static void leaveJNIBlockedFromJNIFunctionCall() {
-    RVMThread t = getCurrentThread();
-    if (traceReallyBlock) {
-      VM.sysWriteln("Thread #", t.getThreadSlot(),
-          " in leaveJNIBlockedFromJNIFunctionCall");
-      VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
-      VM.sysWriteln("state = ", READABLE_EXEC_STATUS[t.getExecStatus()]);
-      VM.sysWriteln("jtoc = ", Magic.getJTOC());
-    }
-    t.leaveJNIBlocked();
+@Entrypoint
+public static void enterJNIBlockedFromCallIntoNative() {
+  RVMThread t = getCurrentThread();
+  if (traceReallyBlock) {
+    VM.sysWriteln("Thread #",t.getThreadSlot(), " in enterJNIBlockedFromCallIntoNative");
+    VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
   }
+  t.enterJNIBlocked();
+}
 
-  /**
-   * Called when JNI code tried to transition from  IN_JNI to IN_JAVA but failed
-   */
-  @Entrypoint
-  @Unpreemptible("May block if the thread was asked to do so, but otherwise will not block")
-  public static void leaveJNIBlockedFromCallIntoNative() {
-    RVMThread t = getCurrentThread();
-    if (traceReallyBlock) {
-      VM.sysWriteln("Thread #", t.getThreadSlot(),
-          " in leaveJNIBlockedFromCallIntoNative");
-      VM.sysWriteln("state = ", READABLE_EXEC_STATUS[t.getExecStatus()]);
-      VM.sysWriteln("jtoc = ", Magic.getJTOC());
+@Entrypoint
+@Unpreemptible("May block if the thread was asked to do so, but otherwise will not block")
+static void leaveJNIBlockedFromJNIFunctionCall() {
+  RVMThread t = getCurrentThread();
+  if (traceReallyBlock) {
+    VM.sysWriteln("Thread #", t.getThreadSlot(),
+        " in leaveJNIBlockedFromJNIFunctionCall");
+    VM.sysWriteln("thread address = ",Magic.objectAsAddress(t));
+    VM.sysWriteln("state = ", READABLE_EXEC_STATUS[t.getExecStatus()]);
+    VM.sysWriteln("jtoc = ", Magic.getJTOC());
+  }
+  t.leaveJNIBlocked();
+}
+
+/**
+ * Called when JNI code tried to transition from  IN_JNI to IN_JAVA but failed
+ */
+@Entrypoint
+@Unpreemptible("May block if the thread was asked to do so, but otherwise will not block")
+public static void leaveJNIBlockedFromCallIntoNative() {
+  RVMThread t = getCurrentThread();
+  if (traceReallyBlock) {
+    VM.sysWriteln("Thread #", t.getThreadSlot(),
+        " in leaveJNIBlockedFromCallIntoNative");
+    VM.sysWriteln("state = ", READABLE_EXEC_STATUS[t.getExecStatus()]);
+    VM.sysWriteln("jtoc = ", Magic.getJTOC());
+  }
+  t.leaveJNIBlocked();
+}
+
+private int setBlockedExecStatus() {
+  int oldState, newState;
+  do {
+    oldState = getExecStatus();
+    if (oldState == IN_JAVA) {
+      newState = IN_JAVA_TO_BLOCK;
+    } else if (oldState == IN_NATIVE) {
+      newState = BLOCKED_IN_NATIVE;
+    } else if (oldState == IN_JNI) {
+      newState = BLOCKED_IN_JNI;
+    } else {
+      newState = oldState;
     }
-    t.leaveJNIBlocked();
-  }
+    /*
+     * use the CAS to assert that we observed what we
+     * thought we observed
+     */
+  } while (!(attemptFastExecStatusTransition(oldState,newState)));
+  return newState;
+}
 
-  private int setBlockedExecStatus() {
-    int oldState, newState;
-    do {
-      oldState = getExecStatus();
-      if (oldState == IN_JAVA) {
-        newState = IN_JAVA_TO_BLOCK;
-      } else if (oldState == IN_NATIVE) {
-        newState = BLOCKED_IN_NATIVE;
-      } else if (oldState == IN_JNI) {
-        newState = BLOCKED_IN_JNI;
-      } else {
-        newState = oldState;
+/**
+ * Attempts to block the thread, and return the state it is in after the
+ * attempt. If we're blocking ourselves, this will always return IN_JAVA. If
+ * the thread signals to us the intention to die as we are trying to block it,
+ * this will return TERMINATED. NOTE: the thread's execStatus will not
+ * actually be TERMINATED at that point yet.
+ * <p>
+ * Note that this method is ridiculously dangerous, especially if you pass
+ * asynchronous==false.  Waiting for another thread to stop is not in itself
+ * interruptible - so if you ask another thread to block and they ask you
+ * to block, you might deadlock.
+ *
+ * @param ba the adapter to block on
+ * @param asynchronous {@code true} if the request is asynchronous (i.e. the
+ *  receiver is only notified), {@code false} if the caller waits for the
+ *  receiver to block
+ * @return the new state of the thread
+ */
+@Unpreemptible("Only blocks if the receiver is the current thread, or if asynchronous is set to false and the thread is not already blocked")
+int block(BlockAdapter ba, boolean asynchronous) {
+  int result;
+  if (traceBlock)
+    VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+        " is requesting that thread #", threadSlot, " blocks.");
+  monitor().lockNoHandshake();
+  int token = ba.requestBlock(this);
+  if (getCurrentThread() == this) {
+    if (traceBlock)
+      VM.sysWriteln("Thread #", threadSlot, " is blocking.");
+    wsWrapperCheckBlock();
+    wsSafeToInstallRBarrier = false;
+    result = getExecStatus();
+  } else {
+    if (traceBlock)
+      VM.sysWriteln("Thread #", threadSlot, " is being told to block.");
+    if (isAboutToTerminate) {
+      if (traceBlock)
+        VM.sysWriteln("Thread #", threadSlot,
+            " is terminating, returning as if blocked in TERMINATED state.");
+      result = TERMINATED;
+    } else {
+      takeYieldpoint = 1;
+      // CAS the execStatus field
+      int newState = setBlockedExecStatus();
+      result = newState;
+      if (traceReallyBlock)
+        VM.sysWriteln("Thread #", getCurrentThreadSlot(),
+            " is blocking thread #", threadSlot, " which is in state ",
+            newState);
+      // this broadcast serves two purposes: notifies threads that are
+      // IN_JAVA but waiting on monitor() that they should awake and
+      // acknowledge the block request; or notifies anyone
+      // waiting for this thread to block that the thread is
+      // BLOCKED_IN_NATIVE or BLOCKED_IN_JNI. in the latter case the
+      // broadcast() happens _before_ the setting of the flags that the
+      // other threads would be awaiting, but that is fine, since we're
+      // still holding the lock anyway.
+      monitor().broadcast();
+      if (newState == IN_JAVA_TO_BLOCK) {
+        if (!asynchronous) {
+          if (traceBlock)
+            VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+                " is waiting for thread #", threadSlot, " to block.");
+          while (ba.hasBlockRequest(this, token) && !ba.isBlocked(this) && !isAboutToTerminate) {
+            if (traceBlock)
+              VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+                  " is calling wait until thread #", threadSlot, " blocks.");
+            // will this deadlock when the thread dies?
+            if (VM.VerifyAssertions) {
+              // do a timed wait, and assert that the thread did not disappear
+              // into native in the meantime
+              monitor().timedWaitRelativeNoHandshake(1000L * 1000L * 1000L); // 1 sec
+              if (traceReallyBlock) {
+                VM.sysWriteln("Thread #", threadSlot, "'s status is ",
+                    getExecStatus());
+              }
+              assertUnacceptableStates(IN_NATIVE);
+            } else {
+              monitor().waitNoHandshake();
+            }
+            if (traceBlock)
+              VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+                  " has returned from the wait call.");
+          }
+          if (isAboutToTerminate) {
+            result = TERMINATED;
+          } else {
+            result=getExecStatus();
+          }
+        }
+      } else if (newState == BLOCKED_IN_NATIVE || newState == BLOCKED_IN_JNI) {
+        // we own the thread for now - it cannot go back to executing Java
+        // code until we release the lock. before we do so we change its
+        // state accordingly and tell anyone who is waiting.
+        if (traceBlock)
+          VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+              " has seen thread #", threadSlot,
+              " in native; changing its status accordingly.");
+        ba.clearBlockRequest(this);
+        ba.setBlocked(this, true);
       }
-      /*
-       * use the CAS to assert that we observed what we
-       * thought we observed
-       */
-    } while (!(attemptFastExecStatusTransition(oldState,newState)));
-    return newState;
+    }
   }
+  monitor().unlock();
+  if (traceReallyBlock)
+    VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+        " is done telling thread #", threadSlot, " to block.");
+  return result;
+}
 
-  /**
-   * Attempts to block the thread, and return the state it is in after the
-   * attempt. If we're blocking ourselves, this will always return IN_JAVA. If
-   * the thread signals to us the intention to die as we are trying to block it,
-   * this will return TERMINATED. NOTE: the thread's execStatus will not
-   * actually be TERMINATED at that point yet.
-   * <p>
-   * Note that this method is ridiculously dangerous, especially if you pass
-   * asynchronous==false.  Waiting for another thread to stop is not in itself
-   * interruptible - so if you ask another thread to block and they ask you
-   * to block, you might deadlock.
-   *
-   * @param ba the adapter to block on
-   * @param asynchronous {@code true} if the request is asynchronous (i.e. the
-   *  receiver is only notified), {@code false} if the caller waits for the
-   *  receiver to block
-   * @return the new state of the thread
-   */
-  @Unpreemptible("Only blocks if the receiver is the current thread, or if asynchronous is set to false and the thread is not already blocked")
-  int block(BlockAdapter ba, boolean asynchronous) {
-    int result;
+private boolean wsSafeToInstallRBarrier = false;
+
+@Unpreemptible("Only blocks if the receiver is the current thread, or if asynchronous is set to false and the thread is not already blocked")
+private boolean wsBlock(BlockAdapter ba, boolean asynchronous) {
+  int result;
+  boolean safeWait = false;
+  if (traceBlock)
+    VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+        " is requesting that thread #", threadSlot, " blocks.");
+  monitor().lockNoHandshake();
+  int token = ba.requestBlock(this);
+  if (getCurrentThread() == this) {
     if (traceBlock)
-      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-          " is requesting that thread #", threadSlot, " blocks.");
-    monitor().lockNoHandshake();
-    int token = ba.requestBlock(this);
-    if (getCurrentThread() == this) {
+      VM.sysWriteln("Thread #", threadSlot, " is blocking.");
+
+    checkBlock();
+    result = getExecStatus();
+  } else {
+    if (traceBlock)
+      VM.sysWriteln("Thread #", threadSlot, " is being told to block.");
+    if (isAboutToTerminate) {
       if (traceBlock)
-        VM.sysWriteln("Thread #", threadSlot, " is blocking.");
-      checkBlock();
-      result = getExecStatus();
+        VM.sysWriteln("Thread #", threadSlot,
+            " is terminating, returning as if blocked in TERMINATED state.");
+      result = TERMINATED;
     } else {
-      if (traceBlock)
-        VM.sysWriteln("Thread #", threadSlot, " is being told to block.");
-      if (isAboutToTerminate) {
-        if (traceBlock)
-          VM.sysWriteln("Thread #", threadSlot,
-              " is terminating, returning as if blocked in TERMINATED state.");
-        result = TERMINATED;
-      } else {
-        takeYieldpoint = 1;
-        // CAS the execStatus field
-        int newState = setBlockedExecStatus();
-        result = newState;
-        if (traceReallyBlock)
-          VM.sysWriteln("Thread #", getCurrentThreadSlot(),
-              " is blocking thread #", threadSlot, " which is in state ",
-              newState);
-        // this broadcast serves two purposes: notifies threads that are
-        // IN_JAVA but waiting on monitor() that they should awake and
-        // acknowledge the block request; or notifies anyone
-        // waiting for this thread to block that the thread is
-        // BLOCKED_IN_NATIVE or BLOCKED_IN_JNI. in the latter case the
-        // broadcast() happens _before_ the setting of the flags that the
-        // other threads would be awaiting, but that is fine, since we're
-        // still holding the lock anyway.
-        monitor().broadcast();
-        if (newState == IN_JAVA_TO_BLOCK) {
-          if (!asynchronous) {
+      takeYieldpoint = 1;
+      // CAS the execStatus field
+      int newState = setBlockedExecStatus();
+      result = newState;
+      if (traceReallyBlock)
+        VM.sysWriteln("Thread #", getCurrentThreadSlot(),
+            " is blocking thread #", threadSlot, " which is in state ",
+            newState);
+      // this broadcast serves two purposes: notifies threads that are
+      // IN_JAVA but waiting on monitor() that they should awake and
+      // acknowledge the block request; or notifies anyone
+      // waiting for this thread to block that the thread is
+      // BLOCKED_IN_NATIVE or BLOCKED_IN_JNI. in the latter case the
+      // broadcast() happens _before_ the setting of the flags that the
+      // other threads would be awaiting, but that is fine, since we're
+      // still holding the lock anyway.
+      monitor().broadcast();
+      if (newState == IN_JAVA_TO_BLOCK) {
+        if (!asynchronous) {
+          if (traceBlock)
+            VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+                " is waiting for thread #", threadSlot, " to block.");
+          while (ba.hasBlockRequest(this, token) && !ba.isBlocked(this) && !isAboutToTerminate) {
             if (traceBlock)
               VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-                  " is waiting for thread #", threadSlot, " to block.");
-            while (ba.hasBlockRequest(this, token) && !ba.isBlocked(this) && !isAboutToTerminate) {
-              if (traceBlock)
-                VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-                    " is calling wait until thread #", threadSlot, " blocks.");
-              // will this deadlock when the thread dies?
-              if (VM.VerifyAssertions) {
-                // do a timed wait, and assert that the thread did not disappear
-                // into native in the meantime
-                monitor().timedWaitRelativeNoHandshake(1000L * 1000L * 1000L); // 1 sec
-                if (traceReallyBlock) {
-                  VM.sysWriteln("Thread #", threadSlot, "'s status is ",
-                      READABLE_EXEC_STATUS[getExecStatus()]);
-                }
-                assertUnacceptableStates(IN_NATIVE);
-              } else {
-                monitor().waitNoHandshake();
+                  " is calling wait until thread #", threadSlot, " blocks.");
+            // will this deadlock when the thread dies?
+            if (VM.VerifyAssertions) {
+              // do a timed wait, and assert that the thread did not disappear
+              // into native in the meantime
+              monitor().timedWaitRelativeNoHandshake(1000L * 1000L * 1000L); // 1 sec
+              if (traceReallyBlock) {
+                VM.sysWriteln("Thread #", threadSlot, "'s status is ",
+                    READABLE_EXEC_STATUS[getExecStatus()]);
               }
-              if (traceBlock)
-                VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-                    " has returned from the wait call.");
-            }
-            if (isAboutToTerminate) {
-              result = TERMINATED;
+              assertUnacceptableStates(IN_NATIVE);
             } else {
-              result = getExecStatus();
+              monitor().waitNoHandshake();
             }
+            if (traceBlock)
+              VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+                  " has returned from the wait call.");
+          }
+          if (isAboutToTerminate) {
+            result = TERMINATED;
+          } else {
+            result = getExecStatus();
           }
-        } else if (newState == BLOCKED_IN_NATIVE || newState == BLOCKED_IN_JNI) {
-          // we own the thread for now - it cannot go back to executing Java
-          // code until we release the lock. before we do so we change its
-          // state accordingly and tell anyone who is waiting.
-          if (traceBlock)
-            VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-                " has seen thread #", threadSlot,
-                " in native; changing its status accordingly.");
-          ba.clearBlockRequest(this);
-          ba.setBlocked(this, true);
         }
+      } else if (newState == BLOCKED_IN_NATIVE || newState == BLOCKED_IN_JNI) {
+        // we own the thread for now - it cannot go back to executing Java
+        // code until we release the lock. before we do so we change its
+        // state accordingly and tell anyone who is waiting.
+        if (traceBlock)
+          VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+              " has seen thread #", threadSlot,
+              " in native; changing its status accordingly.");
+        ba.clearBlockRequest(this);
+        ba.setBlocked(this, true);
       }
     }
-    monitor().unlock();
-    if (traceReallyBlock)
-      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-          " is done telling thread #", threadSlot, " to block.");
-    return result;
   }
+  safeWait = wsSafeToInstallRBarrier;
+  wsSafeToInstallRBarrier = false;
+  monitor().unlock();
+  if (traceReallyBlock)
+    VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+        " is done telling thread #", threadSlot, " to block.");
+  return safeWait;
+}
 
-  public boolean blockedFor(BlockAdapter ba) {
-    monitor().lockNoHandshake();
-    boolean result = ba.isBlocked(this);
-    monitor().unlock();
-    return result;
-  }
+public boolean blockedFor(BlockAdapter ba) {
+  monitor().lockNoHandshake();
+  boolean result = ba.isBlocked(this);
+  monitor().unlock();
+  return result;
+}
 
-  @UninterruptibleNoWarn("Never blocks; only asynchronously notifies the receiver to do so")
-  public int asyncBlock(BlockAdapter ba) {
-    if (VM.VerifyAssertions)
-      VM._assert(getCurrentThread() != this);
-    return block(ba, true);
-  }
+@UninterruptibleNoWarn("Never blocks; only asynchronously notifies the receiver to do so")
+public int asyncBlock(BlockAdapter ba) {
+  if (VM.VerifyAssertions)
+    VM._assert(getCurrentThread() != this);
+  return block(ba, true);
+}
 
-  @Unpreemptible("May block if the receiver is the current thread or if the receiver is not yet blocked; otherwise does not perform actions that lead to blocking")
-  public int block(BlockAdapter ba) {
-    return block(ba, false);
-  }
+@Unpreemptible("May block if the receiver is the current thread or if the receiver is not yet blocked; otherwise does not perform actions that lead to blocking")
+public int block(BlockAdapter ba) {
+  return block(ba, false);
+}
 
-  @Unpreemptible
-  public void beginPairWith(RVMThread other) {
-    if (traceBlock) VM.sysWriteln("attempting to pair ",threadSlot," with ",other.threadSlot);
-    Monitor.lockWithHandshake(
+@Unpreemptible("May block if the receiver is the current thread or if the receiver is not yet blocked; otherwise does not perform actions that lead to blocking")
+private boolean wsBlock(BlockAdapter ba) {
+  return wsBlock(ba, false);
+}
+
+@Unpreemptible
+public void beginPairWith(RVMThread other) {
+  if (traceBlock) VM.sysWriteln("attempting to pair ",threadSlot," with ",other.threadSlot);
+  Monitor.lockWithHandshake(
       communicationLock(),Word.fromIntSignExtend(threadSlot),
       other.communicationLock(),Word.fromIntSignExtend(other.threadSlot));
-  }
+}
 
-  public void endPairWith(RVMThread other) {
-    communicationLock().unlock();
-    other.communicationLock().unlock();
-    if (traceBlock) VM.sysWriteln("unpairing ",threadSlot," from ",other.threadSlot);
-  }
+public void endPairWith(RVMThread other) {
+  communicationLock().unlock();
+  other.communicationLock().unlock();
+  if (traceBlock) VM.sysWriteln("unpairing ",threadSlot," from ",other.threadSlot);
+}
 
-  @Unpreemptible
-  public void beginPairWithCurrent() {
-    beginPairWith(getCurrentThread());
-  }
+@Unpreemptible
+public void beginPairWithCurrent() {
+  beginPairWith(getCurrentThread());
+}
 
-  public void endPairWithCurrent() {
-    endPairWith(getCurrentThread());
-  }
+public void endPairWithCurrent() {
+  endPairWith(getCurrentThread());
+}
 
-  @Unpreemptible
-  private int safeBlock(BlockAdapter ba, boolean asynchronous) {
-    if (VM.VerifyAssertions)
-      VM._assert(getCurrentThread() != this);
-    beginPairWithCurrent();
-    int result = block(ba,asynchronous);
-    endPairWithCurrent();
-    return result;
-  }
+@Unpreemptible
+private int safeBlock(BlockAdapter ba, boolean asynchronous) {
+  if (VM.VerifyAssertions)
+    VM._assert(getCurrentThread() != this);
+  beginPairWithCurrent();
+  int result = block(ba,asynchronous);
+  endPairWithCurrent();
+  return result;
+}
 
-  @Unpreemptible
-  public int safeAsyncBlock(BlockAdapter ba) {
-    return safeBlock(ba, true);
-  }
+@Unpreemptible
+public int safeAsyncBlock(BlockAdapter ba) {
+  return safeBlock(ba, true);
+}
 
-  @Unpreemptible
-  public int safeBlock(BlockAdapter ba) {
-    if (getCurrentThread() == this) {
-      return block(ba,false);
-    } else {
-      return safeBlock(ba, false);
-    }
+@Unpreemptible
+public int safeBlock(BlockAdapter ba) {
+  if (getCurrentThread() == this) {
+    return block(ba,false);
+  } else {
+    return safeBlock(ba, false);
   }
+}
 
-  @Unpreemptible
-  public void beginPairHandshake() {
-    beginPairWithCurrent();
-    block(handshakeBlockAdapter);
-  }
+@Unpreemptible
+public void beginPairHandshake() {
+  beginPairWithCurrent();
+  block(handshakeBlockAdapter);
+}
 
-  @Uninterruptible
-  public void endPairHandshake() {
-    unblock(handshakeBlockAdapter);
-    endPairWithCurrent();
-  }
+@Unpreemptible
+public boolean wsBeginPairHandshake() {
+  beginPairWithCurrent();
+  return wsBlock(handshakeBlockAdapter);
+}
 
-  /**
-   * Save the current thread state.  Call this prior to calling enterNative().  You must
-   * be in a method that is marked BaselineSaveLSRegisters.
-   */
-  @NoInline
-  public static void saveThreadState() {
-    Address curFP = Magic.getFramePointer();
-    getCurrentThread().contextRegisters.setInnermost(Magic.getReturnAddressUnchecked(curFP),
-                                                     Magic.getCallerFramePointer(curFP));
-  }
+@Uninterruptible
+public void endPairHandshake() {
+  unblock(handshakeBlockAdapter);
+  endPairWithCurrent();
+}
 
-  /**
-   * Indicate that we'd like the current thread to be executing privileged code that
-   * does not require synchronization with the GC.  This call may be made on a thread
-   * that is IN_JAVA or IN_JAVA_TO_BLOCK, and will result in the thread being either
-   * IN_NATIVE or BLOCKED_IN_NATIVE.  In the case of an
-   * IN_JAVA_TO_BLOCK-&gt;BLOCKED_IN_NATIVE transition, this call will acquire the
-   * thread's lock and send out a notification to any threads waiting for this thread
-   * to reach a safepoint.  This notification serves to notify them that the thread
-   * is in GC-safe code, but will not reach an actual safepoint for an indetermined
-   * amount of time.  This is significant, because safepoints may perform additional
-   * actions (such as handling handshake requests, which may include things like
-   * mutator flushes and running isync) that IN_NATIVE code will not perform until
-   * returning to IN_JAVA by way of a leaveNative() call.
-   */
-  @NoInline // so we can get the fp
-  public static void enterNative() {
-    RVMThread t = getCurrentThread();
-    if (ALWAYS_LOCK_ON_STATE_TRANSITION) {
-      t.enterNativeBlocked();
-    } else {
-      int oldState, newState;
-      do {
-        oldState = t.getExecStatus();
-        if (oldState == IN_JAVA) {
-          newState = IN_NATIVE;
-        } else {
-          t.assertAcceptableStates(IN_JAVA_TO_BLOCK);
-          t.enterNativeBlocked();
-          return;
-        }
-      } while (!(t.attemptFastExecStatusTransition(oldState, newState)));
-    }
-    // NB this is not a correct assertion, as there is a race.  we could succeed in
-    // CASing the status to IN_NATIVE, but then someone else could asynchronosly
-    // set it to whatever they want.
-    //if (VM.VerifyAssertions)
-    //  VM._assert(t.execStatus == IN_NATIVE);
-  }
+/**
+ * Save the current thread state.  Call this prior to calling enterNative().  You must
+ * be in a method that is marked BaselineSaveLSRegisters.
+ */
+@NoInline
+public static void saveThreadState() {
+  Address curFP = Magic.getFramePointer();
+  getCurrentThread().contextRegisters.setInnermost(Magic.getReturnAddressUnchecked(curFP),
+      Magic.getCallerFramePointer(curFP));
+}
 
-  /**
-   * Attempt to transition from IN_JNI or IN_NATIVE to IN_JAVA, fail if execStatus is
-   * anything but IN_JNI or IN_NATIVE.
-   *
-   * @return true if thread transitioned to IN_JAVA, otherwise false
-   */
-  public static boolean attemptLeaveNativeNoBlock() {
-    if (ALWAYS_LOCK_ON_STATE_TRANSITION)
-      return false;
-    RVMThread t = getCurrentThread();
+/**
+ * Indicate that we'd like the current thread to be executing privileged code that
+ * does not require synchronization with the GC.  This call may be made on a thread
+ * that is IN_JAVA or IN_JAVA_TO_BLOCK, and will result in the thread being either
+ * IN_NATIVE or BLOCKED_IN_NATIVE.  In the case of an
+ * IN_JAVA_TO_BLOCK-&gt;BLOCKED_IN_NATIVE transition, this call will acquire the
+ * thread's lock and send out a notification to any threads waiting for this thread
+ * to reach a safepoint.  This notification serves to notify them that the thread
+ * is in GC-safe code, but will not reach an actual safepoint for an indetermined
+ * amount of time.  This is significant, because safepoints may perform additional
+ * actions (such as handling handshake requests, which may include things like
+ * mutator flushes and running isync) that IN_NATIVE code will not perform until
+ * returning to IN_JAVA by way of a leaveNative() call.
+ */
+@NoInline // so we can get the fp
+public static void enterNative() {
+  RVMThread t = getCurrentThread();
+  if (ALWAYS_LOCK_ON_STATE_TRANSITION) {
+    t.enterNativeBlocked();
+  } else {
     int oldState, newState;
     do {
       oldState = t.getExecStatus();
-      if (oldState == IN_NATIVE || oldState == IN_JNI) {
-        newState = IN_JAVA;
+      if (oldState == IN_JAVA) {
+        newState = IN_NATIVE;
       } else {
-        t.assertAcceptableStates(BLOCKED_IN_NATIVE,BLOCKED_IN_JNI);
-        return false;
+        t.assertAcceptableStates(IN_JAVA_TO_BLOCK);
+        t.enterNativeBlocked();
+        return;
       }
     } while (!(t.attemptFastExecStatusTransition(oldState, newState)));
-    return true;
   }
+  // NB this is not a correct assertion, as there is a race.  we could succeed in
+  // CASing the status to IN_NATIVE, but then someone else could asynchronosly
+  // set it to whatever they want.
+  //if (VM.VerifyAssertions)
+  //  VM._assert(t.execStatus == IN_NATIVE);
+}
 
-  /**
-   * Leave privileged code.  This is valid for threads that are either IN_NATIVE,
-   * IN_JNI, BLOCKED_IN_NATIVE, or BLOCKED_IN_JNI, and always results in the thread
-   * being IN_JAVA.  If the thread was previously BLOCKED_IN_NATIVE or BLOCKED_IN_JNI,
-   * the thread will block until notified that it can run again.
-   */
-  @Unpreemptible("May block if the thread was asked to do so; otherwise does no actions that would lead to blocking")
-  public static void leaveNative() {
-    if (!attemptLeaveNativeNoBlock()) {
-      if (traceReallyBlock) {
-        VM.sysWriteln("Thread #", getCurrentThreadSlot(),
-            " is leaving native blocked");
-      }
-      getCurrentThread().leaveNativeBlocked();
+/**
+ * Attempt to transition from IN_JNI or IN_NATIVE to IN_JAVA, fail if execStatus is
+ * anything but IN_JNI or IN_NATIVE.
+ *
+ * @return true if thread transitioned to IN_JAVA, otherwise false
+ */
+public static boolean attemptLeaveNativeNoBlock() {
+  if (ALWAYS_LOCK_ON_STATE_TRANSITION)
+    return false;
+  RVMThread t = getCurrentThread();
+  int oldState, newState;
+  do {
+    oldState = t.getExecStatus();
+    if (oldState == IN_NATIVE || oldState == IN_JNI) {
+      newState = IN_JAVA;
+    } else {
+      t.assertAcceptableStates(BLOCKED_IN_NATIVE,BLOCKED_IN_JNI);
+      return false;
+    }
+  } while (!(t.attemptFastExecStatusTransition(oldState, newState)));
+  return true;
+}
+
+/**
+ * Leave privileged code.  This is valid for threads that are either IN_NATIVE,
+ * IN_JNI, BLOCKED_IN_NATIVE, or BLOCKED_IN_JNI, and always results in the thread
+ * being IN_JAVA.  If the thread was previously BLOCKED_IN_NATIVE or BLOCKED_IN_JNI,
+ * the thread will block until notified that it can run again.
+ */
+@Unpreemptible("May block if the thread was asked to do so; otherwise does no actions that would lead to blocking")
+public static void leaveNative() {
+  if (!attemptLeaveNativeNoBlock()) {
+    if (traceReallyBlock) {
+      VM.sysWriteln("Thread #", getCurrentThreadSlot(),
+          " is leaving native blocked");
     }
+    getCurrentThread().leaveNativeBlocked();
   }
+}
 
-  public static void enterJNIFromCallIntoNative() {
-    // FIXME: call these in PPC instead of doing it in machine code...
-    getCurrentThread().observeExecStatus();
-    if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JAVA,
+public static void enterJNIFromCallIntoNative() {
+  // FIXME: call these in PPC instead of doing it in machine code...
+  getCurrentThread().observeExecStatus();
+  if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JAVA,
         RVMThread.IN_JNI)) {
-      RVMThread.enterJNIBlockedFromCallIntoNative();
-    }
+    RVMThread.enterJNIBlockedFromCallIntoNative();
   }
+}
 
-  @Unpreemptible
-  public static void leaveJNIFromCallIntoNative() {
-    // FIXME: call these in PPC instead of doing it in machine code...
-    getCurrentThread().observeExecStatus();
-    if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JNI,
+@Unpreemptible
+public static void leaveJNIFromCallIntoNative() {
+  // FIXME: call these in PPC instead of doing it in machine code...
+  getCurrentThread().observeExecStatus();
+  if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JNI,
         RVMThread.IN_JAVA)) {
-      RVMThread.leaveJNIBlockedFromCallIntoNative();
-    }
+    RVMThread.leaveJNIBlockedFromCallIntoNative();
   }
+}
 
-  public static void enterJNIFromJNIFunctionCall() {
-    // FIXME: call these instead of doing it in machine code...  currently this
-    // is never called.
-    getCurrentThread().observeExecStatus();
-    if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JAVA,
+public static void enterJNIFromJNIFunctionCall() {
+  // FIXME: call these instead of doing it in machine code...  currently this
+  // is never called.
+  getCurrentThread().observeExecStatus();
+  if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JAVA,
         RVMThread.IN_JNI)) {
-      RVMThread.enterJNIBlockedFromJNIFunctionCall();
-    }
+    RVMThread.enterJNIBlockedFromJNIFunctionCall();
   }
+}
 
-  @Unpreemptible
-  public static void leaveJNIFromJNIFunctionCall() {
-    // FIXME: call these instead of doing it in machine code...  currently this
-    // is never called.
-    getCurrentThread().observeExecStatus();
-    if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JNI,
+@Unpreemptible
+public static void leaveJNIFromJNIFunctionCall() {
+  // FIXME: call these instead of doing it in machine code...  currently this
+  // is never called.
+  getCurrentThread().observeExecStatus();
+  if (!getCurrentThread().attemptFastExecStatusTransition(RVMThread.IN_JNI,
         RVMThread.IN_JAVA)) {
-      RVMThread.leaveJNIBlockedFromJNIFunctionCall();
-    }
+    RVMThread.leaveJNIBlockedFromJNIFunctionCall();
   }
+}
 
-  public void unblock(BlockAdapter ba) {
-    if (traceBlock)
-      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-          " is requesting that thread #", threadSlot, " unblocks.");
-    monitor().lockNoHandshake();
-    ba.clearBlockRequest(this);
-    ba.setBlocked(this, false);
-    monitor().broadcast();
-    monitor().unlock();
-    if (traceBlock)
-      VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
-          " is done requesting that thread #", threadSlot, " unblocks.");
-  }
+public void unblock(BlockAdapter ba) {
+  if (traceBlock)
+    VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+        " is requesting that thread #", threadSlot, " unblocks.");
+  monitor().lockNoHandshake();
+  ba.clearBlockRequest(this);
+  ba.setBlocked(this, false);
+  monitor().broadcast();
+  monitor().unlock();
+  if (traceBlock)
+    VM.sysWriteln("Thread #", getCurrentThread().threadSlot,
+        " is done requesting that thread #", threadSlot, " unblocks.");
+}
 
-  private void handleDebugRequestForThread() {
-    monitor().lockNoHandshake();
-    dumpLock.lockNoHandshake();
-    extDump();
-    if (!isAboutToTerminate) {
-      setBlockedExecStatus();
-      if (isInJava()) {
-        asyncDebugRequestedForThisThread = true;
-        takeYieldpoint = 1;
-        VM.sysWriteln("(stack trace will follow if thread is not lost...)");
+private void handleDebugRequestForThread() {
+  monitor().lockNoHandshake();
+  dumpLock.lockNoHandshake();
+  extDump();
+  if (!isAboutToTerminate) {
+    setBlockedExecStatus();
+    if (isInJava()) {
+      asyncDebugRequestedForThisThread = true;
+      takeYieldpoint = 1;
+      VM.sysWriteln("(stack trace will follow if thread is not lost...)");
+    } else {
+      if (contextRegisters != null) {
+        dumpStack(contextRegisters.getInnermostFramePointer());
       } else {
-        if (contextRegisters != null) {
-          dumpStack(contextRegisters.getInnermostFramePointer());
-        } else {
-          VM.sysWriteln("(cannot dump stack trace; thread is not running in Java but has no contextRegisters)");
-        }
+        VM.sysWriteln("(cannot dump stack trace; thread is not running in Java but has no contextRegisters)");
       }
     }
-    dumpLock.unlock();
-    monitor().unlock();
   }
+  dumpLock.unlock();
+  monitor().unlock();
+}
 
-  @NoCheckStore
-  public static void checkDebugRequest() {
+@NoCheckStore
+public static void checkDebugRequest() {
+  if (debugRequested) {
+    debugLock.lockNoHandshake();
     if (debugRequested) {
-      debugLock.lockNoHandshake();
-      if (debugRequested) {
-        debugRequested = false;
-        VM.sysWriteln("=== Debug requested - attempting safe VM dump ===");
-        dumpAcct();
-        reportThreadTransitionCounts();
-
-        // FIXME: this code runs concurrently to GC and has no way of stopping
-        // it.  hence it is dangerous.  leaving it as-is for now, since it's
-        // only meant to be used for debugging.
-
-        VM.sysWriteln("Timer ticks = ", timerTicks);
-        doProfileReport.openNoHandshake();
-        // snapshot the threads
-        acctLock.lockNoHandshake();
-        int numDebugThreads = numThreads;
-        for (int i = 0; i < numThreads; ++i) {
-          debugThreads[i] = threads[i];
-        }
-        acctLock.unlock();
-        // do the magic
-        for (int i = 0; i < numDebugThreads; ++i) {
-          debugThreads[i].handleDebugRequestForThread();
-          debugThreads[i] = null;
-        }
+      debugRequested = false;
+      VM.sysWriteln("=== Debug requested - attempting safe VM dump ===");
+      dumpAcct();
+      reportThreadTransitionCounts();
+
+      // FIXME: this code runs concurrently to GC and has no way of stopping
+      // it.  hence it is dangerous.  leaving it as-is for now, since it's
+      // only meant to be used for debugging.
+
+      VM.sysWriteln("Timer ticks = ", timerTicks);
+      doProfileReport.openNoHandshake();
+      // snapshot the threads
+      acctLock.lockNoHandshake();
+      int numDebugThreads = numThreads;
+      for (int i = 0; i < numThreads; ++i) {
+        debugThreads[i] = threads[i];
+      }
+      acctLock.unlock();
+      // do the magic
+      for (int i = 0; i < numDebugThreads; ++i) {
+        debugThreads[i].handleDebugRequestForThread();
+        debugThreads[i] = null;
       }
-      debugLock.unlock();
     }
+    debugLock.unlock();
   }
+}
 
-  void timerTick() {
-    if (shouldBeSampled()) {
-      timeSliceExpired++;
-      takeYieldpoint = 1;
-    }
+void timerTick() {
+  if (shouldBeSampled()) {
+    timeSliceExpired++;
+    takeYieldpoint = 1;
   }
+}
 
-  /** @return whether the thread is allowed to take yieldpoints */
-  @Inline
-  public boolean yieldpointsEnabled() {
-    return yieldpointsEnabledCount == 1;
-  }
+/** @return whether the thread is allowed to take yieldpoints */
+@Inline
+public boolean yieldpointsEnabled() {
+  return yieldpointsEnabledCount == 1;
+}
 
-  /** Enable yieldpoints on this thread. */
-  public void enableYieldpoints() {
-    ++yieldpointsEnabledCount;
-    if (VM.VerifyAssertions)
-      VM._assert(yieldpointsEnabledCount <= 1);
-    if (yieldpointsEnabled() && yieldpointRequestPending) {
-      takeYieldpoint = 1;
-      yieldpointRequestPending = false;
-    }
+/** Enable yieldpoints on this thread. */
+public void enableYieldpoints() {
+  ++yieldpointsEnabledCount;
+  if (VM.VerifyAssertions)
+    VM._assert(yieldpointsEnabledCount <= 1);
+  if (yieldpointsEnabled() && yieldpointRequestPending) {
+    takeYieldpoint = 1;
+    yieldpointRequestPending = false;
   }
+}
 
-  /** Disable yieldpoints on this thread. */
-  public void disableYieldpoints() {
-    --yieldpointsEnabledCount;
-  }
+/** Disable yieldpoints on this thread. */
+public void disableYieldpoints() {
+  --yieldpointsEnabledCount;
+}
 
-  /**
-   * Fail if yieldpoints are disabled on this thread
-   */
-  public void failIfYieldpointsDisabled() {
-    if (!yieldpointsEnabled()) {
-      VM.sysWrite("No yieldpoints on thread ", threadSlot);
-      VM.sysWrite(" with addr ", Magic.objectAsAddress(this));
-      VM.sysWriteln();
-      VM.sysFail("Yieldpoints are disabled on this thread!");
-    }
+/**
+ * Fail if yieldpoints are disabled on this thread
+ */
+public void failIfYieldpointsDisabled() {
+  if (!yieldpointsEnabled()) {
+    VM.sysWrite("No yieldpoints on thread ", threadSlot);
+    VM.sysWrite(" with addr ", Magic.objectAsAddress(this));
+    VM.sysWriteln();
+    VM.sysFail("Yieldpoints are disabled on this thread!");
   }
+}
 
-  /**
-   * @return The currently executing thread
-   */
-  @Uninterruptible
-  public static RVMThread getCurrentThread() {
-    if (VM.BuildForIA32) {
-      return org.jikesrvm.ia32.ThreadLocalState.getCurrentThread();
-    } else {
-      if (VM.VerifyAssertions) VM._assert(VM.BuildForPowerPC);
-      return org.jikesrvm.ppc.ThreadLocalState.getCurrentThread();
-    }
+/**
+ * @return The currently executing thread
+ */
+@Uninterruptible
+public static RVMThread getCurrentThread() {
+  if (VM.BuildForIA32) {
+    return org.jikesrvm.ia32.ThreadLocalState.getCurrentThread();
+  } else {
+    if (VM.VerifyAssertions) VM._assert(VM.BuildForPowerPC);
+    return org.jikesrvm.ppc.ThreadLocalState.getCurrentThread();
   }
+}
 
-  /**
-   * @return the unique slot of the currently executing thread
-   */
-  public static int getCurrentThreadSlot() {
-    return getCurrentThread().threadSlot;
-  }
+/**
+ * @return the unique slot of the currently executing thread
+ */
+public static int getCurrentThreadSlot() {
+  return getCurrentThread().threadSlot;
+}
 
-  /**
-   * @return the slot of this thread
-   */
-  public int getThreadSlot() {
-    return threadSlot;
-  }
+/**
+ * @return the slot of this thread
+ */
+public int getThreadSlot() {
+  return threadSlot;
+}
 
-  /**
-   * Called during booting to give the boot thread a java.lang.Thread
-   */
-  @Interruptible
-  public void setupBootJavaThread() {
-    thread = java.lang.JikesRVMSupport.createThread(this,
-        "Jikes_RVM_Boot_Thread");
-  }
+/**
+ * Called during booting to give the boot thread a java.lang.Thread
+ */
+@Interruptible
+public void setupBootJavaThread() {
+  thread = java.lang.JikesRVMSupport.createThread(this,
+      "Jikes_RVM_Boot_Thread");
+}
 
-  /**
-   * String representation of thread
-   */
-  @Override
-  public String toString() {
-    return name;
+/**
+ * String representation of thread
+ */
+@Override
+public String toString() {
+  return name;
+}
+
+/**
+ * @return the current java.lang.Thread.
+ */
+public Thread getJavaLangThread() {
+  return thread;
+}
+
+/**
+ * @return current thread's JNI environment.
+ */
+public JNIEnvironment getJNIEnv() {
+  return jniEnv;
+}
+
+/** @return the disable GC depth */
+public int getDisableGCDepth() {
+  return disableGCDepth;
+}
+
+public void setDisableGCDepth(int d) {
+  disableGCDepth = d;
+}
+
+/** @return whether allocations by this thread are disallowed */
+public boolean getDisallowAllocationsByThisThread() {
+  return disallowAllocationsByThisThread;
+}
+
+/** Disallow allocations by this thread */
+public void setDisallowAllocationsByThisThread() {
+  disallowAllocationsByThisThread = true;
+}
+
+/** Allow allocations by this thread */
+public void clearDisallowAllocationsByThisThread() {
+  disallowAllocationsByThisThread = false;
+}
+
+/**
+ * Initialize JNI environment for system threads. Called by VM.finishBooting
+ */
+@Interruptible
+public void initializeJNIEnv() {
+  this.jniEnv = this.jniEnvShadow = new JNIEnvironment();
+}
+
+/**
+ * Indicate whether the stack of this Thread contains any C frame (used in
+ * RuntimeEntrypoints.deliverHardwareException for stack resize)
+ *
+ * @return {@code false} during the prolog of the first Java to C transition,
+ *  {@code true} afterward
+ */
+public boolean hasNativeStackFrame() {
+  return jniEnv != null && jniEnv.hasNativeStackFrame();
+}
+
+/*
+ * Starting and ending threads
+ */
+
+/**
+ * Method to be executed when this thread starts running. Calls
+ * java.lang.Thread.run but system threads can override directly.
+ * <p>
+ * This method will catch all uncaught throwables from the thread
+ * and pass them to the thread's uncaught exception handler.
+ */
+@Interruptible
+@Entrypoint
+public void run() {
+  try {
+    synchronized (thread) {
+      Throwable t = java.lang.JikesRVMSupport.getStillBorn(thread);
+      if (t != null) {
+        java.lang.JikesRVMSupport.setStillBorn(thread, null);
+        throw t;
+      }
+    }
+    thread.run();
+  } catch (Throwable t) {
+    if (traceAcct) {
+      VM.sysWriteln("Thread ",getThreadSlot()," exiting with exception.");
+    }
+    // Any throwable that reaches this point wasn't caught by the
+    // thread and is therefore an uncaught exception by definition.
+    // In order to make sure that terminate() sets the correct exit
+    // status for this case, uncaughtExceptionCount needs to be
+    // increased.
+    uncaughtExceptionCount++;
+    try {
+      Thread.UncaughtExceptionHandler handler;
+      handler = thread.getUncaughtExceptionHandler();
+      handler.uncaughtException(thread, t);
+    } catch (Throwable ignore) {
+    }
   }
+}
 
-  /**
-   * @return the current java.lang.Thread.
-   */
-  public Thread getJavaLangThread() {
-    return thread;
+/*
+ * Methods for pinning threads to cores
+ */
+
+protected static int pin_core_index = 0;
+@Interruptible
+private synchronized static int getNextCoreID() {
+  int id = pin_core_index++;
+  if(id == sysCall.sysNumProcessors()) {
+    id = pin_core_index = 0;
   }
+  return id;
+}
 
-  /**
-   * @return current thread's JNI environment.
+/*
+ * This method only support when -Xws:pinSocketCPU is provided
+ * and also hyperthreading is ON
+ * 
+ * A typical layout, which this supports is:
+ * 	
+ $ numactl --hardware
+available: 2 nodes (0-1)
+node 0 cpus: 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30
+node 0 size: 24530 MB
+node 0 free: 208 MB
+node 1 cpus: 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31
+node 1 size: 24576 MB
+node 1 free: 85 MB
+node distances:
+node   0   1 
+0:  10  20 
+1:  20  10 
+*/
+private static int[] multiSocket_physical_cores_inhyperthreading = new int[0];
+@Interruptible
+private synchronized static int getNextCoreID_socketAndCPUHint() {
+  /*
+   *  The implementation of this method assumes the hyperthreading is ON.
+   *  In case hyperthreading is OFF, use the -Xws:pinMap option 
+   *  to hint the pin core ids.
+   *  This function will fail in that case !!
    */
-  public JNIEnvironment getJNIEnv() {
-    return jniEnv;
+  if(multiSocket_physical_cores_inhyperthreading.length == 0) {
+    final int physical_cores = cpusPerSocket * sockets;
+    multiSocket_physical_cores_inhyperthreading = new int[physical_cores];
+    // assuming even number of total processors
+    int curr_cpu = 0;
+    int curr_socket = 0;
+    for(int i=0; i<physical_cores; i++) {
+      if(i == cpusPerSocket*(curr_socket+1)) curr_cpu = ++curr_socket;
+      multiSocket_physical_cores_inhyperthreading[i] = curr_cpu;
+      curr_cpu += 2;
+    }
   }
 
-  /** @return the disable GC depth */
-  public int getDisableGCDepth() {
-    return disableGCDepth;
+  int id = pin_core_index++;
+  if(id == multiSocket_physical_cores_inhyperthreading.length) {
+    id = pin_core_index = 0;
   }
+  return multiSocket_physical_cores_inhyperthreading[id];
+}
 
-  public void setDisableGCDepth(int d) {
-    disableGCDepth = d;
+/*
+ *  This is used only when a exact pinMap is provided at runtime
+ */
+@Interruptible
+private synchronized static int getNextCoreID_fromPinMap() {
+  int id = pin_core_index++;
+  if(id == pin_map_workers.length) {
+    id = pin_core_index = 0;
   }
+  return pin_map_workers[id];
+}
 
-  /** @return whether allocations by this thread are disallowed */
-  public boolean getDisallowAllocationsByThisThread() {
-    return disallowAllocationsByThisThread;
-  }
 
-  /** Disallow allocations by this thread */
-  public void setDisallowAllocationsByThisThread() {
-    disallowAllocationsByThisThread = true;
-  }
+/**
+ * Begin execution of current thread by calling its "run" method. This method
+ * is at the bottom of all created method's stacks.
+ */
+@Interruptible
+@SuppressWarnings({ "unused" })
+@Entrypoint
+private static void startoff() {
+  bindIfRequested();
 
-  /** Allow allocations by this thread */
-  public void clearDisallowAllocationsByThisThread() {
-    disallowAllocationsByThisThread = false;
-  }
+  RVMThread currentThread = getCurrentThread();
 
-  /**
-   * Initialize JNI environment for system threads. Called by VM.finishBooting
-   */
-  @Interruptible
-  public void initializeJNIEnv() {
-    this.jniEnv = this.jniEnvShadow = new JNIEnvironment();
-  }
+  currentThread.perfEventAttach();
 
-  /**
-   * Indicate whether the stack of this Thread contains any C frame (used in
-   * RuntimeEntrypoints.deliverHardwareException for stack resize)
-   *
-   * @return {@code false} during the prolog of the first Java to C transition,
-   *  {@code true} afterward
+  /*
+   * get pthread_id from the operating system and store into RVMThread field
    */
-  public boolean hasNativeStackFrame() {
-    return jniEnv != null && jniEnv.hasNativeStackFrame();
-  }
+  currentThread.thread_id = sysCall.sysGetThreadId();
+  currentThread.priority_handle = sysCall.sysGetThreadPriorityHandle();
 
   /*
-   * Starting and ending threads
+   * set thread priority to match stored value
    */
+  sysCall.sysSetThreadPriority(currentThread.thread_id,
+      currentThread.priority_handle, currentThread.priority - Thread.NORM_PRIORITY);
 
-  /**
-   * Method to be executed when this thread starts running. Calls
-   * java.lang.Thread.run but system threads can override directly.
-   * <p>
-   * This method will catch all uncaught throwables from the thread
-   * and pass them to the thread's uncaught exception handler.
-   */
-  @Interruptible
-  @Entrypoint
-  public void run() {
-    try {
-      synchronized (thread) {
-        Throwable t = java.lang.JikesRVMSupport.getStillBorn(thread);
-        if (t != null) {
-          java.lang.JikesRVMSupport.setStillBorn(thread, null);
-          throw t;
-        }
-      }
-      thread.run();
-    } catch (Throwable t) {
-      if (traceAcct) {
-        VM.sysWriteln("Thread ",getThreadSlot()," exiting with exception.");
-      }
-      // Any throwable that reaches this point wasn't caught by the
-      // thread and is therefore an uncaught exception by definition.
-      // In order to make sure that terminate() sets the correct exit
-      // status for this case, uncaughtExceptionCount needs to be
-      // increased.
-      uncaughtExceptionCount++;
-      try {
-        Thread.UncaughtExceptionHandler handler;
-        handler = thread.getUncaughtExceptionHandler();
-        handler.uncaughtException(thread, t);
-      } catch (Throwable ignore) {
-      }
-    }
+  currentThread.enableYieldpoints();
+  sysCall.sysStashVMThread(currentThread);
+  if (traceAcct) {
+    VM.sysWriteln("Thread #", currentThread.threadSlot, " with pthread id ",
+        currentThread.thread_id, " running!");
   }
 
-  /**
-   * Begin execution of current thread by calling its "run" method. This method
-   * is at the bottom of all created method's stacks.
-   */
-  @Interruptible
-  @SuppressWarnings({ "unused" })
-  @Entrypoint
-  private static void startoff() {
-    bindIfRequested();
-
-    RVMThread currentThread = getCurrentThread();
+  if (trace) {
+    VM.sysWriteln("Thread.startoff(): about to call ", currentThread.toString(), ".run()");
+  }
 
-    /*
-     * get pthread_id from the operating system and store into RVMThread field
-     */
-    currentThread.pthread_id = sysCall.sysGetThreadId();
-    currentThread.priority_handle = sysCall.sysGetThreadPriorityHandle();
+  try {
+    if (currentThread.systemThread != null) {
 
-    /*
-     * set thread priority to match stored value
-     */
-    sysCall.sysSetThreadPriority(currentThread.pthread_id,
-        currentThread.priority_handle, currentThread.priority - Thread.NORM_PRIORITY);
+      if(currentThread.isCollectorThread() && ws_pinning_gc) {
+        if(currentThread.getName().contains("org.mmtk.plan.generational")) {
+          final int index = currentThread.getCollectorContext().getId();
+          sysCall.wsThreadBindMaskSet(pin_map_gc[index]);
+        }
+      }
+      else if(ws_pinning_system) {
+        sysCall.sysThreadBindMaskSet();
+      }
+      if(WS.pinLog) {
+        VM.sysWriteln("[PIN_INFO] RVM-", currentThread.getName() ," has affinity for cpuid-",sysCall.sysGetCPU());
+      }
 
-    currentThread.enableYieldpoints();
-    sysCall.sysStashVMThread(currentThread);
-    if (traceAcct) {
-      VM.sysWriteln("Thread #", currentThread.threadSlot, " with pthread id ",
-          currentThread.pthread_id, " running!");
+      currentThread.systemThread.run();
+    } else {
+      // this is an application thread
+      if(ws_pinning_workers) {
+        // pin to the core
+        int core = 0;
+        if(RVMThread.pin_map_workers.length > 1) {
+          core = getNextCoreID_fromPinMap();
+        }
+        else if(sockets != -1 && cpusPerSocket != -1) {
+          core = getNextCoreID_socketAndCPUHint();
+        }
+        else {
+          core = getNextCoreID();
+        }
+        sysCall.wsThreadBindMaskSet(core);
+      }
+      if(WS.pinLog) VM.sysWriteln("[PIN_INFO] ", currentThread.getName() ," has affinity for cpuid-",sysCall.sysGetCPU());
+      currentThread.run();
+      if(autogenWSThread) WS.terminate();
     }
-
+  } finally {
     if (trace) {
-      VM.sysWriteln("Thread.startoff(): about to call ", currentThread.toString(), ".run()");
-    }
-
-    try {
-      if (currentThread.systemThread != null) {
-        currentThread.systemThread.run();
-      } else {
-        currentThread.run();
-      }
-    } finally {
-      if (trace) {
-        VM.sysWriteln("Thread.startoff(): finished ", currentThread.toString(), ".run()");
-      }
-      currentThread.terminate();
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
+      VM.sysWriteln("Thread.startoff(): finished ", currentThread.toString(), ".run()");
     }
+    currentThread.terminate();
+    if (VM.VerifyAssertions)
+      VM._assert(VM.NOT_REACHED);
   }
+}
 
-  /**
-   * Start execution of 'this' by creating and starting a native thread.
-   */
-  @Interruptible
-  public void start() {
-    // N.B.: cannot hit a yieldpoint between setting execStatus and starting the
-    // thread!!
-    setExecStatus(IN_JAVA);
-    acctLock.lockNoHandshake();
-    numActiveThreads++;
-    if (isSystemThread()) {
-      numActiveSystemThreads++;
-    }
-    JMXSupport.updatePeakThreadCount(numActiveThreads, numActiveSystemThreads);
-    if (daemon) {
-      numActiveDaemons++;
-    }
-    acctLock.unlock();
-    if (traceAcct)
-      VM.sysWriteln("Thread #", threadSlot, " starting!");
-    sysCall.sysThreadCreate(contextRegisters.getInnermostInstructionAddress(),
-        contextRegisters.getInnermostFramePointer(), Magic.objectAsAddress(this),
-        Magic.getJTOC());
-    if (!isSystemThread()) {
-      JMXSupport.increaseStartedThreadCount();
-    }
+/**
+ * Start execution of 'this' by creating and starting a native thread.
+ */
+@Interruptible
+public void start() {
+  // N.B.: cannot hit a yieldpoint between setting execStatus and starting the
+  // thread!!
+  setExecStatus(IN_JAVA);
+  acctLock.lockNoHandshake();
+  numActiveThreads++;
+  if (isSystemThread()) {
+    numActiveSystemThreads++;
+  }
+  JMXSupport.updatePeakThreadCount(numActiveThreads, numActiveSystemThreads);
+  if (daemon) {
+    numActiveDaemons++;
+  }
+  acctLock.unlock();
+  if (traceAcct)
+    VM.sysWriteln("Thread #", threadSlot, " starting!");
+  sysCall.sysThreadCreate(contextRegisters.getInnermostInstructionAddress(),
+      contextRegisters.getInnermostFramePointer(), Magic.objectAsAddress(this),
+      Magic.getJTOC());
+  if (!isSystemThread()) {
+    JMXSupport.increaseStartedThreadCount();
   }
+}
 
-  /**
-   * Terminate execution of current thread by abandoning all references to it
-   * and resuming execution in some other (ready) thread.
-   */
-  @Interruptible
-  public void terminate() {
-    if (traceAcct)
-      VM.sysWriteln("in terminate() for Thread #", threadSlot);
-    if (VM.VerifyAssertions)
-      VM._assert(getCurrentThread() == this);
-    boolean terminateSystem = false;
-    if (traceTermination) {
-      VM.disableGC();
-      VM.sysWriteln("[ BEGIN Verbosely dumping stack at time of thread termination");
-      dumpStack();
-      VM.sysWriteln("END Verbosely dumping stack at time of creating thread termination ]");
-      VM.enableGC();
-    }
+/**
+ * Terminate execution of current thread by abandoning all references to it
+ * and resuming execution in some other (ready) thread.
+ */
+@Interruptible
+public void terminate() {
+  if (traceAcct)
+    VM.sysWriteln("in terminate() for Thread #", threadSlot);
+  if (VM.VerifyAssertions)
+    VM._assert(getCurrentThread() == this);
+  boolean terminateSystem = false;
+  if (traceTermination) {
+    VM.disableGC();
+    VM.sysWriteln("[ BEGIN Verbosely dumping stack at time of thread termination");
+    dumpStack();
+    VM.sysWriteln("END Verbosely dumping stack at time of creating thread termination ]");
+    VM.enableGC();
+  }
 
-    // allow java.lang.Thread.exit() to remove this thread from ThreadGroup
-    java.lang.JikesRVMSupport.threadDied(thread);
+  // allow java.lang.Thread.exit() to remove this thread from ThreadGroup
+  java.lang.JikesRVMSupport.threadDied(thread);
 
-    TraceEngine.engine.removeFeedlet(feedlet);
+  TraceEngine.engine.removeFeedlet(feedlet);
 
-    if (VM.VerifyAssertions) {
-      if (Lock.countLocksHeldByThread(getLockingId()) > 0) {
-        VM.sysWriteln("Error, thread terminating holding a lock");
-        RVMThread.dumpVirtualMachine();
-      }
+  if (VM.VerifyAssertions) {
+    if (Lock.countLocksHeldByThread(getLockingId()) > 0) {
+      VM.sysWriteln("Error, thread terminating holding a lock");
+      RVMThread.dumpVirtualMachine();
     }
+  }
 
-    if (traceAcct)
-      VM.sysWriteln("doing accounting...");
-    acctLock.lockNoHandshake();
+  if (traceAcct)
+    VM.sysWriteln("doing accounting...");
+  acctLock.lockNoHandshake();
 
-    // if the thread terminated because of an exception, remove
-    // the mark from the exception register object, or else the
-    // garbage collector will attempt to relocate its ip field.
-    exceptionRegisters.setInUse(false);
+  // if the thread terminated because of an exception, remove
+  // the mark from the exception register object, or else the
+  // garbage collector will attempt to relocate its ip field.
+  exceptionRegisters.setInUse(false);
 
-    numActiveThreads -= 1;
-    if (isSystemThread()) {
-      numActiveSystemThreads -= 1;
-    }
-    if (daemon) {
-      numActiveDaemons -= 1;
-    }
-    if (traceAcct)
-      VM.sysWriteln("active = ", numActiveThreads, ", daemons = ",
-          numActiveDaemons);
-    if ((numActiveDaemons == numActiveThreads) && (VM.mainThread != null) && VM.mainThread.launched) {
-      // no non-daemon thread remains and the main thread was launched
-      terminateSystem = true;
-    }
-    if (terminateSystem) {
-      if (systemShuttingDown == false) {
-        systemShuttingDown = true;
-      } else {
-        terminateSystem = false;
-      }
-    }
-    if (traceTermination) {
-      VM.sysWriteln("Thread.terminate: myThread.daemon = ", daemon);
-      VM.sysWriteln("  RVMThread.numActiveThreads = ",
-          RVMThread.numActiveThreads);
-      VM.sysWriteln("  RVMThread.numActiveDaemons = ",
-          RVMThread.numActiveDaemons);
-      VM.sysWriteln("  terminateSystem = ", terminateSystem);
+  numActiveThreads -= 1;
+  if (isSystemThread()) {
+    numActiveSystemThreads -= 1;
+  }
+  if (daemon) {
+    numActiveDaemons -= 1;
+  }
+  if (traceAcct)
+    VM.sysWriteln("active = ", numActiveThreads, ", daemons = ",
+        numActiveDaemons);
+  if ((numActiveDaemons == numActiveThreads) && (VM.mainThread != null) && VM.mainThread.launched) {
+    // no non-daemon thread remains and the main thread was launched
+    terminateSystem = true;
+  }
+  if (terminateSystem) {
+    if (systemShuttingDown == false) {
+      systemShuttingDown = true;
+    } else {
+      terminateSystem = false;
     }
+  }
+  if (traceTermination) {
+    VM.sysWriteln("Thread.terminate: myThread.daemon = ", daemon);
+    VM.sysWriteln("  RVMThread.numActiveThreads = ",
+        RVMThread.numActiveThreads);
+    VM.sysWriteln("  RVMThread.numActiveDaemons = ",
+        RVMThread.numActiveDaemons);
+    VM.sysWriteln("  terminateSystem = ", terminateSystem);
+  }
 
-    acctLock.unlock();
+  acctLock.unlock();
 
-    if (traceAcct)
-      VM.sysWriteln("done with accounting.");
+  if (traceAcct)
+    VM.sysWriteln("done with accounting.");
 
-    if (terminateSystem) {
-      if (traceAcct)
-        VM.sysWriteln("terminating system.");
-      if (uncaughtExceptionCount > 0)
+  if (terminateSystem) {
+    if (traceAcct)
+      VM.sysWriteln("terminating system.");
+    if (uncaughtExceptionCount > 0)
       /* Use System.exit so that any shutdown hooks are run. */ {
         if (VM.TraceExceptionDelivery) {
           VM.sysWriteln("Calling sysExit due to uncaught exception.");
@@ -2931,2929 +3442,4548 @@ public final class RVMThread extends ThreadContext {
           callSystemExit(EXIT_STATUS_MAIN_THREAD_COULD_NOT_LAUNCH);
         }
       }
-      /* Use System.exit so that any shutdown hooks are run. */
-      callSystemExit(0);
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-    }
+    /* Use System.exit so that any shutdown hooks are run. */
+    callSystemExit(0);
+    if (VM.VerifyAssertions)
+      VM._assert(VM.NOT_REACHED);
+  }
 
-    if (traceAcct)
-      VM.sysWriteln("making joinable...");
+  if (traceAcct)
+    VM.sysWriteln("making joinable...");
 
-    // this works.  we use synchronized because we cannot use the thread's
-    // monitor().  see comment in join().  this is fine, because we're still
-    // "running" from the standpoint of GC.
-    synchronized (this) {
-      isJoinable = true;
-      notifyAll();
-    }
-    if (traceAcct)
-      VM.sysWriteln("Thread #", threadSlot, " is joinable.");
+  // this works.  we use synchronized because we cannot use the thread's
+  // monitor().  see comment in join().  this is fine, because we're still
+  // "running" from the standpoint of GC.
+  synchronized (this) {
+    isJoinable = true;
+    notifyAll();
+  }
+  if (traceAcct)
+    VM.sysWriteln("Thread #", threadSlot, " is joinable.");
 
-    if (traceAcct)
-      VM.sysWriteln("making joinable...");
+  if (traceAcct)
+    VM.sysWriteln("making joinable...");
+
+  // Switch to uninterruptible portion of termination
+  terminateUnpreemptible();
+}
+
+/**
+ * Calls {@link System#exit(int)} with the correct security status.
+ *
+ * @param exitStatus the exit status to pass on
+ */
+@Interruptible
+private void callSystemExit(final int exitStatus) {
+  AccessController.doPrivileged(new PrivilegedAction<Object>() {
+    @Override
+    public Object run() {
+      System.exit(exitStatus);
+      return null;
+    }
+  });
+}
+
+/**
+ * Unpreemptible portion of thread termination. Unpreemptible to avoid a dead
+ * thread from being scheduled.
+ */
+@Unpreemptible
+private void terminateUnpreemptible() {
+  // return cached free lock
+  if (traceAcct)
+    VM.sysWriteln("returning cached lock...");
+
+  if (cachedFreeLock != null) {
+    if (Lock.trace) {
+      VM.sysWriteln("Thread #", threadSlot, ": about to free lock ",
+          Magic.objectAsAddress(cachedFreeLock));
+    }
+    if (VM.VerifyAssertions)
+      VM._assert(cachedFreeLock.mutex.latestContender != this);
+    Lock.returnLock(cachedFreeLock);
+    cachedFreeLock = null;
+  }
+
+  if (traceAcct)
+    VM.sysWriteln("adding to aboutToTerminate...");
+
+  addAboutToTerminate();
+  // NB we can no longer do anything that would lead to write barriers or
+  // GC
 
-    // Switch to uninterruptible portion of termination
-    terminateUnpreemptible();
+  if (traceAcct) {
+    VM.sysWriteln("acquireCount for my monitor: ", monitor().acquireCount);
+    VM.sysWriteln("timer ticks: ", timerTicks);
+    VM.sysWriteln("yieldpoints taken: ", yieldpointsTaken);
+    VM.sysWriteln("yieldpoints taken fully: ", yieldpointsTakenFully);
   }
+  if (traceAcct)
+    VM.sysWriteln("finishing thread termination...");
 
-  /**
-   * Calls {@link System#exit(int)} with the correct security status.
-   *
-   * @param exitStatus the exit status to pass on
-   */
-  @Interruptible
-  private void callSystemExit(final int exitStatus) {
-    AccessController.doPrivileged(new PrivilegedAction<Object>() {
-      @Override
-      public Object run() {
-        System.exit(exitStatus);
-        return null;
+  finishThreadTermination();
+}
+
+/** Uninterruptible final portion of thread termination. */
+void finishThreadTermination() {
+  sysCall.sysThreadTerminate();
+  if (VM.VerifyAssertions)
+    VM._assert(VM.NOT_REACHED);
+}
+
+/*
+ * Support for yieldpoints
+ */
+
+/**
+ * Yieldpoint taken in prologue.
+ */
+@BaselineSaveLSRegisters
+// Save all non-volatile registers in prologue
+@NoOptCompile
+@NoInline
+// We should also have a pragma that saves all non-volatiles in opt compiler,
+// BaselineExecuctionStateExtractor.java, should then restore all
+// non-volatiles before stack replacement
+// TODO fix this -- related to SaveVolatile
+@Entrypoint
+@Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
+public static void yieldpointFromPrologue() {
+  Address fp = Magic.getFramePointer();
+  yieldpoint(PROLOGUE, fp);
+}
+
+/**
+ * Yieldpoint taken on backedge.
+ */
+@BaselineSaveLSRegisters
+// Save all non-volatile registers in prologue
+@NoOptCompile
+@NoInline
+// We should also have a pragma that saves all non-volatiles in opt compiler,
+// BaselineExecuctionStateExtractor.java, should then restore all
+// non-volatiles before stack replacement
+// TODO fix this -- related to SaveVolatile
+@Entrypoint
+@Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
+public static void yieldpointFromBackedge() {
+  Address fp = Magic.getFramePointer();
+  yieldpoint(BACKEDGE, fp);
+}
+
+/**
+ * Dump the specified frame in a format useful for debugging the stack
+ * trampoline
+ *
+ * @param fp The frame to be dumped.
+ */
+private static void dumpFrame(Address fp) {
+  final Offset returnAddressOffset = StackFrameLayout.getStackFrameReturnAddressOffset();
+  final Offset methodIDOffset = StackFrameLayout.getStackFrameMethodIDOffset();
+  Address sp = fp.minus(40);
+  VM.sysWriteln("--");
+  Address nextFp = Magic.getCallerFramePointer(fp);
+  while (sp.LE(nextFp)) {
+    VM.sysWrite("[", sp, "]");
+    if (sp.EQ(fp) || sp.EQ(nextFp)) {
+      VM.sysWrite("* ");
+    } else if (sp.EQ(fp.plus(returnAddressOffset)) || sp.EQ(nextFp.plus(returnAddressOffset))) {
+      VM.sysWrite("R ");
+    }  else if (sp.EQ(fp.plus(methodIDOffset)) || sp.EQ(nextFp.plus(methodIDOffset))) {
+      VM.sysWrite("M ");
+    } else {
+      VM.sysWrite(" ");
+    }
+    VM.sysWriteln(sp.loadInt());
+    sp = sp.plus(4);
+  }
+}
+
+/**
+ * @return the caller of the frame in which the trampoline is installed (STACKFRAME_SENTINEL_FP by default)
+ */
+public Address getNextUnencounteredFrame() {
+  return hijackedReturnCallerFp.EQ(StackFrameLayout.getStackFrameSentinelFP()) ? hijackedReturnCallerFp : Magic.getCallerFramePointer(hijackedReturnCallerFp);
+}
+
+/**
+ * Yieldpoint taken in epilogue.
+ */
+@BaselineSaveLSRegisters
+// Save all non-volatile registers in prologue
+@NoOptCompile
+@NoInline
+// We should also have a pragma that saves all non-volatiles in opt compiler,
+// BaselineExecutionStateExtractor.java, should then restore all non-volatiles
+// before stack replacement
+// TODO fix this -- related to SaveVolatile
+@Entrypoint
+@Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
+public static void yieldpointFromEpilogue() {
+  Address fp = Magic.getFramePointer();
+  yieldpoint(EPILOGUE, fp);
+}
+
+/*
+ * Support for suspend/resume
+ */
+
+/**
+ * Suspend execution of current thread until it is resumed. Call only if
+ * caller has appropriate security clearance.
+ */
+@UnpreemptibleNoWarn("Exceptions may possibly cause yields")
+public void suspend() {
+  if (false) VM.sysWriteln("Thread #",getCurrentThreadSlot()," suspending Thread #",getThreadSlot());
+  ObjectModel.genericUnlock_internal(thread);
+  Throwable rethrow = null;
+  try {
+    observeExecStatus();
+    if (execStatus != IN_JAVA && execStatus != IN_JAVA_TO_BLOCK &&
+        execStatus != IN_NATIVE && execStatus != BLOCKED_IN_NATIVE &&
+        execStatus != BLOCKED_IN_JNI && execStatus != IN_JNI) {
+      throw new IllegalThreadStateException(
+          "Cannot suspend a thread that is not running.");
+        }
+    block(suspendBlockAdapter);
+  } catch (Throwable t) {
+    rethrow = t;
+  }
+  ObjectModel.genericLock_internal(thread);
+  if (rethrow != null)
+    RuntimeEntrypoints.athrow(rethrow);
+}
+
+/**
+ * Resume execution of a thread that has been suspended. Call only if caller
+ * has appropriate security clearance.
+ */
+@Interruptible
+public void resume() {
+  unblock(suspendBlockAdapter);
+}
+
+public static void yieldNoHandshake() {
+  sysCall.sysThreadYield();
+}
+
+@UnpreemptibleNoWarn
+public static void yieldWithHandshake() {
+  getCurrentThread().checkBlock();
+  sysCall.sysThreadYield();
+}
+/**
+ * Suspend execution of current thread for specified number of seconds (or
+ * fraction).
+ *
+ * @param ns the number of nanoseconds to sleep for
+ * @throws InterruptedException when the sleep is interrupted
+ */
+@Interruptible
+public static void sleep(long ns) throws InterruptedException {
+  RVMThread t = getCurrentThread();
+  t.waiting = Waiting.TIMED_WAITING;
+  long atStart = sysCall.sysNanoTime();
+  long whenEnd = atStart + ns;
+  t.monitor().lockNoHandshake();
+  while (!t.hasInterrupt && t.asyncThrowable == null &&
+      sysCall.sysNanoTime() < whenEnd) {
+    t.monitor().timedWaitAbsoluteWithHandshake(whenEnd);
       }
-    });
+  boolean throwInterrupt = false;
+  Throwable throwThis = null;
+  if (t.hasInterrupt) {
+    t.hasInterrupt = false;
+    throwInterrupt = true;
+  }
+  if (t.asyncThrowable != null) {
+    throwThis = t.asyncThrowable;
+    t.asyncThrowable = null;
+  }
+  t.monitor().unlock();
+  t.waiting = Waiting.RUNNABLE;
+  if (throwThis != null) {
+    RuntimeEntrypoints.athrow(throwThis);
   }
+  if (throwInterrupt) {
+    throw new InterruptedException("sleep interrupted");
+  }
+}
 
-  /**
-   * Unpreemptible portion of thread termination. Unpreemptible to avoid a dead
-   * thread from being scheduled.
-   */
-  @Unpreemptible
-  private void terminateUnpreemptible() {
-    // return cached free lock
-    if (traceAcct)
-      VM.sysWriteln("returning cached lock...");
+/**
+ * Suspend execution of current thread for specified number of seconds (or
+ * fraction). The time from both parameters is added up.
+ *
+ * @param ns the number of nanoseconds to sleep for
+ * @param millis the number of milliseconds to sleep for
+ * @throws InterruptedException when the sleep is interrupted
+ */
+@Interruptible
+public static void sleep(long millis, int ns) throws InterruptedException {
+  sleep(ns + millis * 1000L * 1000L);
+}
+
+/*
+ * Wait and notify support
+ */
 
-    if (cachedFreeLock != null) {
-      if (Lock.trace) {
-        VM.sysWriteln("Thread #", threadSlot, ": about to free lock ",
-            Magic.objectAsAddress(cachedFreeLock));
+@Interruptible
+void waitImpl(Object o, boolean hasTimeout, long whenWakeupNanos) {
+  boolean throwInterrupt = false;
+  Throwable throwThis = null;
+  if (asyncThrowable != null) {
+    throwThis = asyncThrowable;
+    asyncThrowable = null;
+  } else if (!ObjectModel.holdsLock(o, this)) {
+    throw new IllegalMonitorStateException("waiting on " + o);
+  } else if (hasInterrupt) {
+    throwInterrupt = true;
+    hasInterrupt = false;
+  } else {
+    if (STATS) {
+      waitTimeStart = Time.currentTimeMillis();
+    }
+    waiting = hasTimeout ? Waiting.TIMED_WAITING : Waiting.WAITING;
+    if (STATS) {
+      if (hasTimeout) {
+        timedWaitOperations++;
+      } else {
+        waitOperations++;
       }
-      if (VM.VerifyAssertions)
-        VM._assert(cachedFreeLock.mutex.latestContender != this);
-      Lock.returnLock(cachedFreeLock);
-      cachedFreeLock = null;
     }
+    // get lock for object
+    Lock l = ObjectModel.getHeavyLock(o, true);
 
-    if (traceAcct)
-      VM.sysWriteln("adding to aboutToTerminate...");
-
-    addAboutToTerminate();
-    // NB we can no longer do anything that would lead to write barriers or
-    // GC
+    // release the lock
+    l.mutex.lock();
+    // this thread is supposed to own the lock on o
+    if (VM.VerifyAssertions) VM._assert(l.getOwnerId() == getLockingId());
+    RVMThread toAwaken = l.entering.dequeue();
+    waitObject = l.getLockedObject();
+    waitCount = l.getRecursionCount();
+    l.setOwnerId(0);
+    l.waiting.enqueue(this);
+    l.mutex.unlock();
 
-    if (traceAcct) {
-      VM.sysWriteln("acquireCount for my monitor: ", monitor().acquireCount);
-      VM.sysWriteln("timer ticks: ", timerTicks);
-      VM.sysWriteln("yieldpoints taken: ", yieldpointsTaken);
-      VM.sysWriteln("yieldpoints taken fully: ", yieldpointsTakenFully);
+    // if there was a thread waiting, awaken it
+    if (toAwaken != null) {
+      // is this where the problem is coming from?
+      toAwaken.monitor().lockedBroadcastNoHandshake();
     }
-    if (traceAcct)
-      VM.sysWriteln("finishing thread termination...");
+    // block
+    monitor().lockNoHandshake();
+    while (l.waiting.isQueued(this) && !hasInterrupt && asyncThrowable == null &&
+        (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
+      if (hasTimeout) {
+        monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
+      } else {
+        monitor().waitWithHandshake();
+      }
+        }
+    // figure out if anything special happened while we were blocked
+    if (hasInterrupt) {
+      throwInterrupt = true;
+      hasInterrupt = false;
+    }
+    if (asyncThrowable != null) {
+      throwThis = asyncThrowable;
+      asyncThrowable = null;
+    }
+    monitor().unlock();
+    if (l.waiting.isQueued(this)) {
+      l.mutex.lock();
+      l.waiting.remove(this); /*
+                               * in case we got here due to an interrupt or a
+                               * stop() rather than a notify
+                               */
+      l.mutex.unlock();
+      // Note that the above must be done before attempting to acquire
+      // the lock, since acquiring the lock may require queueing the thread.
+      // But we cannot queue the thread if it is already on another
+      // queue.
+    }
+    // reacquire the lock, restoring the recursion count
+    ObjectModel.genericLock_internal(o);
+    waitObject = null;
+    if (waitCount != 1) { // reset recursion count
+      Lock l2 = ObjectModel.getHeavyLock(o, true);
+      l2.setRecursionCount(waitCount);
+    }
+    waiting = Waiting.RUNNABLE;
+    if (STATS) {
+      totalWaitTime += (sysCall.sysCurrentTimeMillis() - waitTimeStart);
+    }
+  }
+  // check if we should exit in a special way
+  if (throwThis != null) {
+    RuntimeEntrypoints.athrow(throwThis);
+  }
+  if (throwInterrupt) {
+    RuntimeEntrypoints.athrow(new InterruptedException("sleep interrupted"));
+  }
+}
+
+/**
+ * Support for Java {@link java.lang.Object#wait()} synchronization primitive.
+ *
+ * @param o
+ *          the object synchronized on
+ */
+@Interruptible
+/* only loses control at expected points -- I think -dave */
+public static void wait(Object o) {
+  getCurrentThread().waitImpl(o, false, 0);
+}
+
+/**
+ * Support for Java {@link java.lang.Object#wait()} synchronization primitive.
+ *
+ * @param o
+ *          the object synchronized on
+ * @param millis
+ *          the number of milliseconds to wait for notification
+ */
+@Interruptible
+public static void wait(Object o, long millis) {
+  long currentNanos = sysCall.sysNanoTime();
+  getCurrentThread().waitImpl(o, true, currentNanos + millis * 1000 * 1000);
+}
 
-    finishThreadTermination();
+long getTotalWaitingCount() {
+  if (STATS) {
+    return waitOperations + timedWaitOperations;
+  } else {
+    return -1L;
   }
+}
 
-  /** Uninterruptible final portion of thread termination. */
-  void finishThreadTermination() {
-    sysCall.sysThreadTerminate();
-    if (VM.VerifyAssertions)
-      VM._assert(VM.NOT_REACHED);
+long getTotalWaitedTime() {
+  if (STATS) {
+    return totalWaitTime;
+  } else {
+    return -1;
   }
+}
 
-  /*
-   * Support for yieldpoints
-   */
+/**
+ * Support for RTSJ- and pthread-style absolute wait.
+ *
+ * @param o
+ *          the object synchronized on
+ * @param whenNanos
+ *          the absolute time in nanoseconds when we should wake up
+ */
+@Interruptible
+public static void waitAbsoluteNanos(Object o, long whenNanos) {
+  getCurrentThread().waitImpl(o, true, whenNanos);
+}
 
-  /**
-   * Yieldpoint taken in prologue.
-   */
-  @BaselineSaveLSRegisters
-  // Save all non-volatile registers in prologue
-  @NoOptCompile
-  @NoInline
-  // We should also have a pragma that saves all non-volatiles in opt compiler,
-  // BaselineExecuctionStateExtractor.java, should then restore all
-  // non-volatiles before stack replacement
-  // TODO fix this -- related to SaveVolatile
-  @Entrypoint
-  @Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
-  public static void yieldpointFromPrologue() {
-    Address fp = Magic.getFramePointer();
-    yieldpoint(PROLOGUE, fp);
+@UnpreemptibleNoWarn("Possible context when generating exception")
+public static void raiseIllegalMonitorStateException(String msg, Object o) {
+  throw new IllegalMonitorStateException(msg + (o == null ? "<null>" : o.toString()));
+}
+
+/**
+ * Support for Java {@link java.lang.Object#notify()} synchronization
+ * primitive.
+ *
+ * @param o the object synchronized on
+ */
+@Interruptible
+public static void notify(Object o) {
+  if (STATS)
+    notifyOperations++;
+  Lock l = ObjectModel.getHeavyLock(o, false);
+  if (l == null)
+    return;
+  // the reason for locking: when inflating a lock we *first* install it in the status
+  // word and *then* initialize its state.  but fortunately, we do so while holding
+  // the lock's mutex.  thus acquiring the lock's mutex is the only way to ensure that
+  // we see the lock's state after initialization.
+  l.mutex.lock();
+  int owner = l.getOwnerId();
+  l.mutex.unlock();
+  int me = getCurrentThread().getLockingId();
+  if (owner != me) {
+    raiseIllegalMonitorStateException("notifying (expected lock to be held by " +
+        me + "(" + getCurrentThread().getLockingId() + ") but was held by " +
+        owner + "(" + l.getOwnerId() + ")) ", o);
+  }
+  l.mutex.lock();
+  RVMThread toAwaken = l.waiting.dequeue();
+  l.mutex.unlock();
+  if (toAwaken != null) {
+    toAwaken.monitor().lockedBroadcastNoHandshake();
   }
+}
 
-  /**
-   * Yieldpoint taken on backedge.
-   */
-  @BaselineSaveLSRegisters
-  // Save all non-volatile registers in prologue
-  @NoOptCompile
-  @NoInline
-  // We should also have a pragma that saves all non-volatiles in opt compiler,
-  // BaselineExecuctionStateExtractor.java, should then restore all
-  // non-volatiles before stack replacement
-  // TODO fix this -- related to SaveVolatile
-  @Entrypoint
-  @Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
-  public static void yieldpointFromBackedge() {
-    Address fp = Magic.getFramePointer();
-    yieldpoint(BACKEDGE, fp);
+/**
+ * Support for Java synchronization primitive.
+ *
+ * @param o the object synchronized on
+ * @see java.lang.Object#notifyAll
+ */
+@Interruptible
+public static void notifyAll(Object o) {
+  if (STATS)
+    notifyAllOperations++;
+  Lock l = ObjectModel.getHeavyLock(o, false);
+  if (l == null)
+    return;
+  l.mutex.lock();
+  int owner = l.getOwnerId();
+  l.mutex.unlock();
+  if (owner != getCurrentThread().getLockingId()) {
+    raiseIllegalMonitorStateException("notifying all (expected lock to be held by " +
+        getCurrentThread().getLockingId() + " but was held by " + l.getOwnerId() +
+        ") ", o);
+  }
+  for (;;) {
+    l.mutex.lock();
+    RVMThread toAwaken = l.waiting.dequeue();
+    l.mutex.unlock();
+    if (toAwaken == null)
+      break;
+    toAwaken.monitor().lockedBroadcastNoHandshake();
   }
+}
+
+public void stop(Throwable cause) {
+  monitor().lockNoHandshake();
+  asyncThrowable = cause;
+  takeYieldpoint = 1;
+  monitor().broadcast();
+  monitor().unlock();
+}
+
+/*
+ * Park and unpark support
+ */
+@Interruptible
+public void park(boolean isAbsolute, long time) throws Throwable {
+  if (parkingPermit) {
+    // fast path
+    parkingPermit = false;
+    return;
+  }
+  // massive retardation. someone might be holding the java.lang.Thread lock.
+  boolean holdsLock = holdsLock(thread);
+  if (holdsLock)
+    ObjectModel.genericUnlock_internal(thread);
+  boolean hasTimeout;
+  long whenWakeupNanos;
+  hasTimeout = (time != 0);
+  if (isAbsolute) {
+    whenWakeupNanos = time;
+  } else {
+    whenWakeupNanos = sysCall.sysNanoTime() + time;
+  }
+  Throwable throwThis = null;
+  monitor().lockNoHandshake();
+  waiting = hasTimeout ? Waiting.TIMED_WAITING : Waiting.WAITING;
+  while (!parkingPermit && !hasInterrupt && asyncThrowable == null &&
+      (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
+    if (hasTimeout) {
+      monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
+    } else {
+      monitor().waitWithHandshake();
+    }
+      }
+  waiting = Waiting.RUNNABLE;
+  parkingPermit = false;
+  if (asyncThrowable != null) {
+    throwThis = asyncThrowable;
+    asyncThrowable = null;
+  }
+  monitor().unlock();
+
+  if (holdsLock)
+    ObjectModel.genericLock_internal(thread);
+
+  if (throwThis != null) {
+    throw throwThis;
+  }
+}
+
+@Interruptible
+public void unpark() {
+  monitor().lockNoHandshake();
+  parkingPermit = true;
+  monitor().broadcast();
+  monitor().unlock();
+}
+
+/**
+ * Get this thread's id for use in lock ownership tests. This is just the
+ * thread's slot as returned by {@link #getThreadSlot()}, shifted appropriately
+ * so it can be directly used in the ownership tests.
+ *
+ * @return the thread's id for use in lock owner ship tests
+ */
+public int getLockingId() {
+  return lockingId;
+}
 
+/**
+ * Provides a skeleton implementation for use in soft handshakes.
+ * <p>
+ * During a soft handshake, the requesting thread waits for all mutator threads
+ * (i.e. non-gc threads) to perform a requested action.
+ */
+@Uninterruptible
+public abstract static class SoftHandshakeVisitor {
   /**
-   * The return barrier.
+   * Sets whatever flags need to be set to signal that the given thread should
+   * perform some action when it acknowledges the soft handshake.
    * <p>
-   * The following code implements return barriers as described
-   * for Lisp by Yuasa
-   *
-   * http://www.yuasa.kuis.kyoto-u.ac.jp/~yuasa/ilc2002/index.html
-   * http://dx.doi.org/10.1109/ISORC.2005.45
-   *
-   * and for Jikes RVM by Kumar et al
+   * This method is only called for threads for which {@link #includeThread(RVMThread)}
+   * is {@code true}.
+   * <p>
+   * This method is called with the thread's monitor held, but while the
+   * thread may still be running. This method is not called on mutators that
+   * have indicated that they are about to terminate.
    *
-   * http://dx.doi.org/10.1145/2398857.2384639
+   * @param t the thread that will be processed
+   * @return {@code false} if not interested in this thread, {@code true} otherwise.
+   * Returning {@code true} will cause a soft handshake request to be put through.
+   */
+  public abstract boolean checkAndSignal(RVMThread t);
+
+  /**
+   * Called when it is determined that the thread is stuck in native. While
+   * this method is being called, the thread cannot return to running Java
+   * code. As such, it is safe to perform actions "on the thread's behalf".
    * <p>
-   * This code is executed when a method returns into a frame that
-   * has been hijacked by the return barrier mechanism.   The return
-   * barrier trampoline will save state, execute this method, and
-   * then upon return from this method will transparently return into
-   * the frame that had been hijacked.
+   * This implementation does nothing.
+   *
+   * @param t the thread that's stuck in native
+   */
+  public void notifyStuckInNative(RVMThread t) {
+  }
+
+  /**
+   * Checks whether to include the specified thread in the soft handshake.
    * <p>
-   * In this default implementation, the barrier reinstalls itself
-   * in the caller's frame thus incrementally moving the barrier down
-   * the stack.
+   * This method will never see any threads from the garbage collector because
+   * those are excluded from the soft handshake by design.
    * <p>
-   * The execution of this method is fragile.  It is generally safest
-   * to call some other method from here that does the substantive work
-   * of the barrier.
+   * This implementation always returns {@code true}.
+   *
+   * @param t The thread to check for inclusion
+   * @return {@code true} if the thread should be included.
    */
-  @Entrypoint
-  @Uninterruptible
-  @Unpreemptible
-  public static void returnBarrier() {
-    /* reinstall the barrier in the caller's frame */
-    if (DEBUG_STACK_TRAMPOLINE) {
-      if (VM.BuildForIA32) {
-        VM.sysWriteln(getCurrentThread().getId(), " T0: ",
-            getCurrentThread().trampolineRegisters.getGPRs().
-            get(org.jikesrvm.ia32.RegisterConstants.EAX.value()).toAddress());
-        VM.sysWriteln(getCurrentThread().getId(), " T1: ",
-            getCurrentThread().trampolineRegisters.getGPRs().
-            get(org.jikesrvm.ia32.RegisterConstants.EDX.value()).toAddress());
+  public boolean includeThread(RVMThread t) {
+    return true;
+  }
+}
+
+@NoCheckStore
+public static int snapshotHandshakeThreads(SoftHandshakeVisitor v) {
+  // figure out which threads to consider
+  acctLock.lockNoHandshake(); // get a consistent view of which threads are live.
+
+  int numToHandshake = 0;
+  for (int i = 0; i < numThreads; ++i) {
+    RVMThread t = threads[i];
+    // We exclude the following threads from the handshake:
+    // -the current thread (because we would deadlock if we included it)
+    // -threads that ignore handshakes by design (e.g. the timer thread)
+    // -collector threads (because they never yield and we would deadlock if we
+    //   tried to wait for them)
+    // -the threads that the provided visitor does not want to include
+    if (t != RVMThread.getCurrentThread() && !t.ignoreHandshakesAndGC() &&
+        !t.isCollectorThread() && v.includeThread(t)) {
+      handshakeThreads[numToHandshake++] = t;
+        }
+  }
+  acctLock.unlock();
+  return numToHandshake;
+}
+
+/**
+ * Tell each thread to take a yieldpoint and wait until all of them have done
+ * so at least once. Additionally, call the visitor on each thread when making
+ * the yieldpoint request; the purpose of the visitor is to set any additional
+ * fields as needed to make specific requests to the threads that yield. Note
+ * that the visitor's <code>visit()</code> method is called with both the
+ * thread's monitor held, and the <code>softHandshakeDataLock</code> held.
+ * <p>
+ * Currently we only use this mechanism for code patch isync requests on PPC,
+ * but this mechanism is powerful enough to be used by sliding-views style
+ * concurrent GC.
+ *
+ * @param v the visitor to use for the handshake
+ */
+@NoCheckStore
+@Unpreemptible("Does not perform actions that lead to blocking, but may wait for threads to rendezvous with the soft handshake")
+public static void softHandshake(SoftHandshakeVisitor v) {
+  handshakeLock.lockWithHandshake(); /*
+                                      * prevent multiple (soft or hard) handshakes
+                                      * from proceeding concurrently
+                                      */
+
+  int numToHandshake = snapshotHandshakeThreads(v);
+  if (VM.VerifyAssertions)
+    VM._assert(softHandshakeLeft == 0);
+
+  // in turn, check if each thread needs a handshake, and if so,
+  // request one
+  for (int i = 0; i < numToHandshake; ++i) {
+    RVMThread t = handshakeThreads[i];
+    handshakeThreads[i] = null; // help GC
+    t.monitor().lockNoHandshake();
+    boolean waitForThisThread = false;
+    if (!t.isAboutToTerminate && v.checkAndSignal(t)) {
+      // CAS the execStatus field
+      t.setBlockedExecStatus();
+      // Note that at this point if the thread tries to either enter or
+      // exit Java code, it will be diverted into either
+      // enterNativeBlocked() or checkBlock(), both of which cannot do
+      // anything until they acquire the monitor() lock, which we now
+      // hold. Thus, the code below can, at its leisure, examine the
+      // thread's state and make its decision about what to do, fully
+      // confident that the thread's state is blocked from changing.
+      if (t.isInJava()) {
+        // the thread is currently executing Java code, so we must ensure
+        // that it either:
+        // 1) takes the next yieldpoint and rendezvous with this soft
+        // handshake request (see yieldpoint), or
+        // 2) performs the rendezvous when leaving Java code
+        // (see enterNativeBlocked, checkBlock, and addAboutToTerminate)
+        // either way, we will wait for it to get there before exiting
+        // this call, since the caller expects that after softHandshake()
+        // returns, no thread will be running Java code without having
+        // acknowledged.
+        t.softHandshakeRequested = true;
+        t.takeYieldpoint = 1;
+        waitForThisThread = true;
       } else {
-        // Return barrier not yet supported on other architectures
-        if (VM.VerifyAssertions) VM._assert(VM.NOT_REACHED);
+        // the thread is not in Java code (it may be blocked or it may be
+        // in native), so we don't have to wait for it since it will
+        // do the Right Thing before returning to Java code. essentially,
+        // the thread cannot go back to running Java without doing whatever
+        // was requested because:
+        // A) we've set the execStatus to blocked, and
+        // B) we're holding its lock.
+        v.notifyStuckInNative(t);
       }
-      VM.sysWriteln(getCurrentThread().getId(), " nf: ", getCurrentThread().hijackedReturnCallerFp);
-      VM.sysWriteln(getCurrentThread().getId(), " lf: ", getCurrentThread().hijackedReturnCalleeFp);
-      VM.sysWriteln(getCurrentThread().getId(), " fp: ", Magic.getFramePointer());
-      VM.sysWriteln(getCurrentThread().getId(), " np: ", Magic.getCallerFramePointer(Magic.getFramePointer()));
     }
-    /* reinstall the barrier in the specified frame */
-    getCurrentThread().installStackTrampolineBridge(getCurrentThread().hijackedReturnCallerFp);
+    t.monitor().unlock();
+
+    // NOTE: at this point the thread may already decrement the
+    // softHandshakeLeft counter, causing it to potentially go negative.
+    // this is unlikely and completely harmless.
+
+    if (waitForThisThread) {
+      softHandshakeDataLock.lockNoHandshake();
+      softHandshakeLeft++;
+      softHandshakeDataLock.unlock();
+    }
   }
 
-  /**
-   * Install the stack trampoline bridge at a given frame, hijacking
-   * that frame, saving the hijacked return address and callee fp
-   * in thread-local state to allow execution of the hijacked frame
-   * later.
-   *
-   * @param targetFp The frame to be hijacked.
-   */
-  @Uninterruptible
-  public void installStackTrampolineBridge(Address targetFp) {
-    Address trampoline = getStackTrampolineBridgeIP();
-    if (trampoline.isZero()) {
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-      else
-        VM.sysWriteln("Warning: attempt to install stack trampoline without bridge instructions - nothing done.  See RVMThread.");
-    } else if (trampoline.NE(Magic.getReturnAddressUnchecked(targetFp))) {
-      /* install the trampoline at fp or the next suitable frame after fp */
-      while (true) {
-        if (Magic.getCallerFramePointer(targetFp).EQ(StackFrameLayout.getStackFrameSentinelFP())) {
-          /* if we're at the bottom of the stack, then do not install anything */
-          hijackedReturnAddress = Address.zero();
-          hijackedReturnCalleeFp = Address.zero();
-          return;
+  // wait for all threads to reach the handshake
+  softHandshakeDataLock.lockNoHandshake();
+  if (VM.VerifyAssertions)
+    VM._assert(softHandshakeLeft >= 0);
+  while (softHandshakeLeft > 0) {
+    // wait and tell the world that we're off in native land. this way
+    // if someone tries to block us at this point (suspend() or GC),
+    // they'll know not to wait for us.
+    softHandshakeDataLock.waitWithHandshake();
+  }
+  if (VM.VerifyAssertions)
+    VM._assert(softHandshakeLeft == 0);
+  softHandshakeDataLock.unlock();
+
+  processAboutToTerminate();
+
+  handshakeLock.unlock();
+}
+
+/**
+ * Checks and clears the need for a soft handshake rendezvous.  This method
+ * cannot do anything that leads to a write barrier or allocation.
+ *
+ * @return whether the soft handshake can be committed
+ */
+public boolean softRendezvousCheckAndClear() {
+  boolean result = false;
+  monitor().lockNoHandshake();
+  if (softHandshakeRequested) {
+    softHandshakeRequested = false;
+    result = true;
+  }
+  monitor().unlock();
+  return result;
+}
+
+/**
+ * Commits the soft handshake rendezvous.  This method cannot do anything
+ * that leads to a write barrier or allocation.
+ */
+public void softRendezvousCommit() {
+  softHandshakeDataLock.lockNoHandshake();
+  softHandshakeLeft--;
+  if (softHandshakeLeft == 0) {
+    softHandshakeDataLock.broadcast();
+  }
+  softHandshakeDataLock.unlock();
+}
+
+/**
+ * Rendezvous with a soft handshake request. Can only be called when the
+ * thread's monitor is held.
+ */
+public void softRendezvous() {
+  if (softRendezvousCheckAndClear())
+    softRendezvousCommit();
+}
+
+/**
+ * Handle requests that required a soft handshake. May be called after we
+ * acknowledged the soft handshake. Thus - this is for actions in which it is
+ * sufficient for the thread to acknowledge that it plans to act upon the
+ * request in the immediate future, rather than that the thread acts upon the
+ * request prior to acknowledging.
+ * <p>
+ * This is almost always called with the monitor() lock held, but that's
+ * not guaranteed.  If you need that lock, you can grab it (since it's a
+ * recursive lock).  But you should avoid grabbing other sorts of locks since
+ * that might cause deadlock.
+ */
+void handleHandshakeRequest() {
+  // Process request for code-patch memory sync operation
+  if (VM.BuildForPowerPC && codePatchSyncRequested) {
+    codePatchSyncRequested = false;
+    // Q: Is this sufficient? Ask Steve why we don't need to sync
+    // icache/dcache. --dave
+    // A: Yes, this is sufficient. We (Filip and Dave) talked about it and
+    // agree that remote processors only need to execute isync. --Filip
+    // make sure not get stale data
+    Magic.synchronizeInstructionCache();
+  }
+  // process memory management requests
+  if (flushRequested && activeMutatorContext) {
+    MemoryManager.flushMutatorContext();
+    flushRequested = false;
+  }
+  // not really a "soft handshake" request but we handle it here anyway
+  if (asyncDebugRequestedForThisThread) {
+    asyncDebugRequestedForThisThread = false;
+    dumpLock.lockNoHandshake();
+    VM.sysWriteln("Handling async stack trace request...");
+    dump();
+    VM.sysWriteln();
+    dumpStack();
+    dumpLock.unlock();
+  }
+}
+
+/**
+ * Stop all mutator threads. This is current intended to be run by a single thread.
+ *
+ * Fixpoint until there are no threads that we haven't blocked. Fixpoint is needed to
+ * catch the (unlikely) case that a thread spawns another thread while we are waiting.
+ */
+@NoCheckStore
+@Unpreemptible
+public static void blockAllMutatorsForGC() {
+  RVMThread.handshakeLock.lockNoHandshake();
+  while (true) {
+    // (1) Find all the threads that need to be blocked for GC
+    RVMThread.acctLock.lockNoHandshake();
+    int numToHandshake = 0;
+    for (int i = 0; i < RVMThread.numThreads; i++) {
+      RVMThread t = RVMThread.threads[i];
+      if (!t.isCollectorThread() && !t.ignoreHandshakesAndGC()) {
+        RVMThread.handshakeThreads[numToHandshake++] = t;
+      }
+    }
+    RVMThread.acctLock.unlock();
+
+    // (2) Remove any threads that have already been blocked from the list.
+    for (int i = 0; i < numToHandshake; i++) {
+      RVMThread t = RVMThread.handshakeThreads[i];
+      t.monitor().lockNoHandshake();
+      if (t.blockedFor(RVMThread.gcBlockAdapter) || RVMThread.notRunning(t.asyncBlock(RVMThread.gcBlockAdapter))) {
+        // Already blocked or not running, remove.
+        RVMThread.handshakeThreads[i--] = RVMThread.handshakeThreads[--numToHandshake];
+        RVMThread.handshakeThreads[numToHandshake] = null; // help GC
+      }
+      t.monitor().unlock();
+    }
+
+    // (3) Quit trying to block threads if all threads are either blocked
+    //     or not running (a thread is "not running" if it is NEW or TERMINATED;
+    //     in the former case it means that the thread has not had start()
+    //     called on it while in the latter case it means that the thread
+    //     is either in the TERMINATED state or is about to be in that state
+    //     real soon now, and will not perform any heap-related work before
+    //     terminating).
+    if (numToHandshake == 0) break;
+
+    // (4) Request a block for GC from all other threads.
+    for (int i = 0; i < numToHandshake; i++) {
+      if (false) VM.sysWriteln("Waiting for ", RVMThread.handshakeThreads[i].getThreadSlot(), " to block.");
+      RVMThread t = RVMThread.handshakeThreads[i];
+      RVMThread.observeExecStatusAtSTW(t.block(RVMThread.gcBlockAdapter));
+      RVMThread.handshakeThreads[i] = null; // help GC
+    }
+  }
+  RVMThread.handshakeLock.unlock();
+
+  // Deal with terminating threads to ensure that all threads are either dead to MMTk or stopped above.
+  RVMThread.processAboutToTerminate();
+}
+
+/**
+ * Unblock all mutators blocked for GC.
+ */
+@NoCheckStore
+@Unpreemptible
+public static void unblockAllMutatorsForGC() {
+  RVMThread.handshakeLock.lockNoHandshake();
+  RVMThread.acctLock.lockNoHandshake();
+  int numToHandshake = 0;
+  for (int i = 0; i < RVMThread.numThreads; i++) {
+    RVMThread t = RVMThread.threads[i];
+    if (!t.isCollectorThread() && !t.ignoreHandshakesAndGC()) {
+      RVMThread.handshakeThreads[numToHandshake++] = t;
+    }
+  }
+  RVMThread.acctLock.unlock();
+  for (int i = 0; i < numToHandshake; i++) {
+    RVMThread.handshakeThreads[i].unblock(RVMThread.gcBlockAdapter);
+    RVMThread.handshakeThreads[i] = null; // Help GC
+  }
+  RVMThread.handshakeLock.unlock();
+}
+
+@Uninterruptible
+public static class HardHandshakeVisitor {
+  public boolean includeThread(RVMThread t) {
+    return true;
+  }
+}
+
+@Uninterruptible
+@NonMoving
+static class AllButGCHardHandshakeVisitor extends HardHandshakeVisitor {
+  @Override
+  public boolean includeThread(RVMThread t) {
+    return !t.isCollectorThread();
+  }
+}
+
+public static final AllButGCHardHandshakeVisitor allButGC =
+new AllButGCHardHandshakeVisitor();
+
+static long totalSuspendTime;
+static long totalResumeTime;
+
+@Unpreemptible
+@NoCheckStore
+public static void hardHandshakeSuspend(BlockAdapter ba,
+    HardHandshakeVisitor hhv) {
+  long before = sysCall.sysNanoTime();
+
+  RVMThread current = getCurrentThread();
+
+  handshakeLock.lockWithHandshake();
+  int numLockedLocks = 0;
+  for (int i = 0; i < nextSlot;++i) {
+    Monitor l = communicationLockBySlot[i];
+    if (l != null) {
+      l.lockWithHandshake();
+      numLockedLocks++;
+    }
+  }
+
+  // fixpoint until there are no threads that we haven't blocked.
+  // fixpoint is needed in case some thread spawns another thread
+  // while we're waiting.  that is unlikely but possible.
+  for (;;) {
+    acctLock.lockNoHandshake();
+    int numToHandshake = 0;
+    for (int i = 0; i < numThreads;++i) {
+      RVMThread t = threads[i];
+      if (t != current &&
+          !t.ignoreHandshakesAndGC() &&
+          hhv.includeThread(t)) {
+        handshakeThreads[numToHandshake++] = t;
+          }
+    }
+    acctLock.unlock();
+
+    for (int i = 0; i < numToHandshake;++i) {
+      RVMThread t = handshakeThreads[i];
+      t.monitor().lockNoHandshake();
+      if (t.blockedFor(ba) ||
+          notRunning(t.asyncBlock(ba))) {
+        // already blocked or not running, remove
+        handshakeThreads[i--] = handshakeThreads[--numToHandshake];
+        handshakeThreads[numToHandshake] = null; // help GC
+          }
+      t.monitor().unlock();
+    }
+    // quit trying to block threads if all threads are either blocked
+    // or not running (a thread is "not running" if it is NEW or TERMINATED;
+    // in the former case it means that the thread has not had start()
+    // called on it while in the latter case it means that the thread
+    // is either in the TERMINATED state or is about to be in that state
+    // real soon now, and will not perform any heap-related stuff before
+    // terminating).
+    if (numToHandshake == 0) break;
+    for (int i = 0; i < numToHandshake;++i) {
+      RVMThread t = handshakeThreads[i];
+      observeExecStatusAtSTW(t.block(ba));
+      handshakeThreads[i] = null; // help GC
+    }
+  }
+
+  processAboutToTerminate(); /*
+                              * ensure that any threads that died while
+                              * we were stopping the world notify us
+                              * that they had stopped.
+                              */
+
+  int numUnlockedLocks = 0;
+  for (int i = 0; i < nextSlot;++i) {
+    Monitor l = communicationLockBySlot[i];
+    if (l != null) {
+      l.unlock();
+      numUnlockedLocks++;
+    }
+  }
+  if (VM.VerifyAssertions) VM._assert(numLockedLocks == numUnlockedLocks);
+  handshakeLock.unlock();
+
+  if (false) {
+    long after = sysCall.sysNanoTime();
+    totalSuspendTime += after - before;
+    VM.sysWriteln("Stopping the world took ",(after - before)," ns (",totalSuspendTime," ns total)");
+  }
+}
+
+@NoCheckStore
+@Unpreemptible
+public static void hardHandshakeResume(BlockAdapter ba,
+    HardHandshakeVisitor hhv) {
+  long before = sysCall.sysNanoTime();
+
+  handshakeLock.lockWithHandshake();
+
+  RVMThread current = getCurrentThread();
+  acctLock.lockNoHandshake();
+  int numToHandshake = 0;
+  for (int i = 0; i < numThreads;++i) {
+    RVMThread t = threads[i];
+    if (t != current &&
+        !t.ignoreHandshakesAndGC() &&
+        hhv.includeThread(t)) {
+      handshakeThreads[numToHandshake++] = t;
         }
-        int cmid = Magic.getCompiledMethodID(targetFp);
-        if (cmid == StackFrameLayout.getInvisibleMethodID()) {
-          /* skip invisible methods */
-          targetFp = Magic.getCallerFramePointer(targetFp);
-        } else {
-          CompiledMethod calleeCM = CompiledMethods.getCompiledMethod(cmid);
-          if (calleeCM.getCompilerType() == CompiledMethod.TRAP ||
-              calleeCM.getMethod().getDeclaringClass().hasBridgeFromNativeAnnotation()) {
-            /* skip traps and native bridges */
-            targetFp = Magic.getCallerFramePointer(targetFp);
-          } else
-            break;
+  }
+  acctLock.unlock();
+  for (int i = 0; i < numToHandshake;++i) {
+    handshakeThreads[i].unblock(ba);
+    handshakeThreads[i] = null; // help GC
+  }
+
+  handshakeLock.unlock();
+
+  if (false) {
+    long after = sysCall.sysNanoTime();
+    totalResumeTime += after - before;
+    VM.sysWriteln("Resuming the world took ",(after - before)," ns (",totalResumeTime," ns total)");
+  }
+}
+
+@Unpreemptible
+public static void hardHandshakeSuspend() {
+  hardHandshakeSuspend(handshakeBlockAdapter,allButGC);
+}
+
+@Unpreemptible
+public static void hardHandshakeResume() {
+  hardHandshakeResume(handshakeBlockAdapter,allButGC);
+}
+
+/**
+ * Process a taken yieldpoint.
+ *
+ * @param whereFrom source of the yieldpoint (e.g. backedge)
+ * @param yieldpointServiceMethodFP the frame pointer of the service
+ *  method that called this method
+ */
+@Unpreemptible("May block if the thread was asked to do so but otherwise does not perform actions that may lead to blocking")
+public static void yieldpoint(int whereFrom, Address yieldpointServiceMethodFP) {
+  RVMThread t = getCurrentThread();
+  boolean wasAtYieldpoint = t.atYieldpoint;
+  t.atYieldpoint = true;
+  t.yieldpointsTaken++;
+  // If thread is in critical section we can't do anything right now, defer
+  // until later
+  // we do this without acquiring locks, since part of the point of disabling
+  // yieldpoints is to ensure that locks are not "magically" acquired
+  // through unexpected yieldpoints. As well, this makes code running with
+  // yieldpoints disabled more predictable. Note furthermore that the only
+  // race here is setting takeYieldpoint to 0. But this is perfectly safe,
+  // since we are guaranteeing that a yieldpoint will run after we emerge from
+  // the no-yieldpoints code. At worst, setting takeYieldpoint to 0 will be
+  // lost (because some other thread sets it to non-0), but in that case we'll
+  // just come back here and reset it to 0 again.
+  if (!t.yieldpointsEnabled()) {
+    if (VM.VerifyAssertions)
+      VM._assert(!t.yieldToOSRRequested);
+    if (traceBlock && !wasAtYieldpoint) {
+      VM.sysWriteln("Thread #", t.threadSlot, " deferring yield!");
+      dumpStack();
+    }
+    t.yieldpointRequestPending = true;
+    t.takeYieldpoint = 0;
+    t.atYieldpoint = false;
+    return;
+  }
+  t.yieldpointsTakenFully++;
+
+  Throwable throwThis = null;
+  t.monitor().lockNoHandshake();
+
+  int takeYieldpointVal = t.takeYieldpoint;
+  if (takeYieldpointVal != 0) {
+    t.takeYieldpoint = 0;
+    // do two things: check if we should be blocking, and act upon
+    // handshake requests. This also has the effect of reasserting that
+    // we are in fact IN_JAVA (as opposed to IN_JAVA_TO_BLOCK).
+    t.wsWrapperCheckBlock();
+
+    // Process timer interrupt event
+    if (t.timeSliceExpired != 0) {
+      t.timeSliceExpired = 0;
+
+      if (t.yieldForCBSCall || t.yieldForCBSMethod) {
+        /*
+         * CBS Sampling is still active from previous quantum. Note that fact,
+         * but leave all the other CBS parameters alone.
+         */
+      } else {
+        if (VM.CBSCallSamplesPerTick > 0) {
+          t.yieldForCBSCall = true;
+          t.takeYieldpoint = -1;
+          t.firstCBSCallSample++;
+          t.firstCBSCallSample = t.firstCBSCallSample % VM.CBSCallSampleStride;
+          t.countdownCBSCall = t.firstCBSCallSample;
+          t.numCBSCallSamples = VM.CBSCallSamplesPerTick;
+        }
+
+        if (VM.CBSMethodSamplesPerTick > 0) {
+          t.yieldForCBSMethod = true;
+          t.takeYieldpoint = -1;
+          t.firstCBSMethodSample++;
+          t.firstCBSMethodSample = t.firstCBSMethodSample % VM.CBSMethodSampleStride;
+          t.countdownCBSMethod = t.firstCBSMethodSample;
+          t.numCBSMethodSamples = VM.CBSMethodSamplesPerTick;
         }
       }
-      hijackedReturnAddress = Magic.getReturnAddressUnchecked(targetFp);
-      hijackedReturnCalleeFp = targetFp;
-      hijackedReturnCallerFp = Magic.getCallerFramePointer(targetFp);
-      if (VM.VerifyAssertions) VM._assert(trampoline.NE(hijackedReturnAddress));
-      if (DEBUG_STACK_TRAMPOLINE) dumpFrame(targetFp);
-      Magic.setReturnAddress(targetFp, trampoline);
-      if (DEBUG_STACK_TRAMPOLINE) {
-        dumpFrame(targetFp);
-        VM.sysWriteln(getId(), " Installing trampoline at: ", targetFp);
-        VM.sysWriteln(getId(), " Trampoline: ", trampoline);
-        VM.sysWriteln(getId(), " Hijacked return address: ", hijackedReturnAddress);
-        VM.sysWriteln(getId(), " Callee fp: ", hijackedReturnCalleeFp);
-        VM.sysWriteln(getId(), " Caller fp: ", hijackedReturnCallerFp);
-        dumpStack(hijackedReturnCalleeFp);
+
+      if (VM.BuildForAdaptiveSystem) {
+        RuntimeMeasurements.takeTimerSample(whereFrom,
+            yieldpointServiceMethodFP);
+      }
+      if (VM.BuildForAdaptiveSystem) {
+        OSRListener
+          .checkForOSRPromotion(whereFrom, yieldpointServiceMethodFP);
+      }
+    }
+
+    if (t.yieldForCBSCall) {
+      if (!(whereFrom == BACKEDGE || whereFrom == OSROPT)) {
+        if (--t.countdownCBSCall <= 0) {
+          if (VM.BuildForAdaptiveSystem) {
+            // take CBS sample
+            RuntimeMeasurements.takeCBSCallSample(whereFrom,
+                yieldpointServiceMethodFP);
+          }
+          t.countdownCBSCall = VM.CBSCallSampleStride;
+          t.numCBSCallSamples--;
+          if (t.numCBSCallSamples <= 0) {
+            t.yieldForCBSCall = false;
+          }
+        }
+      }
+      if (t.yieldForCBSCall) {
+        t.takeYieldpoint = -1;
+      }
+    }
+
+    if (t.yieldForCBSMethod) {
+      if (--t.countdownCBSMethod <= 0) {
+        if (VM.BuildForAdaptiveSystem) {
+          // take CBS sample
+          RuntimeMeasurements.takeCBSMethodSample(whereFrom,
+              yieldpointServiceMethodFP);
+        }
+        t.countdownCBSMethod = VM.CBSMethodSampleStride;
+        t.numCBSMethodSamples--;
+        if (t.numCBSMethodSamples <= 0) {
+          t.yieldForCBSMethod = false;
+        }
+      }
+      if (t.yieldForCBSMethod) {
+        t.takeYieldpoint = 1;
+      }
+    }
+
+    if (VM.BuildForAdaptiveSystem && t.yieldToOSRRequested) {
+      t.yieldToOSRRequested = false;
+      OSRListener.handleOSRFromOpt(yieldpointServiceMethodFP);
+    }
+
+    // what is the reason for this? and what was the reason for doing
+    // a thread switch following the suspension in the OSR trigger code?
+    // ... it seems that at least part of the point here is that if a
+    // thread switch was desired for other reasons, then we need to ensure
+    // that between when this runs and when the glue code runs there will
+    // be no interleaved GC; obviously if we did this before the thread
+    // switch then there would be the possibility of interleaved GC.
+    if (VM.BuildForAdaptiveSystem && t.isWaitingForOsr) {
+      if (VM.BuildForIA32) {
+        org.jikesrvm.osr.ia32.PostThreadSwitch.postProcess(t);
+      } else {
+        if (VM.VerifyAssertions) VM._assert(VM.BuildForPowerPC);
+        org.jikesrvm.osr.ppc.PostThreadSwitch.postProcess(t);
+      }
+    }
+    if (t.asyncThrowable != null) {
+      throwThis = t.asyncThrowable;
+      t.asyncThrowable = null;
+    }
+  }
+  t.monitor().unlock();
+  t.atYieldpoint = false;
+  if (throwThis != null) {
+    throwFromUninterruptible(throwThis);
+  }
+  t.checkAbortFlagAndRespond();
+}
+
+@Unpreemptible
+@Inline
+protected void checkAbortFlagAndRespond() {
+  if(yieldToThrowAbortAtFailure && wsSynchronizationLock == 0) {
+    yieldToThrowAbortAtFailure = false;
+    wsFlag = false;
+    throwFromUninterruptible(wsAbortAtFailure);
+  }
+}
+
+@Unpreemptible
+private static void throwFromUninterruptible(Throwable e) {
+  RuntimeEntrypoints.athrow(e);
+}
+
+/**
+ * Change the size of the currently executing thread's stack.
+ *
+ * @param newSize
+ *          new size (in bytes)
+ * @param exceptionRegisters
+ *          register state at which stack overflow trap was encountered (null
+ *          --&gt; normal method call, not a trap)
+ */
+@Unpreemptible("May block due to allocation")
+public static void resizeCurrentStack(int newSize,
+    AbstractRegisters exceptionRegisters) {
+  if (!getCurrentThread().hijackedReturnAddress.isZero()) {
+    /* stack resizing currently unsupported with return barrier */
+    VM.sysFail("system error: resizing stack while return barrier enabled (currently unsupported)");
+  }
+  if (traceAdjustments)
+    VM.sysWriteln("Thread: resizeCurrentStack");
+  if (MemoryManager.gcInProgress()) {
+    VM.sysFail("system error: resizing stack while GC is in progress");
+  }
+  byte[] newStack = MemoryManager.newStack(newSize);
+  getCurrentThread().disableYieldpoints();
+  transferExecutionToNewStack(newStack, exceptionRegisters);
+  getCurrentThread().enableYieldpoints();
+  if (traceAdjustments) {
+    RVMThread t = getCurrentThread();
+    VM.sysWrite("Thread: resized stack ", t.getThreadSlot());
+    VM.sysWrite(" to ", t.stack.length / 1024);
+    VM.sysWriteln("k");
+  }
+}
+
+@NoInline
+@BaselineNoRegisters
+// this method does not do a normal return and hence does not execute epilogue
+// --> non-volatiles not restored!
+private static void transferExecutionToNewStack(byte[] newStack, AbstractRegisters exceptionRegisters) {
+  // prevent opt compiler from inlining a method that contains a magic
+  // (returnToNewStack) that it does not implement.
+
+  RVMThread myThread = getCurrentThread();
+  byte[] myStack = myThread.stack;
+
+  // initialize new stack with live portion of stack we're
+  // currently running on
+  //
+  // lo-mem hi-mem
+  // |<---myDepth----|
+  // +----------+---------------+
+  // | empty | live |
+  // +----------+---------------+
+  // ^myStack ^myFP ^myTop
+  //
+  // +-------------------+---------------+
+  // | empty | live |
+  // +-------------------+---------------+
+  // ^newStack ^newFP ^newTop
+  //
+  Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
+  Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
+
+  Address myFP = Magic.getFramePointer();
+  Offset myDepth = myTop.diff(myFP);
+  Address newFP = newTop.minus(myDepth);
+
+  // The frame pointer addresses the top of the frame on powerpc and
+  // the bottom
+  // on intel. if we copy the stack up to the current
+  // frame pointer in here, the
+  // copy will miss the header of the intel frame. Thus we make another
+  // call
+  // to force the copy. A more explicit way would be to up to the
+  // frame pointer
+  // and the header for intel.
+  Offset delta = copyStack(newStack);
+
+  // fix up registers and save areas so they refer
+  // to "newStack" rather than "myStack"
+  //
+  if (exceptionRegisters != null) {
+    adjustRegisters(exceptionRegisters, delta);
+  }
+  adjustStack(newStack, newFP, delta);
+
+  // install new stack
+  //
+  myThread.stack = newStack;
+  myThread.stackLimit = Magic.objectAsAddress(newStack).plus(StackFrameLayout.getStackSizeGuard());
+
+  // return to caller, resuming execution on new stack
+  // (original stack now abandoned)
+  //
+  if (VM.BuildForPowerPC) {
+    Magic.returnToNewStack(Magic.getCallerFramePointer(newFP));
+  } else if (VM.BuildForIA32) {
+    Magic.returnToNewStack(newFP);
+  }
+
+  if (VM.VerifyAssertions)
+    VM._assert(VM.NOT_REACHED);
+}
+
+/**
+ * This (suspended) thread's stack has been moved. Fixup register and memory
+ * references to reflect its new position.
+ *
+ * @param delta
+ *          displacement to be applied to all interior references
+ */
+public void fixupMovedStack(Offset delta) {
+  if (traceAdjustments)
+    VM.sysWriteln("Thread: fixupMovedStack");
+
+  if (!contextRegisters.getInnermostFramePointer().isZero()) {
+    adjustRegisters(contextRegisters, delta);
+  }
+  if ((exceptionRegisters.getInUse()) &&
+      (exceptionRegisters.getInnermostFramePointer().NE(Address.zero()))) {
+    adjustRegisters(exceptionRegisters, delta);
+      }
+  if (!contextRegisters.getInnermostFramePointer().isZero()) {
+    adjustStack(stack, contextRegisters.getInnermostFramePointer(), delta);
+  }
+  stackLimit = stackLimit.plus(delta);
+}
+
+/**
+ * A thread's stack has been moved or resized. Adjust registers to reflect new
+ * position.
+ *
+ * @param registers
+ *          registers to be adjusted
+ * @param delta
+ *          displacement to be applied
+ */
+private static void adjustRegisters(AbstractRegisters registers, Offset delta) {
+  if (traceAdjustments)
+    VM.sysWriteln("Thread: adjustRegisters");
+
+  // adjust FP
+  //
+  Address newFP = registers.getInnermostFramePointer().plus(delta);
+  Address ip = registers.getInnermostInstructionAddress();
+  registers.setInnermost(ip, newFP);
+  if (traceAdjustments) {
+    VM.sysWrite(" fp=");
+    VM.sysWrite(registers.getInnermostFramePointer());
+  }
+
+  // additional architecture specific adjustments
+  // (1) frames from all compilers on IA32 need to update ESP
+  int compiledMethodId = Magic.getCompiledMethodID(registers
+      .getInnermostFramePointer());
+  if (compiledMethodId != StackFrameLayout.getInvisibleMethodID()) {
+    if (VM.BuildForIA32) {
+      registers.adjustESP(delta, traceAdjustments);
+    }
+    if (traceAdjustments) {
+      CompiledMethod compiledMethod = CompiledMethods
+        .getCompiledMethod(compiledMethodId);
+      VM.sysWrite(" method=");
+      VM.sysWrite(compiledMethod.getMethod());
+      VM.sysWriteln();
+    }
+  }
+}
+
+/**
+ * A thread's stack has been moved or resized. Adjust internal pointers to
+ * reflect new position.
+ *
+ * @param stack
+ *          stack to be adjusted
+ * @param fp
+ *          pointer to its innermost frame
+ * @param delta
+ *          displacement to be applied to all its interior references
+ */
+private static void adjustStack(byte[] stack, Address fp, Offset delta) {
+  if (traceAdjustments)
+    VM.sysWriteln("Thread: adjustStack");
+
+  while (Magic.getCallerFramePointer(fp).NE(StackFrameLayout.getStackFrameSentinelFP())) {
+    // adjust FP save area
+    //
+    Magic.setCallerFramePointer(fp, Magic.getCallerFramePointer(fp).plus(
+          delta));
+    if (traceAdjustments) {
+      VM.sysWrite(" fp=", fp.toWord());
+    }
+
+    // advance to next frame
+    //
+    fp = Magic.getCallerFramePointer(fp);
+  }
+}
+
+/**
+ * Initialize a new stack with the live portion of the stack we're currently
+ * running on.
+ *
+ * <pre>
+ *  lo-mem                                        hi-mem
+ *                           |&lt;---myDepth----|
+ *                 +----------+---------------+
+ *                 |   empty  |     live      |
+ *                 +----------+---------------+
+ *                  &circ;myStack   &circ;myFP           &circ;myTop
+ *       +-------------------+---------------+
+ *       |       empty       |     live      |
+ *       +-------------------+---------------+
+ *        &circ;newStack           &circ;newFP          &circ;newTop
+ * </pre>
+ *
+ * @param newStack space for the new stack
+ * @return offset that needs to be applied to all interior references of
+ *  the new stack
+ */
+private static Offset copyStack(byte[] newStack) {
+  RVMThread myThread = getCurrentThread();
+  byte[] myStack = myThread.stack;
+
+  Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
+  Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
+  Address myFP = Magic.getFramePointer();
+  Offset myDepth = myTop.diff(myFP);
+  Address newFP = newTop.minus(myDepth);
+
+  // before copying, make sure new stack isn't too small
+  //
+  if (VM.VerifyAssertions) {
+    VM._assert(newFP.GE(Magic.objectAsAddress(newStack).plus(StackFrameLayout.getStackSizeGuard())));
+  }
+
+  Memory.memcopy(newFP, myFP, myDepth.toWord().toExtent());
+
+  return newFP.diff(myFP);
+}
+
+/**
+ * Set the "isDaemon" status of this thread. Although a java.lang.Thread can
+ * only have setDaemon invoked on it before it is started, Threads can become
+ * daemons at any time. Note: making the last non daemon a daemon will
+ * terminate the VM.
+ * <p>
+ * Note: This method might need to be uninterruptible so it is final, which is
+ * why it isn't called setDaemon.
+ * <p>
+ * Public so that java.lang.Thread can use it.
+ *
+ * @param on new status for daemon flag
+ */
+public void makeDaemon(boolean on) {
+  if (daemon == on) {
+    // nothing to do
+  } else {
+    daemon = on;
+    if (getExecStatus() == NEW) {
+      // thread will start as a daemon
+    } else {
+      boolean terminateSystem = false;
+      acctLock.lockNoHandshake();
+      numActiveDaemons += on ? 1 : -1;
+      if (numActiveDaemons == numActiveThreads) {
+        terminateSystem = true;
+      }
+      acctLock.unlock();
+      if (terminateSystem) {
+        if (VM.TraceThreads) {
+          trace("Thread", "last non Daemon demonized");
+        }
+        VM.sysExit(0);
+        if (VM.VerifyAssertions)
+          VM._assert(VM.NOT_REACHED);
+      }
+    }
+  }
+}
+
+/**
+ * Dump information for all threads, via {@link VM#sysWrite(String)}. Each
+ * thread's info is newline-terminated.
+ *
+ * @param verbosity Ignored.
+ */
+public static void dumpAll(int verbosity) {
+  for (int i = 0; i < numThreads; i++) {
+    RVMThread t = threads[i];
+    if (t == null)
+      continue;
+    VM.sysWrite("Thread ");
+    VM.sysWriteInt(t.threadSlot);
+    VM.sysWrite(":  ");
+    VM.sysWriteHex(Magic.objectAsAddress(t));
+    VM.sysWrite("   ");
+    t.dump(verbosity);
+    // Compensate for t.dump() not newline-terminating info.
+    VM.sysWriteln();
+  }
+}
+
+/** @return whether this is the primordial thread, i.e.
+ *    the thread that boots the VM before starting the
+ *    main thread
+ *  */
+public boolean isBootThread() {
+  return this == bootThread;
+}
+
+/** @return whether this is the main thread */
+private boolean isMainThread() {
+  return thread instanceof MainThread;
+}
+
+/** @return whether this is a system thread */
+public boolean isSystemThread() {
+  return systemThread != null;
+}
+
+/** @return the collector thread this RVMTHread is running */
+public CollectorThread getCollectorThread() {
+  if (VM.VerifyAssertions) VM._assert(isCollectorThread());
+  return (CollectorThread)systemThread;
+}
+
+/** @return the value of {@link #daemon}. */
+public boolean isDaemonThread() {
+  return daemon;
+}
+
+/**
+ * @return whether this thread should run concurrently with
+ * stop-the-world garbage collection and ignore handshakes
+ */
+public boolean ignoreHandshakesAndGC() {
+  if (systemThread == null) return false;
+  return systemThread instanceof TimerThread;
+}
+
+/** @return whether the thread started and not terminated */
+public boolean isAlive() {
+  monitor().lockNoHandshake();
+  observeExecStatus();
+  boolean result = execStatus != NEW && execStatus != TERMINATED && !isAboutToTerminate;
+  monitor().unlock();
+  return result;
+}
+
+/**
+ * Sets the name of the thread
+ *
+ * @param name the new name for the thread
+ * @see java.lang.Thread#setName(String)
+ */
+public void setName(String name) {
+  this.name = name;
+}
+
+/**
+ * Gets the name of the thread
+ *
+ * @see java.lang.Thread#getName()
+ * @return name of the thread
+ */
+public String getName() {
+  return name;
+}
+
+/**
+ * Does the currently running Thread hold the lock on an obj?
+ *
+ * @param obj
+ *          the object to check
+ * @return whether the thread holds the lock
+ * @see java.lang.Thread#holdsLock(Object)
+ */
+public boolean holdsLock(Object obj) {
+  RVMThread mine = getCurrentThread();
+  return ObjectModel.holdsLock(obj, mine);
+}
+
+/**
+ * Was this thread interrupted?
+ *
+ * @return whether the thread has been interrupted
+ * @see java.lang.Thread#isInterrupted()
+ */
+public boolean isInterrupted() {
+  return hasInterrupt;
+}
+
+/**
+ * Clear the interrupted status of this thread
+ *
+ * @see java.lang.Thread#interrupted()
+ */
+public void clearInterrupted() {
+  hasInterrupt = false;
+}
+
+/**
+ * Interrupt this thread
+ *
+ * @see java.lang.Thread#interrupt()
+ */
+@Interruptible
+public void interrupt() {
+  monitor().lockNoHandshake();
+  hasInterrupt = true;
+  monitor().broadcast();
+  monitor().unlock();
+}
+
+/**
+ * Get the priority of the thread
+ *
+ * @return the thread's priority
+ * @see java.lang.Thread#getPriority()
+ */
+public int getPriority() {
+  if (isAlive()) {
+    // compute current priority
+    priority = sysCall.sysGetThreadPriority(thread_id, priority_handle) + Thread.NORM_PRIORITY;
+  }
+  if (tracePriority) {
+    VM.sysWriteln("Thread #", getThreadSlot(), " get priority returning: ", priority);
+  }
+  return priority;
+}
+
+/**
+ * Set the priority of the thread
+ *
+ * @param priority the thread's priority
+ * @see java.lang.Thread#getPriority()
+ */
+public void setPriority(int priority) {
+  if (isAlive()) {
+    int result = sysCall.sysSetThreadPriority(thread_id, priority_handle, priority - Thread.NORM_PRIORITY);
+    if (result == 0) {
+      this.priority = priority;
+      if (tracePriority) {
+        VM.sysWriteln("Thread #", getThreadSlot(), " set priority: ", priority);
+      }
+    } else {
+      // setting priority failed
+      if (tracePriority) {
+        VM.sysWriteln("Thread #", getThreadSlot(), " failed to set priority: ", priority, ", result: ", result);
+      }
+    }
+  } else {
+    if (tracePriority) {
+      VM.sysWriteln("Thread #", getThreadSlot(), " set priority: ", priority, " while not running");
+    }
+    this.priority = priority;
+  }
+}
+
+/**
+ * Get the state of the thread in a manner compatible with the Java API
+ *
+ * @return thread state
+ * @see java.lang.Thread#getState()
+ */
+@Interruptible
+public Thread.State getState() {
+  monitor().lockNoHandshake();
+  try {
+    observeExecStatus();
+    switch (execStatus) {
+      case NEW:
+        return Thread.State.NEW;
+      case IN_JAVA:
+      case IN_NATIVE:
+      case IN_JNI:
+      case IN_JAVA_TO_BLOCK:
+      case BLOCKED_IN_NATIVE:
+      case BLOCKED_IN_JNI:
+        if (isAboutToTerminate) {
+          return Thread.State.TERMINATED;
+        }
+        switch (waiting) {
+          case RUNNABLE:
+            return Thread.State.RUNNABLE;
+          case WAITING:
+            return Thread.State.WAITING;
+          case TIMED_WAITING:
+            return Thread.State.TIMED_WAITING;
+          default:
+            VM.sysFail("Unknown waiting value: " + waiting);
+            return null;
+        }
+      case TERMINATED:
+        return Thread.State.TERMINATED;
+      default:
+        VM.sysFail("Unknown value of execStatus: " + execStatus);
+        return null;
+    }
+  } finally {
+    monitor().unlock();
+  }
+}
+
+/**
+ * Wait for the thread to die or for the timeout to occur
+ *
+ * @param ms
+ *          milliseconds to wait
+ * @param ns
+ *          nanoseconds to wait
+ * @throws InterruptedException when the thread is interrupted
+ */
+@Interruptible
+public void join(long ms, int ns) throws InterruptedException {
+  RVMThread myThread = getCurrentThread();
+  if (VM.VerifyAssertions)
+    VM._assert(myThread != this);
+  if (traceBlock)
+    VM.sysWriteln("Joining on Thread #", threadSlot);
+  // this uses synchronized because we cannot have one thread acquire
+  // another thread's lock using the WithHandshake scheme, as that would result
+  // in a thread holding two threads' monitor()s.  using synchronized
+  // turns out to be just fine - see comment in terminate().
+  synchronized (this) {
+    if (ms == 0 && ns == 0) {
+      while (!isJoinable) {
+        wait(this);
+        if (traceBlock)
+          VM.sysWriteln("relooping in join on Thread #", threadSlot);
+      }
+    } else {
+      long startNano = Time.nanoTime();
+      long whenWakeup = startNano + ms * 1000L * 1000L + ns;
+      while (!isJoinable) {
+        waitAbsoluteNanos(this, whenWakeup);
+        if (Time.nanoTime() >= whenWakeup) {
+          break;
+        }
+        if (traceBlock)
+          VM.sysWriteln("relooping in join on Thread #", threadSlot);
+      }
+    }
+  }
+}
+
+/**
+ * Gets live threads.
+ * <p>
+ * Note: this is an expensive operation operation because we're grabbing
+ * the accounting lock and thus prevent the threading system from changing
+ * the set of active threads.
+ *
+ * @return the live threads that ought to be user-visible, i.e.
+ *  all threads except the system threads
+ */
+@Interruptible
+public static Thread[] getLiveThreadsForJMX() {
+  int threadIndex = 0;
+
+  acctLock.lockNoHandshake();
+  Thread[] liveThreads = new Thread[numActiveThreads];
+  for (int i = 0; i < RVMThread.numThreads; i++) {
+    RVMThread t = RVMThread.threads[i];
+    if (t.isAlive() && !t.isSystemThread()) {
+      Thread javaLangThread = t.getJavaLangThread();
+      if (javaLangThread == null) {
+        continue;
+      }
+      boolean enoughSpace = threadIndex < numActiveThreads;
+      if (!enoughSpace) {
+        // unlock because of imminent (assertion) failure
+        acctLock.unlock();
+
+        if (VM.VerifyAssertions) {
+          VM._assert(VM.NOT_REACHED,
+              "Not enough space in array for all live threads");
+        } else {
+          VM.sysFail("Not enough space in array for all live threads");
+        }
       }
-    }
-  }
 
-  /**
-   * de-install the stack trampoline (disabling return barriers).
-   */
-  @Uninterruptible
-  public void deInstallStackTrampoline() {
-    if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("deinstalling trampoline: ", framePointer);
-    if (!hijackedReturnCalleeFp.isZero()) {
-      if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln("need to reinstall: ", hijackedReturnAddress);
-      hijackedReturnCalleeFp.plus(StackFrameLayout.getStackFrameReturnAddressOffset()).store(hijackedReturnAddress);
-      hijackedReturnCalleeFp = Address.zero();
-      hijackedReturnCallerFp = StackFrameLayout.getStackFrameSentinelFP();
+      liveThreads[threadIndex] = javaLangThread;
+      threadIndex++;
     }
   }
+  acctLock.unlock();
+  return liveThreads;
+}
 
-  /** @return the address of the stack trampoline bridge code */
-  @Inline
-  private Address getStackTrampolineBridgeIP() {
-    return Magic.objectAsAddress(stackTrampolineBridgeInstructions);
+/**
+ * Counts the stack frames of this thread.
+ *
+ * @return the number of stack frames in this thread
+ */
+@Interruptible
+public int countStackFrames() {
+  if (!isSuspended) {
+    throw new IllegalThreadStateException(
+        "Thread.countStackFrames called on non-suspended thread");
   }
+  throw new UnimplementedError();
+}
 
-  /** @return the hijacked return address */
-  @Inline
-  public Address getTrampolineHijackedReturnAddress() {
-    return hijackedReturnAddress;
-  }
+/**
+ * @return the length of the stack
+ */
+public int getStackLength() {
+  return stack.length;
+}
 
-  /**
-   * Determine whether a given method is the stack trampoline
-   *
-   * @param ip the code to be checked
-   * @return <code>true</code> if the code is the stack trampoline.
-   */
-  @Inline
-  public static boolean isTrampolineIP(Address ip) {
-    return getCurrentThread().getStackTrampolineBridgeIP().EQ(ip);
-  }
+/**
+ * @return the stack
+ */
+public byte[] getStack() {
+  return stack;
+}
 
-  /**
-   * Given a frame that has been hijacked by the stack trampoline,
-   * return the real (hijacked) return address.
-   *
-   * @param hijackedFp a frame that has been hijacked by the stack trampoline
-   * @return the return address for the frame that was hijacked.
-   */
-  @Uninterruptible
-  public static Address getHijackedReturnAddress(Address hijackedFp) {
-    if (VM.VerifyAssertions) VM._assert(isTrampolineIP(Magic.getReturnAddressUnchecked(hijackedFp)));
-    RVMThread t = getCurrentThread();
-      if (!t.hijackedReturnCalleeFp.EQ(hijackedFp)) {
-        for (int tid = 0; tid < nextSlot; tid++) {
-          t = threadBySlot[tid];
-          if (t != null && t.hijackedReturnCalleeFp.EQ(hijackedFp))
-            break;
-        }
-      }
-      if (VM.VerifyAssertions) VM._assert(t.hijackedReturnCalleeFp.EQ(hijackedFp),
-          "No matching thread found");
-      return t.hijackedReturnAddress;
-  }
+/**
+ * @return the thread's exception registers
+ */
+public AbstractRegisters getExceptionRegisters() {
+  return exceptionRegisters;
+}
 
-  /**
-   * Dump the specified frame in a format useful for debugging the stack
-   * trampoline
-   *
-   * @param fp The frame to be dumped.
-   */
-  private static void dumpFrame(Address fp) {
-    final Offset returnAddressOffset = StackFrameLayout.getStackFrameReturnAddressOffset();
-    final Offset methodIDOffset = StackFrameLayout.getStackFrameMethodIDOffset();
-    Address sp = fp.minus(40);
-    VM.sysWriteln("--");
-    Address nextFp = Magic.getCallerFramePointer(fp);
-    while (sp.LE(nextFp)) {
-      VM.sysWrite("[", sp, "]");
-      if (sp.EQ(fp) || sp.EQ(nextFp)) {
-        VM.sysWrite("* ");
-      } else if (sp.EQ(fp.plus(returnAddressOffset)) || sp.EQ(nextFp.plus(returnAddressOffset))) {
-        VM.sysWrite("R ");
-      }  else if (sp.EQ(fp.plus(methodIDOffset)) || sp.EQ(nextFp.plus(methodIDOffset))) {
-        VM.sysWrite("M ");
-      } else {
-        VM.sysWrite(" ");
-      }
-      VM.sysWriteln(sp.loadInt());
-      sp = sp.plus(4);
-    }
-  }
+/**
+ * @return the thread's context registers (saved registers when thread is
+ *         suspended by scheduler).
+ */
+public AbstractRegisters getContextRegisters() {
+  return contextRegisters;
+}
 
-  /**
-   * @return the caller of the frame in which the trampoline is installed (STACKFRAME_SENTINEL_FP by default)
-   */
-  public Address getNextUnencounteredFrame() {
-    return hijackedReturnCallerFp.EQ(StackFrameLayout.getStackFrameSentinelFP()) ? hijackedReturnCallerFp : Magic.getCallerFramePointer(hijackedReturnCallerFp);
-  }
+/** Set the initial attempt. */
+public void reportCollectionAttempt() {
+  collectionAttempt++;
+}
 
-  /**
-   * Yieldpoint taken in epilogue.
-   */
-  @BaselineSaveLSRegisters
-  // Save all non-volatile registers in prologue
-  @NoOptCompile
-  @NoInline
-  // We should also have a pragma that saves all non-volatiles in opt compiler,
-  // BaselineExecutionStateExtractor.java, should then restore all non-volatiles
-  // before stack replacement
-  // TODO fix this -- related to SaveVolatile
-  @Entrypoint
-  @Unpreemptible("Becoming another thread interrupts the current thread, avoid preemption in the process")
-  public static void yieldpointFromEpilogue() {
-    Address fp = Magic.getFramePointer();
-    yieldpoint(EPILOGUE, fp);
-  }
+/** @return the number of collection attempts */
+public int getCollectionAttempt() {
+  return collectionAttempt;
+}
 
-  /*
-   * Support for suspend/resume
-   */
+/** Resets the attempts. */
+public void resetCollectionAttempts() {
+  collectionAttempt = 0;
+}
 
-  /**
-   * Suspend execution of current thread until it is resumed. Call only if
-   * caller has appropriate security clearance.
-   */
-  @UnpreemptibleNoWarn("Exceptions may possibly cause yields")
-  public void suspend() {
-    if (false) VM.sysWriteln("Thread #",getCurrentThreadSlot()," suspending Thread #",getThreadSlot());
-    ObjectModel.genericUnlock(thread);
-    Throwable rethrow = null;
-    try {
-      observeExecStatus();
-      if (execStatus != IN_JAVA && execStatus != IN_JAVA_TO_BLOCK &&
-          execStatus != IN_NATIVE && execStatus != BLOCKED_IN_NATIVE &&
-          execStatus != BLOCKED_IN_JNI && execStatus != IN_JNI) {
-        throw new IllegalThreadStateException(
-          "Cannot suspend a thread that is not running.");
-      }
-      block(suspendBlockAdapter);
-    } catch (Throwable t) {
-      rethrow = t;
-    }
-    ObjectModel.genericLock(thread);
-    if (rethrow != null)
-      RuntimeEntrypoints.athrow(rethrow);
-  }
+/** @return the physical allocation failed flag. */
+public boolean physicalAllocationFailed() {
+  return physicalAllocationFailed;
+}
 
-  /**
-   * Resume execution of a thread that has been suspended. Call only if caller
-   * has appropriate security clearance.
-   */
-  @Interruptible
-  public void resume() {
-    unblock(suspendBlockAdapter);
-  }
+/** Set the physical allocation failed flag. */
+public void setPhysicalAllocationFailed() {
+  physicalAllocationFailed = true;
+}
 
-  public static void yieldNoHandshake() {
-    sysCall.sysThreadYield();
-  }
+/** Clear the physical allocation failed flag. */
+public void clearPhysicalAllocationFailed() {
+  physicalAllocationFailed = false;
+}
 
-  @UnpreemptibleNoWarn
-  public static void yieldWithHandshake() {
-    getCurrentThread().checkBlock();
-    sysCall.sysThreadYield();
-  }
-  /**
-   * Suspend execution of current thread for specified number of seconds (or
-   * fraction).
-   *
-   * @param ns the number of nanoseconds to sleep for
-   * @throws InterruptedException when the sleep is interrupted
-   */
-  @Interruptible
-  public static void sleep(long ns) throws InterruptedException {
-    RVMThread t = getCurrentThread();
-    t.waiting = Waiting.TIMED_WAITING;
-    long atStart = sysCall.sysNanoTime();
-    long whenEnd = atStart + ns;
-    t.monitor().lockNoHandshake();
-    while (!t.hasInterrupt && t.asyncThrowable == null &&
-        sysCall.sysNanoTime() < whenEnd) {
-      t.monitor().timedWaitAbsoluteWithHandshake(whenEnd);
-    }
-    boolean throwInterrupt = false;
-    Throwable throwThis = null;
-    if (t.hasInterrupt) {
-      t.hasInterrupt = false;
-      throwInterrupt = true;
-    }
-    if (t.asyncThrowable != null) {
-      throwThis = t.asyncThrowable;
-      t.asyncThrowable = null;
-    }
-    t.monitor().unlock();
-    t.waiting = Waiting.RUNNABLE;
-    if (throwThis != null) {
-      RuntimeEntrypoints.athrow(throwThis);
-    }
-    if (throwInterrupt) {
-      throw new InterruptedException("sleep interrupted");
-    }
-  }
+/**
+ * @return the outstanding OutOfMemoryError.
+ */
+public static OutOfMemoryError getOutOfMemoryError() {
+  return outOfMemoryError;
+}
 
-  /**
-   * Suspend execution of current thread for specified number of seconds (or
-   * fraction). The time from both parameters is added up.
-   *
-   * @param ns the number of nanoseconds to sleep for
-   * @param millis the number of milliseconds to sleep for
-   * @throws InterruptedException when the sleep is interrupted
-   */
-  @Interruptible
-  public static void sleep(long millis, int ns) throws InterruptedException {
-    sleep(ns + millis * 1000L * 1000L);
-  }
+/**
+ * @return number of active threads in the system.
+ */
+public static int getNumActiveThreads() {
+  return numActiveThreads;
+}
 
-  /*
-   * Wait and notify support
-   */
+public static int getNumActiveSystemThreads() {
+  return numActiveSystemThreads;
+}
 
-  @Interruptible
-  void waitImpl(Object o, boolean hasTimeout, long whenWakeupNanos) {
-    boolean throwInterrupt = false;
-    Throwable throwThis = null;
-    if (asyncThrowable != null) {
-      throwThis = asyncThrowable;
-      asyncThrowable = null;
-    } else if (!ObjectModel.holdsLock(o, this)) {
-      throw new IllegalMonitorStateException("waiting on " + o);
-    } else if (hasInterrupt) {
-      throwInterrupt = true;
-      hasInterrupt = false;
-    } else {
-      if (STATS) {
-        waitTimeStart = Time.currentTimeMillis();
-      }
-      waiting = hasTimeout ? Waiting.TIMED_WAITING : Waiting.WAITING;
-      if (STATS) {
-        if (hasTimeout) {
-          timedWaitOperations++;
-        } else {
-          waitOperations++;
-        }
-      }
-      // get lock for object
-      Lock l = ObjectModel.getHeavyLock(o, true);
+/**
+ * @return number of active daemon threads.
+ */
+public static int getNumActiveDaemons() {
+  return numActiveDaemons;
+}
 
-      // release the lock
-      l.mutex.lock();
-      // this thread is supposed to own the lock on o
-      if (VM.VerifyAssertions) VM._assert(l.getOwnerId() == getLockingId());
-      RVMThread toAwaken = l.entering.dequeue();
-      waitObject = l.getLockedObject();
-      waitCount = l.getRecursionCount();
-      l.setOwnerId(0);
-      l.waiting.enqueue(this);
-      l.mutex.unlock();
+/**
+ * Handles uncaught exceptions for subclasses of {@link SystemThread}.
+ * Uncaught exceptions for normal threads will end up in that thread's {@link #run()}
+ * method which will invoke the thread's uncaught exception handler.
+ *
+ * @param exceptionObject the exception object that wasn't caught
+ * @see #run() run() method of application threads
+ * @see SystemThread#run() run() method of system threads
+ */
+@Interruptible
+public void handleUncaughtException(Throwable exceptionObject) {
+  uncaughtExceptionCount++;
+
+  handlePossibleRecursiveException();
+  VM.enableGC();
+  if (thread == null) {
+    VM.sysWrite("Exception in the primordial thread \"", getName(),
+        "\" while booting: ");
+  } else {
+    // This is output like that of the Sun JDK.
+    VM.sysWrite("Exception in thread \"", getName(), "\": ");
+  }
+  if (exceptionObject instanceof OutOfMemoryError) {
+    VM.sysWriteln("   <<No stacktrace available>>");
+  } else if (VM.fullyBooted) {
+    exceptionObject.printStackTrace();
+  }
+  getCurrentThread().terminate();
+  if (VM.VerifyAssertions)
+    VM._assert(VM.NOT_REACHED);
+}
 
-      // if there was a thread waiting, awaken it
-      if (toAwaken != null) {
-        // is this where the problem is coming from?
-        toAwaken.monitor().lockedBroadcastNoHandshake();
-      }
-      // block
-      monitor().lockNoHandshake();
-      while (l.waiting.isQueued(this) && !hasInterrupt && asyncThrowable == null &&
-             (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
-        if (hasTimeout) {
-          monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
-        } else {
-          monitor().waitWithHandshake();
-        }
-      }
-      // figure out if anything special happened while we were blocked
-      if (hasInterrupt) {
-        throwInterrupt = true;
-        hasInterrupt = false;
-      }
-      if (asyncThrowable != null) {
-        throwThis = asyncThrowable;
-        asyncThrowable = null;
-      }
-      monitor().unlock();
-      if (l.waiting.isQueued(this)) {
-        l.mutex.lock();
-        l.waiting.remove(this); /*
-                                 * in case we got here due to an interrupt or a
-                                 * stop() rather than a notify
-                                 */
-        l.mutex.unlock();
-        // Note that the above must be done before attempting to acquire
-        // the lock, since acquiring the lock may require queueing the thread.
-        // But we cannot queue the thread if it is already on another
-        // queue.
-      }
-      // reacquire the lock, restoring the recursion count
-      ObjectModel.genericLock(o);
-      waitObject = null;
-      if (waitCount != 1) { // reset recursion count
-        Lock l2 = ObjectModel.getHeavyLock(o, true);
-        l2.setRecursionCount(waitCount);
-      }
-      waiting = Waiting.RUNNABLE;
-      if (STATS) {
-        totalWaitTime += (sysCall.sysCurrentTimeMillis() - waitTimeStart);
+/** Handle the case of exception handling triggering new exceptions. */
+private void handlePossibleRecursiveException() {
+  if (uncaughtExceptionCount > 1 &&
+      uncaughtExceptionCount <= VM.maxSystemTroubleRecursionDepth + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite) {
+    VM.sysWrite("We got an uncaught exception while (recursively) handling ");
+    VM.sysWrite(uncaughtExceptionCount - 1);
+    VM.sysWrite(" uncaught exception");
+    if (uncaughtExceptionCount - 1 != 1) {
+      VM.sysWrite("s");
+    }
+    VM.sysWriteln(".");
       }
+  if (uncaughtExceptionCount > VM.maxSystemTroubleRecursionDepth) {
+    dumpVirtualMachine();
+    VM.dieAbruptlyRecursiveSystemTrouble();
+    if (VM.VerifyAssertions)
+      VM._assert(VM.NOT_REACHED);
+  }
+}
+
+private static void dumpThread(RVMThread t) {
+  if (t == null) {
+    VM.sysWrite("none");
+  } else {
+    VM.sysWrite(t.threadSlot, "(", READABLE_EXEC_STATUS[t.getExecStatus()]);
+    if (t.isAboutToTerminate) {
+      VM.sysWrite("T");
     }
-    // check if we should exit in a special way
-    if (throwThis != null) {
-      RuntimeEntrypoints.athrow(throwThis);
+    if (t.isBlocking) {
+      VM.sysWrite("B");
     }
-    if (throwInterrupt) {
-      RuntimeEntrypoints.athrow(new InterruptedException("sleep interrupted"));
+    if (t.isJoinable) {
+      VM.sysWrite("J");
     }
+    if (t.atYieldpoint) {
+      VM.sysWrite("Y");
+    }
+    VM.sysWrite(")");
   }
+}
 
-  /**
-   * Support for Java {@link java.lang.Object#wait()} synchronization primitive.
-   *
-   * @param o
-   *          the object synchronized on
-   */
-  @Interruptible
-  /* only loses control at expected points -- I think -dave */
-  public static void wait(Object o) {
-    getCurrentThread().waitImpl(o, false, 0);
-  }
-
-  /**
-   * Support for Java {@link java.lang.Object#wait()} synchronization primitive.
-   *
-   * @param o
-   *          the object synchronized on
-   * @param millis
-   *          the number of milliseconds to wait for notification
-   */
-  @Interruptible
-  public static void wait(Object o, long millis) {
-    long currentNanos = sysCall.sysNanoTime();
-    getCurrentThread().waitImpl(o, true, currentNanos + millis * 1000 * 1000);
-  }
-
-  long getTotalWaitingCount() {
-    if (STATS) {
-      return waitOperations + timedWaitOperations;
-    } else {
-      return -1L;
+private static void dumpThreadArray(RVMThread[] array, int bound) {
+  for (int i = 0; i < bound; ++i) {
+    if (i != 0) {
+      VM.sysWrite(", ");
     }
+    VM.sysWrite(i, ":");
+    dumpThread(array[i]);
   }
+}
 
-  long getTotalWaitedTime() {
-    if (STATS) {
-      return totalWaitTime;
-    } else {
-      return -1;
+private static void dumpThreadSlotArray(int[] array, int bound) {
+  for (int i = 0; i < bound; ++i) {
+    if (i != 0) {
+      VM.sysWrite(", ");
     }
+    VM.sysWrite(i, ":");
+    int threadSlot = array[i];
+    VM.sysWrite(threadSlot, ",");
+    dumpThread(threadBySlot[array[i]]);
   }
+}
 
-  /**
-   * Support for RTSJ- and pthread-style absolute wait.
-   *
-   * @param o
-   *          the object synchronized on
-   * @param whenNanos
-   *          the absolute time in nanoseconds when we should wake up
-   */
-  @Interruptible
-  public static void waitAbsoluteNanos(Object o, long whenNanos) {
-    getCurrentThread().waitImpl(o, true, whenNanos);
-  }
+private static void dumpThreadArray(String name, RVMThread[] array, int bound) {
+  VM.sysWrite(name);
+  VM.sysWrite(": ");
+  dumpThreadArray(array, bound);
+  VM.sysWriteln();
+}
 
-  @UnpreemptibleNoWarn("Possible context when generating exception")
-  public static void raiseIllegalMonitorStateException(String msg, Object o) {
-    throw new IllegalMonitorStateException(msg + (o == null ? "<null>" : o.toString()));
-  }
+private static void dumpThreadSlotArray(String name, int[] array, int bound) {
+  VM.sysWrite(name);
+  VM.sysWrite(": ");
+  dumpThreadSlotArray(array, bound);
+  VM.sysWriteln();
+}
 
-  /**
-   * Support for Java {@link java.lang.Object#notify()} synchronization
-   * primitive.
-   *
-   * @param o the object synchronized on
-   */
-  @Interruptible
-  public static void notify(Object o) {
-    if (STATS)
-      notifyOperations++;
-    Lock l = ObjectModel.getHeavyLock(o, false);
-    if (l == null)
-      return;
-    // the reason for locking: when inflating a lock we *first* install it in the status
-    // word and *then* initialize its state.  but fortunately, we do so while holding
-    // the lock's mutex.  thus acquiring the lock's mutex is the only way to ensure that
-    // we see the lock's state after initialization.
-    l.mutex.lock();
-    int owner = l.getOwnerId();
-    l.mutex.unlock();
-    int me = getCurrentThread().getLockingId();
-    if (owner != me) {
-      raiseIllegalMonitorStateException("notifying (expected lock to be held by " +
-          me + "(" + getCurrentThread().getLockingId() + ") but was held by " +
-          owner + "(" + l.getOwnerId() + ")) ", o);
-    }
-    l.mutex.lock();
-    RVMThread toAwaken = l.waiting.dequeue();
-    l.mutex.unlock();
-    if (toAwaken != null) {
-      toAwaken.monitor().lockedBroadcastNoHandshake();
+public static void dumpAcct() {
+  acctLock.lockNoHandshake();
+  dumpLock.lockNoHandshake();
+  VM.sysWriteln("====== Begin Thread Accounting Dump ======");
+  dumpThreadArray("threadBySlot", threadBySlot, nextSlot);
+  dumpThreadSlotArray("aboutToTerminate", aboutToTerminate, aboutToTerminateN);
+  VM.sysWrite("freeSlots: ");
+  for (int i = 0; i < freeSlotN; ++i) {
+    if (i != 0) {
+      VM.sysWrite(", ");
     }
+    VM.sysWrite(i, ":", freeSlots[i]);
   }
+  VM.sysWriteln();
+  dumpThreadArray("threads", threads, numThreads);
+  VM.sysWriteln("====== End Thread Accounting Dump ======");
+  dumpLock.unlock();
+  acctLock.unlock();
+}
 
-  /**
-   * Support for Java synchronization primitive.
-   *
-   * @param o the object synchronized on
-   * @see java.lang.Object#notifyAll
-   */
-  @Interruptible
-  public static void notifyAll(Object o) {
-    if (STATS)
-      notifyAllOperations++;
-    Lock l = ObjectModel.getHeavyLock(o, false);
-    if (l == null)
-      return;
-    l.mutex.lock();
-    int owner = l.getOwnerId();
-    l.mutex.unlock();
-    if (owner != getCurrentThread().getLockingId()) {
-      raiseIllegalMonitorStateException("notifying all (expected lock to be held by " +
-          getCurrentThread().getLockingId() + " but was held by " + l.getOwnerId() +
-          ") ", o);
-    }
-    for (;;) {
-      l.mutex.lock();
-      RVMThread toAwaken = l.waiting.dequeue();
-      l.mutex.unlock();
-      if (toAwaken == null)
-        break;
-      toAwaken.monitor().lockedBroadcastNoHandshake();
-    }
+public void extDump() {
+  dump();
+  VM.sysWriteln();
+  VM.sysWriteln("acquireCount for my monitor: ", monitor().acquireCount);
+  VM.sysWriteln("yieldpoints taken: ", yieldpointsTaken);
+  VM.sysWriteln("yieldpoints taken fully: ", yieldpointsTakenFully);
+  VM.sysWriteln("native entered blocked: ", nativeEnteredBlocked);
+  VM.sysWriteln("JNI entered blocked: ", jniEnteredBlocked);
+}
+
+/**
+ * Dump this thread's identifying information, for debugging, via
+ * {@link VM#sysWrite(String)}. We do not use any spacing or newline
+ * characters. Callers are responsible for space-separating or
+ * newline-terminating output.
+ */
+public void dump() {
+  dump(0);
+}
+
+/**
+ * Dump this thread's identifying information, for debugging, via
+ * {@link VM#sysWrite(String)}. We pad to a minimum of leftJustify
+ * characters. We do not use any spacing characters. Callers are responsible
+ * for space-separating or newline-terminating output.
+ *
+ * @param leftJustify
+ *          minimum number of characters emitted, with any extra characters
+ *          being spaces.
+ */
+public void dumpWithPadding(int leftJustify) {
+  char[] buf = Services.grabDumpBuffer();
+  int len = dump(buf);
+  VM.sysWrite(buf, len);
+  for (int i = leftJustify - len; i > 0; i--) {
+    VM.sysWrite(" ");
   }
+  Services.releaseDumpBuffer();
+}
 
-  public void stop(Throwable cause) {
-    monitor().lockNoHandshake();
-    asyncThrowable = cause;
-    takeYieldpoint = 1;
-    monitor().broadcast();
-    monitor().unlock();
+/**
+ * Dump this thread's identifying information, for debugging, via
+ * {@link VM#sysWrite(String)}. We do not use any spacing or newline
+ * characters. Callers are responsible for space-separating or
+ * newline-terminating output.
+ *
+ * This function avoids write barriers and allocation.
+ *
+ * @param verbosity
+ *          Ignored.
+ */
+public void dump(int verbosity) {
+  char[] buf = Services.grabDumpBuffer();
+  int len = dump(buf);
+  VM.sysWrite(buf, len);
+  Services.releaseDumpBuffer();
+}
+
+/**
+ * Dump this thread's info, for debugging. Copy the info about it into a
+ * destination char array. We do not use any spacing or newline characters.
+ *
+ * This function may be called during GC; it avoids write barriers and
+ * allocation.
+ *
+ * For this reason, we do not throw an <code>IndexOutOfBoundsException</code>.
+ *
+ * @param dest
+ *          char array to copy the source info into.
+ * @param offset
+ *          Offset into <code>dest</code> where we start copying
+ *
+ * @return 1 plus the index of the last character written. If we were to write
+ *         zero characters (which we won't) then we would return
+ *         <code>offset</code>. This is intended to represent the first
+ *         unused position in the array <code>dest</code>. However, it also
+ *         serves as a pseudo-overflow check: It may have the value
+ *         <code>dest.length</code>, if the array <code>dest</code> was
+ *         completely filled by the call, or it may have a value greater than
+ *         <code>dest.length</code>, if the info needs more than
+ *         <code>dest.length - offset</code> characters of space.
+ *
+ * -1 if <code>offset</code> is negative.
+ */
+public int dump(char[] dest, int offset) {
+  offset = Services.sprintf(dest, offset, getThreadSlot()); // id
+  if (daemon) {
+    offset = Services.sprintf(dest, offset, "-daemon"); // daemon thread?
+  }
+  if (isBootThread()) {
+    offset = Services.sprintf(dest, offset, "-Boot"); // Boot (Primordial)
+    // thread
+  }
+  if (isSystemThread()) {
+    offset = Services.sprintf(dest, offset, "-system"); // System Thread
   }
+  if (isMainThread()) {
+    offset = Services.sprintf(dest, offset, "-main"); // Main Thread
+  }
+  if (isCollectorThread()) {
+    offset = Services.sprintf(dest, offset, "-collector"); // gc thread?
+  }
+  offset = Services.sprintf(dest, offset, "-");
+  offset = Services.sprintf(dest, offset, READABLE_EXEC_STATUS[getExecStatus()]);
+  offset = Services.sprintf(dest, offset, "-");
+  offset = Services.sprintf(dest, offset, java.lang.JikesRVMSupport
+      .getEnumName(waiting));
+  if (hasInterrupt || asyncThrowable != null) {
+    offset = Services.sprintf(dest, offset, "-interrupted");
+  }
+  if (isAboutToTerminate) {
+    offset = Services.sprintf(dest, offset, "-terminating");
+  }
+  return offset;
+}
 
-  /*
-   * Park and unpark support
-   */
-  @Interruptible
-  public void park(boolean isAbsolute, long time) throws Throwable {
-    if (parkingPermit) {
-      // fast path
-      parkingPermit = false;
-      return;
-    }
-    // massive retardation. someone might be holding the java.lang.Thread lock.
-    boolean holdsLock = holdsLock(thread);
-    if (holdsLock)
-      ObjectModel.genericUnlock(thread);
-    boolean hasTimeout;
-    long whenWakeupNanos;
-    hasTimeout = (time != 0);
-    if (isAbsolute) {
-      whenWakeupNanos = time;
-    } else {
-      whenWakeupNanos = sysCall.sysNanoTime() + time;
-    }
-    Throwable throwThis = null;
-    monitor().lockNoHandshake();
-    waiting = hasTimeout ? Waiting.TIMED_WAITING : Waiting.WAITING;
-    while (!parkingPermit && !hasInterrupt && asyncThrowable == null &&
-           (!hasTimeout || sysCall.sysNanoTime() < whenWakeupNanos)) {
-      if (hasTimeout) {
-        monitor().timedWaitAbsoluteWithHandshake(whenWakeupNanos);
-      } else {
-        monitor().waitWithHandshake();
-      }
-    }
-    waiting = Waiting.RUNNABLE;
-    parkingPermit = false;
-    if (asyncThrowable != null) {
-      throwThis = asyncThrowable;
-      asyncThrowable = null;
-    }
-    monitor().unlock();
+/**
+ * Dump this thread's info, for debugging. Copy the info about it into a
+ * destination char array. We do not use any spacing or newline characters.
+ * <p>
+ * This is identical to calling {@link #dump(char[],int)} with an
+ * <code>offset</code> of zero.
+ *
+ * @param dest array to dump the info into
+ *
+ * @return see {@link #dump(char[], int)}
+ */
+public int dump(char[] dest) {
+  return dump(dest, 0);
+}
+
+/** Dump statistics gather on operations */
+static void dumpStats() {
+  VM.sysWrite("FatLocks: ");
+  VM.sysWrite(waitOperations);
+  VM.sysWriteln(" wait operations");
+  VM.sysWrite("FatLocks: ");
+  VM.sysWrite(timedWaitOperations);
+  VM.sysWriteln(" timed wait operations");
+  VM.sysWrite("FatLocks: ");
+  VM.sysWrite(notifyOperations);
+  VM.sysWriteln(" notify operations");
+  VM.sysWrite("FatLocks: ");
+  VM.sysWrite(notifyAllOperations);
+}
 
-    if (holdsLock)
-      ObjectModel.genericLock(thread);
+/**
+ * Prints out message in format {@code "[j] (td) who: what"}, where:
+ * <ul>
+ *  <li>{@code j = java thread id}
+ *  <li>{@code t = numActiveThreads}
+ *  <li>{@code d = numActiveDaemon}
+ * </ul>
+ * The parenthetical values are printed only if {@link #traceDetails} is true.
+ * <p>
+ * We serialize against a mutex to avoid intermingling debug output from
+ * multiple threads.
+ *
+ * @param who the string for the who parameter
+ * @param what the string for the what parameter
+ */
+public static void trace(String who, String what) {
+  outputLock.lockNoHandshake();
+  VM.sysWrite("[");
+  RVMThread t = getCurrentThread();
+  t.dump();
+  VM.sysWrite("] ");
+  if (traceDetails) {
+    VM.sysWrite("(");
+    VM.sysWriteInt(numActiveDaemons);
+    VM.sysWrite("/");
+    VM.sysWriteInt(numActiveThreads);
+    VM.sysWrite(") ");
+  }
+  VM.sysWrite(who);
+  VM.sysWrite(": ");
+  VM.sysWrite(what);
+  VM.sysWriteln();
+  outputLock.unlock();
+}
 
-    if (throwThis != null) {
-      throw throwThis;
-    }
-  }
+/**
+ * Prints out message in format {@code "[j] (td) who: what howmany"}, where:
+ * <ul>
+ *  <li>{@code j = java thread id}
+ *  <li>{@code t = numActiveThreads}
+ *  <li>{@code d = numActiveDaemon}
+ * </ul>
+ * The parenthetical values are printed only if {@link #traceDetails} is true.
+ * <p>
+ * We serialize against a mutex to avoid intermingling debug output from
+ * multiple threads.
+ *
+ * @param who the string for the who parameter
+ * @param what the string for the what parameter
+ * @param howmany the count for the howmany parameter
+ */
+public static void trace(String who, String what, int howmany) {
+  _trace(who, what, howmany, false);
+}
 
-  @Interruptible
-  public void unpark() {
-    monitor().lockNoHandshake();
-    parkingPermit = true;
-    monitor().broadcast();
-    monitor().unlock();
-  }
+// same as trace, but prints integer value in hex
+//
+public static void traceHex(String who, String what, int howmany) {
+  _trace(who, what, howmany, true);
+}
 
-  /**
-   * Get this thread's id for use in lock ownership tests. This is just the
-   * thread's slot as returned by {@link #getThreadSlot()}, shifted appropriately
-   * so it can be directly used in the ownership tests.
-   *
-   * @return the thread's id for use in lock owner ship tests
-   */
-  public int getLockingId() {
-    return lockingId;
-  }
+public static void trace(String who, String what, Address addr) {
+  outputLock.lockNoHandshake();
+  VM.sysWrite("[");
+  getCurrentThread().dump();
+  VM.sysWrite("] ");
+  if (traceDetails) {
+    VM.sysWrite("(");
+    VM.sysWriteInt(numActiveDaemons);
+    VM.sysWrite("/");
+    VM.sysWriteInt(numActiveThreads);
+    VM.sysWrite(") ");
+  }
+  VM.sysWrite(who);
+  VM.sysWrite(": ");
+  VM.sysWrite(what);
+  VM.sysWrite(" ");
+  VM.sysWriteHex(addr);
+  VM.sysWriteln();
+  outputLock.unlock();
+}
 
-  /**
-   * Provides a skeleton implementation for use in soft handshakes.
-   * <p>
-   * During a soft handshake, the requesting thread waits for all mutator threads
-   * (i.e. non-gc threads) to perform a requested action.
-   */
-  @Uninterruptible
-  public abstract static class SoftHandshakeVisitor {
-    /**
-     * Sets whatever flags need to be set to signal that the given thread should
-     * perform some action when it acknowledges the soft handshake.
-     * <p>
-     * This method is only called for threads for which {@link #includeThread(RVMThread)}
-     * is {@code true}.
-     * <p>
-     * This method is called with the thread's monitor held, but while the
-     * thread may still be running. This method is not called on mutators that
-     * have indicated that they are about to terminate.
-     *
-     * @param t the thread that will be processed
-     * @return {@code false} if not interested in this thread, {@code true} otherwise.
-     * Returning {@code true} will cause a soft handshake request to be put through.
-     */
-    public abstract boolean checkAndSignal(RVMThread t);
+private static void _trace(String who, String what, int howmany, boolean hex) {
+  outputLock.lockNoHandshake();
+  VM.sysWrite("[");
+  // VM.sysWriteInt(RVMThread.getCurrentThread().getThreadSlot());
+  getCurrentThread().dump();
+  VM.sysWrite("] ");
+  if (traceDetails) {
+    VM.sysWrite("(");
+    VM.sysWriteInt(numActiveDaemons);
+    VM.sysWrite("/");
+    VM.sysWriteInt(numActiveThreads);
+    VM.sysWrite(") ");
+  }
+  VM.sysWrite(who);
+  VM.sysWrite(": ");
+  VM.sysWrite(what);
+  VM.sysWrite(" ");
+  if (hex) {
+    VM.sysWriteHex(howmany);
+  } else {
+    VM.sysWriteInt(howmany);
+  }
+  VM.sysWriteln();
+  outputLock.unlock();
+}
 
-    /**
-     * Called when it is determined that the thread is stuck in native. While
-     * this method is being called, the thread cannot return to running Java
-     * code. As such, it is safe to perform actions "on the thread's behalf".
-     * <p>
-     * This implementation does nothing.
-     *
-     * @param t the thread that's stuck in native
-     */
-    public void notifyStuckInNative(RVMThread t) {
-    }
+/**
+ * Print interesting scheduler information, starting with a stack traceback.
+ * <p>
+ * Note: the system could be in a fragile state when this method is called, so
+ * we try to rely on as little runtime functionality as possible (eg. use no
+ * bytecodes that require RuntimeEntrypoints support).
+ *
+ * @param message the message to write before the actual traceback
+ */
+public static void traceback(String message) {
+  if (VM.runningVM && threadingInitialized) {
+    outputLock.lockNoHandshake();
+  }
+  VM.sysWriteln(message);
+  tracebackWithoutLock();
+  if (VM.runningVM && threadingInitialized) {
+    outputLock.unlock();
+  }
+}
 
-    /**
-     * Checks whether to include the specified thread in the soft handshake.
-     * <p>
-     * This method will never see any threads from the garbage collector because
-     * those are excluded from the soft handshake by design.
-     * <p>
-     * This implementation always returns {@code true}.
-     *
-     * @param t The thread to check for inclusion
-     * @return {@code true} if the thread should be included.
-     */
-    public boolean includeThread(RVMThread t) {
-      return true;
-    }
+public static void traceback(String message, int number) {
+  if (VM.runningVM && threadingInitialized) {
+    outputLock.lockNoHandshake();
   }
+  VM.sysWriteln(message, number);
+  tracebackWithoutLock();
+  if (VM.runningVM && threadingInitialized) {
+    outputLock.unlock();
+  }
+}
 
-  @NoCheckStore
-  public static int snapshotHandshakeThreads(SoftHandshakeVisitor v) {
-    // figure out which threads to consider
-    acctLock.lockNoHandshake(); // get a consistent view of which threads are live.
+static void tracebackWithoutLock() {
+  if (VM.runningVM) {
+    VM.sysWriteln("Thread #", getCurrentThreadSlot());
+    dumpStack(Magic.getCallerFramePointer(Magic.getFramePointer()));
+  } else {
+    dumpStack();
+  }
+}
 
-    int numToHandshake = 0;
-    for (int i = 0; i < numThreads; ++i) {
-      RVMThread t = threads[i];
-      // We exclude the following threads from the handshake:
-      // -the current thread (because we would deadlock if we included it)
-      // -threads that ignore handshakes by design (e.g. the timer thread)
-      // -collector threads (because they never yield and we would deadlock if we
-      //   tried to wait for them)
-      // -the threads that the provided visitor does not want to include
-      if (t != RVMThread.getCurrentThread() && !t.ignoreHandshakesAndGC() &&
-          !t.isCollectorThread() && v.includeThread(t)) {
-        handshakeThreads[numToHandshake++] = t;
-      }
+/**
+ * Dump stack of calling thread, starting at callers frame
+ */
+@UninterruptibleNoWarn("Never blocks")
+public static void dumpStack() {
+  if (VM.runningVM) {
+    VM.sysWriteln("Dumping stack for Thread #", getCurrentThreadSlot());
+    dumpStack(Magic.getFramePointer());
+  } else {
+    StackTraceElement[] elements = (new Throwable(
+          "--traceback from Jikes RVM's RVMThread class--")).getStackTrace();
+    for (StackTraceElement element : elements) {
+      System.err.println(element.toString());
     }
-    acctLock.unlock();
-    return numToHandshake;
   }
+}
 
-  /**
-   * Tell each thread to take a yieldpoint and wait until all of them have done
-   * so at least once. Additionally, call the visitor on each thread when making
-   * the yieldpoint request; the purpose of the visitor is to set any additional
-   * fields as needed to make specific requests to the threads that yield. Note
-   * that the visitor's <code>visit()</code> method is called with both the
-   * thread's monitor held, and the <code>softHandshakeDataLock</code> held.
-   * <p>
-   * Currently we only use this mechanism for code patch isync requests on PPC,
-   * but this mechanism is powerful enough to be used by sliding-views style
-   * concurrent GC.
-   *
-   * @param v the visitor to use for the handshake
-   */
-  @NoCheckStore
-  @Unpreemptible("Does not perform actions that lead to blocking, but may wait for threads to rendezvous with the soft handshake")
-  public static void softHandshake(SoftHandshakeVisitor v) {
-    handshakeLock.lockWithHandshake(); /*
-                                        * prevent multiple (soft or hard) handshakes
-                                        * from proceeding concurrently
-                                        */
-
-    int numToHandshake = snapshotHandshakeThreads(v);
-    if (VM.VerifyAssertions)
-      VM._assert(softHandshakeLeft == 0);
-
-    // in turn, check if each thread needs a handshake, and if so,
-    // request one
-    for (int i = 0; i < numToHandshake; ++i) {
-      RVMThread t = handshakeThreads[i];
-      handshakeThreads[i] = null; // help GC
-      t.monitor().lockNoHandshake();
-      boolean waitForThisThread = false;
-      if (!t.isAboutToTerminate && v.checkAndSignal(t)) {
-        // CAS the execStatus field
-        t.setBlockedExecStatus();
-        // Note that at this point if the thread tries to either enter or
-        // exit Java code, it will be diverted into either
-        // enterNativeBlocked() or checkBlock(), both of which cannot do
-        // anything until they acquire the monitor() lock, which we now
-        // hold. Thus, the code below can, at its leisure, examine the
-        // thread's state and make its decision about what to do, fully
-        // confident that the thread's state is blocked from changing.
-        if (t.isInJava()) {
-          // the thread is currently executing Java code, so we must ensure
-          // that it either:
-          // 1) takes the next yieldpoint and rendezvous with this soft
-          // handshake request (see yieldpoint), or
-          // 2) performs the rendezvous when leaving Java code
-          // (see enterNativeBlocked, checkBlock, and addAboutToTerminate)
-          // either way, we will wait for it to get there before exiting
-          // this call, since the caller expects that after softHandshake()
-          // returns, no thread will be running Java code without having
-          // acknowledged.
-          t.softHandshakeRequested = true;
-          t.takeYieldpoint = 1;
-          waitForThisThread = true;
-        } else {
-          // the thread is not in Java code (it may be blocked or it may be
-          // in native), so we don't have to wait for it since it will
-          // do the Right Thing before returning to Java code. essentially,
-          // the thread cannot go back to running Java without doing whatever
-          // was requested because:
-          // A) we've set the execStatus to blocked, and
-          // B) we're holding its lock.
-          v.notifyStuckInNative(t);
-        }
-      }
-      t.monitor().unlock();
-
-      // NOTE: at this point the thread may already decrement the
-      // softHandshakeLeft counter, causing it to potentially go negative.
-      // this is unlikely and completely harmless.
+/**
+ * Dump state of a (stopped) thread's stack.
+ *
+ * @param fp address of starting frame. first frame output is the calling
+ * frame of passed frame
+ */
+public static void dumpStack(Address fp) {
+  if (VM.VerifyAssertions) {
+    VM._assert(VM.runningVM);
+  }
+  Address ip = RVMThread.getReturnAddress_(fp);
+  fp = Magic.getCallerFramePointer(fp);
+  dumpStack(ip, fp);
+}
 
-      if (waitForThisThread) {
-        softHandshakeDataLock.lockNoHandshake();
-        softHandshakeLeft++;
-        softHandshakeDataLock.unlock();
+/**
+ * Dump state of a (stopped) thread's stack.
+ *
+ * @param ip instruction pointer for first frame to dump
+ * @param fp frame pointer for first frame to dump
+ */
+public static void dumpStack(Address ip, Address fp) {
+  boolean b = Monitor.lockNoHandshake(dumpLock);
+  RVMThread t = getCurrentThread();
+  ++t.inDumpStack;
+  if (t.inDumpStack > 1 &&
+      t.inDumpStack <= VM.maxSystemTroubleRecursionDepth + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite) {
+    VM.sysWrite("RVMThread.dumpStack(): in a recursive call, ");
+    VM.sysWrite(t.inDumpStack);
+    VM.sysWriteln(" deep.");
       }
-    }
-
-    // wait for all threads to reach the handshake
-    softHandshakeDataLock.lockNoHandshake();
-    if (VM.VerifyAssertions)
-      VM._assert(softHandshakeLeft >= 0);
-    while (softHandshakeLeft > 0) {
-      // wait and tell the world that we're off in native land. this way
-      // if someone tries to block us at this point (suspend() or GC),
-      // they'll know not to wait for us.
-      softHandshakeDataLock.waitWithHandshake();
-    }
+  if (t.inDumpStack > VM.maxSystemTroubleRecursionDepth) {
+    VM.dieAbruptlyRecursiveSystemTrouble();
     if (VM.VerifyAssertions)
-      VM._assert(softHandshakeLeft == 0);
-    softHandshakeDataLock.unlock();
+      VM._assert(VM.NOT_REACHED);
+  }
 
-    processAboutToTerminate();
+  if (fp.EQ(StackFrameLayout.getStackFrameSentinelFP())) {
+    VM.sysWriteln("Empty stack");
+  } else if (!isAddressValidFramePointer(fp)) {
+    VM.sysWrite("Bogus looking frame pointer: ", fp);
+    VM.sysWriteln(" not dumping stack");
+  } else {
+    try {
+      VM.sysWriteln("-- Stack --");
+      while (Magic.getCallerFramePointer(fp).NE(
+            StackFrameLayout.getStackFrameSentinelFP())) {
 
-    handshakeLock.unlock();
-  }
+        // if code is outside of RVM heap, assume it to be native code,
+        // skip to next frame
+        if (!MemoryManager.addressInVM(ip)) {
+          showMethod("native frame", fp);
+          ip = RVMThread.getReturnAddress_(fp);
+          fp = Magic.getCallerFramePointer(fp);
+        } else {
 
-  /**
-   * Checks and clears the need for a soft handshake rendezvous.  This method
-   * cannot do anything that leads to a write barrier or allocation.
-   *
-   * @return whether the soft handshake can be committed
-   */
-  public boolean softRendezvousCheckAndClear() {
-    boolean result = false;
-    monitor().lockNoHandshake();
-    if (softHandshakeRequested) {
-      softHandshakeRequested = false;
-      result = true;
+          int compiledMethodId = Magic.getCompiledMethodID(fp);
+          boolean idOutOfRange = compiledMethodId > CompiledMethods.numCompiledMethods() ||
+            compiledMethodId < 1;
+          VM.sysWrite("(", fp);
+          VM.sysWrite(" ", compiledMethodId, ")");
+          if (compiledMethodId == StackFrameLayout.getInvisibleMethodID()) {
+            showMethod("invisible method", fp);
+          } else if (idOutOfRange) {
+            showMethod("invalid compiled method id", fp);
+            break;
+          } else {
+            // normal java frame(s)
+            CompiledMethod compiledMethod = CompiledMethods
+              .getCompiledMethod(compiledMethodId);
+            if (compiledMethod == null) {
+              showMethod(compiledMethodId, fp);
+            } else if (compiledMethod.getCompilerType() == CompiledMethod.TRAP) {
+              showMethod("hardware trap", fp);
+            } else if (!isAddressValidFramePointer(fp)) {
+              VM.sysWrite("Bogus looking frame pointer: ", fp);
+              VM.sysWriteln(" not dumping stack");
+              break;
+            } else {
+              RVMMethod method = compiledMethod.getMethod();
+              if (compiledMethod.containsReturnAddress(ip)) {
+                Offset instructionOffset = compiledMethod
+                  .getInstructionOffset(ip);
+                int lineNumber = compiledMethod
+                  .findLineNumberForInstruction(instructionOffset);
+                boolean frameShown = false;
+                if (VM.BuildForOptCompiler && compiledMethod.getCompilerType() == CompiledMethod.OPT) {
+                  OptCompiledMethod optInfo = (OptCompiledMethod) compiledMethod;
+                  // Opt stack frames may contain multiple inlined methods.
+                  OptMachineCodeMap map = optInfo.getMCMap();
+                  int iei = map.getInlineEncodingForMCOffset(instructionOffset);
+                  if (iei >= 0) {
+                    int[] inlineEncoding = map.inlineEncoding;
+                    int bci = map.getBytecodeIndexForMCOffset(instructionOffset);
+                    for (; iei >= 0; iei = OptEncodedCallSiteTree.getParent(iei, inlineEncoding)) {
+                      int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
+                      method = MemberReference.getMethodRef(mid).getResolvedMember();
+                      lineNumber = ((NormalMethod) method).getLineNumberForBCIndex(bci);
+                      showMethod(method, lineNumber, fp, bci, instructionOffset);
+                      if (iei > 0) {
+                        bci = OptEncodedCallSiteTree.getByteCodeOffset(iei, inlineEncoding);
+                      }
+                    }
+                    frameShown = true;
+                  }
+                }
+                if (!frameShown) {
+                  int bci = -1;
+                  if (compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
+                    BaselineCompiledMethod bcm = (BaselineCompiledMethod) compiledMethod;
+                    bci = bcm.findBytecodeIndexForInstruction(instructionOffset);
+                  }
+                  showMethod(method, lineNumber, fp, bci, instructionOffset);
+                }
+              } else {
+                VM.sysWrite("    WARNING: Instruction pointer ");
+                VM.sysWrite(ip);
+                VM.sysWrite(" not in method code");
+                showMethod(method, -1, fp, -1, Offset.max());
+              }
+            }
+          }
+          ip = RVMThread.getReturnAddress(fp);
+          fp = Magic.getCallerFramePointer(fp);
+        }
+        if (!isAddressValidFramePointer(fp)) {
+          VM.sysWrite("Bogus looking frame pointer: ", fp);
+          VM.sysWriteln(" end of stack dump");
+          break;
+        }
+            } // end while
+    } catch (Throwable th) {
+      VM.sysWriteln("Something bad killed the stack dump. The last frame pointer was: ", fp);
     }
-    monitor().unlock();
-    return result;
   }
+  --t.inDumpStack;
 
-  /**
-   * Commits the soft handshake rendezvous.  This method cannot do anything
-   * that leads to a write barrier or allocation.
-   */
-  public void softRendezvousCommit() {
-    softHandshakeDataLock.lockNoHandshake();
-    softHandshakeLeft--;
-    if (softHandshakeLeft == 0) {
-      softHandshakeDataLock.broadcast();
-    }
-    softHandshakeDataLock.unlock();
-  }
+  Monitor.unlock(b, dumpLock);
+}
 
-  /**
-   * Rendezvous with a soft handshake request. Can only be called when the
-   * thread's monitor is held.
-   */
-  public void softRendezvous() {
-    if (softRendezvousCheckAndClear())
-      softRendezvousCommit();
-  }
+/**
+ * Return true if the supplied address could be a valid frame pointer. To
+ * check for validity we make sure the frame pointer is in one of the spaces;
+ * <ul>
+ * <li>LOS (For regular threads)</li>
+ * <li>Immortal (For threads allocated in immortal space such as collectors)</li>
+ * <li>Boot (For the boot thread)</li>
+ * </ul>
+ *
+ * <p>
+ * or it is {@link StackFrameLayout#getStackFrameSentinelFP()}.
+ * {@code STACKFRAME_SENTINEL_FP} is possible when the thread has been created
+ * but has yet to be scheduled.
+ * </p>
+ *
+ * @param address
+ *          the address.
+ * @return true if the address could be a frame pointer, false otherwise.
+ */
+private static boolean isAddressValidFramePointer(final Address address) {
+  if (address.EQ(Address.zero()))
+    return false; // Avoid hitting assertion failure in MMTk
+  else
+    return address.EQ(StackFrameLayout.getStackFrameSentinelFP()) || MemoryManager.mightBeFP(address);
+}
 
-  /**
-   * Handle requests that required a soft handshake. May be called after we
-   * acknowledged the soft handshake. Thus - this is for actions in which it is
-   * sufficient for the thread to acknowledge that it plans to act upon the
-   * request in the immediate future, rather than that the thread acts upon the
-   * request prior to acknowledging.
-   * <p>
-   * This is almost always called with the monitor() lock held, but that's
-   * not guaranteed.  If you need that lock, you can grab it (since it's a
-   * recursive lock).  But you should avoid grabbing other sorts of locks since
-   * that might cause deadlock.
-   */
-  void handleHandshakeRequest() {
-    // Process request for code-patch memory sync operation
-    if (VM.BuildForPowerPC && codePatchSyncRequested) {
-      codePatchSyncRequested = false;
-      // Q: Is this sufficient? Ask Steve why we don't need to sync
-      // icache/dcache. --dave
-      // A: Yes, this is sufficient. We (Filip and Dave) talked about it and
-      // agree that remote processors only need to execute isync. --Filip
-      // make sure not get stale data
-      Magic.synchronizeInstructionCache();
-    }
-    // process memory management requests
-    if (flushRequested && activeMutatorContext) {
-      MemoryManager.flushMutatorContext();
-      flushRequested = false;
-    }
-    // not really a "soft handshake" request but we handle it here anyway
-    if (asyncDebugRequestedForThisThread) {
-      asyncDebugRequestedForThisThread = false;
-      dumpLock.lockNoHandshake();
-      VM.sysWriteln("Handling async stack trace request...");
-      dump();
-      VM.sysWriteln();
-      dumpStack();
-      dumpLock.unlock();
-    }
+private static void showPrologue(Address fp) {
+  VM.sysWrite("   at ");
+  if (SHOW_FP_IN_STACK_DUMP) {
+    VM.sysWrite("[");
+    VM.sysWrite(fp);
+    VM.sysWrite(", ");
+    VM.sysWrite(RVMThread.getReturnAddress_(fp));
+    VM.sysWrite("] ");
   }
+}
 
-  /**
-   * Stop all mutator threads. This is current intended to be run by a single thread.
-   *
-   * Fixpoint until there are no threads that we haven't blocked. Fixpoint is needed to
-   * catch the (unlikely) case that a thread spawns another thread while we are waiting.
-   */
-  @NoCheckStore
-  @Unpreemptible
-  public static void blockAllMutatorsForGC() {
-    RVMThread.handshakeLock.lockNoHandshake();
-    while (true) {
-      // (1) Find all the threads that need to be blocked for GC
-      RVMThread.acctLock.lockNoHandshake();
-      int numToHandshake = 0;
-      for (int i = 0; i < RVMThread.numThreads; i++) {
-        RVMThread t = RVMThread.threads[i];
-        if (!t.isCollectorThread() && !t.ignoreHandshakesAndGC()) {
-          RVMThread.handshakeThreads[numToHandshake++] = t;
-        }
-      }
-      RVMThread.acctLock.unlock();
-
-      // (2) Remove any threads that have already been blocked from the list.
-      for (int i = 0; i < numToHandshake; i++) {
-        RVMThread t = RVMThread.handshakeThreads[i];
-        t.monitor().lockNoHandshake();
-        if (t.blockedFor(RVMThread.gcBlockAdapter) || RVMThread.notRunning(t.asyncBlock(RVMThread.gcBlockAdapter))) {
-          // Already blocked or not running, remove.
-          RVMThread.handshakeThreads[i--] = RVMThread.handshakeThreads[--numToHandshake];
-          RVMThread.handshakeThreads[numToHandshake] = null; // help GC
-        }
-        t.monitor().unlock();
-      }
+/**
+ * Show a method where getCompiledMethod returns null
+ *
+ * @param compiledMethodId the id of the compiled method
+ * @param fp the frame pointer of the method's frame
+ */
+private static void showMethod(int compiledMethodId, Address fp) {
+  showPrologue(fp);
+  VM.sysWriteln(
+      "<unprintable normal Java frame: CompiledMethods.getCompiledMethod(",
+      compiledMethodId, ") returned null>");
+}
 
-      // (3) Quit trying to block threads if all threads are either blocked
-      //     or not running (a thread is "not running" if it is NEW or TERMINATED;
-      //     in the former case it means that the thread has not had start()
-      //     called on it while in the latter case it means that the thread
-      //     is either in the TERMINATED state or is about to be in that state
-      //     real soon now, and will not perform any heap-related work before
-      //     terminating).
-      if (numToHandshake == 0) break;
-
-      // (4) Request a block for GC from all other threads.
-      for (int i = 0; i < numToHandshake; i++) {
-        if (false) VM.sysWriteln("Waiting for ", RVMThread.handshakeThreads[i].getThreadSlot(), " to block.");
-        RVMThread t = RVMThread.handshakeThreads[i];
-        RVMThread.observeExecStatusAtSTW(t.block(RVMThread.gcBlockAdapter));
-        RVMThread.handshakeThreads[i] = null; // help GC
-      }
-    }
-    RVMThread.handshakeLock.unlock();
+/**
+ * Shows a method that we can't show (ie just a text description of the stack
+ * frame
+ *
+ * @param name the method's name
+ * @param fp the frame pointer of the method's frame
+ */
+private static void showMethod(String name, Address fp) {
+  showPrologue(fp);
+  VM.sysWrite("<");
+  VM.sysWrite(name);
+  VM.sysWriteln(">");
+}
 
-    // Deal with terminating threads to ensure that all threads are either dead to MMTk or stopped above.
-    RVMThread.processAboutToTerminate();
+/**
+ * Helper function for {@link #dumpStack(Address,Address)}. Print a stack
+ * frame showing the method.
+ *
+ * @param method the underlying method
+ * @param lineNumber the line number for the stack trace
+ * @param fp the frame pointer of the method's frame
+ * @param bci byte code index (value &lt; 0 if unknown)
+ * @param mcOffset machine code offset for the instruction ({@code Offset.max()} if unknown)
+ */
+private static void showMethod(RVMMethod method, int lineNumber, Address fp, int bci, Offset mcOffset) {
+  showPrologue(fp);
+  if (method == null) {
+    VM.sysWrite("<unknown method>");
+  } else {
+    VM.sysWrite(method.getDeclaringClass().getDescriptor());
+    VM.sysWrite(" ");
+    VM.sysWrite(method.getName());
+    VM.sysWrite(method.getDescriptor());
   }
-
-  /**
-   * Unblock all mutators blocked for GC.
-   */
-  @NoCheckStore
-  @Unpreemptible
-  public static void unblockAllMutatorsForGC() {
-    RVMThread.handshakeLock.lockNoHandshake();
-    RVMThread.acctLock.lockNoHandshake();
-    int numToHandshake = 0;
-    for (int i = 0; i < RVMThread.numThreads; i++) {
-      RVMThread t = RVMThread.threads[i];
-      if (!t.isCollectorThread() && !t.ignoreHandshakesAndGC()) {
-        RVMThread.handshakeThreads[numToHandshake++] = t;
-      }
-    }
-    RVMThread.acctLock.unlock();
-    for (int i = 0; i < numToHandshake; i++) {
-      RVMThread.handshakeThreads[i].unblock(RVMThread.gcBlockAdapter);
-      RVMThread.handshakeThreads[i] = null; // Help GC
-    }
-    RVMThread.handshakeLock.unlock();
+  if (lineNumber > 0) {
+    VM.sysWrite(" at line ");
+    VM.sysWriteInt(lineNumber);
   }
-
-  @Uninterruptible
-  public static class HardHandshakeVisitor {
-    public boolean includeThread(RVMThread t) {
-      return true;
-    }
+  if (bci >= 0) {
+    VM.sysWrite(" at bytecode index ");
+    VM.sysWriteInt(bci);
   }
-
-  @Uninterruptible
-  @NonMoving
-  static class AllButGCHardHandshakeVisitor extends HardHandshakeVisitor {
-    @Override
-    public boolean includeThread(RVMThread t) {
-      return !t.isCollectorThread();
-    }
+  if (!mcOffset.isMax()) {
+    VM.sysWrite(" at machine code offset ");
+    VM.sysWrite(mcOffset);
   }
+  VM.sysWriteln();
+}
 
-  public static final AllButGCHardHandshakeVisitor allButGC =
-    new AllButGCHardHandshakeVisitor();
+/**
+ * Dump state of a (stopped) thread's stack and exit the virtual machine.
+ *
+ * @param fp
+ *          address of starting frame Returned: doesn't return. This method is
+ *          called from sysSignal*.c when something goes horrifically wrong
+ *          with exception handling and we want to die with useful
+ *          diagnostics.
+ */
+@Entrypoint
+public static void dumpStackAndDie(Address fp) {
+  if (!exitInProgress) {
+    // This is the first time I've been called, attempt to exit "cleanly"
+    exitInProgress = true;
+    dumpStack(fp);
+    VM.sysExit(EXIT_STATUS_DUMP_STACK_AND_DIE);
+  } else {
+    // Another failure occurred while attempting to exit cleanly.
+    // Get out quick and dirty to avoid hanging.
+    sysCall.sysExit(EXIT_STATUS_RECURSIVELY_SHUTTING_DOWN);
+  }
+}
 
-  static long totalSuspendTime;
-  static long totalResumeTime;
+/**
+ * @return whether it is safe to start forcing garbage collects for stress testing
+ */
+public static boolean safeToForceGCs() {
+  return gcEnabled();
+}
 
-  @Unpreemptible
-  @NoCheckStore
-  public static void hardHandshakeSuspend(BlockAdapter ba,
-                                          HardHandshakeVisitor hhv) {
-    long before = sysCall.sysNanoTime();
-
-    RVMThread current = getCurrentThread();
-
-    handshakeLock.lockWithHandshake();
-    int numLockedLocks = 0;
-    for (int i = 0; i < nextSlot;++i) {
-      Monitor l = communicationLockBySlot[i];
-      if (l != null) {
-        l.lockWithHandshake();
-        numLockedLocks++;
-      }
-    }
+/**
+ * @return whether garbage collection is enabled
+ */
+public static boolean gcEnabled() {
+  return threadingInitialized && getCurrentThread().yieldpointsEnabled();
+}
 
-    // fixpoint until there are no threads that we haven't blocked.
-    // fixpoint is needed in case some thread spawns another thread
-    // while we're waiting.  that is unlikely but possible.
-    for (;;) {
-      acctLock.lockNoHandshake();
-      int numToHandshake = 0;
-      for (int i = 0; i < numThreads;++i) {
-        RVMThread t = threads[i];
-        if (t != current &&
-            !t.ignoreHandshakesAndGC() &&
-            hhv.includeThread(t)) {
-          handshakeThreads[numToHandshake++] = t;
-        }
-      }
-      acctLock.unlock();
+/**
+ * Set up the initial thread and processors as part of boot image writing
+ *
+ * @return the boot thread
+ */
+@Interruptible
+public static RVMThread setupBootThread() {
+  if (VM.VerifyAssertions) VM._assert(bootThread == null);
+  BootThread bt = new BootThread();
+  bootThread = bt.getRVMThread();
+  bootThread.feedlet = TraceEngine.engine.makeFeedlet(
+      "Jikes RVM boot thread",
+      "Thread used to execute the initial boot sequence of Jikes RVM");
+  numActiveThreads++;
+  numActiveSystemThreads++;
+  numActiveDaemons++;
+  return bootThread;
+}
 
-      for (int i = 0; i < numToHandshake;++i) {
-        RVMThread t = handshakeThreads[i];
-        t.monitor().lockNoHandshake();
-        if (t.blockedFor(ba) ||
-            notRunning(t.asyncBlock(ba))) {
-          // already blocked or not running, remove
-          handshakeThreads[i--] = handshakeThreads[--numToHandshake];
-          handshakeThreads[numToHandshake] = null; // help GC
-        }
-        t.monitor().unlock();
-      }
-      // quit trying to block threads if all threads are either blocked
-      // or not running (a thread is "not running" if it is NEW or TERMINATED;
-      // in the former case it means that the thread has not had start()
-      // called on it while in the latter case it means that the thread
-      // is either in the TERMINATED state or is about to be in that state
-      // real soon now, and will not perform any heap-related stuff before
-      // terminating).
-      if (numToHandshake == 0) break;
-      for (int i = 0; i < numToHandshake;++i) {
-        RVMThread t = handshakeThreads[i];
-        observeExecStatusAtSTW(t.block(ba));
-        handshakeThreads[i] = null; // help GC
-      }
+/**
+ * Dump state of virtual machine.
+ */
+public static void dumpVirtualMachine() {
+  boolean b = Monitor.lockNoHandshake(dumpLock);
+  getCurrentThread().disableYieldpoints();
+  VM.sysWriteln();
+  VM.sysWrite("-- Threads --");
+  VM.sysWriteln();
+  for (int i = 0; i < numThreads; ++i) {
+    RVMThread t = threads[i];
+    if (t != null) {
+      t.dumpWithPadding(30);
+      VM.sysWriteln();
     }
+  }
+  VM.sysWriteln();
 
-    processAboutToTerminate(); /*
-                                * ensure that any threads that died while
-                                * we were stopping the world notify us
-                                * that they had stopped.
-                                */
+  VM.sysWriteln();
+  VM.sysWrite("-- Locks in use --");
+  VM.sysWriteln();
+  Lock.dumpLocks();
 
-    int numUnlockedLocks = 0;
-    for (int i = 0; i < nextSlot;++i) {
-      Monitor l = communicationLockBySlot[i];
-      if (l != null) {
-        l.unlock();
-        numUnlockedLocks++;
-      }
-    }
-    if (VM.VerifyAssertions) VM._assert(numLockedLocks == numUnlockedLocks);
-    handshakeLock.unlock();
+  VM.sysWriteln("Dumping stack of active thread");
+  VM.sysWriteln();
+  dumpStack();
 
-    if (false) {
-      long after = sysCall.sysNanoTime();
-      totalSuspendTime += after - before;
-      VM.sysWriteln("Stopping the world took ",(after - before)," ns (",totalSuspendTime," ns total)");
+  VM.sysWriteln("Attempting to dump the stack of all other live threads");
+  VM.sysWriteln("This is somewhat risky since if the thread is running we're going to be quite confused");
+  for (int i = 0; i < numThreads; ++i) {
+    RVMThread thr = threads[i];
+    if (thr != null && thr != RVMThread.getCurrentThread() && thr.isAlive()) {
+      thr.dump();
+      // PNT: FIXME: this won't work so well since the context registers
+      // don't tend to have sane values
+      if (thr.contextRegisters != null && !thr.ignoreHandshakesAndGC())
+        dumpStack(thr.contextRegisters.getInnermostFramePointer());
     }
   }
+  getCurrentThread().enableYieldpoints();
+  Monitor.unlock(b, dumpLock);
+}
 
-  @NoCheckStore
-  @Unpreemptible
-  public static void hardHandshakeResume(BlockAdapter ba,
-                                         HardHandshakeVisitor hhv) {
-    long before = sysCall.sysNanoTime();
-
-    handshakeLock.lockWithHandshake();
+public static Feedlet getCurrentFeedlet() {
+  return getCurrentThread().feedlet;
+}
 
-    RVMThread current = getCurrentThread();
-    acctLock.lockNoHandshake();
-    int numToHandshake = 0;
-    for (int i = 0; i < numThreads;++i) {
-      RVMThread t = threads[i];
-      if (t != current &&
-          !t.ignoreHandshakesAndGC() &&
-          hhv.includeThread(t)) {
-        handshakeThreads[numToHandshake++] = t;
+////////////////////////// VM.countThreadTransitions support //////////////////////////
+
+static final int[] sloppyExecStatusHistogram =
+new int[LAST_EXEC_STATUS];
+static final int[] statusAtSTWHistogram =
+new int[LAST_EXEC_STATUS];
+static final int[] execStatusTransitionHistogram =
+new int[LAST_EXEC_STATUS * LAST_EXEC_STATUS];
+
+public static void reportThreadTransitionCounts() {
+  VM.sysWriteln("Thread Transition Counts:");
+  dump1DHisto("Sloppy Exec Status Histogram",sloppyExecStatusHistogram);
+  dump1DHisto("Status At Stop-the-world Histogram",statusAtSTWHistogram);
+  VM.sysWriteln("  Exec Status Transition Histogram:");
+  for (int fromI = 0; fromI < LAST_EXEC_STATUS; ++fromI) {
+    for (int toI = 0; toI < LAST_EXEC_STATUS; ++toI) {
+      int val =
+        execStatusTransitionHistogram[
+        transitionHistogramIndex(fromI,toI)];
+      if (val != 0) {
+        VM.sysWriteln("    ",fromI,"->",toI," ",val);
       }
     }
-    acctLock.unlock();
-    for (int i = 0; i < numToHandshake;++i) {
-      handshakeThreads[i].unblock(ba);
-      handshakeThreads[i] = null; // help GC
-    }
-
-    handshakeLock.unlock();
+  }
+}
 
-    if (false) {
-      long after = sysCall.sysNanoTime();
-      totalResumeTime += after - before;
-      VM.sysWriteln("Resuming the world took ",(after - before)," ns (",totalResumeTime," ns total)");
+static void dump1DHisto(String name,int[] histo) {
+  VM.sysWriteln("  ",name,":");
+  for (int i = 0; i < LAST_EXEC_STATUS; ++i) {
+    if (histo[i] != 0) {
+      VM.sysWriteln("    ",i," ",histo[i]);
     }
   }
+}
 
-  @Unpreemptible
-  public static void hardHandshakeSuspend() {
-    hardHandshakeSuspend(handshakeBlockAdapter,allButGC);
-  }
+void observeExecStatus() {
+  sloppyExecStatusHistogram[execStatus]++;
+}
 
-  @Unpreemptible
-  public static void hardHandshakeResume() {
-    hardHandshakeResume(handshakeBlockAdapter,allButGC);
-  }
+public static void observeExecStatusAtSTW(int execStatus) {
+  statusAtSTWHistogram[execStatus]++;
+}
 
-  /**
-   * Process a taken yieldpoint.
-   *
-   * @param whereFrom source of the yieldpoint (e.g. backedge)
-   * @param yieldpointServiceMethodFP the frame pointer of the service
-   *  method that called this method
-   */
-  @Unpreemptible("May block if the thread was asked to do so but otherwise does not perform actions that may lead to blocking")
-  public static void yieldpoint(int whereFrom, Address yieldpointServiceMethodFP) {
-    RVMThread t = getCurrentThread();
-    boolean wasAtYieldpoint = t.atYieldpoint;
-    t.atYieldpoint = true;
-    t.yieldpointsTaken++;
-    // If thread is in critical section we can't do anything right now, defer
-    // until later
-    // we do this without acquiring locks, since part of the point of disabling
-    // yieldpoints is to ensure that locks are not "magically" acquired
-    // through unexpected yieldpoints. As well, this makes code running with
-    // yieldpoints disabled more predictable. Note furthermore that the only
-    // race here is setting takeYieldpoint to 0. But this is perfectly safe,
-    // since we are guaranteeing that a yieldpoint will run after we emerge from
-    // the no-yieldpoints code. At worst, setting takeYieldpoint to 0 will be
-    // lost (because some other thread sets it to non-0), but in that case we'll
-    // just come back here and reset it to 0 again.
-    if (!t.yieldpointsEnabled()) {
-      if (VM.VerifyAssertions)
-        VM._assert(!t.yieldToOSRRequested);
-      if (traceBlock && !wasAtYieldpoint) {
-        VM.sysWriteln("Thread #", t.threadSlot, " deferring yield!");
-        dumpStack();
-      }
-      t.yieldpointRequestPending = true;
-      t.takeYieldpoint = 0;
-      t.atYieldpoint = false;
-      return;
-    }
-    t.yieldpointsTakenFully++;
+// FIXME: add histograms for states returned from various calls to block()
+// currently we just do it for the block() call in GC STW.
 
-    Throwable throwThis = null;
-    t.monitor().lockNoHandshake();
+static int transitionHistogramIndex(int oldState,int newState) {
+  return oldState + newState * LAST_EXEC_STATUS;
+}
 
-    int takeYieldpointVal = t.takeYieldpoint;
-    if (takeYieldpointVal != 0) {
-      t.takeYieldpoint = 0;
-      // do two things: check if we should be blocking, and act upon
-      // handshake requests. This also has the effect of reasserting that
-      // we are in fact IN_JAVA (as opposed to IN_JAVA_TO_BLOCK).
-      t.checkBlock();
+static void observeStateTransition(int oldState,int newState) {
+  execStatusTransitionHistogram[transitionHistogramIndex(oldState,newState)]++;
+  sloppyExecStatusHistogram[oldState]++;
+  sloppyExecStatusHistogram[newState]++;
+}
 
-      // Process timer interrupt event
-      if (t.timeSliceExpired != 0) {
-        t.timeSliceExpired = 0;
 
-        if (t.yieldForCBSCall || t.yieldForCBSMethod) {
-          /*
-           * CBS Sampling is still active from previous quantum. Note that fact,
-           * but leave all the other CBS parameters alone.
-           */
-        } else {
-          if (VM.CBSCallSamplesPerTick > 0) {
-            t.yieldForCBSCall = true;
-            t.takeYieldpoint = -1;
-            t.firstCBSCallSample++;
-            t.firstCBSCallSample = t.firstCBSCallSample % VM.CBSCallSampleStride;
-            t.countdownCBSCall = t.firstCBSCallSample;
-            t.numCBSCallSamples = VM.CBSCallSamplesPerTick;
-          }
 
-          if (VM.CBSMethodSamplesPerTick > 0) {
-            t.yieldForCBSMethod = true;
-            t.takeYieldpoint = -1;
-            t.firstCBSMethodSample++;
-            t.firstCBSMethodSample = t.firstCBSMethodSample % VM.CBSMethodSampleStride;
-            t.countdownCBSMethod = t.firstCBSMethodSample;
-            t.numCBSMethodSamples = VM.CBSMethodSamplesPerTick;
-          }
-        }
+/**
+ * JikesRVM TRY-CATCH WORK-STEALING 
+ */
 
-        if (VM.BuildForAdaptiveSystem) {
-          RuntimeMeasurements.takeTimerSample(whereFrom,
-              yieldpointServiceMethodFP);
-        }
-        if (VM.BuildForAdaptiveSystem) {
-          OSRListener
-              .checkForOSRPromotion(whereFrom, yieldpointServiceMethodFP);
-        }
-      }
+/*
+ * RDTSC timings for barrier
+ */
+protected long totalBarrierCPUCycles = 0;
 
-      if (t.yieldForCBSCall) {
-        if (!(whereFrom == BACKEDGE || whereFrom == OSROPT)) {
-          if (--t.countdownCBSCall <= 0) {
-            if (VM.BuildForAdaptiveSystem) {
-              // take CBS sample
-              RuntimeMeasurements.takeCBSCallSample(whereFrom,
-                  yieldpointServiceMethodFP);
-            }
-            t.countdownCBSCall = VM.CBSCallSampleStride;
-            t.numCBSCallSamples--;
-            if (t.numCBSCallSamples <= 0) {
-              t.yieldForCBSCall = false;
-            }
-          }
-        }
-        if (t.yieldForCBSCall) {
-          t.takeYieldpoint = -1;
-        }
-      }
+/*
+ * RDTSC timings for successful steals
+ */
+protected long totalSuccessStealCPUCycles = 0;
 
-      if (t.yieldForCBSMethod) {
-        if (--t.countdownCBSMethod <= 0) {
-          if (VM.BuildForAdaptiveSystem) {
-            // take CBS sample
-            RuntimeMeasurements.takeCBSMethodSample(whereFrom,
-                yieldpointServiceMethodFP);
-          }
-          t.countdownCBSMethod = VM.CBSMethodSampleStride;
-          t.numCBSMethodSamples--;
-          if (t.numCBSMethodSamples <= 0) {
-            t.yieldForCBSMethod = false;
-          }
-        }
-        if (t.yieldForCBSMethod) {
-          t.takeYieldpoint = 1;
-        }
-      }
+/*
+ * RDTSC timings for failed steals
+ */
+protected long totalFailedStealCPUCycles = 0;
 
-      if (VM.BuildForAdaptiveSystem && t.yieldToOSRRequested) {
-        t.yieldToOSRRequested = false;
-        OSRListener.handleOSRFromOpt(yieldpointServiceMethodFP);
-      }
+// Automatically launch the workstealing thread
+// as soon as application's main method is executed
+public static boolean autogenWSThread = true;
+protected static boolean wsThreadsLaunched = false;
 
-      // what is the reason for this? and what was the reason for doing
-      // a thread switch following the suspension in the OSR trigger code?
-      // ... it seems that at least part of the point here is that if a
-      // thread switch was desired for other reasons, then we need to ensure
-      // that between when this runs and when the glue code runs there will
-      // be no interleaved GC; obviously if we did this before the thread
-      // switch then there would be the possibility of interleaved GC.
-      if (VM.BuildForAdaptiveSystem && t.isWaitingForOsr) {
-        if (VM.BuildForIA32) {
-          org.jikesrvm.osr.ia32.PostThreadSwitch.postProcess(t);
-        } else {
-          if (VM.VerifyAssertions) VM._assert(VM.BuildForPowerPC);
-          org.jikesrvm.osr.ppc.PostThreadSwitch.postProcess(t);
-        }
-      }
-      if (t.asyncThrowable != null) {
-        throwThis = t.asyncThrowable;
-        t.asyncThrowable = null;
-      }
-    }
-    t.monitor().unlock();
-    t.atYieldpoint = false;
-    if (throwThis != null) {
-      throwFromUninterruptible(throwThis);
-    }
+/*
+ * Thread pinning support
+ */
+// {
+protected boolean trace_cpuid = false; 
+public static boolean ws_pinning_workers = false;
+public static int sockets = -1;
+public static int cpusPerSocket = -1;
+public static int[] pin_map_workers = new int[0];
+protected int ws_id = -1;
+public static boolean ws_pinning_system = false;
+public static int[] pin_map_system = new int[0];
+public static boolean ws_pinning_gc = false;
+public static int[] pin_map_gc = new int[0];
+// }
+
+private static final Monitor[] workStealingLockBySlot = new Monitor[MAX_THREADS];
+
+public StackFrameCopier wsFrameCopier = new StackFrameCopier();
+private byte[] wsShadowStack;
+private WS.Continuation wsContinuation = new WS.Continuation(); 
+public WS.Join wsJoin = new WS.Join();
+public WS.FinishFirst wsFinishFirst = new WS.FinishFirst();
+public WS.Finish wsFinish = new WS.Finish();
+public int wsSpecialNVMap = 0;
+public boolean wsFlag = false;
+public volatile boolean wsInJoin = false;
+Random wsRand;
+
+// Speculation support from here =====================>
+@Uninterruptible
+private class FinishAbortInfo {
+  final Monitor monitor;
+  volatile int counter;
+  boolean aborted;
+  public FinishAbortInfo() {
+    monitor = new Monitor();
+    counter = 0;
+    aborted = false;
   }
+}
+protected FinishAbortInfo finish_abort_scope = null; 
+private final AbstractRegisters contextRegistersCopyAtStackWalk;
 
-  @Unpreemptible
-  private static void throwFromUninterruptible(Throwable e) {
-    RuntimeEntrypoints.athrow(e);
+@Uninterruptible
+@NoInline
+protected boolean checkIfAbortAlreadyInitiated() {
+  finish_abort_scope.monitor.lockNoHandshake();
+  if(finish_abort_scope.aborted) {
+    finish_abort_scope.monitor.unlock();
+    return true;
   }
+  finish_abort_scope.aborted = true;
+  finish_abort_scope.monitor.unlock();
+  return false;
+}
 
-  /**
-   * Change the size of the currently executing thread's stack.
-   *
-   * @param newSize
-   *          new size (in bytes)
-   * @param exceptionRegisters
-   *          register state at which stack overflow trap was encountered (null
-   *          --&gt; normal method call, not a trap)
-   */
-  @Unpreemptible("May block due to allocation")
-  public static void resizeCurrentStack(int newSize,
-      AbstractRegisters exceptionRegisters) {
-    if (!getCurrentThread().hijackedReturnAddress.isZero()) {
-      /* stack resizing currently unsupported with return barrier */
-      VM.sysFail("system error: resizing stack while return barrier enabled (currently unsupported)");
-    }
-    if (traceAdjustments)
-      VM.sysWriteln("Thread: resizeCurrentStack");
-    if (MemoryManager.gcInProgress()) {
-      VM.sysFail("system error: resizing stack while GC is in progress");
-    }
-    byte[] newStack = MemoryManager.newStack(newSize);
-    getCurrentThread().disableYieldpoints();
-    transferExecutionToNewStack(newStack, exceptionRegisters);
-    getCurrentThread().enableYieldpoints();
-    if (traceAdjustments) {
-      RVMThread t = getCurrentThread();
-      VM.sysWrite("Thread: resized stack ", t.getThreadSlot());
-      VM.sysWrite(" to ", t.stack.length / 1024);
-      VM.sysWriteln("k");
-    }
+@UnpreemptibleNoWarn
+@Inline
+protected void decrement_finish_abort_joins() {
+  finish_abort_scope.monitor.lockNoHandshake();
+  if(--finish_abort_scope.counter == 0) finish_abort_scope.monitor.broadcast();
+  WS.printMSG("caught AbortOnFailure");
+  finish_abort_scope.monitor.unlock();
+}
+
+@UnpreemptibleNoWarn
+@Inline
+protected void increment_finish_abort_joins() {
+  finish_abort_scope.monitor.lockNoHandshake();
+  finish_abort_scope.counter++;
+  finish_abort_scope.monitor.unlock();
+}
+
+@UnpreemptibleNoWarn
+@Inline
+protected void wait_finish_abort() {
+  finish_abort_scope.monitor.lockNoHandshake();
+  while(finish_abort_scope.counter > 0) {
+    finish_abort_scope.monitor.waitNoHandshake();
   }
+  finish_abort_scope.monitor.unlock();
+}
 
-  @NoInline
-  @BaselineNoRegisters
-  // this method does not do a normal return and hence does not execute epilogue
-  // --> non-volatiles not restored!
-  private static void transferExecutionToNewStack(byte[] newStack, AbstractRegisters exceptionRegisters) {
-    // prevent opt compiler from inlining a method that contains a magic
-    // (returnToNewStack) that it does not implement.
+@UnpreemptibleNoWarn
+@Inline
+protected void start_new_finish_abort() {
+  finish_abort_scope = new FinishAbortInfo();
+}
 
-    RVMThread myThread = getCurrentThread();
-    byte[] myStack = myThread.stack;
+@UnpreemptibleNoWarn
+@Inline
+protected boolean finishScopeMatches(RVMThread other) {
+  return finish_abort_scope.equals(other.finish_abort_scope);
+}
 
-    // initialize new stack with live portion of stack we're
-    // currently running on
-    //
-    // lo-mem hi-mem
-    // |<---myDepth----|
-    // +----------+---------------+
-    // | empty | live |
-    // +----------+---------------+
-    // ^myStack ^myFP ^myTop
-    //
-    // +-------------------+---------------+
-    // | empty | live |
-    // +-------------------+---------------+
-    // ^newStack ^newFP ^newTop
-    //
-    Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
-    Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
-
-    Address myFP = Magic.getFramePointer();
-    Offset myDepth = myTop.diff(myFP);
-    Address newFP = newTop.minus(myDepth);
-
-    // The frame pointer addresses the top of the frame on powerpc and
-    // the bottom
-    // on intel. if we copy the stack up to the current
-    // frame pointer in here, the
-    // copy will miss the header of the intel frame. Thus we make another
-    // call
-    // to force the copy. A more explicit way would be to up to the
-    // frame pointer
-    // and the header for intel.
-    Offset delta = copyStack(newStack);
-
-    // fix up registers and save areas so they refer
-    // to "newStack" rather than "myStack"
-    //
-    if (exceptionRegisters != null) {
-      adjustRegisters(exceptionRegisters, delta);
-    }
-    adjustStack(newStack, newFP, delta);
+// <===================== Speculation support UNTIL here 
+
+public volatile WS.StealInfo wsStealHead = null;
+public volatile WS.FinishInfo wsFinishHead = null;
+
+public int totalSteals = 0;
+public int findAttempts = 0;
+public int pushes = 0;
+protected int thiefInstalledBarriers = 0;
+protected int preInstalledBarriers = 0;
+// following 4 declarations & 2 methods valid only if createContinuationDistribution==true
+protected int tasksEQ2 = 0;	// tasks <= 2
+protected int tasksLE4 = 0;	// tasks <= 4
+protected int tasksGT4 = 0;	// tasks <= 8
+@Inline
+private void continuationsDistribution(int tasks) {
+  if(tasks == 2) tasksEQ2++;
+  else if(tasks > 2 && tasks <= 4) tasksLE4++;
+  else if(tasks > 4) tasksGT4++;
+}
 
-    // install new stack
-    //
-    myThread.stack = newStack;
-    myThread.stackLimit = Magic.objectAsAddress(newStack).plus(StackFrameLayout.getStackSizeGuard());
+protected boolean wsThread = false;
+protected int wsSynchronizationLock = 0;
 
-    // return to caller, resuming execution on new stack
-    // (original stack now abandoned)
-    //
-    if (VM.BuildForPowerPC) {
-      Magic.returnToNewStack(Magic.getCallerFramePointer(newFP));
-    } else if (VM.BuildForIA32) {
-      Magic.returnToNewStack(newFP);
-    }
+private boolean wsWaitingInsideBarrier = false;
+private byte[] wsVictimShadowStack = null;
+Address victimYieldFpOnNewStack = Address.zero();
+Address victimYieldIPOnNewStack = Address.zero();
+@Inline
+public void wsSetInnermost() {
+  contextRegisters.setInnermost(victimYieldIPOnNewStack, victimYieldFpOnNewStack);
+}
+public final byte[] wsGetClonedStack() {
+  return wsVictimShadowStack;
+}
+private final static int ARRAY_OF_CONTINUATIONS_MAXSIZE = 25; 
+private final static int ON_OVERFLOW_RESTART_INDEX_IN_ARRAY_OF_CONTINUATIONS = 20;
+private final AddressArray array_of_continuations = AddressArray.create(ARRAY_OF_CONTINUATIONS_MAXSIZE);
+private int fpsInContList = 0;
+private int indexInContList = 0;
+private boolean iInstalledABarrier = false;
 
-    if (VM.VerifyAssertions)
-      VM._assert(VM.NOT_REACHED);
-  }
+public static boolean wsRetBarrier = false;
 
-  /**
-   * This (suspended) thread's stack has been moved. Fixup register and memory
-   * references to reflect its new position.
-   *
-   * @param delta
-   *          displacement to be applied to all interior references
-   */
-  public void fixupMovedStack(Offset delta) {
-    if (traceAdjustments)
-      VM.sysWriteln("Thread: fixupMovedStack");
+/** Registers used by return barrier trampoline */
+private AbstractRegisters trampolineRegisters = ArchitectureFactory.createRegisters();
 
-    if (!contextRegisters.getInnermostFramePointer().isZero()) {
-      adjustRegisters(contextRegisters, delta);
-    }
-    if ((exceptionRegisters.getInUse()) &&
-        (exceptionRegisters.getInnermostFramePointer().NE(Address.zero()))) {
-      adjustRegisters(exceptionRegisters, delta);
-    }
-    if (!contextRegisters.getInnermostFramePointer().isZero()) {
-      adjustStack(stack, contextRegisters.getInnermostFramePointer(), delta);
-    }
-    stackLimit = stackLimit.plus(delta);
-  }
+/** Return address of stack frame hijacked by return barrier */
+private Address hijackedReturnAddress;
 
-  /**
-   * A thread's stack has been moved or resized. Adjust registers to reflect new
-   * position.
-   *
-   * @param registers
-   *          registers to be adjusted
-   * @param delta
-   *          displacement to be applied
-   */
-  private static void adjustRegisters(AbstractRegisters registers, Offset delta) {
-    if (traceAdjustments)
-      VM.sysWriteln("Thread: adjustRegisters");
+/** Callee frame pointer for stack frame hijacked by return barrier */
+private Address hijackedReturnCalleeFp = Address.zero();
 
-    // adjust FP
-    //
-    Address newFP = registers.getInnermostFramePointer().plus(delta);
-    Address ip = registers.getInnermostInstructionAddress();
-    registers.setInnermost(ip, newFP);
-    if (traceAdjustments) {
-      VM.sysWrite(" fp=");
-      VM.sysWrite(registers.getInnermostFramePointer());
-    }
+/** Caller frame pointer for stack frame hijacked by return barrier */
+private Address hijackedReturnCallerFp = StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
 
-    // additional architecture specific adjustments
-    // (1) frames from all compilers on IA32 need to update ESP
-    int compiledMethodId = Magic.getCompiledMethodID(registers
-        .getInnermostFramePointer());
-    if (compiledMethodId != StackFrameLayout.getInvisibleMethodID()) {
-      if (VM.BuildForIA32) {
-        registers.adjustESP(delta, traceAdjustments);
-      }
-      if (traceAdjustments) {
-        CompiledMethod compiledMethod = CompiledMethods
-            .getCompiledMethod(compiledMethodId);
-        VM.sysWrite(" method=");
-        VM.sysWrite(compiledMethod.getMethod());
-        VM.sysWriteln();
-      }
-    }
-  }
+/** @return the callee frame pointer for the stack frame hijacked by the return barrier */
+public Address getHijackedReturnCalleeFp() { return hijackedReturnCalleeFp; }
 
-  /**
-   * A thread's stack has been moved or resized. Adjust internal pointers to
-   * reflect new position.
-   *
-   * @param stack
-   *          stack to be adjusted
-   * @param fp
-   *          pointer to its innermost frame
-   * @param delta
-   *          displacement to be applied to all its interior references
-   */
-  private static void adjustStack(byte[] stack, Address fp, Offset delta) {
-    if (traceAdjustments)
-      VM.sysWriteln("Thread: adjustStack");
-
-    while (Magic.getCallerFramePointer(fp).NE(StackFrameLayout.getStackFrameSentinelFP())) {
-      // adjust FP save area
-      //
-      Magic.setCallerFramePointer(fp, Magic.getCallerFramePointer(fp).plus(
-          delta));
-      if (traceAdjustments) {
-        VM.sysWrite(" fp=", fp.toWord());
-      }
+/** debugging flag for return barrier trampoline */
+public static final boolean DEBUG_STACK_TRAMPOLINE = false;
 
-      // advance to next frame
-      //
-      fp = Magic.getCallerFramePointer(fp);
-    }
-  }
+/** pointer to bridge code for return barrier trampoline */
+public static CodeArray stackTrampolineBridgeInstructions;
 
-  /**
-   * Initialize a new stack with the live portion of the stack we're currently
-   * running on.
-   *
-   * <pre>
-   *  lo-mem                                        hi-mem
-   *                           |&lt;---myDepth----|
-   *                 +----------+---------------+
-   *                 |   empty  |     live      |
-   *                 +----------+---------------+
-   *                  &circ;myStack   &circ;myFP           &circ;myTop
-   *       +-------------------+---------------+
-   *       |       empty       |     live      |
-   *       +-------------------+---------------+
-   *        &circ;newStack           &circ;newFP          &circ;newTop
-   * </pre>
-   *
-   * @param newStack space for the new stack
-   * @return offset that needs to be applied to all interior references of
-   *  the new stack
-   */
-  private static Offset copyStack(byte[] newStack) {
-    RVMThread myThread = getCurrentThread();
-    byte[] myStack = myThread.stack;
+//--------------> Speculative Abort
 
-    Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
-    Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
-    Address myFP = Magic.getFramePointer();
-    Offset myDepth = myTop.diff(myFP);
-    Address newFP = newTop.minus(myDepth);
+private static final Monitor[] lockForSpeculativeTask = new Monitor[MAX_THREADS];
+protected volatile boolean isThief = true;
+protected volatile boolean threadIsBusy = false;
+protected volatile boolean yieldToThrowAbortAtFailure = false;
+protected volatile boolean yieldToDumpStack = false;
+protected WS.AbortAtFailure wsAbortAtFailure = new WS.AbortAtFailure();
+protected WS.AbortAtSuccess wsAbortAtSuccess = new WS.AbortAtSuccess();
 
-    // before copying, make sure new stack isn't too small
-    //
-    if (VM.VerifyAssertions) {
-      VM._assert(newFP.GE(Magic.objectAsAddress(newStack).plus(StackFrameLayout.getStackSizeGuard())));
-    }
+@Inline
+public Monitor wsAbortLock() {
+  return lockForSpeculativeTask[threadSlot];
+}
 
-    Memory.memcopy(newFP, myFP, myDepth.toWord().toExtent());
+@Uninterruptible
+@NoInline
+protected void setWorkerAsThief() {
+  wsAbortLock().lockNoHandshake();
+  isThief = true;
+  wsAbortLock().unlock();
+}
 
-    return newFP.diff(myFP);
-  }
+@Uninterruptible
+@NoInline
+protected void setWorkerAsVictim() {
+  wsAbortLock().lockNoHandshake();
+  isThief = false;
+  wsAbortLock().unlock();
+}
 
-  /**
-   * Set the "isDaemon" status of this thread. Although a java.lang.Thread can
-   * only have setDaemon invoked on it before it is started, Threads can become
-   * daemons at any time. Note: making the last non daemon a daemon will
-   * terminate the VM.
-   * <p>
-   * Note: This method might need to be uninterruptible so it is final, which is
-   * why it isn't called setDaemon.
-   * <p>
-   * Public so that java.lang.Thread can use it.
-   *
-   * @param on new status for daemon flag
-   */
-  public void makeDaemon(boolean on) {
-    if (daemon == on) {
-      // nothing to do
-    } else {
-      daemon = on;
-      if (getExecStatus() == NEW) {
-        // thread will start as a daemon
-      } else {
-        boolean terminateSystem = false;
-        acctLock.lockNoHandshake();
-        numActiveDaemons += on ? 1 : -1;
-        if (numActiveDaemons == numActiveThreads) {
-          terminateSystem = true;
-        }
-        acctLock.unlock();
-        if (terminateSystem) {
-          if (VM.TraceThreads) {
-            trace("Thread", "last non Daemon demonized");
-          }
-          VM.sysExit(0);
-          if (VM.VerifyAssertions)
-            VM._assert(VM.NOT_REACHED);
-        }
-      }
-    }
-  }
+@Uninterruptible
+@NoInline
+protected boolean checkIfWorkerIsThief() {
+  wsAbortLock().lockNoHandshake();
+  boolean status = isThief;
+  wsAbortLock().unlock();
+  return status;
+}
 
-  /**
-   * Dump information for all threads, via {@link VM#sysWrite(String)}. Each
-   * thread's info is newline-terminated.
-   *
-   * @param verbosity Ignored.
-   */
-  public static void dumpAll(int verbosity) {
-    for (int i = 0; i < numThreads; i++) {
-      RVMThread t = threads[i];
-      if (t == null)
-        continue;
-      VM.sysWrite("Thread ");
-      VM.sysWriteInt(t.threadSlot);
-      VM.sysWrite(":  ");
-      VM.sysWriteHex(Magic.objectAsAddress(t));
-      VM.sysWrite("   ");
-      t.dump(verbosity);
-      // Compensate for t.dump() not newline-terminating info.
-      VM.sysWriteln();
-    }
+@UnpreemptibleNoWarn
+@NoInline
+protected boolean tryDisableStealing() {
+  wsAbortLock().lockNoHandshake();
+  if(threadIsBusy) {
+    wsAbortLock().unlock();
+    return false;
   }
+  threadIsBusy = true;
+  wsAbortLock().unlock();
+  return true;
+}
 
-  /** @return whether this is the primordial thread, i.e.
-   *    the thread that boots the VM before starting the
-   *    main thread
-*  */
-  public boolean isBootThread() {
-    return this == bootThread;
-  }
+@UnpreemptibleNoWarn
+@NoInline
+public void canAbortIfRequired() {
+  wsAbortLock().lockNoHandshake();
+  threadIsBusy = false;
+  wsAbortLock().unlock();
+}
 
-  /** @return whether this is the main thread */
-  private boolean isMainThread() {
-    return thread instanceof MainThread;
-  }
+@UnpreemptibleNoWarn
+@NoInline
+public void resetWSDatastructure() {
+        wsFrameCopier = new StackFrameCopier();
+        wsContinuation = new WS.Continuation();
+        wsJoin = new WS.Join();
+        wsFinishFirst = new WS.FinishFirst();
+        wsFinish = new WS.Finish();
+        wsSpecialNVMap = 0;
+        wsStealHead = null;
+        wsFinishHead = null;
+        wsInJoin = false;
+        wsWaitingInsideBarrier = false;
+        wsVictimShadowStack = null;
+        victimYieldFpOnNewStack = Address.zero();
+        victimYieldIPOnNewStack = Address.zero();
+        iInstalledABarrier = false;
+        fpsInContList = 0;
+        indexInContList = 0;
+        finish_abort_scope = null;
+}
 
-  /** @return whether this is a system thread */
-  public boolean isSystemThread() {
-    return systemThread != null;
-  }
+//<-------------- Speculative Abort
 
-  /** @return the collector thread this RVMTHread is running */
-  public CollectorThread getCollectorThread() {
-    if (VM.VerifyAssertions) VM._assert(isCollectorThread());
-    return (CollectorThread)systemThread;
+@Uninterruptible
+@Inline
+public static Address getReturnAddress_(Address fp) {
+  Address rtn = Magic.getReturnAddressUnchecked(fp);
+  if (isTrampolineIP(rtn)) {
+    RVMThread t = getCurrentThread();
+    if (!t.hijackedReturnCalleeFp.EQ(fp)) {
+      for (int tid = 0; tid < nextSlot; tid++) {
+        t = threadBySlot[tid];
+        if (t != null && t.hijackedReturnCalleeFp.EQ(fp))
+          break;
+      }
+    }
+    VM.sysWrite("<H>");
+    return t.hijackedReturnAddress;
+  } else {
+    return rtn;
   }
+}
 
-  /** @return the value of {@link #daemon}. */
-  public boolean isDaemonThread() {
-    return daemon;
+@Uninterruptible
+@Inline
+public static Address getReturnAddress(Address fp) {
+  Address rtn = Magic.getReturnAddressUnchecked(fp);
+  if (isTrampolineIP(rtn)) {
+    RVMThread t = getCurrentThread();
+    if (!t.hijackedReturnCalleeFp.EQ(fp)) {
+      for (int tid = 0; tid < nextSlot; tid++) {
+        t = threadBySlot[tid];
+        if (t != null && t.hijackedReturnCalleeFp.EQ(fp))
+          break;
+      }
+    }
+    return t.hijackedReturnAddress;
+  } else {
+    return rtn;
   }
+}
 
-  /**
-   * @return whether this thread should run concurrently with
-   * stop-the-world garbage collection and ignore handshakes
-   */
-  public boolean ignoreHandshakesAndGC() {
-    if (systemThread == null) return false;
-    return systemThread instanceof TimerThread;
+/**
+ * The return barrier.
+ * <p>
+ * The following code implements return barriers as described
+ * for Lisp by Yuasa
+ *
+ * http://www.yuasa.kuis.kyoto-u.ac.jp/~yuasa/ilc2002/index.html
+ * http://dx.doi.org/10.1109/ISORC.2005.45
+ *
+ * and for Jikes RVM by Kumar et al
+ *
+ * http://dx.doi.org/10.1145/2398857.2384639
+ * <p>
+ * This code is executed when a method returns into a frame that
+ * has been hijacked by the return barrier mechanism.   The return
+ * barrier trampoline will save state, execute this method, and
+ * then upon return from this method will transparently return into
+ * the frame that had been hijacked.
+ * <p>
+ * In this default implementation, the barrier reinstalls itself
+ * in the caller's frame thus incrementally moving the barrier down
+ * the stack.
+ * <p>
+ * The execution of this method is fragile.  It is generally safest
+ * to call some other method from here that does the substantive work
+ * of the barrier.
+ */
+@Entrypoint
+@Uninterruptible
+@Unpreemptible
+public static void returnBarrier() {
+    /* reinstall the barrier in the caller's frame */
+    if (DEBUG_STACK_TRAMPOLINE) {
+      if (VM.BuildForIA32) {
+        VM.sysWriteln(getCurrentThread().getId(), " T0: ",
+            getCurrentThread().trampolineRegisters.getGPRs().
+            get(org.jikesrvm.ia32.RegisterConstants.EAX.value()).toAddress());
+        VM.sysWriteln(getCurrentThread().getId(), " T1: ",
+            getCurrentThread().trampolineRegisters.getGPRs().
+            get(org.jikesrvm.ia32.RegisterConstants.EDX.value()).toAddress());
+      } else {
+        // Return barrier not yet supported on other architectures
+        if (VM.VerifyAssertions) VM._assert(VM.NOT_REACHED);
+      }
+      VM.sysWriteln(getCurrentThread().getId(), " nf: ", getCurrentThread().hijackedReturnCallerFp);
+      VM.sysWriteln(getCurrentThread().getId(), " lf: ", getCurrentThread().hijackedReturnCalleeFp);
+      VM.sysWriteln(getCurrentThread().getId(), " fp: ", Magic.getFramePointer());
+      VM.sysWriteln(getCurrentThread().getId(), " np: ", Magic.getCallerFramePointer(Magic.getFramePointer()));
+    }
+    /* reinstall the barrier in the specified frame */
+    getCurrentThread().returnBarrier_internal();
   }
 
-  /** @return whether the thread started and not terminated */
-  public boolean isAlive() {
-    monitor().lockNoHandshake();
-    observeExecStatus();
-    boolean result = execStatus != NEW && execStatus != TERMINATED && !isAboutToTerminate;
-    monitor().unlock();
-    return result;
+/**
+ * Install the stack trampoline bridge at a given frame, hijacking
+ * that frame, saving the hijacked return address and callee fp
+ * in thread-local state to allow execution of the hijacked frame
+ * later.
+ *
+ * @param targetFp The frame to be hijacked.
+ */
+@Uninterruptible
+@Inline
+public void wsInstallStackTrampolineBridge(Address targetFp) {
+  Address trampoline = getStackTrampolineBridgeIP();
+  if(wsDebugTrace) {
+    if (trampoline.isZero()) {
+      if (VM.VerifyAssertions)
+        VM._assert(VM.NOT_REACHED);
+      else
+        VM.sysWriteln("Warning: attempt to install stack trampoline without bridge instructions - nothing done.  See RVMThread.");
+    } else if (trampoline.NE(Magic.getReturnAddressUnchecked(targetFp))) {
+      /* install the trampoline at fp or the next suitable frame after fp */
+      while (true) {
+        if (Magic.getCallerFramePointer(targetFp).EQ(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+          /* if we're at the bottom of the stack, then do not install anything */
+          hijackedReturnAddress = Address.zero();
+          hijackedReturnCalleeFp = Address.zero();
+          return;
+        }
+        int cmid = Magic.getCompiledMethodID(targetFp);
+        if (cmid == StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
+          /* skip invisible methods */
+          VM.sysWriteln("Warning: install stack trampoline skipping INVISIBLE_METHOD..  See RVMThread.");
+          targetFp = Magic.getCallerFramePointer(targetFp);
+        } else {
+          CompiledMethod calleeCM = CompiledMethods.getCompiledMethod(cmid);
+          if (calleeCM.getCompilerType() == CompiledMethod.TRAP ||
+              calleeCM.getMethod().getDeclaringClass().hasBridgeFromNativeAnnotation()) {
+            /* skip traps and native bridges */
+            VM.sysWriteln("Warning: install stack trampoline skipping Traps..  See RVMThread.");
+            targetFp = Magic.getCallerFramePointer(targetFp);
+          } else
+            break;
+        }
+      }
+      if (DEBUG_STACK_TRAMPOLINE) {
+        VM.sysWriteln(getId(), " Installing trampoline at: ", targetFp);
+        VM.sysWriteln(getId(), " Dumping my original stack first");
+        dumpStack(this.contextRegisters.getInnermostInstructionAddress(),this.contextRegisters.getInnermostFramePointer());
+      }
+      hijackedReturnAddress = Magic.getReturnAddressUnchecked(targetFp);
+      hijackedReturnCalleeFp = targetFp;
+      hijackedReturnCallerFp = Magic.getCallerFramePointer(targetFp);
+      if (VM.VerifyAssertions) VM._assert(trampoline.NE(hijackedReturnAddress));
+      Magic.setReturnAddress(targetFp, trampoline);
+      if (DEBUG_STACK_TRAMPOLINE) {
+        VM.sysWriteln(getId(), " Trampoline: ", trampoline);
+        VM.sysWriteln(getId(), " Hijacked return address: ", hijackedReturnAddress);
+        VM.sysWriteln(getId(), " Callee fp: ", hijackedReturnCalleeFp);
+        VM.sysWriteln(getId(), " Caller fp: ", hijackedReturnCallerFp);
+        VM.sysWriteln(getId(), " Trampoline installation done. Now Dumping the new stack");
+        //				dumpStack(hijackedReturnCalleeFp);
+        dumpStack(this.contextRegisters.getInnermostInstructionAddress(),this.contextRegisters.getInnermostFramePointer());
+      }
+    }
   }
-
-  /**
-   * Sets the name of the thread
-   *
-   * @param name the new name for the thread
-   * @see java.lang.Thread#setName(String)
-   */
-  public void setName(String name) {
-    this.name = name;
+  else {
+    // No checks on fast path
+    hijackedReturnAddress = Magic.getReturnAddressUnchecked(targetFp);
+    hijackedReturnCalleeFp = targetFp;
+    hijackedReturnCallerFp = Magic.getCallerFramePointer(targetFp);
+    Magic.setReturnAddress(targetFp, trampoline);
   }
+}
 
-  /**
-   * Gets the name of the thread
-   *
-   * @see java.lang.Thread#getName()
-   * @return name of the thread
-   */
-  public String getName() {
-    return name;
-  }
+@Uninterruptible
+@Inline
+public void resetTramoplineInfo() {
+  if(wsDebugTrace) {
+    VM.sysWriteln(getId(),": Resetting my barrier variables");
+  }
+  wsReturnBarrierUninstalled = true;
+  hijackedReturnCalleeFp = Address.zero();
+  hijackedReturnCallerFp = StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+}
 
-  /**
-   * Does the currently running Thread hold the lock on an obj?
-   *
-   * @param obj
-   *          the object to check
-   * @return whether the thread holds the lock
-   * @see java.lang.Thread#holdsLock(Object)
-   */
-  public boolean holdsLock(Object obj) {
-    RVMThread mine = getCurrentThread();
-    return ObjectModel.holdsLock(obj, mine);
-  }
+@Uninterruptible
+@Inline
+public void resetTramoplineInfo_unlocked() {
+  wsReturnBarrierUninstalled = true;
+  wsSafeToReturnFromBarrier = true;
+  wsWaitingInsideBarrier = false;
+  hijackedReturnCalleeFp = Address.zero();
+  hijackedReturnCallerFp = StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+}
 
-  /**
-   * Was this thread interrupted?
-   *
-   * @return whether the thread has been interrupted
-   * @see java.lang.Thread#isInterrupted()
-   */
-  public boolean isInterrupted() {
-    return hasInterrupt;
+/**
+ * de-install the stack trampoline (disabling return barriers).
+ */
+@Uninterruptible
+@Inline
+public void deInstallStackTrampoline() {
+  if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": deinstalling trampoline: ", framePointer);
+  if (!hijackedReturnCalleeFp.isZero()) {
+    if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": need to reinstall: ", hijackedReturnAddress);
+    hijackedReturnCalleeFp.plus(StackframeLayoutConstants.STACKFRAME_RETURN_ADDRESS_OFFSET).store(hijackedReturnAddress);
+    hijackedReturnCalleeFp = Address.zero();
+    hijackedReturnCallerFp = StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+    wsReturnBarrierUninstalled = true;
+    if(wsDebugTrace) {
+      VM.sysWriteln(getId(),": My barrier is deInstalled by thief W-",getCurrentThread().getId());
+    }
   }
+}
 
-  /**
-   * Clear the interrupted status of this thread
-   *
-   * @see java.lang.Thread#interrupted()
-   */
-  public void clearInterrupted() {
-    hasInterrupt = false;
+@Uninterruptible
+@Inline
+public void deInstallStackTrampoline_fromGC() {
+  if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": deinstalling trampoline: ", framePointer);
+  if (!hijackedReturnCalleeFp.isZero()) {
+    if (DEBUG_STACK_TRAMPOLINE) VM.sysWriteln(getId(),": need to reinstall: ", hijackedReturnAddress);
+    hijackedReturnCalleeFp.plus(StackframeLayoutConstants.STACKFRAME_RETURN_ADDRESS_OFFSET).store(hijackedReturnAddress);
+    hijackedReturnCalleeFp = Address.zero();
+    hijackedReturnCallerFp = StackframeLayoutConstants.STACKFRAME_SENTINEL_FP;
+    wsReturnBarrierUninstalled = true;
+    if(workstealingInProgress) VM.sysFail("GC cannot take place when workstealingInProgress");
+    wsSafeToReturnFromBarrier = true;
+    wsWaitingInsideBarrier = false;
+    if(wsDebugTrace) {
+      VM.sysWriteln(getId(),": My barrier is deInstalled from GC");
+    }
   }
+}
 
-  /**
-   * Interrupt this thread
-   *
-   * @see java.lang.Thread#interrupt()
-   */
-  @Interruptible
-  public void interrupt() {
-    monitor().lockNoHandshake();
-    hasInterrupt = true;
-    monitor().broadcast();
-    monitor().unlock();
-  }
+@Uninterruptible
+@Inline
+private void wsUnlockFromReturnBarrier() {
+  wsLock().lockNoHandshake();
+  /* Never use this method here at all if the victim has already branched into the return barrier else there will be bugs !!
+     deInstallStackTrampoline();
+     */
 
-  /**
-   * Get the priority of the thread
-   *
-   * @return the thread's priority
-   * @see java.lang.Thread#getPriority()
-   */
-  public int getPriority() {
-    if (isAlive()) {
-      // compute current priority
-      priority = sysCall.sysGetThreadPriority(pthread_id, priority_handle) + Thread.NORM_PRIORITY;
-    }
-    if (tracePriority) {
-      VM.sysWriteln("Thread #", getThreadSlot(), " get priority returning: ", priority);
-    }
-    return priority;
-  }
+  // List contains fps of callee to the continuation frames. Once the steal is completed, 
+  // means the last fp in the list is the callee to the task stolen in this steal.
+  fpsInContList--;	
+  wsSafeToReturnFromBarrier = true;
+  wsLock().broadcast();
+  wsLock().unlock();
+}
 
-  /**
-   * Set the priority of the thread
-   *
-   * @param priority the thread's priority
-   * @see java.lang.Thread#getPriority()
-   */
-  public void setPriority(int priority) {
-    if (isAlive()) {
-      int result = sysCall.sysSetThreadPriority(pthread_id, priority_handle, priority - Thread.NORM_PRIORITY);
-      if (result == 0) {
-        this.priority = priority;
-        if (tracePriority) {
-          VM.sysWriteln("Thread #", getThreadSlot(), " set priority: ", priority);
-        }
-      } else {
-        // setting priority failed
-        if (tracePriority) {
-          VM.sysWriteln("Thread #", getThreadSlot(), " failed to set priority: ", priority, ", result: ", result);
-        }
-      }
-    } else {
-      if (tracePriority) {
-        VM.sysWriteln("Thread #", getThreadSlot(), " set priority: ", priority, " while not running");
-      }
-      this.priority = priority;
-    }
-  }
+// Some debug flags
+// {
+final protected static boolean createContinuationDistribution = false;
+// Switches to enable / disble optimizations related to return barrier
+// 1) The most basic optimization w.r.t return barrier
+final private static boolean victimCanBeReleasedAfterRBarrierIsInstalled = true;
+// 2) Enable this only if 1 is true
+final private static boolean victimCanReinstallBarrier = true;
+// 3) Enable this only if 1 and 2 is true
+final private static boolean thiefCanInitiateStealFromAPreInstalledBarrier = true;
+// }
 
-  /**
-   * Get the state of the thread in a manner compatible with the Java API
-   *
-   * @return thread state
-   * @see java.lang.Thread#getState()
-   */
-  @Interruptible
-  public Thread.State getState() {
-    monitor().lockNoHandshake();
-    try {
-      observeExecStatus();
-      switch (execStatus) {
-      case NEW:
-        return Thread.State.NEW;
-      case IN_JAVA:
-      case IN_NATIVE:
-      case IN_JNI:
-      case IN_JAVA_TO_BLOCK:
-      case BLOCKED_IN_NATIVE:
-      case BLOCKED_IN_JNI:
-        if (isAboutToTerminate) {
-          return Thread.State.TERMINATED;
+@Uninterruptible
+@Inline
+public void returnBarrier_internal() {
+  if(wsDebugTrace) {
+    VM.sysWriteln(getId(),": Entering inside rbarrier");
+  }
+  {
+    wsLock().lockNoHandshake();
+    hijackedReturnAddress_original = hijackedReturnAddress;
+    while(true) {
+      boolean removeBarrier = false;
+      // 1. should break out if no steals in progress
+      //		1a) try to re-install the barrier 
+      if(wsSafeToReturnFromBarrier) {
+        if(victimCanReinstallBarrier) {
+          if(indexInContList < fpsInContList) {
+            if(false) {
+              final int remaining = fpsInContList - indexInContList;
+              if(remaining >= 4) { 
+                // install in the middle most fp - better than installing in each fp
+                final int sum = indexInContList + fpsInContList;
+                indexInContList = (sum%2 == 0) ? (sum/2 -1) : sum/2;
+              }
+            }
+            wsInstallStackTrampolineBridge(array_of_continuations.get(indexInContList++));	
+            if(wsDebugTrace) {
+              VM.sysWriteln(getId(),": Done reinstalling my own rbarrier");
+            }
+            break;
+          }
+          else {
+            // remove barrier variables as its now going to be unInstalled
+            removeBarrier = true;
+          }
         }
-        switch (waiting) {
-        case RUNNABLE:
-          return Thread.State.RUNNABLE;
-        case WAITING:
-          return Thread.State.WAITING;
-        case TIMED_WAITING:
-          return Thread.State.TIMED_WAITING;
-        default:
-          VM.sysFail("Unknown waiting value: " + waiting);
-          return null;
+        else {
+          // remove barrier variables as its now going to be unInstalled
+          removeBarrier = true;
         }
-      case TERMINATED:
-        return Thread.State.TERMINATED;
-      default:
-        VM.sysFail("Unknown value of execStatus: " + execStatus);
-        return null;
       }
-    } finally {
-      monitor().unlock();
-    }
-  }
-
-  /**
-   * Wait for the thread to die or for the timeout to occur
-   *
-   * @param ms
-   *          milliseconds to wait
-   * @param ns
-   *          nanoseconds to wait
-   * @throws InterruptedException when the thread is interrupted
-   */
-  @Interruptible
-  public void join(long ms, int ns) throws InterruptedException {
-    RVMThread myThread = getCurrentThread();
-    if (VM.VerifyAssertions)
-      VM._assert(myThread != this);
-    if (traceBlock)
-      VM.sysWriteln("Joining on Thread #", threadSlot);
-    // this uses synchronized because we cannot have one thread acquire
-    // another thread's lock using the WithHandshake scheme, as that would result
-    // in a thread holding two threads' monitor()s.  using synchronized
-    // turns out to be just fine - see comment in terminate().
-    synchronized (this) {
-      if (ms == 0 && ns == 0) {
-        while (!isJoinable) {
-          wait(this);
-          if (traceBlock)
-            VM.sysWriteln("relooping in join on Thread #", threadSlot);
+      // If I am here then it means either: 
+      // a) I shd remove barrier 
+      // 			OR
+      // b) !wsSafeToReturnFromBarrier
+      if(removeBarrier) {
+        // Break out only if 
+        // i) no work-stealing is in progress
+        //				OR
+        // ii) The last thief decided that no further steal happens from this barrier
+        //    position. This is only if there are no more continuations remaining below
+        //    Only one variable workstealingInProgress is not sufficient to decide. 
+        //
+        //    Helps reducing failed steal ========> 
+        //	  If there is no continuations but before I reach here, another thief get
+        //    holds of me then it can do a failed steal attempt.
+        //
+        //	  Helps removing deadlock =========>
+        //	  When the last theif found there are no more continuations left, it marks
+        //    wsReturnBarrierUninstalled =  true. Now if we dont have the check for 
+        //    wsReturnBarrierUninstalled here then there maybe a deadlock. Suppose another
+        //    another theif grabs me mark workstealingInProgress=true. But just then I reach
+        //    over here and see that workstealingInProgress is in progress, I will keep waiting
+        //    However the thief is not aware of this, and it will wait for me to yield, which
+        //    will never happen. Hence two variables required here.
+        if(!workstealingInProgress || wsReturnBarrierUninstalled) {
+          if(wsDebugTrace) {
+            VM.sysWriteln(getId(),": No steal in progress hence removing my barrier");
+          }
+          resetTramoplineInfo();
+          break;
         }
-      } else {
-        long startNano = Time.nanoTime();
-        long whenWakeup = startNano + ms * 1000L * 1000L + ns;
-        while (!isJoinable) {
-          waitAbsoluteNanos(this, whenWakeup);
-          if (Time.nanoTime() >= whenWakeup) {
-            break;
+        else {
+          if(wsDebugTrace) {
+            VM.sysWriteln(getId(),": There is a steal in progress hence cannot remove my barrier and so waiting");
           }
-          if (traceBlock)
-            VM.sysWriteln("relooping in join on Thread #", threadSlot);
         }
       }
-    }
-  }
-
-  /**
-   * Gets live threads.
-   * <p>
-   * Note: this is an expensive operation operation because we're grabbing
-   * the accounting lock and thus prevent the threading system from changing
-   * the set of active threads.
-   *
-   * @return the live threads that ought to be user-visible, i.e.
-   *  all threads except the system threads
-   */
-  @Interruptible
-  public static Thread[] getLiveThreadsForJMX() {
-    int threadIndex = 0;
-
-    acctLock.lockNoHandshake();
-    Thread[] liveThreads = new Thread[numActiveThreads];
-    for (int i = 0; i < RVMThread.numThreads; i++) {
-      RVMThread t = RVMThread.threads[i];
-      if (t.isAlive() && !t.isSystemThread()) {
-        Thread javaLangThread = t.getJavaLangThread();
-        if (javaLangThread == null) {
-          continue;
+      else {
+        // case b
+        // ==> simply wait !!!
+        if(wsDebugTrace) {
+          VM.sysWriteln(getId(),": Thief still access my stack hence waiting in barrier to try unwind");
         }
-        boolean enoughSpace = threadIndex < numActiveThreads;
-          if (!enoughSpace) {
-            // unlock because of imminent (assertion) failure
-            acctLock.unlock();
-
-            if (VM.VerifyAssertions) {
-              VM._assert(VM.NOT_REACHED,
-                  "Not enough space in array for all live threads");
-            } else {
-              VM.sysFail("Not enough space in array for all live threads");
-            }
-          }
-
-        liveThreads[threadIndex] = javaLangThread;
-        threadIndex++;
       }
+      final long start = Magic.getTimeBase();
+      wsWaitingInsideBarrier = true;
+      wsLock().waitNoHandshake();
+      wsWaitingInsideBarrier = false;
+      totalBarrierCPUCycles += (Magic.getTimeBase() - start);
+      // 3. update the hijacked return address as thief may have updated it with join instruction
+      hijackedReturnAddress_original = hijackedReturnAddress;
     }
-    acctLock.unlock();
-    return liveThreads;
-  }
 
-  /**
-   * Counts the stack frames of this thread.
-   *
-   * @return the number of stack frames in this thread
-   */
-  @Interruptible
-  public int countStackFrames() {
-    if (!isSuspended) {
-      throw new IllegalThreadStateException(
-          "Thread.countStackFrames called on non-suspended thread");
-    }
-    throw new UnimplementedError();
+    wsLock().unlock();
   }
-
-  /**
-   * @return the length of the stack
-   */
-  public int getStackLength() {
-    return stack.length;
+  if(wsDebugTrace) {
+    VM.sysWriteln(getId(),": Returning from rbarrier");
   }
+}
 
-  /**
-   * @return the stack
-   */
-  public byte[] getStack() {
-    return stack;
-  }
+private Address hijackedReturnAddress_original; //is set only from returnBarrier() method
+public Address getHijackedReturnCallerFp() { return hijackedReturnCallerFp; }
+public Address getHijackedReturnAddress() { return hijackedReturnAddress; }
 
-  /**
-   * @return the thread's exception registers
-   */
-  public AbstractRegisters getExceptionRegisters() {
-    return exceptionRegisters;
-  }
+public boolean wsMaintainsClonedStackAlso() {
+  return !wsReturnBarrierUninstalled;
+}
 
-  /**
-   * @return the thread's context registers (saved registers when thread is
-   *         suspended by scheduler).
-   */
-  public AbstractRegisters getContextRegisters() {
-    return contextRegisters;
-  }
+// Lock/Unlock flags for return barrier: a) and b)
+/*
+ * a)
+ * --- This flag is turned on by thief at the victim as soon as it installs a barrier
+ * on this victim
+ * --- Thief can mark it off if it starts a steal from a barrier but finds 0 or 1
+ * continuations.
+ * --- Victim is allowed to mark it off only when its removing the barrier from its
+ * stack
+ * 
+ * Thieves use this to decide if they can start stealing from a return barrier
+ * without forcing the victim to execute yieldpoint. 
+ */
+private boolean wsReturnBarrierUninstalled = true;
+/*
+ * b) 
+ * -- Default value is true. Only a thief can make it off (false)
+ * Victims can only read but cannot write to it. Victims use it
+ * to decide when it becomes safe for them to re-install this barrier
+ * at a new position.
+ */
+private boolean wsSafeToReturnFromBarrier = true;
 
-  /** Set the initial attempt. */
-  public void reportCollectionAttempt() {
-    collectionAttempt++;
-  }
+/*
+ * This lock is used to decide if a steal is is progress at a victim.
+ * However, this flag is also used inside return barrier to decide
+ * if its safe for a victim to remove its return barrier from its stack.
+ * Only a thief is allowed to write to this flag and make it true/false.
+ * Victims can only read it. Unless its false, they cannot remove its
+ * return barrier. 
+ */
+protected boolean workstealingInProgress = false;
 
-  /** @return the number of collection attempts */
-  public int getCollectionAttempt() {
-    return collectionAttempt;
-  }
+public void setHijackedReturnAddress(Address ip) { hijackedReturnAddress = ip; } 
 
-  /** Resets the attempts. */
-  public void resetCollectionAttempts() {
-    collectionAttempt = 0;
-  }
+/** @return the address of the stack trampoline bridge code */
+@Inline
+private Address getStackTrampolineBridgeIP() { return Magic.objectAsAddress(stackTrampolineBridgeInstructions); }
 
-  /** @return the physical allocation failed flag. */
-  public boolean physicalAllocationFailed() {
-    return physicalAllocationFailed;
-  }
+/** @return the hijacked return address */
+@Inline
+public Address getTrampolineHijackedReturnAddress() { return hijackedReturnAddress; }
 
-  /** Set the physical allocation failed flag. */
-  public void setPhysicalAllocationFailed() {
-    physicalAllocationFailed = true;
-  }
+/**
+ * Determine whether a given method is the stack trampoline
+ *
+ * @param ip the code to be checked
+ * @return <code>true</code> if the code is the stack trampoline.
+ */
+@Inline
+public static boolean isTrampolineIP(Address ip) { return getCurrentThread().getStackTrampolineBridgeIP().EQ(ip); }
 
-  /** Clear the physical allocation failed flag. */
-  public void clearPhysicalAllocationFailed() {
-    physicalAllocationFailed = false;
+/**
+ * Given a frame that has been hijacked by the stack trampoline,
+ * return the real (hijacked) return address.
+ *
+ * @param hijackedFp a frame that has been hijacked by the stack trampoline
+ * @return the return address for the frame that was hijacked.
+ */
+@Uninterruptible
+public static Address getHijackedReturnAddress(Address hijackedFp) {
+  if (VM.VerifyAssertions) VM._assert(isTrampolineIP(Magic.getReturnAddressUnchecked(hijackedFp)));
+  RVMThread t = getCurrentThread();
+  if (!t.hijackedReturnCalleeFp.EQ(hijackedFp)) {
+    for (int tid = 0; tid < nextSlot; tid++) {
+      t = threadBySlot[tid];
+      if (t != null && t.hijackedReturnCalleeFp.EQ(hijackedFp))
+        break;
+    }
   }
+  return t.hijackedReturnAddress;
+}
 
-  /**
-   * @return the outstanding OutOfMemoryError.
-   */
-  public static OutOfMemoryError getOutOfMemoryError() {
-    return outOfMemoryError;
-  }
+@Uninterruptible
+@Inline
+public Address getCalleeFramePointer(final Address fp) {
+  Address calleeFP = fp;
+  final Address top = Magic.objectAsAddress(this.getStack());
+  final Address base = top.plus(this.getStackLength());
 
-  /**
-   * @return number of active threads in the system.
-   */
-  public static int getNumActiveThreads() {
-    return numActiveThreads;
+  while(calleeFP.NE(base)) {
+    if(calleeFP.loadAddress().EQ(fp)) return calleeFP;
+    calleeFP = calleeFP.minus(StackframeLayoutConstants.BYTES_IN_STACKSLOT);
   }
+  return Address.zero();
+}
 
-  public static int getNumActiveSystemThreads() {
-    return numActiveSystemThreads;
+@Unpreemptible
+@Inline
+protected void wsCheckShadowStack_retbarrier(RVMThread victim) {
+  if (wsShadowStack == null || wsShadowStack.length < victim.getStackLength()) {
+    wsShadowStack = MemoryManager.newStack(victim.getStackLength());
   }
 
-  /**
-   * @return number of active daemon threads.
-   */
-  public static int getNumActiveDaemons() {
-    return numActiveDaemons;
+  if (victim.wsVictimShadowStack == null || victim.wsVictimShadowStack.length < victim.getStackLength()) {
+    victim.wsVictimShadowStack = MemoryManager.newStack(victim.getStackLength());
   }
+}
 
-  /**
-   * Handles uncaught exceptions for subclasses of {@link SystemThread}.
-   * Uncaught exceptions for normal threads will end up in that thread's {@link #run()}
-   * method which will invoke the thread's uncaught exception handler.
-   *
-   * @param exceptionObject the exception object that wasn't caught
-   * @see #run() run() method of application threads
-   * @see SystemThread#run() run() method of system threads
-   */
-  @Interruptible
-  public void handleUncaughtException(Throwable exceptionObject) {
-    uncaughtExceptionCount++;
+@Unpreemptible
+@Inline
+public static Address wsCloneVictimStack(final RVMThread victim, final Address yieldpointFP) {
+  byte[] newStack = victim.wsVictimShadowStack;
+  byte[] currStack = victim.getStack();
 
-    handlePossibleRecursiveException();
-    VM.enableGC();
-    if (thread == null) {
-      VM.sysWrite("Exception in the primordial thread \"", getName(),
-          "\" while booting: ");
-    } else {
-      // This is output like that of the Sun JDK.
-      VM.sysWrite("Exception in thread \"", getName(), "\": ");
-    }
-    if (exceptionObject instanceof OutOfMemoryError) {
-      VM.sysWriteln("   <<No stacktrace available>>");
-    } else if (VM.fullyBooted) {
-      exceptionObject.printStackTrace();
-    }
-    getCurrentThread().terminate();
-    if (VM.VerifyAssertions)
-      VM._assert(VM.NOT_REACHED);
-  }
+  Address currTop = Magic.objectAsAddress(currStack).plus(currStack.length);
+  Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
 
-  /** Handle the case of exception handling triggering new exceptions. */
-  private void handlePossibleRecursiveException() {
-    if (uncaughtExceptionCount > 1 &&
-        uncaughtExceptionCount <= VM.maxSystemTroubleRecursionDepth + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite) {
-      VM.sysWrite("We got an uncaught exception while (recursively) handling ");
-      VM.sysWrite(uncaughtExceptionCount - 1);
-      VM.sysWrite(" uncaught exception");
-      if (uncaughtExceptionCount - 1 != 1) {
-        VM.sysWrite("s");
-      }
-      VM.sysWriteln(".");
-    }
-    if (uncaughtExceptionCount > VM.maxSystemTroubleRecursionDepth) {
-      dumpVirtualMachine();
-      VM.dieAbruptlyRecursiveSystemTrouble();
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-    }
-  }
+  Offset currDepth = currTop.diff(yieldpointFP);
+  Address newFP = newTop.minus(currDepth);
 
-  private static void dumpThread(RVMThread t) {
-    if (t == null) {
-      VM.sysWrite("none");
-    } else {
-      VM.sysWrite(t.threadSlot, "(", READABLE_EXEC_STATUS[t.getExecStatus()]);
-      if (t.isAboutToTerminate) {
-        VM.sysWrite("T");
-      }
-      if (t.isBlocking) {
-        VM.sysWrite("B");
-      }
-      if (t.isJoinable) {
-        VM.sysWrite("J");
-      }
-      if (t.atYieldpoint) {
-        VM.sysWrite("Y");
-      }
-      VM.sysWrite(")");
-    }
-  }
+  Memory.memcopy(newFP, yieldpointFP, currDepth.toWord().toExtent());
 
-  private static void dumpThreadArray(RVMThread[] array, int bound) {
-    for (int i = 0; i < bound; ++i) {
-      if (i != 0) {
-        VM.sysWrite(", ");
-      }
-      VM.sysWrite(i, ":");
-      dumpThread(array[i]);
-    }
-  }
+  Offset delta = newFP.diff(yieldpointFP);
 
-  private static void dumpThreadSlotArray(int[] array, int bound) {
-    for (int i = 0; i < bound; ++i) {
-      if (i != 0) {
-        VM.sysWrite(", ");
-      }
-      VM.sysWrite(i, ":");
-      int threadSlot = array[i];
-      VM.sysWrite(threadSlot, ",");
-      dumpThread(threadBySlot[array[i]]);
-    }
-  }
+  adjustStack(newStack, newFP, delta);
+  victim.victimYieldIPOnNewStack = Magic.getReturnAddress(yieldpointFP);
 
-  private static void dumpThreadArray(String name, RVMThread[] array, int bound) {
-    VM.sysWrite(name);
-    VM.sysWrite(": ");
-    dumpThreadArray(array, bound);
-    VM.sysWriteln();
-  }
+  return Magic.getCallerFramePointer(newFP);
+}
 
-  private static void dumpThreadSlotArray(String name, int[] array, int bound) {
-    VM.sysWrite(name);
-    VM.sysWrite(": ");
-    dumpThreadSlotArray(array, bound);
-    VM.sysWriteln();
-  }
+/**
+ * This method should always be called from a method which has following annotations:
+ * 1) @Unpreemptible
+ * 2) @NoInline
+ * 3) @NoOptCompile
+ * 4) @BaselineSaveLSRegisters
+ */
+@Unpreemptible
+@NoInline
+@BaselineNoRegisters
+private void wsCloneMyOwnStack(Address ip, Address fp) {
+  byte[] newStack = wsVictimShadowStack;
+  byte[] myStack = stack;
+
+  // initialize new stack with live portion of stack we're
+  // currently running on
+  //
+  // lo-mem hi-mem
+  // |<---myDepth----|
+  // +----------+---------------+
+  // | empty | live |
+  // +----------+---------------+
+  // ^myStack ^myFP ^myTop
+  //
+  // +-------------------+---------------+
+  // | empty | live |
+  // +-------------------+---------------+
+  // ^newStack ^newFP ^newTop
+  //
+  Address myTop = Magic.objectAsAddress(myStack).plus(myStack.length);
+  Address newTop = Magic.objectAsAddress(newStack).plus(newStack.length);
+
+  Address myFP = Magic.getFramePointer();
+  Offset myDepth = myTop.diff(myFP);
+  Address newFP = newTop.minus(myDepth);
+
+  // The frame pointer addresses the top of the frame on powerpc and
+  // the bottom
+  // on intel. if we copy the stack up to the current
+  // frame pointer in here, the
+  // copy will miss the header of the intel frame. Thus we make another
+  // call
+  // to force the copy. A more explicit way would be to up to the
+  // frame pointer
+  // and the header for intel.
+  Offset delta = copyStack(newStack);
+
+  // fix up registers and save areas so they refer
+  // to "newStack" rather than "myStack"
+  //
+  adjustStack(newStack, newFP, delta);
 
-  public static void dumpAcct() {
-    acctLock.lockNoHandshake();
-    dumpLock.lockNoHandshake();
-    VM.sysWriteln("====== Begin Thread Accounting Dump ======");
-    dumpThreadArray("threadBySlot", threadBySlot, nextSlot);
-    dumpThreadSlotArray("aboutToTerminate", aboutToTerminate, aboutToTerminateN);
-    VM.sysWrite("freeSlots: ");
-    for (int i = 0; i < freeSlotN; ++i) {
-      if (i != 0) {
-        VM.sysWrite(", ");
-      }
-      VM.sysWrite(i, ":", freeSlots[i]);
-    }
-    VM.sysWriteln();
-    dumpThreadArray("threads", threads, numThreads);
-    VM.sysWriteln("====== End Thread Accounting Dump ======");
-    dumpLock.unlock();
-    acctLock.unlock();
-  }
+  victimYieldFpOnNewStack = Magic.getCallerFramePointer(newFP);
+  victimYieldIPOnNewStack = Magic.getReturnAddress(newFP);
+}
 
-  public void extDump() {
-    dump();
-    VM.sysWriteln();
-    VM.sysWriteln("acquireCount for my monitor: ", monitor().acquireCount);
-    VM.sysWriteln("yieldpoints taken: ", yieldpointsTaken);
-    VM.sysWriteln("yieldpoints taken fully: ", yieldpointsTakenFully);
-    VM.sysWriteln("native entered blocked: ", nativeEnteredBlocked);
-    VM.sysWriteln("JNI entered blocked: ", jniEnteredBlocked);
-  }
+/**
+ * Replace the execution of the current thread with some stolen work.
+ */
+@Interruptible
+public static void wsSteal(java.lang.Thread victim) {
+  wsSteal(JikesRVMSupport.getThread(victim));
+}
 
-  /**
-   * Dump this thread's identifying information, for debugging, via
-   * {@link VM#sysWrite(String)}. We do not use any spacing or newline
-   * characters. Callers are responsible for space-separating or
-   * newline-terminating output.
-   */
-  public void dump() {
-    dump(0);
+@Unpreemptible
+private void wsCheckShadowStack(int length) {
+  if (wsShadowStack == null || wsShadowStack.length < length) {
+    wsShadowStack = MemoryManager.newStack(length);
   }
+}
 
-  /**
-   * Dump this thread's identifying information, for debugging, via
-   * {@link VM#sysWrite(String)}. We pad to a minimum of leftJustify
-   * characters. We do not use any spacing characters. Callers are responsible
-   * for space-separating or newline-terminating output.
-   *
-   * @param leftJustify
-   *          minimum number of characters emitted, with any extra characters
-   *          being spaces.
-   */
-  public void dumpWithPadding(int leftJustify) {
-    char[] buf = Services.grabDumpBuffer();
-    int len = dump(buf);
-    VM.sysWrite(buf, len);
-    for (int i = leftJustify - len; i > 0; i--) {
-      VM.sysWrite(" ");
-    }
-    Services.releaseDumpBuffer();
-  }
+/**
+ * Replace the execution of the current thread with some stolen work.
+ */
+@Unpreemptible
+public static void wsSteal(RVMThread victim) {
+  RVMThread.getCurrentThread().wsStealInternal(victim);
+}
+
+@Unpreemptible
+public static void wsSteal_retbarrier(RVMThread victim) {
+  RVMThread.getCurrentThread().wsStealInternal_retbarrier(victim);
+}
+
+public Address stackTop() {
+  return stackTop(stack);
+}
 
-  /**
-   * Dump this thread's identifying information, for debugging, via
-   * {@link VM#sysWrite(String)}. We do not use any spacing or newline
-   * characters. Callers are responsible for space-separating or
-   * newline-terminating output.
-   *
-   * This function avoids write barriers and allocation.
-   *
-   * @param verbosity
-   *          Ignored.
-   */
-  public void dump(int verbosity) {
-    char[] buf = Services.grabDumpBuffer();
-    int len = dump(buf);
-    VM.sysWrite(buf, len);
-    Services.releaseDumpBuffer();
+public Address stackTop(byte[] stack) {
+  return Magic.objectAsAddress(stack).plus(stack.length);
+}
+
+// debugging support
+final protected static boolean wsDebugTrace = false;
+private RVMThread wsDebugMyCurrentVictim = null;
+private boolean wsDebugRBAlreadyInstalled = false;
+// debugging support
+@UnpreemptibleNoWarn
+public static void dumpWSDetailsWhileDeliveringHardwareException() {
+  RVMThread me = getCurrentThread();
+  if(me.wsDebugMyCurrentVictim != null) {
+    VM.sysWriteln("============================================================================================================");
+    VM.sysWriteln("Trying to dump details of current work-stealing... Though it might be dangerous..");
+    VM.sysWriteln("My victim was thread ",me.wsDebugMyCurrentVictim.getId());
+    VM.sysWriteln("Did I installed a return barrier = ",me.iInstalledABarrier);
+    VM.sysWriteln("Did I found a pre-installed return barrier = ",me.wsDebugRBAlreadyInstalled);
+    if((!me.iInstalledABarrier && !me.wsDebugRBAlreadyInstalled) || !RVMThread.victimCanBeReleasedAfterRBarrierIsInstalled) {
+      VM.sysWriteln("First Trying to dump the original stack of victim");
+      dumpStack(me.wsDebugMyCurrentVictim.getContextRegisters().getInnermostInstructionAddress(), me.wsDebugMyCurrentVictim.getContextRegisters().getInnermostFramePointer());
+    }
+    if(me.iInstalledABarrier || me.wsDebugRBAlreadyInstalled) {
+      VM.sysWriteln("Dumping the hijacked addresses w.r.t return barrier at the victim: ");
+      VM.sysWriteln("Hijacked return address: ", me.wsDebugMyCurrentVictim.hijackedReturnAddress);
+      VM.sysWriteln("Callee fp: ", me.wsDebugMyCurrentVictim.hijackedReturnCalleeFp);
+      VM.sysWriteln("Caller fp: ", me.wsDebugMyCurrentVictim.hijackedReturnCallerFp);
+    }
+    if(me.iInstalledABarrier || me.wsDebugRBAlreadyInstalled) {
+      VM.sysWriteln("Now Trying to dump the cloned stack of victim");
+      dumpStack(me.wsDebugMyCurrentVictim.victimYieldIPOnNewStack, me.wsDebugMyCurrentVictim.victimYieldFpOnNewStack);
+    }
+    if(me.wsFrameCopier.debugStackFrameProcessing) {
+      VM.sysWriteln("Hardware Exception was actually generated inside StackFrameCopier.copyStack(.....)");
+      VM.sysWriteln("The fp being scanned was = ",me.wsFrameCopier.debugScanFp);
+      VM.sysWriteln("The ip being scanned was = ",me.wsFrameCopier.debugScanIp);
+    }
+    VM.sysWriteln("DONE dumping details of current work-stealing....");
+    VM.sysWriteln("============================================================================================================");
   }
+}
 
-  /**
-   * Dump this thread's info, for debugging. Copy the info about it into a
-   * destination char array. We do not use any spacing or newline characters.
-   *
-   * This function may be called during GC; it avoids write barriers and
-   * allocation.
-   *
-   * For this reason, we do not throw an <code>IndexOutOfBoundsException</code>.
-   *
-   * @param dest
-   *          char array to copy the source info into.
-   * @param offset
-   *          Offset into <code>dest</code> where we start copying
-   *
-   * @return 1 plus the index of the last character written. If we were to write
-   *         zero characters (which we won't) then we would return
-   *         <code>offset</code>. This is intended to represent the first
-   *         unused position in the array <code>dest</code>. However, it also
-   *         serves as a pseudo-overflow check: It may have the value
-   *         <code>dest.length</code>, if the array <code>dest</code> was
-   *         completely filled by the call, or it may have a value greater than
-   *         <code>dest.length</code>, if the info needs more than
-   *         <code>dest.length - offset</code> characters of space.
-   *
-   * -1 if <code>offset</code> is negative.
-   */
-  public int dump(char[] dest, int offset) {
-    offset = Services.sprintf(dest, offset, getThreadSlot()); // id
-    if (daemon) {
-      offset = Services.sprintf(dest, offset, "-daemon"); // daemon thread?
-    }
-    if (isBootThread()) {
-      offset = Services.sprintf(dest, offset, "-Boot"); // Boot (Primordial)
-      // thread
-    }
-    if (isSystemThread()) {
-      offset = Services.sprintf(dest, offset, "-system"); // System Thread
-    }
-    if (isMainThread()) {
-      offset = Services.sprintf(dest, offset, "-main"); // Main Thread
+@UnpreemptibleNoWarn
+@Inline
+private boolean wsSafeToAttemptSteal() {
+  boolean safe = false;
+  wsLock().lockNoHandshake();
+  safe = !workstealingInProgress;
+  if(safe) {
+    workstealingInProgress = true;
+    if(!RVMThread.thiefCanInitiateStealFromAPreInstalledBarrier) wsReturnBarrierUninstalled = true;
+    if(wsDebugTrace) {
+      VM.sysWriteln(getCurrentThread().getId(),": Grabbed victim W-",getId());
+    }
+    final boolean barrierPreInstalled = thiefCanInitiateStealFromAPreInstalledBarrier && !wsReturnBarrierUninstalled;
+    if(barrierPreInstalled) {
+      /*
+       * In this case, we can safely decide here if we really need to start
+       * steal from this barrier. If there are no more continuations left
+       * in the continuation list, then no need to use this barrier. Mark
+       * it unusable and start stealing by yielding the victim.
+       */
+      final boolean startStealFromBarrier = indexInContList < fpsInContList;
+      if(startStealFromBarrier) {
+        wsSafeToReturnFromBarrier = false;
+        if(wsDebugTrace) {
+          getCurrentThread().wsDebugRBAlreadyInstalled = true;
+          VM.sysWriteln(getCurrentThread().getId(),": RBarrier preinstalled on W-",getId());
+        }
+      }
+      else {
+        wsReturnBarrierUninstalled = true;
+        wsSafeToReturnFromBarrier = true;
+        if(wsDebugTrace) {
+          getCurrentThread().wsDebugRBAlreadyInstalled = true;
+          VM.sysWriteln(getCurrentThread().getId(),": RBarrier preinstalled But of no use on W-",getId());
+        }
+      }
     }
-    if (isCollectorThread()) {
-      offset = Services.sprintf(dest, offset, "-collector"); // gc thread?
+    fpsInContList = 0;
+    indexInContList = 0;
+  }
+  wsLock().unlock();
+  return safe;
+}
+
+@UnpreemptibleNoWarn
+@Inline
+private void wsFinishedStealing(boolean markBarrierUnusable) {
+  wsLock().lockNoHandshake();
+  workstealingInProgress = false;
+  if(markBarrierUnusable) {
+    wsSafeToReturnFromBarrier = true;
+    wsReturnBarrierUninstalled = true;
+    if(wsDebugTrace) {
+      VM.sysWriteln(getCurrentThread().getId(),": Marking the barrier unsuable and uninstalled for W-",getId());
     }
-    offset = Services.sprintf(dest, offset, "-");
-    offset = Services.sprintf(dest, offset, READABLE_EXEC_STATUS[getExecStatus()]);
-    offset = Services.sprintf(dest, offset, "-");
-    offset = Services.sprintf(dest, offset, java.lang.JikesRVMSupport
-        .getEnumName(waiting));
-    if (hasInterrupt || asyncThrowable != null) {
-      offset = Services.sprintf(dest, offset, "-interrupted");
+  }
+  if(wsWaitingInsideBarrier) {
+    if(wsDebugTrace) {
+      VM.sysWriteln(getCurrentThread().getId(),": Stealing done and broadcasting to come out of barrier to W-",getId());
     }
-    if (isAboutToTerminate) {
-      offset = Services.sprintf(dest, offset, "-terminating");
+    // unlock victim from wait inside barrier
+    wsLock().broadcast();
+  }
+  else {
+    if(wsDebugTrace) {
+      VM.sysWriteln(getCurrentThread().getId(),": Stealing done but no broadcast to vicitm W-",getId());
     }
-    return offset;
   }
+  wsLock().unlock();
+}
 
-  /**
-   * Dump this thread's info, for debugging. Copy the info about it into a
-   * destination char array. We do not use any spacing or newline characters.
-   * <p>
-   * This is identical to calling {@link #dump(char[],int)} with an
-   * <code>offset</code> of zero.
-   *
-   * @param dest array to dump the info into
-   *
-   * @return see {@link #dump(char[], int)}
-   */
-  public int dump(char[] dest) {
-    return dump(dest, 0);
-  }
+@UnpreemptibleNoWarn
+private void wsStealInternal(RVMThread victim) {
+  if (VM.VerifyAssertions) VM._assert(wsStealHead == null);
+  if (VM.VerifyAssertions) VM._assert(this != victim);
+  if (VM.VerifyAssertions) VM._assert(!wsFlag);
+
+  if(!victim.wsSafeToAttemptSteal()) return;
+
+  if(!tryDisableStealing()) {
+    victim.wsFinishedStealing(false);
+    return;
+  }
+
+  final long startStealCPUCycles = Magic.getTimeBase();
+
+  findAttempts++;
+
+  // Synchronize with victim
+  victim.beginPairHandshake();
+
+  if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = victim;
+
+  if (!victim.wsFlag) {
+    // Nothing to steal!
+    if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+    victim.endPairHandshake();
+    victim.wsFinishedStealing(false);
+    canAbortIfRequired();
+    totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+    return;
+  }
+
+  // Container for steal/join info.
+  WS.StealInfo steal = new WS.StealInfo();
+  WS.FinishInfo finish = new WS.FinishInfo();
+
+  // Ensure stack size now the victim is stopped, should rarely run.
+  wsCheckShadowStack(victim.stack.length);
+
+  // Copy the context registers from the victim.
+  Address ip, fp;
+  contextRegisters.clear();
+  victim.monitor().lockNoHandshake();
+  if (victim.getExecStatus() == RVMThread.BLOCKED_IN_JNI) {
+    ip = Address.zero();
+    fp = victim.getJNIEnv().topJavaFP();
+  } else {
+    ip = victim.getContextRegisters().getInnermostInstructionAddress();
+    fp = victim.getContextRegisters().getInnermostFramePointer();
+  }
+  victim.monitor().unlock();
+  contextRegisters.setInnermost(ip,fp);
+
+  // Search the victim for potential steals
+  int found = victim.wsFindSteal(contextRegisters, steal, finish);
+  if (found <= 1) victim.wsFlag = false;
+  if (found == 0) {
+    // Nothing to steal!
+    if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+    victim.endPairHandshake();
+    victim.wsFinishedStealing(false);
+    canAbortIfRequired();
+    totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+    return;
+  }
+  
+  setWorkerAsVictim();
+  if(createContinuationDistribution) {
+    victim.continuationsDistribution(found);
+  }
+  // New head of our join info is the victims old head.
+  wsStealHead = steal.prev();
+  wsFinishHead = steal.finish;
+
+  // work out how much 
+  Address newTop = stackTop(wsShadowStack);
+  Address vicTop = victim.stackTop();
+  Offset offset = newTop.diff(vicTop);
+  Address newFP = newTop.minus(steal.fpOffset);
+
+  // fix up the stack and registers while walking the real stack
+  contextRegisters.setInUse(true);
+  wsFrameCopier.copyStack(fp, ip, victim, this, contextRegisters, steal.fpOffset,
+      -1, offset, vicTop);
+  adjustRegisters(contextRegisters, offset);
+  if (VM.VerifyAssertions) {
+    Address testFp = newFP;
+    while (testFp.NE(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+      VM._assert(testFp.GE(Magic.objectAsAddress(wsShadowStack)));
+      VM._assert(testFp.LT(stackTop(wsShadowStack)));
+      testFp = Magic.getCallerFramePointer(testFp);
+    }
+  }
+
+  // install new stack
+  byte[] temp = stack;
+  stack = wsShadowStack;
+  wsShadowStack = temp;
+
+  // jump into new stack by throwing an exception
+  VM.disableGC();
+  WS.incFinish(steal.finish);
+
+  int compiledMethodId = Magic.getCompiledMethodID(newFP);
+  CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+  Address catchBlockStart = compiledMethod.getInstructionAddress(true, steal.cbOffset);
+  contextRegisters.setInnermost(catchBlockStart, newFP);
+
+  totalSteals++;
+
+  //Find out if this victim has any live finish_abort scope on its stack
+  contextRegistersCopyAtStackWalk.clear();
+  contextRegistersCopyAtStackWalk.setInnermost(ip,fp);
+  final Offset victimOffset_AbortAtFailureException = stackWalkToFindAbortExceptionOffset(contextRegistersCopyAtStackWalk);
+
+  // Find out if my new stack has any live finish_abort scope on its stack
+  contextRegistersCopyAtStackWalk.clear();
+  contextRegistersCopyAtStackWalk.setInnermost(catchBlockStart, newFP);
+  final Offset thiefOffset_AbortAtFailureException = stackWalkToFindAbortExceptionOffset(contextRegistersCopyAtStackWalk);
+  if(victimOffset_AbortAtFailureException.EQ(thiefOffset_AbortAtFailureException)) {
+    finish_abort_scope = victim.finish_abort_scope;
+    WS.printMSG("at steal, finish_abort IN range");
+  }
+  else {
+    finish_abort_scope = null;
+    WS.printMSG("at steal, finish_abort NOT-in range");
+  }
+
+  if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+  victim.endPairHandshake();
+  totalSuccessStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+  victim.wsFinishedStealing(false);
+  stackLimit = Magic.objectAsAddress(stack).plus(StackframeLayoutConstants.STACK_SIZE_GUARD);
+  compiledMethod.getExceptionDeliverer().deliverException(compiledMethod, catchBlockStart, wsContinuation, contextRegisters);
+}
 
-  /** Dump statistics gather on operations */
-  static void dumpStats() {
-    VM.sysWrite("FatLocks: ");
-    VM.sysWrite(waitOperations);
-    VM.sysWriteln(" wait operations");
-    VM.sysWrite("FatLocks: ");
-    VM.sysWrite(timedWaitOperations);
-    VM.sysWriteln(" timed wait operations");
-    VM.sysWrite("FatLocks: ");
-    VM.sysWrite(notifyOperations);
-    VM.sysWriteln(" notify operations");
-    VM.sysWrite("FatLocks: ");
-    VM.sysWrite(notifyAllOperations);
-  }
+@UnpreemptibleNoWarn
+private void wsStealInternal_retbarrier(RVMThread victim) {
+  if (VM.VerifyAssertions) VM._assert(wsStealHead == null);
+  if (VM.VerifyAssertions) VM._assert(this != victim);
+  if (VM.VerifyAssertions) VM._assert(!wsFlag);
 
-  /**
-   * Prints out message in format {@code "[j] (td) who: what"}, where:
-   * <ul>
-   *  <li>{@code j = java thread id}
-   *  <li>{@code t = numActiveThreads}
-   *  <li>{@code d = numActiveDaemon}
-   * </ul>
-   * The parenthetical values are printed only if {@link #traceDetails} is true.
-   * <p>
-   * We serialize against a mutex to avoid intermingling debug output from
-   * multiple threads.
-   *
-   * @param who the string for the who parameter
-   * @param what the string for the what parameter
-   */
-  public static void trace(String who, String what) {
-    outputLock.lockNoHandshake();
-    VM.sysWrite("[");
-    RVMThread t = getCurrentThread();
-    t.dump();
-    VM.sysWrite("] ");
-    if (traceDetails) {
-      VM.sysWrite("(");
-      VM.sysWriteInt(numActiveDaemons);
-      VM.sysWrite("/");
-      VM.sysWriteInt(numActiveThreads);
-      VM.sysWrite(") ");
-    }
-    VM.sysWrite(who);
-    VM.sysWrite(": ");
-    VM.sysWrite(what);
-    VM.sysWriteln();
-    outputLock.unlock();
+  if(wsDebugTrace) {
+    VM.sysWriteln(this.getId(),": Stealing from W-",victim.getId());
   }
 
- /**
-  * Prints out message in format {@code "[j] (td) who: what howmany"}, where:
-  * <ul>
-  *  <li>{@code j = java thread id}
-  *  <li>{@code t = numActiveThreads}
-  *  <li>{@code d = numActiveDaemon}
-  * </ul>
-  * The parenthetical values are printed only if {@link #traceDetails} is true.
-  * <p>
-  * We serialize against a mutex to avoid intermingling debug output from
-  * multiple threads.
-  *
-  * @param who the string for the who parameter
-  * @param what the string for the what parameter
-  * @param howmany the count for the howmany parameter
-  */
-  public static void trace(String who, String what, int howmany) {
-    _trace(who, what, howmany, false);
-  }
-
-  // same as trace, but prints integer value in hex
-  //
-  public static void traceHex(String who, String what, int howmany) {
-    _trace(who, what, howmany, true);
-  }
+  if(!victim.wsSafeToAttemptSteal()) return;
 
-  public static void trace(String who, String what, Address addr) {
-    outputLock.lockNoHandshake();
-    VM.sysWrite("[");
-    getCurrentThread().dump();
-    VM.sysWrite("] ");
-    if (traceDetails) {
-      VM.sysWrite("(");
-      VM.sysWriteInt(numActiveDaemons);
-      VM.sysWrite("/");
-      VM.sysWriteInt(numActiveThreads);
-      VM.sysWrite(") ");
-    }
-    VM.sysWrite(who);
-    VM.sysWrite(": ");
-    VM.sysWrite(what);
-    VM.sysWrite(" ");
-    VM.sysWriteHex(addr);
-    VM.sysWriteln();
-    outputLock.unlock();
-  }
+  final long startStealCPUCycles = Magic.getTimeBase();
+  findAttempts++;
 
-  private static void _trace(String who, String what, int howmany, boolean hex) {
-    outputLock.lockNoHandshake();
-    VM.sysWrite("[");
-    // VM.sysWriteInt(RVMThread.getCurrentThread().getThreadSlot());
-    getCurrentThread().dump();
-    VM.sysWrite("] ");
-    if (traceDetails) {
-      VM.sysWrite("(");
-      VM.sysWriteInt(numActiveDaemons);
-      VM.sysWrite("/");
-      VM.sysWriteInt(numActiveThreads);
-      VM.sysWrite(") ");
-    }
-    VM.sysWrite(who);
-    VM.sysWrite(": ");
-    VM.sysWrite(what);
-    VM.sysWrite(" ");
-    if (hex) {
-      VM.sysWriteHex(howmany);
-    } else {
-      VM.sysWriteInt(howmany);
-    }
-    VM.sysWriteln();
-    outputLock.unlock();
-  }
+  // check if return barrier is already installed
+  // No need to take wsLock(), as we have already told victim not
+  // to unwind from barrier (if any present)
+  final boolean barrierPreInstalled = thiefCanInitiateStealFromAPreInstalledBarrier && !victim.wsReturnBarrierUninstalled;
 
-  /**
-   * Print interesting scheduler information, starting with a stack traceback.
-   * <p>
-   * Note: the system could be in a fragile state when this method is called, so
-   * we try to rely on as little runtime functionality as possible (eg. use no
-   * bytecodes that require RuntimeEntrypoints support).
-   *
-   * @param message the message to write before the actual traceback
+  /*
+   * ensure that the victim is stopped inside @BaselineSaveLSRegisters frame
+   * so that thief can safely copy its frame and process callee save registers
+   * offline.
    */
-  public static void traceback(String message) {
-    if (VM.runningVM && threadingInitialized) {
-      outputLock.lockNoHandshake();
+  boolean wsSafeToInstallRBarrierInVictim = true;
+
+  if(!barrierPreInstalled) {
+    if(RVMThread.wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Attempting pairing with W-",victim.getId());
     }
-    VM.sysWriteln(message);
-    tracebackWithoutLock();
-    if (VM.runningVM && threadingInitialized) {
-      outputLock.unlock();
+
+    wsSafeToInstallRBarrierInVictim = victim.wsBeginPairHandshake();
+    victim.deInstallStackTrampoline();
+
+    if(RVMThread.wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Pairing done with W-",victim.getId());
     }
   }
 
-  public static void traceback(String message, int number) {
-    if (VM.runningVM && threadingInitialized) {
-      outputLock.lockNoHandshake();
+  if(RVMThread.wsDebugTrace) {
+    VM.sysWriteln(this.getId(),": Pairing done with W-",victim.getId());
+    wsDebugRBAlreadyInstalled = false;
+    wsDebugMyCurrentVictim = victim;
+  }
+
+  // Ensure stack size now the victim is stopped, should rarely run.
+  wsCheckShadowStack_retbarrier(victim);
+
+  if (!victim.wsFlag) {
+    if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+    if(wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": wsFlag was false, releasing W-",victim.getId());
     }
-    VM.sysWriteln(message, number);
-    tracebackWithoutLock();
-    if (VM.runningVM && threadingInitialized) {
-      outputLock.unlock();
+    // Nothing to steal!
+    if(!barrierPreInstalled) {
+      victim.endPairHandshake();
+      totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
     }
+    // No need to sum time for failed steal in case barrierPreInstalled
+    // because the only time lost by victim is what it waits inside
+    // handshake function inside the barrier. That place has its
+    // own timer hence no need for timing victim loss here.
+    victim.wsFinishedStealing(true);
+    return;
   }
 
-  static void tracebackWithoutLock() {
-    if (VM.runningVM) {
-      VM.sysWriteln("Thread #", getCurrentThreadSlot());
-      dumpStack(Magic.getCallerFramePointer(Magic.getFramePointer()));
-    } else {
-      dumpStack();
-    }
+  if(wsDebugTrace) {
+    VM.sysWriteln(this.getId(),": Start searching continuation in W-",victim.getId());
   }
 
-  /**
-   * Dump stack of calling thread, starting at callers frame
-   */
-  @UninterruptibleNoWarn("Never blocks")
-  public static void dumpStack() {
-    if (VM.runningVM) {
-      VM.sysWriteln("Dumping stack for Thread #", getCurrentThreadSlot());
-      dumpStack(Magic.getFramePointer());
-    } else {
-      StackTraceElement[] elements = (new Throwable(
-          "--traceback from Jikes RVM's RVMThread class--")).getStackTrace();
-      for (StackTraceElement element : elements) {
-        System.err.println(element.toString());
+  // Container for steal/join info.
+  WS.StealInfo steal = new WS.StealInfo();
+  WS.FinishInfo finish = new WS.FinishInfo();
+
+  // Copy the context registers from the victim.
+  Address ip, fp;
+  contextRegisters.clear();
+  boolean victimBlockedInJNI = false;
+  if(!barrierPreInstalled) { 
+    victim.monitor().lockNoHandshake();
+    if (victim.getExecStatus() == RVMThread.BLOCKED_IN_JNI) {
+      ip = Address.zero();
+      fp = victim.getJNIEnv().topJavaFP();
+      victimBlockedInJNI = true;
+      if(wsDebugTrace) {
+        VM.sysWriteln(this.getId(),": Found blocked in JNI W-",victim.getId());
       }
-    }
-  }
 
-  /**
-   * Dump state of a (stopped) thread's stack.
-   *
-   * @param fp address of starting frame. first frame output is the calling
-   * frame of passed frame
-   */
-  public static void dumpStack(Address fp) {
-    if (VM.VerifyAssertions) {
-      VM._assert(VM.runningVM);
+    } else {
+      ip = victim.getContextRegisters().getInnermostInstructionAddress();
+      fp = victim.getContextRegisters().getInnermostFramePointer();
     }
-    Address ip = Magic.getReturnAddress(fp);
-    fp = Magic.getCallerFramePointer(fp);
-    dumpStack(ip, fp);
+    victim.wsSafeToReturnFromBarrier = false;
+    victim.monitor().unlock();
+  }
+  else {
+    fp = victim.victimYieldFpOnNewStack;
+    ip = victim.victimYieldIPOnNewStack;
+    preInstalledBarriers++;
   }
 
-  /**
-   * Dump state of a (stopped) thread's stack.
-   *
-   * @param ip instruction pointer for first frame to dump
-   * @param fp frame pointer for first frame to dump
-   */
-  public static void dumpStack(Address ip, Address fp) {
-    boolean b = Monitor.lockNoHandshake(dumpLock);
-    RVMThread t = getCurrentThread();
-    ++t.inDumpStack;
-    if (t.inDumpStack > 1 &&
-        t.inDumpStack <= VM.maxSystemTroubleRecursionDepth + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite) {
-      VM.sysWrite("RVMThread.dumpStack(): in a recursive call, ");
-      VM.sysWrite(t.inDumpStack);
-      VM.sysWriteln(" deep.");
-    }
-    if (t.inDumpStack > VM.maxSystemTroubleRecursionDepth) {
-      VM.dieAbruptlyRecursiveSystemTrouble();
-      if (VM.VerifyAssertions)
-        VM._assert(VM.NOT_REACHED);
-    }
+  contextRegisters.setInnermost(ip,fp);
 
-    if (fp.EQ(StackFrameLayout.getStackFrameSentinelFP())) {
-      VM.sysWriteln("Empty stack");
-    } else if (!isAddressValidFramePointer(fp)) {
-      VM.sysWrite("Bogus looking frame pointer: ", fp);
-      VM.sysWriteln(" not dumping stack");
-    } else {
-      try {
-        VM.sysWriteln("-- Stack --");
-        while (Magic.getCallerFramePointer(fp).NE(
-            StackFrameLayout.getStackFrameSentinelFP())) {
+  Address vicTop = barrierPreInstalled ? victim.stackTop(victim.wsGetClonedStack()) : victim.stackTop();
+  // Search the victim for potential steals
+  int found = (victimBlockedInJNI || !wsSafeToInstallRBarrierInVictim) ? victim.wsFindSteal(contextRegisters, steal, finish) : victim.wsFindSteal_retBarrier(steal, finish, vicTop, barrierPreInstalled, startStealCPUCycles);
 
-          // if code is outside of RVM heap, assume it to be native code,
-          // skip to next frame
-          if (!MemoryManager.addressInVM(ip)) {
-            showMethod("native frame", fp);
-            ip = Magic.getReturnAddress(fp);
-            fp = Magic.getCallerFramePointer(fp);
-          } else {
+  if(wsDebugTrace) {
+    VM.sysWriteln(victim.getId(),": Total available continuations = ",found);
+  }
 
-            int compiledMethodId = Magic.getCompiledMethodID(fp);
-            boolean idOutOfRange = compiledMethodId > CompiledMethods.numCompiledMethods() ||
-                compiledMethodId < 1;
-            VM.sysWrite("(", fp);
-            VM.sysWrite(" ", compiledMethodId, ")");
-            if (compiledMethodId == StackFrameLayout.getInvisibleMethodID()) {
-              showMethod("invisible method", fp);
-            } else if (idOutOfRange) {
-                showMethod("invalid compiled method id", fp);
-                break;
-            } else {
-              // normal java frame(s)
-              CompiledMethod compiledMethod = CompiledMethods
-                  .getCompiledMethod(compiledMethodId);
-              if (compiledMethod == null) {
-                showMethod(compiledMethodId, fp);
-              } else if (compiledMethod.getCompilerType() == CompiledMethod.TRAP) {
-                showMethod("hardware trap", fp);
-              } else if (!isAddressValidFramePointer(fp)) {
-                  VM.sysWrite("Bogus looking frame pointer: ", fp);
-                  VM.sysWriteln(" not dumping stack");
-                  break;
-              } else {
-                RVMMethod method = compiledMethod.getMethod();
-                if (compiledMethod.containsReturnAddress(ip)) {
-                  Offset instructionOffset = compiledMethod
-                      .getInstructionOffset(ip);
-                  int lineNumber = compiledMethod
-                      .findLineNumberForInstruction(instructionOffset);
-                  boolean frameShown = false;
-                  if (VM.BuildForOptCompiler && compiledMethod.getCompilerType() == CompiledMethod.OPT) {
-                    OptCompiledMethod optInfo = (OptCompiledMethod) compiledMethod;
-                    // Opt stack frames may contain multiple inlined methods.
-                    OptMachineCodeMap map = optInfo.getMCMap();
-                    int iei = map.getInlineEncodingForMCOffset(instructionOffset);
-                    if (iei >= 0) {
-                      int[] inlineEncoding = map.inlineEncoding;
-                      int bci = map.getBytecodeIndexForMCOffset(instructionOffset);
-                      for (; iei >= 0; iei = OptEncodedCallSiteTree.getParent(iei, inlineEncoding)) {
-                        int mid = OptEncodedCallSiteTree.getMethodID(iei, inlineEncoding);
-                        method = MemberReference.getMethodRef(mid).getResolvedMember();
-                        lineNumber = ((NormalMethod) method).getLineNumberForBCIndex(bci);
-                        showMethod(method, lineNumber, fp, bci, instructionOffset);
-                        if (iei > 0) {
-                          bci = OptEncodedCallSiteTree.getByteCodeOffset(iei, inlineEncoding);
-                        }
-                      }
-                      frameShown = true;
-                    }
-                  }
-                  if (!frameShown) {
-                    int bci = -1;
-                    if (compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
-                      BaselineCompiledMethod bcm = (BaselineCompiledMethod) compiledMethod;
-                      bci = bcm.findBytecodeIndexForInstruction(instructionOffset);
-                    }
-                    showMethod(method, lineNumber, fp, bci, instructionOffset);
-                  }
-                } else {
-                  VM.sysWrite("    WARNING: Instruction pointer ");
-                  VM.sysWrite(ip);
-                  VM.sysWrite(" not in method code");
-                  showMethod(method, -1, fp, -1, Offset.max());
-                }
-              }
-            }
-            ip = Magic.getReturnAddress(fp);
-            fp = Magic.getCallerFramePointer(fp);
-          }
-          if (!isAddressValidFramePointer(fp)) {
-            VM.sysWrite("Bogus looking frame pointer: ", fp);
-            VM.sysWriteln(" end of stack dump");
-            break;
-          }
-        } // end while
-      } catch (Throwable th) {
-        VM.sysWriteln("Something bad killed the stack dump. The last frame pointer was: ", fp);
-      }
+  if (found <= 1 && !barrierPreInstalled) {
+    /*
+     * If we started the steal from a return barrier and we discover
+     * that found <=1 then it does not mean wsFlag=false for this victim.
+     * There may be continuations available above the barrier, which can
+     * be stolen by yielding the victim.
+     */
+    victim.wsFlag = false;
+  }
+  if (found == 0) {
+    if(RVMThread.wsDebugTrace) wsDebugMyCurrentVictim = null;
+    //Nothing to steal means there was no return barrier installed
+    if(wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Nothing to steal, releasing W-",victim.getId());
+    }
+    if(!barrierPreInstalled) {
+      victim.wsSafeToReturnFromBarrier = true;
+      victim.endPairHandshake();
+      totalFailedStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
     }
-    --t.inDumpStack;
+    // No need to sum time for failed steal in case barrierPreInstalled
+    // because the only time lost by victim is what it waits inside
+    // handshake function inside the barrier. That place has its
+    // own timer hence no need for timing victim loss here.
 
-    Monitor.unlock(b, dumpLock);
+    victim.wsFinishedStealing(true);
+    return;
+  }
+  if(createContinuationDistribution) {
+    victim.continuationsDistribution(found);
   }
 
-  /**
-   * Return true if the supplied address could be a valid frame pointer. To
-   * check for validity we make sure the frame pointer is in one of the spaces;
-   * <ul>
-   * <li>LOS (For regular threads)</li>
-   * <li>Immortal (For threads allocated in immortal space such as collectors)</li>
-   * <li>Boot (For the boot thread)</li>
-   * </ul>
-   *
-   * <p>
-   * or it is {@link StackFrameLayout#getStackFrameSentinelFP()}.
-   * {@code STACKFRAME_SENTINEL_FP} is possible when the thread has been created
-   * but has yet to be scheduled.
-   * </p>
-   *
-   * @param address
-   *          the address.
-   * @return true if the address could be a frame pointer, false otherwise.
-   */
-  private static boolean isAddressValidFramePointer(final Address address) {
-    if (address.EQ(Address.zero()))
-      return false; // Avoid hitting assertion failure in MMTk
-    else
-      return address.EQ(StackFrameLayout.getStackFrameSentinelFP()) || MemoryManager.mightBeFP(address);
-  }
-
-  private static void showPrologue(Address fp) {
-    VM.sysWrite("   at ");
-    if (SHOW_FP_IN_STACK_DUMP) {
-      VM.sysWrite("[");
-      VM.sysWrite(fp);
-      VM.sysWrite(", ");
-      VM.sysWrite(Magic.getReturnAddress(fp));
-      VM.sysWrite("] ");
-    }
+  // update variables if I installed a barrier
+  if(iInstalledABarrier) {
+    vicTop =  victim.stackTop(victim.wsGetClonedStack());
+    fp = victim.victimYieldFpOnNewStack;
+    ip = victim.victimYieldIPOnNewStack;
   }
 
-  /**
-   * Show a method where getCompiledMethod returns null
-   *
-   * @param compiledMethodId the id of the compiled method
-   * @param fp the frame pointer of the method's frame
-   */
-  private static void showMethod(int compiledMethodId, Address fp) {
-    showPrologue(fp);
-    VM.sysWriteln(
-        "<unprintable normal Java frame: CompiledMethods.getCompiledMethod(",
-        compiledMethodId, ") returned null>");
+  // New head of our join info is the victims old head.
+  wsStealHead = steal.prev();
+  wsFinishHead = steal.finish;
+
+  // work out how much 
+  Address newTop = stackTop(wsShadowStack);
+  Offset offset = newTop.diff(vicTop);
+  Address newFP = newTop.minus(steal.fpOffset);
+
+  // fix up the stack and registers while walking the real stack
+  contextRegisters.setInUse(true);
+
+  if(wsDebugTrace) {
+    VM.sysWriteln(this.getId(),": Start processing frames from W-",victim.getId());
   }
 
-  /**
-   * Shows a method that we can't show (ie just a text description of the stack
-   * frame
-   *
-   * @param name the method's name
-   * @param fp the frame pointer of the method's frame
-   */
-  private static void showMethod(String name, Address fp) {
-    showPrologue(fp);
-    VM.sysWrite("<");
-    VM.sysWrite(name);
-    VM.sysWriteln(">");
+  wsFrameCopier.copyStack(fp, ip, victim, this, contextRegisters, steal.fpOffset, 
+      -1, offset, vicTop);
+
+  if(wsDebugTrace) {
+    VM.sysWriteln(this.getId(),": Done processing stolen frames from W-",victim.getId());
   }
 
-  /**
-   * Helper function for {@link #dumpStack(Address,Address)}. Print a stack
-   * frame showing the method.
-   *
-   * @param method the underlying method
-   * @param lineNumber the line number for the stack trace
-   * @param fp the frame pointer of the method's frame
-   * @param bci byte code index (value &lt; 0 if unknown)
-   * @param mcOffset machine code offset for the instruction ({@code Offset.max()} if unknown)
-   */
-  private static void showMethod(RVMMethod method, int lineNumber, Address fp, int bci, Offset mcOffset) {
-    showPrologue(fp);
-    if (method == null) {
-      VM.sysWrite("<unknown method>");
-    } else {
-      VM.sysWrite(method.getDeclaringClass().getDescriptor());
-      VM.sysWrite(" ");
-      VM.sysWrite(method.getName());
-      VM.sysWrite(method.getDescriptor());
-    }
-    if (lineNumber > 0) {
-      VM.sysWrite(" at line ");
-      VM.sysWriteInt(lineNumber);
-    }
-    if (bci >= 0) {
-      VM.sysWrite(" at bytecode index ");
-      VM.sysWriteInt(bci);
-    }
-    if (!mcOffset.isMax()) {
-      VM.sysWrite(" at machine code offset ");
-      VM.sysWrite(mcOffset);
+  WS.incFinish(steal.finish);
+
+  final boolean canReleaseNow = (iInstalledABarrier || barrierPreInstalled) && RVMThread.victimCanBeReleasedAfterRBarrierIsInstalled;
+
+  if(canReleaseNow) {
+    final boolean isBarrierUnusable = (found == 1) && (iInstalledABarrier||barrierPreInstalled);
+    victim.wsFinishedStealing(isBarrierUnusable);
+    if(wsDebugTrace) {
+      VM.sysWriteln(this.getId(),": Releasing from barrier by marking workstealing done for W-",victim.getId());
     }
-    VM.sysWriteln();
+    iInstalledABarrier = false;
   }
 
-  /**
-   * Dump state of a (stopped) thread's stack and exit the virtual machine.
-   *
-   * @param fp
-   *          address of starting frame Returned: doesn't return. This method is
-   *          called from sysSignal*.c when something goes horrifically wrong
-   *          with exception handling and we want to die with useful
-   *          diagnostics.
-   */
-  @Entrypoint
-  public static void dumpStackAndDie(Address fp) {
-    if (!exitInProgress) {
-      // This is the first time I've been called, attempt to exit "cleanly"
-      exitInProgress = true;
-      dumpStack(fp);
-      VM.sysExit(EXIT_STATUS_DUMP_STACK_AND_DIE);
-    } else {
-      // Another failure occurred while attempting to exit cleanly.
-      // Get out quick and dirty to avoid hanging.
-      sysCall.sysExit(EXIT_STATUS_RECURSIVELY_SHUTTING_DOWN);
+  adjustRegisters(contextRegisters, offset);
+
+  if (VM.VerifyAssertions) {
+    Address testFp = newFP;
+    while (testFp.NE(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+      VM._assert(testFp.GE(Magic.objectAsAddress(wsShadowStack)));
+      VM._assert(testFp.LT(stackTop(wsShadowStack)));
+      testFp = Magic.getCallerFramePointer(testFp);
     }
   }
 
-  /**
-   * @return whether it is safe to start forcing garbage collects for stress testing
-   */
-  public static boolean safeToForceGCs() {
-    return gcEnabled();
+  // install new stack
+  byte[] temp = stack;
+  stack = wsShadowStack;
+  wsShadowStack = temp;
+
+  // jump into new stack by throwing an exception
+  VM.disableGC();
+
+  if(wsDebugTrace) {
+    wsDebugMyCurrentVictim = null;
+    VM.sysWriteln(this.getId(),": Stealing Done from W-",victim.getId());
   }
 
-  /**
-   * @return whether garbage collection is enabled
-   */
-  public static boolean gcEnabled() {
-    return threadingInitialized && getCurrentThread().yieldpointsEnabled();
+  int compiledMethodId = Magic.getCompiledMethodID(newFP);
+  CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+  Address catchBlockStart = compiledMethod.getInstructionAddress(true, steal.cbOffset);
+
+  totalSteals++;
+
+  if(!canReleaseNow) {
+    victim.endPairHandshake();
+    totalSuccessStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles); 
+    victim.wsFinishedStealing(false);
   }
 
-  /**
-   * Set up the initial thread and processors as part of boot image writing
-   *
-   * @return the boot thread
-   */
-  @Interruptible
-  public static RVMThread setupBootThread() {
-    if (VM.VerifyAssertions) VM._assert(bootThread == null);
-    BootThread bt = new BootThread();
-    bootThread = bt.getRVMThread();
-    bootThread.feedlet = TraceEngine.engine.makeFeedlet(
-        "Jikes RVM boot thread",
-        "Thread used to execute the initial boot sequence of Jikes RVM");
-    numActiveThreads++;
-    numActiveSystemThreads++;
-    numActiveDaemons++;
-    return bootThread;
+  if(wsDebugTrace) {
+    VM.sysWriteln(this.getId(),": Throwing exception to start continuation");
   }
 
-  /**
-   * Dump state of virtual machine.
-   */
-  public static void dumpVirtualMachine() {
-    boolean b = Monitor.lockNoHandshake(dumpLock);
-    getCurrentThread().disableYieldpoints();
-    VM.sysWriteln();
-    VM.sysWrite("-- Threads --");
-    VM.sysWriteln();
-    for (int i = 0; i < numThreads; ++i) {
-      RVMThread t = threads[i];
-      if (t != null) {
-        t.dumpWithPadding(30);
-        VM.sysWriteln();
+  contextRegisters.setInnermost(catchBlockStart, newFP);	//return barrier
+  stackLimit = Magic.objectAsAddress(stack).plus(StackframeLayoutConstants.STACK_SIZE_GUARD);
+  compiledMethod.getExceptionDeliverer().deliverException(compiledMethod, catchBlockStart, wsContinuation, contextRegisters);
+}
+
+/**
+ * Implement join functionality. This is always run by the victim, and there are basically two paths here.
+ * 
+ * 1) The victim stops and decrements the finish.
+ * 2) Control is returned to the victim to push some result into the finish state (after which it calls completeJoin). 
+ */
+@Inline
+@Unpreemptible
+public void wsJoinInternal(Address fp, Address ip) {
+  // Medium-path check for unnecessary join call.
+  Offset fpOffset = stackTop().diff(fp);
+  if (wsStealHead == null || !wsStealHead.matches(fpOffset)) {
+    return;
+  }
+
+  int compiledMethodId = Magic.getCompiledMethodID(fp);
+  CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+  Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+  Offset cbOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, RVMType.WSContinuationType, true);
+  if (!wsStealHead.matches(fpOffset, cbOffset)) {
+    // Another check just to make sure we are doing the right thing
+    return;
+  }
+
+  cbOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, RVMType.WSJoinType, true);
+  if (cbOffset.sGE(Offset.zero())) {
+    // This join wants to return data to the finish.
+    wsInJoin = true;
+    wsJoin.finish = wsStealHead.finish;
+    RuntimeEntrypoints.athrow(wsJoin);
+  }
+  wsCompleteJoinInternal();
+}
+
+@NoInline
+@UnpreemptibleNoWarn
+public void wsCompleteFinishInternal() {
+  ObjectModel.genericUnlock_internal(wsFinishHead);
+  wsInJoin = false;
+  wsFlag = false;
+  wsStealHead = null;
+  wsFinishHead = null;
+  wsSpecialNVMap = 0;
+  if(RVMThread.wsRetBarrier) {
+    resetTramoplineInfo_unlocked();
+    WS.searchForWork_retbarrier();
+  }
+  else {
+    WS.searchForWork();
+  }
+}
+
+@NoInline
+@UnpreemptibleNoWarn
+public void wsCompleteJoinInternal() {
+  WS.StealInfo steal = wsStealHead;
+  if (WS.decFinish(steal.finish)) {
+    // We are going to run the finish...
+    VM.disableGC();
+    Magic.saveThreadState(contextRegisters);
+    Address fp = contextRegisters.getInnermostFramePointer();
+    Address top = stackTop();
+    // Search for the right frame.
+
+    while (top.diff(fp).NE(wsFinishHead.fpOffset)) {
+      if (VM.VerifyAssertions) VM._assert(fp.NE(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP));
+      int compiledMethodId = Magic.getCompiledMethodID(fp);
+      if (compiledMethodId == StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
+        contextRegisters.unwindStackFrame();
+      } else {
+        CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+        ExceptionDeliverer exceptionDeliverer = compiledMethod.getExceptionDeliverer();
+        exceptionDeliverer.unwindStackFrame(compiledMethod, contextRegisters);
       }
-    }
-    VM.sysWriteln();
+      fp = contextRegisters.getInnermostFramePointer();
+    }
+
+    int compiledMethodId = Magic.getCompiledMethodID(fp);
+    CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+    Address catchBlockStart = compiledMethod.getInstructionAddress(true, wsFinishHead.cbOffset);
+    contextRegisters.setInnermost(catchBlockStart, fp);
+    contextRegisters.setInUse(true);
+    stackLimit = Magic.objectAsAddress(stack).plus(StackframeLayoutConstants.STACK_SIZE_GUARD);
+    wsFinish.data = wsFinishHead;
+    wsInJoin = false;
+    wsSpecialNVMap = 0;
+    wsStealHead = wsFinishHead.steal;
+    wsFinishHead = wsFinishHead.prev();
+    compiledMethod.getExceptionDeliverer().deliverException(compiledMethod, catchBlockStart, wsFinish, contextRegisters);
+    // Not reached
+  }
+  wsInJoin = false;
+  wsFlag = false;
+  wsStealHead = null;
+  wsFinishHead = null;
+  wsSpecialNVMap = 0;
+  if(wsRetBarrier) {
+    resetTramoplineInfo_unlocked();
+    WS.searchForWork_retbarrier();
+  }
+  else {
+    WS.searchForWork();
+  }
+}
 
-    VM.sysWriteln();
-    VM.sysWrite("-- Locks in use --");
-    VM.sysWriteln();
-    Lock.dumpLocks();
+@UnpreemptibleNoWarn
+@Inline
+public Address getAddressValueOnClonedStack(final Address fp) {
+  if(fp.isZero()) return fp;
+  else return stackTop(wsVictimShadowStack).minus(stackTop().diff(fp));
+}
 
-    VM.sysWriteln("Dumping stack of active thread");
-    VM.sysWriteln();
-    dumpStack();
+@UnpreemptibleNoWarn
+@Inline
+private Address getAddressValueOnMainStack(final Address fp) {
+  return stackTop().minus(stackTop(wsVictimShadowStack).diff(fp));
+}
+
+/**
+ * Search through a potential victim's stack, and find:
+ *
+ *   1) The oldest continuation that can be stolen
+ *   2) The enclosing finish for this continuation.
+ * 
+ * The passed JoinInfo and FinishInfo classes are populated
+ * accordingly if a steal is found.
+ *
+ * @param top
+ * @param registers
+ * @param info
+ * @return
+ */
+@UnpreemptibleNoWarn
+@Inline
+private int wsFindSteal(AbstractRegisters registers, WS.StealInfo steal, WS.FinishInfo finish) {
+  int found = 0;
+  boolean skip = wsInJoin;
+  Address fp = registers.getInnermostFramePointer();
+  Address top = stackTop();
+  Offset stealCBOffset = Offset.zero();
+  Offset stealFPOffset = Offset.zero();
+  Offset finishCBOffset = Offset.zero();
+  Offset finishFPOffset = Offset.zero();
+  Address prevFp = Address.zero();
+  Address stealPrevFp = Address.zero();
+  Address finishPrevFp = Address.zero();
+
+  boolean foundStolen = false;
+  boolean foundFinish = true;
+  while (Magic.getCallerFramePointer(fp).NE(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+    Offset fpOffset = top.diff(fp);
+    int compiledMethodId = Magic.getCompiledMethodID(fp);
+    if (compiledMethodId != StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
+      CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+      if (compiledMethod.getCompilerType() == CompiledMethod.OPT || compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
+        // Process each normal stack frame.
+        // First we search for the oldest unstolen continuation. Once we hit an already stolen continuation or reach the end we are done.
+        // We also need to know the enclosing finish block.
+        // We need to try and find the outermost finish block for each method to make sure. 
+
+        Address ip = registers.getInnermostInstructionAddress();
+        Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+
+        Offset currentIPOffset = ipOffset;
+        Offset finishIPOffset = ipOffset;
+
+        // Search for a continuation to steal.
+        if (!foundStolen) {
+          while (true) {
+            Offset catchBlock = compiledMethod.findCatchBlockForInstruction(currentIPOffset, RVMType.WSContinuationType, true);
+            if (catchBlock.sLT(Offset.zero())) break;
+            if (wsStealHead != null && wsStealHead.find(fpOffset, catchBlock) != null) {
+              // This continuation has already been stolen, so we discard the current state. 
+              foundStolen = true;
+              break;
+            }
+            // This continuation has not been stolen, so we update info to reflect it.
+            if (!skip) {
+              finishIPOffset = currentIPOffset;
+              stealCBOffset = catchBlock;
+              stealFPOffset = fpOffset;
+              stealPrevFp = prevFp;
+              found++;
+              foundFinish = false;
+            }
+            skip = false;
+            // Advance into the catch block
+            currentIPOffset = catchBlock.plus(1);
+          }
+        }
 
-    VM.sysWriteln("Attempting to dump the stack of all other live threads");
-    VM.sysWriteln("This is somewhat risky since if the thread is running we're going to be quite confused");
-    for (int i = 0; i < numThreads; ++i) {
-      RVMThread thr = threads[i];
-      if (thr != null && thr != RVMThread.getCurrentThread() && thr.isAlive()) {
-        thr.dump();
-        // PNT: FIXME: this won't work so well since the context registers
-        // don't tend to have sane values
-        if (thr.contextRegisters != null && !thr.ignoreHandshakesAndGC())
-          dumpStack(thr.contextRegisters.getInnermostFramePointer());
+        // Search for an enclosing finish.
+        if (!foundFinish) {
+          Offset catchBlock = compiledMethod.findCatchBlockForInstruction(finishIPOffset, RVMType.WSFinishType, true);
+          if (catchBlock.sGE(Offset.zero())) {
+            // We found a finish block.
+            finishCBOffset = catchBlock;
+            finishFPOffset = fpOffset;
+            finishPrevFp = prevFp;
+            foundFinish = true;
+            if (foundStolen) {
+              // We know the continuation we are stealing, and we have found the first finish.
+              break;
+            }
+          }
+        }
       }
     }
-    getCurrentThread().enableYieldpoints();
-    Monitor.unlock(b, dumpLock);
-  }
-
-  public static Feedlet getCurrentFeedlet() {
-    return getCurrentThread().feedlet;
-  }
-
-  ////////////////////////// VM.countThreadTransitions support //////////////////////////
-
-  static final int[] sloppyExecStatusHistogram =
-    new int[LAST_EXEC_STATUS];
-  static final int[] statusAtSTWHistogram =
-    new int[LAST_EXEC_STATUS];
-  static final int[] execStatusTransitionHistogram =
-    new int[LAST_EXEC_STATUS * LAST_EXEC_STATUS];
-
-  public static void reportThreadTransitionCounts() {
-    VM.sysWriteln("Thread Transition Counts:");
-    dump1DHisto("Sloppy Exec Status Histogram",sloppyExecStatusHistogram);
-    dump1DHisto("Status At Stop-the-world Histogram",statusAtSTWHistogram);
-    VM.sysWriteln("  Exec Status Transition Histogram:");
-    for (int fromI = 0; fromI < LAST_EXEC_STATUS; ++fromI) {
-      for (int toI = 0; toI < LAST_EXEC_STATUS; ++toI) {
-        int val =
-          execStatusTransitionHistogram[
-            transitionHistogramIndex(fromI,toI)];
-        if (val != 0) {
-          VM.sysWriteln("    ",fromI,"->",toI," ",val);
-        }
+    registers.unwindStackFrame();
+    prevFp = fp;
+    fp = registers.getInnermostFramePointer();
+  }
+  if (found > 0) {
+    // Find the finish object to use.
+    if (foundFinish) {
+      // Look for an existing finish.
+      if (wsFinishHead != null) {
+        steal.finish = wsFinishHead.find(finishFPOffset, finishCBOffset);
       }
+      if (steal.finish == null) {
+        // We are the first to use this finish.
+        finish.set(finishFPOffset, finishCBOffset);
+        finish.setPrev(wsFinishHead);
+        steal.finish = finish;
+        wsFinishHead = finish;
+
+        WS.installJoinInstructions(top.minus(finishFPOffset), finishPrevFp);
+      }
+    } else {
+      // We must be delivering back to a parent finish.
+      steal.finish = wsFinishHead;
     }
+    WS.installJoinInstructions(top.minus(stealFPOffset), stealPrevFp);
+    steal.set(stealFPOffset, stealCBOffset);
+    steal.setPrev(wsStealHead);
+    wsStealHead = steal;
+    if (VM.VerifyAssertions) VM._assert(steal.finish != null);
   }
+  return found;
+}
 
-  static void dump1DHisto(String name,int[] histo) {
-    VM.sysWriteln("  ",name,":");
-    for (int i = 0; i < LAST_EXEC_STATUS; ++i) {
-      if (histo[i] != 0) {
-        VM.sysWriteln("    ",i," ",histo[i]);
+@UnpreemptibleNoWarn
+@Inline
+private Offset stackWalkToFindAbortExceptionOffset(AbstractRegisters registers) {
+  Address prevFp = Address.zero();
+  Address fp = registers.getInnermostFramePointer();
+
+  while (Magic.getCallerFramePointer(fp).NE(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+    int compiledMethodId = Magic.getCompiledMethodID(fp);
+    if (compiledMethodId != StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
+      CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+      if (compiledMethod.getCompilerType() == CompiledMethod.OPT || compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
+        Address ip = registers.getInnermostInstructionAddress();
+        Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+        Offset catchBlock = compiledMethod.findCatchBlockForInstruction(ipOffset, RVMType.WSAbortAtFailureType, true);
+        if (catchBlock.sGE(Offset.zero())) {
+          // We found a finish block.
+          return catchBlock;
+        }
       }
     }
+    registers.unwindStackFrame();
+    prevFp = fp;
+    fp = registers.getInnermostFramePointer();
   }
+  return Offset.zero();
+}
 
-  void observeExecStatus() {
-    sloppyExecStatusHistogram[execStatus]++;
+@UnpreemptibleNoWarn
+@Inline
+private void saveContinuation(final Address fp, final boolean mainStack) {
+  if(fpsInContList == RVMThread.ARRAY_OF_CONTINUATIONS_MAXSIZE) {
+    // reset index
+    fpsInContList = RVMThread.ON_OVERFLOW_RESTART_INDEX_IN_ARRAY_OF_CONTINUATIONS;
   }
+  final Address fpStore = mainStack ? getAddressValueOnMainStack(fp) : fp;
+  array_of_continuations.set(fpsInContList++, fpStore);
+}
 
-  public static void observeExecStatusAtSTW(int execStatus) {
-    statusAtSTWHistogram[execStatus]++;
+@UnpreemptibleNoWarn
+@Inline
+private int wsFindSteal_retBarrier(WS.StealInfo steal, WS.FinishInfo finish, Address top, boolean initiateStealFromBarrier, long startStealCPUCycles) {
+  Address fp = initiateStealFromBarrier ? getAddressValueOnClonedStack(hijackedReturnCallerFp) : this.contextRegisters.getInnermostFramePointer();
+  Address ip = initiateStealFromBarrier ? hijackedReturnAddress : this.contextRegisters.getInnermostInstructionAddress();
+
+  int found = 0;
+  boolean skip = wsInJoin;
+  Offset stealCBOffset = Offset.zero();
+  Offset stealFPOffset = Offset.zero();
+  Offset finishCBOffset = Offset.zero();
+  Offset finishFPOffset = Offset.zero();
+
+  Address stealPrevFp = initiateStealFromBarrier ? getAddressValueOnClonedStack(hijackedReturnCalleeFp) : Address.zero();
+
+  Address finishPrevFp = stealPrevFp;
+  Address prevFp = stealPrevFp;
+
+  boolean foundStolen = false;
+  boolean foundFinish = true;
+
+  Address prevJavaFrameFp = Address.zero();
+  boolean firstContinuationFound = false;
+  boolean barrierInstalled = false;
+
+  while (Magic.getCallerFramePointer(fp).NE(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+    final Offset fpOffset = top.diff(fp);
+    final int compiledMethodId = Magic.getCompiledMethodID(fp);
+    if (compiledMethodId != StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
+      final CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+      if (compiledMethod.getCompilerType() == CompiledMethod.OPT || compiledMethod.getCompilerType() == CompiledMethod.BASELINE) {
+        // Process each normal stack frame.
+        // First we search for the oldest unstolen continuation. Once we hit an already stolen continuation or reach the end we are done.
+        // We also need to know the enclosing finish block.
+        // We need to try and find the outermost finish block for each method to make sure. 
+        final Offset ipOffset = compiledMethod.getInstructionOffset(ip);	// it has debug info
+
+        Offset currentIPOffset = ipOffset;
+        Offset finishIPOffset = ipOffset;
+        // Search for a continuation to steal.
+        if (!foundStolen) {
+          while (true) {
+            final Offset catchBlock = compiledMethod.findCatchBlockForInstruction(currentIPOffset, RVMType.WSContinuationType, true);
+            if (catchBlock.sLT(Offset.zero())) break;
+            if (wsStealHead != null && wsStealHead.find(fpOffset, catchBlock) != null) {
+              // This continuation has already been stolen, so we discard the current state. 
+              foundStolen = true;
+              break;
+            }
+            // This continuation has not been stolen, so we update info to reflect it.
+            if (!skip) {
+              if(initiateStealFromBarrier) {
+                if(!prevJavaFrameFp.isZero()) {
+                  saveContinuation(prevJavaFrameFp, true);
+                }
+              }
+              else {
+                if(!prevJavaFrameFp.isZero() && firstContinuationFound) {
+                  saveContinuation(prevJavaFrameFp, false);
+                }
+                //install return barrier for the callee of the newest continuation on victim stack
+                else if(!prevJavaFrameFp.isZero() && !firstContinuationFound) {
+                  firstContinuationFound = true;
+                }
+              }
+              finishIPOffset = currentIPOffset;
+              stealCBOffset = catchBlock;
+              stealFPOffset = fpOffset;
+              stealPrevFp = prevFp;
+              found++;
+              foundFinish = false;
+            }
+            skip = false;
+            // Advance into the catch block
+            currentIPOffset = catchBlock.plus(1);
+          }
+        }
+
+        // Search for an enclosing finish.
+        if (!foundFinish) {
+          Offset catchBlock = compiledMethod.findCatchBlockForInstruction(finishIPOffset, RVMType.WSFinishType, true);
+          if (catchBlock.sGE(Offset.zero())) {
+            // We found a finish block.
+            finishCBOffset = catchBlock;
+            finishFPOffset = fpOffset;
+            finishPrevFp = prevFp;
+            foundFinish = true;
+          }
+        }
+        if(!initiateStealFromBarrier && firstContinuationFound && !barrierInstalled) {
+          final RVMThread me = getCurrentThread();
+          me.iInstalledABarrier = true;
+          barrierInstalled = true;
+          wsReturnBarrierUninstalled = false;
+          if(wsDebugTrace) {
+            VM.sysWriteln(getCurrentThread().getId(),": Cloning stack of W-",getId());
+          }
+          victimYieldFpOnNewStack = wsCloneVictimStack(this, this.contextRegisters.getInnermostFramePointer());
+          //keep a copy of the gprs obtained by stackwalk of only the topmost frame of this yielded victim
+          if(wsDebugTrace) {
+            VM.sysWriteln(getCurrentThread().getId(),": Going to install return barrier in W-",getId());
+          }
+          wsInstallStackTrampolineBridge(prevJavaFrameFp);
+          thiefInstalledBarriers++;
+          if(wsDebugTrace) {
+            VM.sysWriteln(getCurrentThread().getId(),": Installed rbarrier in W-",getId());
+          }
+          if(RVMThread.victimCanBeReleasedAfterRBarrierIsInstalled) {
+            endPairHandshake();
+          }
+          me.totalSuccessStealCPUCycles += (Magic.getTimeBase() - startStealCPUCycles);
+        }
+        prevJavaFrameFp = fp;
+        if(foundStolen && foundFinish) break;
+      }
+      else {
+        prevJavaFrameFp = Address.zero();
+      }
+    }
+    ip = RVMThread.getReturnAddress(fp);
+    prevFp = fp;
+    fp = Magic.getCallerFramePointer(prevFp);
   }
 
-  // FIXME: add histograms for states returned from various calls to block()
-  // currently we just do it for the block() call in GC STW.
+  if (found > 0) {
+    // Notify the victim to awake if its waiting inside return barrier
+    if(initiateStealFromBarrier || barrierInstalled) {
+      if(wsDebugTrace) {
+        VM.sysWriteln(getCurrentThread().getId(),": Send broadcast to release from barrier to W-",getId());
+      }
+      wsUnlockFromReturnBarrier();
+    }
 
-  static int transitionHistogramIndex(int oldState,int newState) {
-    return oldState + newState * LAST_EXEC_STATUS;
-  }
+    // Find the finish object to use.
+    if (foundFinish) {
+      // Look for an existing finish.
+      if (wsFinishHead != null) {
+        steal.finish = wsFinishHead.find(finishFPOffset, finishCBOffset);
+      }
+      if (steal.finish == null) {
+        // We are the first to use this finish.
+        finish.set(finishFPOffset, finishCBOffset);
+        finish.setPrev(wsFinishHead);
+        steal.finish = finish;
+        wsFinishHead = finish;
+        if (VM.VerifyAssertions) VM._assert(finishPrevFp.GE(stealPrevFp));	//return barrier
+        if(!initiateStealFromBarrier) WS.installJoinInstructions(top.minus(finishFPOffset), finishPrevFp, this);
+        else WS.installJoinInstructions(stackTop().minus(finishFPOffset), getAddressValueOnMainStack(finishPrevFp), this);
+      }
+    } else {
+      // We must be delivering back to a parent finish.
+      steal.finish = wsFinishHead;
+    }
+
+    if(!initiateStealFromBarrier) {
+      WS.installJoinInstructions(top.minus(stealFPOffset), stealPrevFp, this);
+      // install join instruction in the coloned stack as well
+      final Address retAddress = stealPrevFp.EQ(hijackedReturnCalleeFp) ? hijackedReturnAddress : RVMThread.getReturnAddress(stealPrevFp);
+      Magic.setReturnAddress(getAddressValueOnClonedStack(stealPrevFp), retAddress);
+      steal.set(stealFPOffset, stealCBOffset, stealPrevFp);
+    }
+    else {
+      final Address stealPrevFpOnMainStack = getAddressValueOnMainStack(stealPrevFp);
+      WS.installJoinInstructions(stackTop().minus(stealFPOffset), stealPrevFpOnMainStack, this);
+      final Address retAddress = stealPrevFpOnMainStack.EQ(hijackedReturnCalleeFp) ? hijackedReturnAddress : RVMThread.getReturnAddress(stealPrevFpOnMainStack);
+      Magic.setReturnAddress(stealPrevFp, retAddress);
+      steal.set(stealFPOffset, stealCBOffset, stealPrevFpOnMainStack);
+    }
 
-  static void observeStateTransition(int oldState,int newState) {
-    execStatusTransitionHistogram[transitionHistogramIndex(oldState,newState)]++;
-    sloppyExecStatusHistogram[oldState]++;
-    sloppyExecStatusHistogram[newState]++;
+    steal.setPrev(wsStealHead);
+    wsStealHead = steal;
+    if (VM.VerifyAssertions) VM._assert(steal.finish != null);
   }
+
+  return found;
+}
 }
diff --git a/rvm/src/org/jikesrvm/scheduler/StackFrameCopier.java b/rvm/src/org/jikesrvm/scheduler/StackFrameCopier.java
new file mode 100755
index 0000000..4cd2756
--- /dev/null
+++ b/rvm/src/org/jikesrvm/scheduler/StackFrameCopier.java
@@ -0,0 +1,235 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.jikesrvm.scheduler;
+
+import org.jikesrvm.ia32.StackframeLayoutConstants;
+import org.jikesrvm.architecture.AbstractRegisters;
+import org.jikesrvm.runtime.UnboxedSizeConstants;
+import org.jikesrvm.VM;
+import org.jikesrvm.compilers.common.CompiledMethod;
+import org.jikesrvm.compilers.common.CompiledMethods;
+import org.jikesrvm.ia32.RegisterConstants;
+import org.jikesrvm.mm.mminterface.GCMapIterator;
+import org.jikesrvm.mm.mminterface.GCMapIteratorGroup;
+import org.jikesrvm.mm.mminterface.MemoryManager;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.runtime.Memory;
+import org.jikesrvm.scheduler.RVMThread;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.NonMoving;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.pragma.Untraced;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.Offset;
+import org.vmmagic.unboxed.Word;
+import org.vmmagic.unboxed.WordArray;
+import org.jikesrvm.ia32.RegisterConstants;
+
+
+@NonMoving
+@Uninterruptible
+public final class StackFrameCopier {
+
+	/***********************************************************************
+	 *
+	 * Instance variables
+	 */
+	private final GCMapIteratorGroup iteratorGroup = new GCMapIteratorGroup();
+	@Untraced
+	private GCMapIterator iterator;
+
+	// Return Barrier Implementation
+	@Untraced
+	private final WordArray gprs_current = MemoryManager.newNonMovingWordArray(RegisterConstants.NUM_GPRS);
+
+	/***********************************************************************
+	 *
+	 * Thread scanning
+	 */
+
+	private void reinitializeStackIteratorGroup(RVMThread scanThread) {
+		if(RVMThread.wsDebugTrace) {
+			debugStackFrameProcessing = true;
+			debugScanFp = Address.zero();
+			debugScanIp = Address.zero();
+		}
+		for(int i=0; i<RegisterConstants.NUM_GPRS; i++) gprs_current.set(i, Word.zero());
+		Address gprs = Magic.objectAsAddress(gprs_current);
+		/* reinitialize the stack iterator group */
+		iteratorGroup.newStackWalk(scanThread, gprs);
+	}
+	
+	/**
+	 * A more general interface to thread scanning, which permits the
+	 * scanning of stack segments which are dislocated from the thread
+	 * structure.
+	 *
+	 * @param thread The thread to be scanned
+	 * @param gprs The general purpose registers associated with the
+	 * stack being scanned (normally extracted from the thread).
+	 * @param topFrame The top frame of the stack being scanned, or zero
+	 * if this is to be inferred from the thread (normally the case).
+	 */
+	protected void copyStack(Address fp, Address ip, RVMThread scanThread, RVMThread toThread, 
+			AbstractRegisters toRegs, Offset stealFPOffset, int count, Offset newStackOffset, Address scanTop) {
+		
+		/* reinitialize the stack iterator group */
+		reinitializeStackIteratorGroup(scanThread);
+		
+		/* Skip over the frames we do not want to copy */
+		Address prevFp = Address.zero();
+		while (true) {
+			Offset fpOffset = scanTop.diff(fp);
+			if (fpOffset.EQ(stealFPOffset)) {
+				if (toRegs != null) {
+					//toRegs.copyFrom(regs);
+					// TODO this doesn't deal with FPRs.
+					iteratorGroup.copyRegisterValues(Magic.objectAsAddress(toRegs.getGPRs()));
+					toRegs.setInnermost(ip, fp);
+				}
+				break;
+			}
+			if (Magic.getCallerFramePointer(fp).EQ(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+				VM.sysWriteln("Requested fp: ", stealFPOffset);
+				VM.sysWriteln("Should be FP: ", scanTop.minus(stealFPOffset));
+				VM.sysWriteln("Scan Top: ", scanTop);
+				VM.sysWriteln("Offset:   ", newStackOffset);
+				RVMThread.dumpStack(scanThread.getContextRegisters().getInnermostInstructionAddress(), scanThread.getContextRegisters().getInnermostFramePointer());
+				VM.sysFail("Could not find requested fp");
+			}
+			processFrame(newStackOffset, ip, fp);
+			ip = RVMThread.getReturnAddress(fp);
+			prevFp = fp;
+			fp = Magic.getCallerFramePointer(fp);
+		}
+
+		// Copy the initial part of this frame
+		Memory.alignedWordCopy(prevFp.plus(newStackOffset).plus(UnboxedSizeConstants.BYTES_IN_ADDRESS), prevFp.plus(UnboxedSizeConstants.BYTES_IN_ADDRESS), fp.diff(prevFp).toInt() - UnboxedSizeConstants.BYTES_IN_ADDRESS);
+		Magic.setCallerFramePointer(prevFp.plus(newStackOffset), fp.plus(newStackOffset));
+		while(true) {
+			Address nextFp = Magic.getCallerFramePointer(fp);
+
+			if (nextFp.EQ(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP) || count == 0) {
+				Magic.setCallerFramePointer(fp.plus(newStackOffset), StackframeLayoutConstants.STACKFRAME_SENTINEL_FP);
+				prevFp.plus(newStackOffset).store(Address.zero(), Offset.fromIntSignExtend(StackframeLayoutConstants.STACKFRAME_RETURN_ADDRESS_OFFSET.toInt()));
+				fp.plus(newStackOffset).store(StackframeLayoutConstants.INVISIBLE_METHOD_ID, Offset.fromIntSignExtend(StackframeLayoutConstants.STACKFRAME_METHOD_ID_OFFSET.toInt()));
+				break;
+			}
+
+			// Copy the rest of this frame
+			Memory.alignedWordCopy(fp.plus(newStackOffset).plus(UnboxedSizeConstants.BYTES_IN_ADDRESS), fp.plus(UnboxedSizeConstants.BYTES_IN_ADDRESS), nextFp.diff(prevFp).toInt() - UnboxedSizeConstants.BYTES_IN_ADDRESS);
+
+			// Fix up the frame pointer
+			Magic.setCallerFramePointer(fp.plus(newStackOffset), nextFp.plus(newStackOffset));
+
+			// Process the frame
+			processFrameAndUpdateThread(scanThread, toThread, newStackOffset, ip, fp);
+			count--;
+
+			// Move on to the next frame
+			ip = RVMThread.getReturnAddress(fp);
+			prevFp = fp;
+			fp = nextFp;
+		}
+
+		if(false) {
+			int stolenNVMap = 0;
+			int seenNV = 0;
+			int targetNV = 0;
+			for (int i=0; i< RegisterConstants.NONVOLATILE_GPRS.length; i++) {
+				targetNV |= (1 << RegisterConstants.NONVOLATILE_GPRS[i].value());
+			}
+
+			while (Magic.getCallerFramePointer(fp).NE(StackframeLayoutConstants.STACKFRAME_SENTINEL_FP)) {
+				/* set up iterators etc, and skip the frame if appropriate */
+				int compiledMethodId = Magic.getCompiledMethodID(fp);
+				if (compiledMethodId != StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
+					/* establish the compiled method */
+					CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+
+					/* get the code associated with this frame */
+					Offset offset = compiledMethod.getInstructionOffset(ip);
+
+					/* initialize MapIterator for this frame */
+					iterator = iteratorGroup.selectIterator(compiledMethod);
+					iterator.setupIterator(compiledMethod, offset, fp);
+
+					int nvObjectMap = iterator.getNVObjectMap();
+					int nvSaved = iterator.getNVRegistersSaved();
+					iterator.cleanupPointers();
+
+					stolenNVMap |= (~seenNV & nvObjectMap);
+					seenNV |= nvSaved | nvObjectMap;
+
+					if (seenNV == targetNV) {
+						break;
+					}
+				}
+				// Move on to the next frame
+				ip = RVMThread.getReturnAddress(fp);
+				fp = Magic.getCallerFramePointer(fp);
+			}
+			toThread.wsSpecialNVMap = stolenNVMap;
+			for(int i=0; i < RegisterConstants.NONVOLATILE_GPRS.length; i++) {
+				int reg = RegisterConstants.NONVOLATILE_GPRS[i].value();
+				if ((toThread.wsSpecialNVMap & (1 << reg)) != 0) {
+					Address refaddr = iteratorGroup.getRegisterLocation(reg);
+					if (Magic.addressAsObject(refaddr.loadAddress()) == scanThread) {
+						refaddr.store(Magic.objectAsAddress(toThread), newStackOffset);
+					}
+				}
+			}
+		}
+		debugStackFrameProcessing = false;
+	}
+
+	protected void processFrame(Offset stackOffset, Address ip, Address fp) {
+		processFrameAndUpdateThread(null, null, stackOffset, ip, fp);
+	}
+
+	protected Address debugScanFp = Address.zero();
+	protected Address debugScanIp = Address.zero();
+	protected boolean debugStackFrameProcessing = false;
+	
+	private void processFrameAndUpdateThread(RVMThread oldThread, RVMThread newThread, Offset stackOffset, Address ip, Address fp) {
+		if(RVMThread.wsDebugTrace) {
+			debugScanFp = fp;
+			debugScanIp = ip;
+		}
+		/* set up iterators etc, and skip the frame if appropriate */
+		int compiledMethodId = Magic.getCompiledMethodID(fp);
+		if (compiledMethodId != StackframeLayoutConstants.INVISIBLE_METHOD_ID) {
+			/* establish the compiled method */
+			CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+
+			/* get the code associated with this frame */
+			Offset offset = compiledMethod.getInstructionOffset(ip);
+
+			/* initialize MapIterator for this frame */
+			if(RVMThread.wsDebugTrace) {
+				VM.sysWriteln(RVMThread.getCurrentThread().getId(),": starting processing frame ", fp);
+			}
+			iterator = iteratorGroup.selectIterator(compiledMethod);
+			iterator.setupIterator(compiledMethod, offset, fp);
+
+			/* scan the frame for object pointers */
+			for (Address refaddr = iterator.getNextReferenceAddress(); !refaddr.isZero(); refaddr = iterator.getNextReferenceAddress()) {
+				if (oldThread != null && Magic.addressAsObject(refaddr.loadAddress()) == oldThread) {
+					refaddr.store(Magic.objectAsAddress(newThread), stackOffset);
+				}
+			}
+
+			iterator.cleanupPointers();
+		}
+	}
+}
diff --git a/rvm/src/org/jikesrvm/scheduler/WS.java b/rvm/src/org/jikesrvm/scheduler/WS.java
new file mode 100755
index 0000000..d7e846d
--- /dev/null
+++ b/rvm/src/org/jikesrvm/scheduler/WS.java
@@ -0,0 +1,793 @@
+
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.jikesrvm.scheduler;
+
+/*
+ * Authors: Vivek Kumar, Daniel Frampton
+ */
+
+import static org.jikesrvm.runtime.SysCall.sysCall;
+
+import java.util.Iterator;
+import java.util.Random;
+import java.util.Set;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.TreeSet;
+import java.io.Closeable;
+
+import org.jikesrvm.VM;
+import org.jikesrvm.classloader.RVMType;
+import org.jikesrvm.compilers.common.CompiledMethod;
+import org.jikesrvm.compilers.common.CompiledMethods;
+import org.jikesrvm.objectmodel.ObjectModel;
+import org.jikesrvm.runtime.Entrypoints;
+import org.jikesrvm.runtime.Magic;
+import org.jikesrvm.runtime.RuntimeEntrypoints;
+import org.vmmagic.pragma.Inline;
+import org.vmmagic.pragma.Interruptible;
+import org.vmmagic.pragma.NoInline;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.pragma.UninterruptibleNoWarn;
+import org.vmmagic.pragma.Unpreemptible;
+import org.vmmagic.pragma.UnpreemptibleNoWarn;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.Offset;
+import org.mmtk.utility.statistics.EventCounter;
+import org.jikesrvm.ia32.StackframeLayoutConstants;
+
+/**
+ * Work stealing support class
+ */
+@Uninterruptible
+public class WS {
+  private static final int MAX_WORKERS = 32;
+
+  private static boolean initialized = false;
+  protected static volatile int numWorkers = 0;
+  public static int wsProcs = 1; 
+  private static volatile boolean terminate = false;
+  protected static int[] workers = null;
+  public static boolean stats = false;
+
+  public static boolean wsInitialized() {
+    return initialized;
+  }
+
+  /*
+   * In a big project (eg. JMetal) a work-stealing method
+   * may be called from several places i.e. several other methods.
+   * If there is a case where a method foo() calls some work-stealing
+   * method under a synchronized block, then there is no meaning of performing 
+   * work-stealing from this block. In such case it may also lead to deadlock
+   * To avoid this, we temporarily switch OFF the work-stealing on current thread
+   * if its calling work-stealing inside a synchronized block. 
+   */
+  @Inline
+  public static void pauseStealOnThread() {
+    final RVMThread me = RVMThread.getCurrentThread();
+    if(me.wsThread) {
+      if(me.wsSynchronizationLock == 0) {
+        me.wsLock().lockNoHandshake();
+        if(!me.workstealingInProgress) {
+          me.workstealingInProgress = true;
+          me.wsSynchronizationLock++;					
+        }
+        me.wsLock().unlock();
+      }
+    }
+  }
+
+  // Switch ON work-stealing once the synchronized block
+  // is done
+  @Inline
+  public static void resumeStealOnThread() {
+    final RVMThread me = RVMThread.getCurrentThread();
+    if(me.wsThread) {
+      if(me.wsSynchronizationLock > 0) {
+        me.wsSynchronizationLock--;
+        if(me.wsSynchronizationLock == 0) {
+          me.wsLock().lockNoHandshake();
+          me.workstealingInProgress = false;
+          me.wsLock().unlock();
+          me.checkAbortFlagAndRespond();
+        }
+      }
+    }
+  }
+
+  // Thread pinning only
+  public static boolean pinLog = false;
+
+  private final static EventCounter wsSuccessStealCycles = new EventCounter("wsSuccessStealCycles", true, true);
+  private final static EventCounter wsFailedStealCycles = new EventCounter("wsFailedStealCycles", true, true);
+  private final static EventCounter wsBarrierCycles = new EventCounter("wsBarrierCycles", true, true);
+  private final static EventCounter wsThiefInstalledRBarriers = new EventCounter("wsThiefInstalledRBarriers", true, true);
+  private final static EventCounter wsPreInstalledRBarriers = new EventCounter("wsPreInstalledRBarriers", true, true);
+  private final static EventCounter wsFailedSteals = new EventCounter("wsFailedSteals", true, true);
+  private final static EventCounter wsThreads = new EventCounter("wsThreads", true, true);
+  private final static EventCounter wsTasksPushed = new EventCounter("wsTasksPushed", true, true);
+  private final static EventCounter wsSuccessSteals = new EventCounter("wsSuccessSteals", true, true);
+
+  private final static EventCounter wsTasksEQ2 = RVMThread.createContinuationDistribution ? new EventCounter("wsTasksEQ2", true, true) : null; 
+  private final static EventCounter wsTasksLE4 = RVMThread.createContinuationDistribution ? new EventCounter("wsTasksLE4", true, true) : null;
+  private final static EventCounter wsTasksGT4 = RVMThread.createContinuationDistribution ? new EventCounter("wsTasksGT4", true, true) : null;
+
+  public static void updateStealRatioExternally(int steals, int pushes) {
+    wsSuccessSteals.wsInc(steals);
+    wsTasksPushed.wsInc(pushes);
+    RVMThread.pin_core_index = 0;
+  }
+
+  public static void launchedFromX10(int procs) {
+    wsProcs = procs;
+    RVMThread.autogenWSThread = true;
+    RVMThread.wsThreadsLaunched = true;
+  }
+
+  @Interruptible
+  public synchronized static void register() {
+    final RVMThread me = RVMThread.getCurrentThread();
+    me.wsThread = true;
+    me.workstealingInProgress = false;
+    me.perfEventGroup = RVMThread.PERF_EVENT_GROUP_WS;
+    if (!initialized) {
+      initialized = true;
+      workers = new int[MAX_WORKERS];
+    }
+    int slot = me.getThreadSlot();
+    me.wsRand = new Random();
+    me.ws_id = numWorkers;
+    workers[numWorkers++] = slot;
+    if(RVMThread.wsRetBarrier) {
+      me.wsCheckShadowStack_retbarrier(me);
+    }
+    if(pinLog){
+      VM.sysWriteln("[PIN_INFO] W-",me.ws_id, " is on cpuid-",sysCall.sysGetCPU());
+    }
+  }
+
+  // can be used to verify the result
+  public static long wsTotalPush() {
+    long totalPushes= 0;
+    for(int i=0; i < numWorkers; i++){
+      totalPushes += RVMThread.threadBySlot[workers[i]].pushes;
+    }
+    return totalPushes;
+  }
+
+  public static void terminate() {
+    if(pinLog){
+      VM.sysWriteln("[PIN_INFO] W-",RVMThread.getCurrentThread().ws_id, " is on cpuid-",sysCall.sysGetCPU());
+    }
+    terminate = true;
+  }
+
+  @UninterruptibleNoWarn
+  public static void dumpWSStatistics() {
+    int steals = 0;
+    int totalFindAttempts = 0;
+    long totalPushes = 0;
+    long successStealCPUCycles = 0;
+    long failedStealCPUCycles = 0;
+    long totalThiefInstalledBarriers = 0;
+    long totalPreInstalledBarriers = 0;
+    long barrierCPUCycles = 0;
+
+    long tasksEQ2 = 0;	// tasks <= 2
+    long tasksLE4 = 0;	// tasks <= 4
+    long tasksGT4 = 0;	// tasks <= 8
+
+    for(int i=0; i < numWorkers; i++){
+      steals += RVMThread.threadBySlot[workers[i]].totalSteals;
+      RVMThread.threadBySlot[workers[i]].totalSteals = 0;
+      totalFindAttempts += RVMThread.threadBySlot[workers[i]].findAttempts;
+      RVMThread.threadBySlot[workers[i]].findAttempts = 0;
+      totalPushes += RVMThread.threadBySlot[workers[i]].pushes;
+      RVMThread.threadBySlot[workers[i]].pushes = 0;
+      successStealCPUCycles += RVMThread.threadBySlot[workers[i]].totalSuccessStealCPUCycles;
+      RVMThread.threadBySlot[workers[i]].totalSuccessStealCPUCycles = 0;
+      failedStealCPUCycles += RVMThread.threadBySlot[workers[i]].totalFailedStealCPUCycles;
+      RVMThread.threadBySlot[workers[i]].totalFailedStealCPUCycles = 0;
+      barrierCPUCycles += RVMThread.threadBySlot[workers[i]].totalBarrierCPUCycles;
+      RVMThread.threadBySlot[workers[i]].totalBarrierCPUCycles = 0;
+      totalThiefInstalledBarriers += RVMThread.threadBySlot[workers[i]].thiefInstalledBarriers;
+      RVMThread.threadBySlot[workers[i]].thiefInstalledBarriers = 0;
+      totalPreInstalledBarriers += RVMThread.threadBySlot[workers[i]].preInstalledBarriers;
+      RVMThread.threadBySlot[workers[i]].preInstalledBarriers = 0;
+      if(RVMThread.createContinuationDistribution) {
+        tasksEQ2 += RVMThread.threadBySlot[workers[i]].tasksEQ2;
+        RVMThread.threadBySlot[workers[i]].tasksEQ2 = 0;
+        tasksLE4 += RVMThread.threadBySlot[workers[i]].tasksLE4;
+        RVMThread.threadBySlot[workers[i]].tasksLE4 = 0;
+        tasksGT4 += RVMThread.threadBySlot[workers[i]].tasksGT4;
+        RVMThread.threadBySlot[workers[i]].tasksGT4 = 0;
+      }
+      // trace pinning info
+      if(pinLog) RVMThread.threadBySlot[workers[i]].trace_cpuid = true;
+    }
+
+    // summarize MMTk statistics
+    wsSuccessSteals.wsInc(steals);
+    wsTasksPushed.wsInc(totalPushes);
+    final int failedSteals = totalFindAttempts - steals;
+    wsFailedSteals.wsInc(failedSteals);
+    wsSuccessStealCycles.wsInc(successStealCPUCycles);
+    wsFailedStealCycles.wsInc(failedStealCPUCycles);
+    wsBarrierCycles.wsInc(barrierCPUCycles);
+    wsThiefInstalledRBarriers.wsInc(totalThiefInstalledBarriers);
+    wsPreInstalledRBarriers.wsInc(totalPreInstalledBarriers);
+    if(RVMThread.createContinuationDistribution) {
+      wsTasksEQ2.wsInc(tasksEQ2);
+      wsTasksLE4.wsInc(tasksLE4);
+      wsTasksGT4.wsInc(tasksGT4);
+    }
+
+    // print logs for this iteration
+
+    VM.sysWrite("Statistics: ");
+    VM.sysWrite("Total Pushes = ",totalPushes);
+    VM.sysWrite(" Total SuccessfulSteals = ",steals);
+    VM.sysWrite(" Total SuccessStealCPUCycles = ",successStealCPUCycles);
+    VM.sysWrite(" Total FailedSteals = ",failedSteals);
+    VM.sysWrite(" Total FailedStealCPUCycles = ",failedStealCPUCycles);
+    VM.sysWrite(" Total BarrierCPUCycles = ",barrierCPUCycles);
+    VM.sysWrite(" Total ThiefInstalledBarriers = ",totalThiefInstalledBarriers);
+    VM.sysWrite(" Total PreInstalledBarriers = ",totalPreInstalledBarriers);
+
+    VM.sysWriteln();
+  }
+
+  public static void harnessBegin() {
+    if(!RVMThread.autogenWSThread) return;
+    for(int i=0; i < numWorkers; i++){
+      RVMThread.threadBySlot[workers[i]].totalSteals = 0;
+      RVMThread.threadBySlot[workers[i]].findAttempts = 0;
+      RVMThread.threadBySlot[workers[i]].pushes = 0;
+      RVMThread.threadBySlot[workers[i]].totalSuccessStealCPUCycles = 0;
+      RVMThread.threadBySlot[workers[i]].totalFailedStealCPUCycles = 0;
+      RVMThread.threadBySlot[workers[i]].totalBarrierCPUCycles = 0;
+      RVMThread.threadBySlot[workers[i]].thiefInstalledBarriers = 0;
+      RVMThread.threadBySlot[workers[i]].preInstalledBarriers = 0;
+      if(RVMThread.createContinuationDistribution) {
+        RVMThread.threadBySlot[workers[i]].tasksEQ2 = 0;
+        RVMThread.threadBySlot[workers[i]].tasksLE4 = 0;
+        RVMThread.threadBySlot[workers[i]].tasksGT4 = 0;
+      }
+    }
+  }
+
+  @UninterruptibleNoWarn
+  public static void harnessEnd() {
+    if(!RVMThread.autogenWSThread) return;
+    int steals = 0;
+    int totalFindAttempts = 0;
+    long totalPushes = 0;
+    long successStealCPUCycles = 0;
+    long failedStealCPUCycles = 0;
+    long barrierCPUCycles = 0;
+    long totalThiefInstalledBarriers = 0;
+    long totalPreInstalledBarriers = 0;
+    long tasksEQ2 = 0;	// tasks <= 2
+    long tasksLE4 = 0;	// tasks <= 4
+    long tasksGT4 = 0;	// tasks <= 8
+
+    for(int i=0; i < numWorkers; i++){
+      steals += RVMThread.threadBySlot[workers[i]].totalSteals;
+      RVMThread.threadBySlot[workers[i]].totalSteals = 0;
+      totalFindAttempts += RVMThread.threadBySlot[workers[i]].findAttempts;
+      RVMThread.threadBySlot[workers[i]].findAttempts = 0;
+      totalPushes += RVMThread.threadBySlot[workers[i]].pushes;
+      RVMThread.threadBySlot[workers[i]].pushes = 0;
+      successStealCPUCycles += RVMThread.threadBySlot[workers[i]].totalSuccessStealCPUCycles;
+      RVMThread.threadBySlot[workers[i]].totalSuccessStealCPUCycles = 0;
+      failedStealCPUCycles += RVMThread.threadBySlot[workers[i]].totalFailedStealCPUCycles;
+      RVMThread.threadBySlot[workers[i]].totalFailedStealCPUCycles = 0;
+      barrierCPUCycles += RVMThread.threadBySlot[workers[i]].totalBarrierCPUCycles;
+      RVMThread.threadBySlot[workers[i]].totalBarrierCPUCycles = 0;
+      totalThiefInstalledBarriers += RVMThread.threadBySlot[workers[i]].thiefInstalledBarriers;
+      RVMThread.threadBySlot[workers[i]].thiefInstalledBarriers = 0;
+      totalPreInstalledBarriers += RVMThread.threadBySlot[workers[i]].preInstalledBarriers;
+      RVMThread.threadBySlot[workers[i]].preInstalledBarriers = 0;
+      if(RVMThread.createContinuationDistribution) {
+        tasksEQ2 += RVMThread.threadBySlot[workers[i]].tasksEQ2;
+        RVMThread.threadBySlot[workers[i]].tasksEQ2 = 0;
+        tasksLE4 += RVMThread.threadBySlot[workers[i]].tasksLE4;
+        RVMThread.threadBySlot[workers[i]].tasksLE4 = 0;
+        tasksGT4 += RVMThread.threadBySlot[workers[i]].tasksGT4;
+        RVMThread.threadBySlot[workers[i]].tasksGT4 = 0;
+      }
+    }
+
+    // summarize MMTk statistics
+    wsSuccessSteals.wsInc(steals);
+    wsTasksPushed.wsInc(totalPushes);
+    final int failedSteals = totalFindAttempts - steals;
+    wsFailedSteals.wsInc(failedSteals);
+    wsSuccessStealCycles.wsInc(successStealCPUCycles);
+    wsFailedStealCycles.wsInc(failedStealCPUCycles);
+    wsThreads.wsInc(numWorkers);
+    wsBarrierCycles.wsInc(barrierCPUCycles);
+    wsThiefInstalledRBarriers.wsInc(totalThiefInstalledBarriers);
+    wsPreInstalledRBarriers.wsInc(totalPreInstalledBarriers);
+    if(RVMThread.createContinuationDistribution) {
+      wsTasksEQ2.wsInc(tasksEQ2);
+      wsTasksLE4.wsInc(tasksLE4);
+      wsTasksGT4.wsInc(tasksGT4);
+    }
+  }
+
+  @Interruptible
+  public static void workerMain() {
+    register();
+    RVMThread.getCurrentThread().wsFlag = false;
+    if(RVMThread.wsRetBarrier) {
+      searchForWork_retbarrier();
+    }
+    else {
+      searchForWork();
+    }
+  }
+
+  @Inline
+  public static void setFlag() {
+    final RVMThread me = RVMThread.getCurrentThread();
+    me.pushes++;
+    me.wsFlag = true;
+  }
+
+  @NoInline
+  @Unpreemptible
+  public static void join() {
+    // Find our caller
+    Address fp = Magic.getCallerFramePointer(Magic.getFramePointer());
+    Address ip = Magic.getReturnAddress(Magic.getFramePointer());
+    RVMThread.getCurrentThread().wsJoinInternal(fp, ip);
+  }
+
+  @Inline
+  @Unpreemptible
+  public static void completeJoin() {
+    RVMThread.getCurrentThread().wsCompleteJoinInternal();
+  }
+
+  @Inline
+  @Unpreemptible
+  public static void completeFinishFirst() {
+    RVMThread.getCurrentThread().wsCompleteFinishInternal();
+  }
+
+
+  @NoInline
+  @Unpreemptible
+  public static void finish() {
+    // Find our caller
+    Address fp = Magic.getCallerFramePointer(Magic.getFramePointer());
+    Address ip = Magic.getReturnAddress(Magic.getFramePointer());
+
+    RVMThread t = RVMThread.getCurrentThread();
+    FinishInfo finish = t.wsFinishHead;
+
+    if (finish != null) {
+      if (VM.VerifyAssertions) VM._assert(!finish.done);
+      int compiledMethodId = Magic.getCompiledMethodID(fp);
+      CompiledMethod compiledMethod = CompiledMethods.getCompiledMethod(compiledMethodId);
+      Offset fpOffset = t.stackTop().diff(fp);
+      Offset ipOffset = compiledMethod.getInstructionOffset(ip);
+      Offset cbOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, RVMType.WSFinishType, true);
+
+      if (finish.matches(fpOffset, cbOffset)) {
+        ObjectModel.genericLock_internal(finish);
+        finish.waiting = true;
+        boolean done = finish.done = (finish.count == 0);
+        if (done) {
+          ObjectModel.genericUnlock_internal(finish);
+          t.wsFinishHead = finish.prev();
+          if (finish.data != null) {
+            t.wsFinish.data = finish;
+            RuntimeEntrypoints.athrow(t.wsFinish);
+          }
+        } else {
+          finish.steal = t.wsStealHead;
+          cbOffset = compiledMethod.findCatchBlockForInstruction(ipOffset, RVMType.WSFinishFirstType, true);
+          if (cbOffset.sGE(Offset.zero())) {
+            // We want to return data from outside asyncs to a finish.
+            t.wsInJoin = true;
+            t.wsFinishFirst.finish = finish;
+            RuntimeEntrypoints.athrow(t.wsFinishFirst);
+          }
+          t.wsCompleteFinishInternal();
+          // Not reached
+        }
+      }
+    }
+  }
+
+  @Uninterruptible
+  protected static void incFinish(FinishInfo finish) {
+    int old; 
+    do {
+      old = Magic.prepareInt(finish, Entrypoints.wsFinishCountField.getOffset());
+    } while (!Magic.attemptInt(finish, Entrypoints.wsFinishCountField.getOffset(), old, old+1));
+  }
+
+  @Unpreemptible
+  protected static boolean decFinish(FinishInfo finish) {
+    int old; 
+    do {
+      old = Magic.prepareInt(finish, Entrypoints.wsFinishCountField.getOffset());
+    } while (!Magic.attemptInt(finish, Entrypoints.wsFinishCountField.getOffset(), old, old-1));
+    if (old == 1) {
+      ObjectModel.genericLock_internal(finish);
+      if (finish.waiting && !finish.done) {
+        finish.done = true;
+        ObjectModel.genericUnlock_internal(finish);
+        return true;
+      }
+      ObjectModel.genericUnlock_internal(finish);
+    }
+    return false;
+  }
+
+
+
+  /*
+   * Never sleep while searching a victim.
+   * Thieves always keep spinning
+   */
+  @UnpreemptibleNoWarn
+  @NoInline
+  protected static void searchForWork() {
+    final RVMThread me = RVMThread.getCurrentThread();
+    me.setWorkerAsThief();
+    me.resetWSDatastructure();
+    // trace pin info
+    if(me.trace_cpuid && pinLog) {
+      me.trace_cpuid = false;
+      VM.sysWriteln("[PIN_INFO] W-",me.ws_id, " is on cpuid-",sysCall.sysGetCPU());
+    }
+    Address fp = Magic.getFramePointer();
+    Address callerFp = Magic.getCallerFramePointer(fp);
+    Magic.setReturnAddress(callerFp, Address.zero());
+    Magic.setCallerFramePointer(callerFp, StackframeLayoutConstants.STACKFRAME_SENTINEL_FP);
+    Random rand = me.wsRand;
+    while (!terminate) {
+      int n = rand.nextInt(numWorkers);
+      RVMThread victim = RVMThread.threadBySlot[workers[n]];
+      if (!terminate && victim != null && victim.wsFlag && !victim.workstealingInProgress) {
+        // thread possibly has work
+        RVMThread.wsSteal(victim);
+      }
+    }
+    me.terminate();
+  }
+
+  @UnpreemptibleNoWarn
+  @NoInline
+  protected static void searchForWork_retbarrier() {
+    final RVMThread me = RVMThread.getCurrentThread();
+    // trace pin info
+    if(me.trace_cpuid && pinLog) {
+      me.trace_cpuid = false;
+      VM.sysWriteln("[PIN_INFO] W-",me.ws_id, " is on cpuid-",sysCall.sysGetCPU());
+    }
+    if(RVMThread.wsDebugTrace) {
+      VM.sysWriteln(me.getId(),": Searching for Work..");
+    }
+    Address fp = Magic.getFramePointer();
+    Address callerFp = Magic.getCallerFramePointer(fp);
+    Magic.setReturnAddress(callerFp, Address.zero());
+    Magic.setCallerFramePointer(callerFp, StackframeLayoutConstants.STACKFRAME_SENTINEL_FP);
+    Random rand = me.wsRand;
+    while (!terminate) {
+      int n = rand.nextInt(numWorkers);
+      RVMThread victim = RVMThread.threadBySlot[workers[n]];
+      if (!terminate && victim != null && victim.wsFlag && !victim.workstealingInProgress) {
+        // thread possibly has work
+        RVMThread.wsSteal_retbarrier(victim);
+      }
+    }
+    me.terminate();
+  }
+
+  private final static boolean abort_debug = false;
+  
+  private final static Set<Closeable> closeableObjects = new TreeSet<Closeable>();
+  @Uninterruptible
+  public static void addCloseable(Closeable object) {
+    VM.sysFail("WS.addCloseable is currently disabled");
+    closeableObjects.add(object);
+  }
+  @Uninterruptible
+  public static void applyCloseable() {
+    VM.sysFail("WS.applyCloseable is currently disabled");
+    Iterator<Closeable> itr = closeableObjects.iterator();
+    while(itr.hasNext()) {
+      Closeable c = itr.next();
+      try {
+        c.close();
+      } catch(java.io.IOException e){ }
+    }
+    closeableObjects.clear();
+  }
+
+  @Inline
+  protected static void printMSG(String str) {
+    if(abort_debug) VM.sysWriteln(RVMThread.getCurrentThread().getName()+": "+str);
+  }
+
+  @Uninterruptible
+  @Inline
+  public static synchronized void allocateFinishAbort() {
+    RVMThread.getCurrentThread().start_new_finish_abort();
+  }
+
+  @UnpreemptibleNoWarn
+  @NoInline
+  public static void wsAcceptAbortAtSuccess() {
+    RVMThread me = RVMThread.getCurrentThread();
+    // 3. Reset data structures
+    printMSG("caught AbortOnSuccess");
+    // 2. Reset aborting status
+    me.wait_finish_abort();
+    printMSG("All threads aborted");
+    me.resetWSDatastructure();
+    // 1. Enable stealing across all workers
+    for(int i=0; i < numWorkers; i++){
+      RVMThread worker = RVMThread.threadBySlot[workers[i]];
+      worker.canAbortIfRequired();
+    }
+    printMSG("All steals enabled");
+    // 1. Enable stealing across all workers
+    // 4. Continue executing the user application
+  }
+
+  @UnpreemptibleNoWarn
+  @NoInline
+  public static void wsAcceptAbortAtFailure() {
+    RVMThread.getCurrentThread().decrement_finish_abort_joins();
+    printMSG("going to be thief");
+    searchForWork();
+  }
+
+  @UnpreemptibleNoWarn
+  @NoInline
+  public static void abort() {
+    RVMThread me = RVMThread.getCurrentThread();
+    if(me.checkIfAbortAlreadyInitiated()) return;
+    printMSG("Initiating abort");
+    // 2. disable work-stealing across all workers, but first on self
+    me.wsFlag = false;
+    printMSG("disabling steal");
+    for(int i=0; i < numWorkers; i++){
+      RVMThread worker = RVMThread.threadBySlot[workers[i]];
+      while(!worker.tryDisableStealing());
+      printMSG("steal stopped on "+worker.getName());
+    }
+    for(int i=0; i < numWorkers; i++){
+      RVMThread worker = RVMThread.threadBySlot[workers[i]];
+      if(worker != me) {
+        // 3a. Yield this worker and check if this worker is a victim
+        printMSG("attempting to pair with "+worker.getName());
+        worker.beginPairHandshake();
+        if(!worker.checkIfWorkerIsThief() && me.finishScopeMatches(worker)) {
+          //worker.wsFlag = false;
+          worker.yieldToThrowAbortAtFailure = true;
+          me.increment_finish_abort_joins();
+          printMSG("Installed AbortOnFailure on "+worker.getName());
+        }
+        else {
+          worker.yieldToDumpStack = true;
+        }
+        worker.endPairHandshake();
+        printMSG("DONE pair with "+worker.getName());
+      }
+    }
+    // 5. Now I will throw AbortAtSuccess
+    printMSG("Going to throw AbortOnSuccess");
+    RuntimeEntrypoints.athrow(me.wsAbortAtSuccess);
+  }
+
+  @Uninterruptible
+  protected static abstract class Info {
+
+    protected Offset cbOffset;
+    /**
+     * fp offsets are from the base of the stack, so larger offsets mean more recently executed methods.
+     */
+    protected Offset fpOffset;
+
+    protected abstract Info prev();
+
+    protected void set(Offset fpOffset, Offset cbOffset) {
+      this.fpOffset = fpOffset;
+      this.cbOffset = cbOffset;
+    }
+
+    protected boolean newerThan(Offset fpOffset) {
+      return this.fpOffset.sGT(fpOffset);
+    }
+
+    protected boolean newerThan(Info other) {
+      return this.fpOffset.sGT(other.fpOffset);
+    }
+
+    protected boolean olderThan(Offset fpOffset) {
+      return this.fpOffset.sLT(fpOffset);
+    }
+
+    protected boolean olderThan(Info other) {
+      return this.fpOffset.sLT(other.fpOffset);
+    }
+
+    protected boolean matches(Offset fpOffset) {
+      return fpOffset.EQ(this.fpOffset);
+    }
+
+    protected boolean matches(Offset fpOffset, Offset cbOffset) {
+      return fpOffset.EQ(this.fpOffset) && cbOffset.EQ(this.cbOffset);
+    }
+
+    protected Info find(Offset fpOffset, Offset cbOffset) {
+      Info current = this;
+      while (current != null && current.newerThan(fpOffset)) {
+        current = current.prev();
+      }
+      while (current != null && current.matches(fpOffset)) {
+        if (current.matches(fpOffset, cbOffset)) {
+          return current;
+        }
+        current = current.prev();
+      }
+      return null;
+    }
+
+    protected void dump() {
+      Info current = this;
+      while (current != null) {
+        VM.sysWriteln(fpOffset, " at ", cbOffset);
+        current = current.prev();
+      }
+    }
+  }
+
+  @Uninterruptible
+  public static class FinishInfo extends Info implements Iterable<WS.FinishData> {
+    private FinishInfo prev;
+    private volatile boolean waiting;
+    private volatile int count;
+    private volatile FinishData data;
+    private volatile boolean done;
+    protected FinishInfo prev() { return prev; }
+    protected void setPrev(FinishInfo prev) { this.prev = prev; }
+
+    protected FinishInfo find(Offset fpOffset, Offset cbOffset) {
+      return (FinishInfo)super.find(fpOffset, cbOffset);
+    }
+
+    @Interruptible
+    public Iterator<FinishData> iterator() {
+      return new FinishIterator(data);
+    }
+
+    private static class FinishIterator implements Iterator<FinishData> {
+      private FinishData current;
+
+      FinishIterator(FinishData head) {
+        current = head;
+      }
+
+      public boolean hasNext() {
+        return current != null;
+      }
+
+      public FinishData next() {
+        FinishData result = current;
+        current = current.next;
+        return result;
+      }
+
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    }
+
+    @Interruptible
+    public void addData(int key, Object value) {
+      FinishData newHead = new FinishData(key, value);
+      FinishData oldHead;
+      do {
+        oldHead = data;
+        newHead.next = oldHead;
+      } while (!Synchronization.tryCompareAndSwap(this, Entrypoints.wsFinishDataField.getOffset(), oldHead, newHead));
+    }
+    public StealInfo steal;
+  }
+
+  public final static class FinishData {
+    public FinishData(int key, Object value) {
+      this.key = key;
+      this.value = value;
+    }
+    public final int key;
+    public final Object value;
+    protected FinishData next;
+  }
+
+  @Uninterruptible
+  protected static class StealInfo extends Info {
+    private StealInfo prev;
+    protected FinishInfo finish;
+    protected Address joinInstInstalledFP;
+
+    protected void set(Offset fpOffset, Offset cbOffset, Address joinInstInstalledFP) {
+      this.joinInstInstalledFP = joinInstInstalledFP;
+      super.set(fpOffset, cbOffset);
+    }
+    protected StealInfo prev() { return prev; }
+    protected void setPrev(StealInfo prev) { this.prev = prev; }
+    protected StealInfo find(Offset fpOffset, Offset cbOffset) {
+      return (StealInfo)super.find(fpOffset, cbOffset);
+    }
+  }
+
+  public static class AbortAtFailure extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+  }
+  public static class AbortAtSuccess extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+  }
+  public static class Finish extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+    public Iterable<WS.FinishData> data;
+  }
+  public static class Join extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+    public FinishInfo finish;
+  }
+  public static class FinishFirst extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+    public FinishInfo finish;
+  }
+  public static class Continuation extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+  }
+
+  protected static void installJoinInstructions(Address fp, Address prevFp) {
+    Address ip = Magic.getReturnAddress(prevFp);
+    CompiledMethod cm = CompiledMethods.getCompiledMethod(Magic.getCompiledMethodID(fp));
+    if (cm.hasJoinInstructions()) {
+      if (!cm.inJoinInstructions(ip)) { 
+        Magic.setReturnAddress(prevFp, ip.plus(cm.joinDelta()));
+      }
+    }
+  }
+
+  protected static void installJoinInstructions(Address fp, Address prevFp, RVMThread victim) {
+    final Address ip = prevFp.EQ(victim.getHijackedReturnCalleeFp()) ? victim.getHijackedReturnAddress() : Magic.getReturnAddress(prevFp); 
+    CompiledMethod cm = CompiledMethods.getCompiledMethod(Magic.getCompiledMethodID(fp));
+    if (cm.hasJoinInstructions()) {
+      if (!cm.inJoinInstructions(ip)) {
+        //return barrier
+        if(prevFp.EQ(victim.getHijackedReturnCalleeFp())) {
+          victim.setHijackedReturnAddress(ip.plus(cm.joinDelta()));
+        }
+        else {
+          Magic.setReturnAddress(prevFp, ip.plus(cm.joinDelta()));
+        }
+      }
+    }
+  }
+}
+
diff --git a/tools/bootloader/main.c b/tools/bootloader/main.c
index 13249bb..7fa88f2 100644
--- a/tools/bootloader/main.c
+++ b/tools/bootloader/main.c
@@ -81,7 +81,19 @@ Extent determinePageSize();
 #define PROCESSORS_INDEX              BOOTCLASSPATH_A_INDEX + 1
 #define VERBOSE_SIGNAL_HANDLING       PROCESSORS_INDEX + 1
 
-#define numNonstandardArgs      VERBOSE_SIGNAL_HANDLING + 1
+// TryCatchWS related
+#define WS_PINAUTO		      VERBOSE_SIGNAL_HANDLING + 1
+#define WS_PINMAP		      WS_PINAUTO + 1
+#define WS_PINLOG		      WS_PINMAP + 1
+#define WS_PINSOCKETCPU		      WS_PINLOG + 1
+#define WS_PINMAPSYS		      WS_PINSOCKETCPU + 1
+#define WS_PERFEVENT		      WS_PINMAPSYS + 1
+#define WS_PINMAPGC		      WS_PERFEVENT + 1
+#define WS_RETBARRIER		      WS_PINMAPGC + 1
+#define WS_PROCS		      WS_RETBARRIER + 1
+#define WS_STATS		      WS_PROCS + 1
+
+#define numNonstandardArgs      WS_STATS + 1
 
 static const char* nonStandardArgs[numNonstandardArgs] = {
   "-X",
@@ -105,6 +117,16 @@ static const char* nonStandardArgs[numNonstandardArgs] = {
   "-Xbootclasspath/a:",
   "-X:availableProcessors=",
   "-X:verboseSignalHandling",
+  "-Xws:pinAuto=",
+  "-Xws:pinMap=",
+  "-Xws:pinLog=",
+  "-Xws:pinSocketCPU=",
+  "-Xws:pinMapSys=",
+  "-Xws:perfEvent=",
+  "-Xws:pinMapGC=",
+  "-Xws:retBarrier=",
+  "-Xws:procs=",
+  "-Xws:stats=",
 };
 
 // a NULL-terminated list.
@@ -141,6 +163,29 @@ static const char* nonStandardUsage[] = {
   "                             -X:gc:threads to control gc parallelism)",
   "  -X:verboseSignalHandling   Print out information when handling software and",
   "                             hardware signals",
+  "#====================================================================================",
+  "#============== WORK-STEALING SPECIFIC OPTIONS ======================================",
+  "#====================================================================================",
+  "#1. THREAD PINNING SPECIFIC......",
+  "  -Xws:pinAuto=<true/false>  Pin work-stealing threads to core id",
+  "  -Xws:pinMap=<0:2:4:6...>   Provide cpu map to pin the worker-stealing threads",
+  "  -Xws:pinLog=<true/false>   Print cpu id on which each work-stealing threads are running",
+  "                              (printing is done at the launch and end of application)",
+  "  -Xws:pinSocketCPU=<1:8>    Provide number of sockets and number of cpus available",
+  "                              (format is num_sockets:num_cpus_per_socket)",
+  "  -Xws:pinMapSys=<0:2...>    Provide set of cpus where system threads should run",
+  "                             This also includes GC threads if they are not pinned separately",
+  "  -Xws:pinMapGC=<0:1...>     Provide set of cpus where GC threads should run",
+  "                             map should be for each and every GC threads",
+  "#2. LINUX PERF EVENTS COUNTERS...",
+  "  -Xws:perfEvent=<true>      True if want to measure per thread performance counter events",
+  "#3. NORMAL USAGE...",
+  "  -Xws:retBarrier=<true>     Use return barrier to reduce the steal time",
+  "                             default option is false",
+  "  -Xws:procs=<number>        Total work-stealing worker threads",
+  "  -Xws:stats=<true>          Display work-stealing statistics. Useful in a large project",
+  "                             where you dont know where exactly main method is being called.",
+  "                             The default option is false",
   NULL                         /* End of messages */
 };
 
diff --git a/tools/bootloader/sys.h b/tools/bootloader/sys.h
index aeea7e0..df57903 100644
--- a/tools/bootloader/sys.h
+++ b/tools/bootloader/sys.h
@@ -105,6 +105,11 @@ extern Extent pageSize;
 #define EXTERNAL
 #endif
 
+#ifdef RVM_WITH_LIBNUMA
+#include <numa.h>
+#include <numaif.h>
+#endif
+
 #if (defined RVM_FOR_LINUX) && (defined RVM_FOR_HARMONY)
 #define LINUX
 #endif
@@ -330,6 +335,20 @@ EXTERNAL jfloat sysVaArgJfloat(va_list *ap);
 EXTERNAL jdouble sysVaArgJdouble(va_list *ap);
 EXTERNAL jobject sysVaArgJobject(va_list *ap);
 
+//TryCatchWS specific
+EXTERNAL void sysPerfEventInit_thread(int events);
+EXTERNAL void sysPerfEventCreate_thread(int id, const char *eventName);
+EXTERNAL void sysPerfEventOpen_thread(int id, void*tid, int *fds);
+EXTERNAL void sysPerfEventClose_thread(int id, int *fds);
+EXTERNAL void sysPerfEventEnable_thread(int *fds, int numEvents);
+EXTERNAL void sysPerfEventDisable_thread(int *fds, int numEvents);
+EXTERNAL void sysPerfEventRead_thread(int id, int *fds, uint64_t *values);
+EXTERNAL int sysGetCPU();
+EXTERNAL int sysCheckNUMAnode(void* memory);
+EXTERNAL void sysThreadBindMaskSet();
+EXTERNAL void wsThreadBindMaskSet(int cpuMask);
+EXTERNAL void wsIniatilizeSysThreadBindMask(int cpuMask);
+
 /** Only called externally from Java programs. */
 EXTERNAL void sysExit(int) NORETURN;
 
diff --git a/tools/bootloader/sysMemory.c b/tools/bootloader/sysMemory.c
index c36c4af..2a14aad 100644
--- a/tools/bootloader/sysMemory.c
+++ b/tools/bootloader/sysMemory.c
@@ -231,6 +231,9 @@ EXTERNAL void * sysMMapErrno(char *start , size_t length ,
   void* res;
   TRACE_PRINTF("%s: sysMMapErrno %p %zu %d %d %d %zu\n",
                Me, start, length, protection, flags, fd, offset);
+  #ifdef RVM_WITH_LIBNUMA
+  numa_set_localalloc();
+  #endif
   res = mmap(start, (size_t)(length), protection, flags, fd, (off_t)offset);
   if (res == (void *) -1) {
     ERROR_PRINTF("%s: sysMMapErrno %p %zu %d %d %d %ld failed with %d.\n",
diff --git a/tools/bootloader/sysPerfEvent.c b/tools/bootloader/sysPerfEvent.c
index 5704b2a..5934b3d 100644
--- a/tools/bootloader/sysPerfEvent.c
+++ b/tools/bootloader/sysPerfEvent.c
@@ -30,7 +30,17 @@
   EXTERNAL void sysPerfEventEnable() {}
   EXTERNAL void sysPerfEventDisable() {}
   EXTERNAL void sysPerfEventRead(int id, long long *values) {}
+  EXTERNAL void sysPerfEventInit_thread(int events) {}
+  EXTERNAL void sysPerfEventCreate_thread(int id, const char *eventName) {}
+  EXTERNAL void sysPerfEventOpen_thread(int id, void*tid, int *fds) {}
+  EXTERNAL void sysPerfEventClose_thread(int id, int *fds) {}
+  EXTERNAL void sysPerfEventEnable_thread(int *fds, int numEvents) {}
+  EXTERNAL void sysPerfEventDisable_thread(int *fds, int numEvents) {}
+  EXTERNAL void sysPerfEventRead_thread(int id, int *fds, uint64_t *values) {}
 #else
+  static int perfVerbose = 0;
+  static struct perf_event_attr *perf_event_attrs_thread;
+  extern "C" Word sysGetThreadId();
   static int enabled = 0;
   static int *perf_event_fds;
   static struct perf_event_attr *perf_event_attrs;
@@ -107,4 +117,88 @@
       errx(1, "read of perf event did not return 3 64-bit values");
     }
   }
+
+  EXTERNAL void sysPerfEventInit_thread(int numEvents)
+  {
+   int ret = pfm_initialize();
+   if (ret != PFM_SUCCESS) {
+     errx(1, "error in pfm_initialize: %s", pfm_strerror(ret));
+   }
+ 
+   perf_event_attrs_thread = (struct perf_event_attr *)calloc(numEvents, sizeof(struct perf_event_attr));
+   if (!perf_event_attrs_thread) {
+     errx(1, "error allocating perf_event_attrs_thread");
+   }
+   for(int i=0; i < numEvents; i++) {
+     perf_event_attrs_thread[i].size = sizeof(struct perf_event_attr);
+   }
+  // enabled = 1;
+ }
+ 
+ EXTERNAL void sysPerfEventCreate_thread(int id, const char *eventName)
+ {
+   struct perf_event_attr *pe = (perf_event_attrs_thread + id);
+   int ret = pfm_get_perf_event_encoding(eventName, PFM_PLM3, pe, NULL, NULL);
+   if (ret != PFM_SUCCESS) {
+     errx(1, "error creating event %d '%s': %s\n", id, eventName, pfm_strerror(ret));
+   }
+   pe->read_format = PERF_FORMAT_TOTAL_TIME_ENABLED | PERF_FORMAT_TOTAL_TIME_RUNNING;
+   pe->disabled = 1;
+   pe->inherit = 0;
+ }
+ 
+ EXTERNAL void sysPerfEventClose_thread(int id, int *fds) {
+   close(fds[id]);
+ }
+ 
+ EXTERNAL void sysPerfEventOpen_thread(int id, void* tid, int *fds) {
+   struct perf_event_attr *pe = (perf_event_attrs_thread + id);
+   fds[id] = perf_event_open(pe, 0, -1, -1, 0);
+   if (fds[id] == -1) {
+     err(1, "error in perf_event_open for event %d", id);
+   }
+   if(perfVerbose)
+     printf("Create Counter %d at fd %d for thread %d\n", id, fds[id],sysGetThreadId());
+ }
+ 
+ EXTERNAL void sysPerfEventEnable_thread(int *fds, int numEvents)
+ {
+ 	int i;
+ 	for(i=0; i< numEvents; i++) {
+ 		if (ioctl(fds[i], PERF_EVENT_IOC_ENABLE, 0)) {
+ 			err(1, "error enabling perf event");
+ 		}
+ 	}
+ }
+ 
+ EXTERNAL void sysPerfEventDisable_thread(int *fds, int numEvents)
+ {
+ 	int i;
+ 	for(i=0; i< numEvents; i++) {
+ 		if (ioctl(fds[i], PERF_EVENT_IOC_DISABLE, 0)) {
+ 			err(1, "error disabling perf event");
+ 		}
+ 	}
+ }
+ 
+ EXTERNAL void sysPerfEventRead_thread(int id, int *fds, uint64_t *values)
+ {
+   if (fds[id] < 0) {
+ 	  printf("ERROR: reading event %d\n",id);
+ 	  return;
+   }
+   memset(values, 0, sizeof(uint64_t) * 3);
+   size_t expectedBytes = 3 * sizeof(uint64_t);
+   int ret = read(fds[id], values, expectedBytes);
+   if (ret < 0) {
+     err(1, "error reading event: %s", strerror(errno));
+   }
+   if (ret != expectedBytes) {
+     errx(1, "read of perf event did not return 3 64-bit values");
+   }
+   if(perfVerbose)
+     printf("Counter %d at fd %d: value %lld\n",sysGetThreadId(),fds[id], values[0]);
+   close(fds[id]);
+   fds[id] = -1;
+ }
 #endif
diff --git a/tools/bootloader/sysThread.c b/tools/bootloader/sysThread.c
index 451986f..6f5ca0e 100644
--- a/tools/bootloader/sysThread.c
+++ b/tools/bootloader/sysThread.c
@@ -42,7 +42,6 @@ static const Address MAIN_THREAD_ALLOW_TERMINATE = 1;
  */
 static const Address MAIN_THREAD_DONT_TERMINATE = 2;
 
-
 #ifdef RVM_FOR_HARMONY
 #include "hythread.h"
 #else
@@ -524,6 +523,76 @@ return NULL;
 #endif
 }
 
+/*
+ * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+ * From here---->
+ */
+
+EXTERNAL int sysCheckNUMAnode(void* memory) { 
+#ifndef RVM_WITH_LIBNUMA
+  return -1;
+#else
+  int status[1];
+  int ret_code;
+  status[0]=-1;
+  ret_code=move_pages(0 /*self memory */, 1, &memory, NULL, status, 0);
+  if(ret_code != 0) {
+    fprintf(stderr,"sysCheckNUMAnode failed (errno=%d)\n",ret_code);
+    exit(1);
+  }
+  return status[0];
+#endif
+}
+
+#ifndef RVM_FOR_MACOS
+static cpu_set_t ws_sysThread_cpuset;
+#endif
+
+EXTERNAL void wsIniatilizeSysThreadBindMask(int cpuMask) {
+#ifndef RVM_FOR_MACOS
+        static int first = 0;
+        if(first == 0) {
+                CPU_ZERO(&ws_sysThread_cpuset);
+                first = 1;
+        }
+        CPU_SET( cpuMask, &ws_sysThread_cpuset );
+#endif
+}
+
+EXTERNAL void wsThreadBindMaskSet( int cpuMask ) {
+#if !defined(RVM_FOR_HARMONY) || !defined(RVM_FOR_MACOS)
+#ifdef RVM_FOR_LINUX
+        cpu_set_t cpuset;
+        CPU_ZERO(&cpuset);
+        CPU_SET( cpuMask, &cpuset );
+        pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);
+#endif
+#endif
+}
+
+EXTERNAL void sysThreadBindMaskSet() {
+#ifndef RVM_FOR_HARMONY
+#ifdef RVM_FOR_LINUX
+#ifndef RVM_FOR_MACOS
+        pthread_setaffinity_np(pthread_self(), sizeof(ws_sysThread_cpuset), &ws_sysThread_cpuset);
+#endif
+#endif
+#endif
+}
+
+EXTERNAL int sysGetCPU( ) {
+#if !defined(RVM_FOR_HARMONY) || !defined(RVM_FOR_MACOS)
+#ifdef RVM_FOR_LINUX
+        return sched_getcpu();
+#endif
+#endif
+}
+
+/*
+ * Till Here <----
+ * Thread Pinning Support for JavaWS (Try-Catch) Work-Stealing
+ */
+
 // Routines to support sleep/wakeup of idle threads
 
 EXTERNAL void* getThreadId()
-- 
2.7.4

