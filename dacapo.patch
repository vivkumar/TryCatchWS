From a581117639c1a0a9f5b1b75e7bd313a6b3cde28a Mon Sep 17 00:00:00 2001
From: Vivek Kumar <vivekk@iiitd.ac.in>
Date: Tue, 5 Mar 2019 14:22:44 +0530
Subject: [PATCH 1/1] support for speculative task parallelism

Signed-off-by: Vivek Kumar <vivekk@iiitd.ac.in>
---
 benchmarks/bms/Featherlight/Makefile               |   23 +
 .../bms/Featherlight/QueryParserTokenManager.java  | 1189 ++++++++++++++++++++
 benchmarks/bms/Featherlight/Search.java            |  313 ++++++
 .../bms/Featherlight/bms-lusearch-fix-build.xml    |   53 +
 benchmarks/bms/Featherlight/libs.xml               |  122 ++
 benchmarks/bms/Featherlight/lucene-build.xml       |  650 +++++++++++
 benchmarks/bms/ForkJoin/Makefile                   |   17 +
 .../bms/ForkJoin/QueryParserTokenManager.java      | 1185 +++++++++++++++++++
 benchmarks/bms/ForkJoin/Search.java                |  330 ++++++
 benchmarks/bms/ForkJoin/bms-lusearch-fix-build.xml |   53 +
 benchmarks/bms/ForkJoin/libs.xml                   |  120 ++
 benchmarks/bms/ForkJoin/lucene-build.xml           |  648 +++++++++++
 benchmarks/bms/ManualAbort/Makefile                |   23 +
 .../bms/ManualAbort/QueryParserTokenManager.java   | 1189 ++++++++++++++++++++
 benchmarks/bms/ManualAbort/Search.java             |  333 ++++++
 .../bms/ManualAbort/bms-lusearch-fix-build.xml     |   53 +
 benchmarks/bms/ManualAbort/libs.xml                |  122 ++
 benchmarks/bms/ManualAbort/lucene-build.xml        |  650 +++++++++++
 benchmarks/bms/Sequential/Makefile                 |   17 +
 .../bms/Sequential/QueryParserTokenManager.java    | 1185 +++++++++++++++++++
 benchmarks/bms/Sequential/Search.java              |  313 ++++++
 .../bms/Sequential/bms-lusearch-fix-build.xml      |   53 +
 benchmarks/bms/Sequential/libs.xml                 |  117 ++
 benchmarks/bms/Sequential/lucene-build.xml         |  648 +++++++++++
 benchmarks/bms/lusearch-fix/build.xml              |    2 +-
 benchmarks/harness/build.xml                       |    3 +-
 .../harness/src/org/dacapo/harness/Benchmark.java  |    8 +-
 .../harness/src/org/dacapo/harness/EuroPAR19.java  |   50 +
 benchmarks/libs/libs.xml                           |    5 +
 benchmarks/path.xml                                |    6 +
 benchmarks/util.xml                                |    4 +-
 31 files changed, 9477 insertions(+), 7 deletions(-)
 create mode 100755 benchmarks/bms/Featherlight/Makefile
 create mode 100644 benchmarks/bms/Featherlight/QueryParserTokenManager.java
 create mode 100644 benchmarks/bms/Featherlight/Search.java
 create mode 100644 benchmarks/bms/Featherlight/bms-lusearch-fix-build.xml
 create mode 100644 benchmarks/bms/Featherlight/libs.xml
 create mode 100644 benchmarks/bms/Featherlight/lucene-build.xml
 create mode 100755 benchmarks/bms/ForkJoin/Makefile
 create mode 100644 benchmarks/bms/ForkJoin/QueryParserTokenManager.java
 create mode 100644 benchmarks/bms/ForkJoin/Search.java
 create mode 100644 benchmarks/bms/ForkJoin/bms-lusearch-fix-build.xml
 create mode 100644 benchmarks/bms/ForkJoin/libs.xml
 create mode 100644 benchmarks/bms/ForkJoin/lucene-build.xml
 create mode 100755 benchmarks/bms/ManualAbort/Makefile
 create mode 100644 benchmarks/bms/ManualAbort/QueryParserTokenManager.java
 create mode 100644 benchmarks/bms/ManualAbort/Search.java
 create mode 100644 benchmarks/bms/ManualAbort/bms-lusearch-fix-build.xml
 create mode 100644 benchmarks/bms/ManualAbort/libs.xml
 create mode 100644 benchmarks/bms/ManualAbort/lucene-build.xml
 create mode 100755 benchmarks/bms/Sequential/Makefile
 create mode 100644 benchmarks/bms/Sequential/QueryParserTokenManager.java
 create mode 100644 benchmarks/bms/Sequential/Search.java
 create mode 100644 benchmarks/bms/Sequential/bms-lusearch-fix-build.xml
 create mode 100644 benchmarks/bms/Sequential/libs.xml
 create mode 100644 benchmarks/bms/Sequential/lucene-build.xml
 create mode 100644 benchmarks/harness/src/org/dacapo/harness/EuroPAR19.java
 create mode 100644 benchmarks/path.xml

diff --git a/benchmarks/bms/Featherlight/Makefile b/benchmarks/bms/Featherlight/Makefile
new file mode 100755
index 0000000..8339096
--- /dev/null
+++ b/benchmarks/bms/Featherlight/Makefile
@@ -0,0 +1,23 @@
+AJWS=../../../../../translator/transform.sh
+
+all:
+	wget -c http://archive.apache.org/dist/lucene/java/lucene-2.4.1-src.tar.gz
+	tar xvfz lucene-2.4.1-src.tar.gz; cd lucene-2.4.1; ant jar-core; mv build/lucene-core-2.4.jar ../.
+	rm -rf lucene-2.4.1; mv lucene-2.4.1-src.tar.gz ../../libs/lucene/downloads/.
+	EXTRA_JARS_AJWS="./lucene-core-2.4.jar" $(AJWS) Search.java
+	cp classes/Search.java ../lusearch-fix/src/org/dacapo/lusearchFix/Search.java
+	cp ./bms-lusearch-fix-build.xml  ../lusearch-fix/build.xml
+	cp ./libs.xml ../../libs/.
+	wget -c http://archive.apache.org/dist/commons/cli/binaries/commons-cli-1.2-bin.tar.gz
+	mv commons-cli-1.2-bin.tar.gz ../../harness/downloads/
+	cd ../../libs/lucene/downloads; tar xvfz lucene-2.4.1-src.tar.gz
+	cp QueryParserTokenManager.java ../../libs/lucene/downloads/lucene-2.4.1/src/java/org/apache/lucene/queryParser/.
+	cp lucene-build.xml  ../../libs/lucene/downloads/lucene-2.4.1/build.xml
+	rm ../../libs/lucene/downloads/lucene-2.4.1-src.tar.gz || true
+	cp -rf ../../libs/lucene/downloads/lucene-2.4.1 .
+	tar cvfz lucene-2.4.1-src.tar.gz lucene-2.4.1
+	rm -rf lucene-2.4.1
+	mv lucene-2.4.1-src.tar.gz ../../libs/lucene/downloads/.
+	cd ../../; ant clean lusearch-fix
+clean:
+	rm -rf classes logs 2>/dev/null
diff --git a/benchmarks/bms/Featherlight/QueryParserTokenManager.java b/benchmarks/bms/Featherlight/QueryParserTokenManager.java
new file mode 100644
index 0000000..07a7383
--- /dev/null
+++ b/benchmarks/bms/Featherlight/QueryParserTokenManager.java
@@ -0,0 +1,1189 @@
+/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */
+package org.apache.lucene.queryParser;
+import java.io.IOException;
+import java.io.StringReader;
+import java.text.DateFormat;
+import java.text.Collator;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Vector;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.document.DateField;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.ConstantScoreRangeQuery;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.util.Parameter;
+
+/** Token Manager. */
+public class QueryParserTokenManager implements QueryParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_3(int pos, long active0)
+{
+   switch (pos)
+   {
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_3(int pos, long active0)
+{
+   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_3()
+{
+   switch(curChar)
+   {
+      case 40:
+         return jjStopAtPos(0, 13);
+      case 41:
+         return jjStopAtPos(0, 14);
+      case 42:
+         return jjStartNfaWithStates_3(0, 16, 36);
+      case 43:
+         return jjStopAtPos(0, 11);
+      case 45:
+         return jjStopAtPos(0, 12);
+      case 58:
+         return jjStopAtPos(0, 15);
+      case 91:
+         return jjStopAtPos(0, 23);
+      case 94:
+         return jjStopAtPos(0, 17);
+      case 123:
+         return jjStopAtPos(0, 24);
+      default :
+         return jjMoveNfa_3(0, 0);
+   }
+}
+private int jjStartNfaWithStates_3(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_3(state, pos + 1);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_3(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 36;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+               case 25:
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 0:
+                  if ((0xfbffd4f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  else if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  else if (curChar == 33)
+                  {
+                     if (kind > 10)
+                        kind = 10;
+                  }
+                  if ((0x7bffd0f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  else if (curChar == 42)
+                  {
+                     if (kind > 21)
+                        kind = 21;
+                  }
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 4:
+                  if (curChar == 38 && kind > 8)
+                     kind = 8;
+                  break;
+               case 5:
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 13:
+                  if (curChar == 33 && kind > 10)
+                     kind = 10;
+                  break;
+               case 14:
+                  if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 15:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 18:
+                  if (curChar == 34 && kind > 18)
+                     kind = 18;
+                  break;
+               case 20:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjAddStates(8, 9);
+                  break;
+               case 21:
+                  if (curChar == 46)
+                     jjCheckNAdd(22);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjCheckNAdd(22);
+                  break;
+               case 23:
+                  if (curChar == 42 && kind > 21)
+                     kind = 21;
+                  break;
+               case 24:
+                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 27:
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if ((0x7bffd0f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+                  if ((0x7bfff8f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 31:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+                  if ((0x7bfff8f8ffffd9ffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 34:
+                  jjCheckNAddStates(10, 12);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddTwoStates(27, 27);
+                  break;
+               case 0:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddStates(13, 15);
+                  else if (curChar == 126)
+                  {
+                     if (kind > 20)
+                        kind = 20;
+                     jjstateSet[jjnewStateCnt++] = 20;
+                  }
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  else if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  else if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  else if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 1:
+                  if (curChar == 68 && kind > 8)
+                     kind = 8;
+                  break;
+               case 2:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 3:
+                  if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 6:
+                  if (curChar == 82 && kind > 9)
+                     kind = 9;
+                  break;
+               case 7:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  break;
+               case 8:
+                  if (curChar == 124 && kind > 9)
+                     kind = 9;
+                  break;
+               case 9:
+                  if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 10:
+                  if (curChar == 84 && kind > 10)
+                     kind = 10;
+                  break;
+               case 11:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 12:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  break;
+               case 15:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 16:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 17;
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 19:
+                  if (curChar != 126)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjstateSet[jjnewStateCnt++] = 20;
+                  break;
+               case 24:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 25:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 26:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(27, 27);
+                  break;
+               case 27:
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 30:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(31, 31);
+                  break;
+               case 31:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 33:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(34, 34);
+                  break;
+               case 34:
+                  jjCheckNAddStates(10, 12);
+                  break;
+               case 35:
+                  if (curChar == 92)
+                     jjCheckNAddStates(13, 15);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+               case 25:
+               case 27:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  break;
+               case 15:
+               case 17:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 24:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+               case 31:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+               case 34:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(10, 12);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      org.jikesrvm.scheduler.WS.pauseStealOnThread();
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { 
+        org.jikesrvm.scheduler.WS.resumeStealOnThread();
+        return curPos; 
+      }
+   }
+}
+private final int jjStopStringLiteralDfa_1(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x40000000L) != 0L)
+         {
+            jjmatchedKind = 33;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_1(int pos, long active0)
+{
+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_1(0x40000000L);
+      case 125:
+         return jjStopAtPos(0, 31);
+      default :
+         return jjMoveNfa_1(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_1(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x40000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 30, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_1(0, active0);
+}
+private int jjStartNfaWithStates_1(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_1(state, pos + 1);
+}
+private int jjMoveNfa_1(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 33)
+                        kind = 33;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 32)
+                     kind = 32;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xdfffffffffffffffL & l) == 0L)
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(16, 18);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(16, 18);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   return jjMoveNfa_0(0, 0);
+}
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 3;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 25)
+                     kind = 25;
+                  jjAddStates(19, 20);
+                  break;
+               case 1:
+                  if (curChar == 46)
+                     jjCheckNAdd(2);
+                  break;
+               case 2:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 25)
+                     kind = 25;
+                  jjCheckNAdd(2);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjStopStringLiteralDfa_2(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x4000000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_2(int pos, long active0)
+{
+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_2(0x4000000L);
+      case 93:
+         return jjStopAtPos(0, 27);
+      default :
+         return jjMoveNfa_2(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 26, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(0, active0);
+}
+private int jjStartNfaWithStates_2(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_2(state, pos + 1);
+}
+private int jjMoveNfa_2(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 29)
+                        kind = 29;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 28)
+                     kind = 28;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xffffffffdfffffffL & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(16, 18);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(16, 18);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+static final int[] jjnextStates = {
+   15, 16, 18, 29, 32, 23, 33, 30, 20, 21, 32, 23, 33, 31, 34, 27, 
+   2, 4, 5, 0, 1, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
+"\50", "\51", "\72", "\52", "\136", null, null, null, null, null, "\133", "\173", 
+null, "\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "Boost",
+   "RangeEx",
+   "RangeIn",
+   "DEFAULT",
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 
+   3, -1, 3, -1, -1, -1, 3, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x3ffffff01L, 
+};
+static final long[] jjtoSkip = {
+   0x80L, 
+};
+protected CharStream input_stream;
+private final int[] jjrounds = new int[36];
+private final int[] jjstateSet = new int[72];
+protected char curChar;
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream){
+   input_stream = stream;
+}
+
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 36; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 4 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 3;
+int defaultLexState = 3;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      org.jikesrvm.scheduler.WS.pauseStealOnThread();
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      org.jikesrvm.scheduler.WS.resumeStealOnThread();
+      return matchedToken;
+   }
+
+   switch(curLexState)
+   {
+     case 0:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_0();
+       break;
+     case 1:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_1();
+       break;
+     case 2:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_2();
+       break;
+     case 3:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_3();
+       break;
+   }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else
+        {
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/benchmarks/bms/Featherlight/Search.java b/benchmarks/bms/Featherlight/Search.java
new file mode 100644
index 0000000..05ac7b2
--- /dev/null
+++ b/benchmarks/bms/Featherlight/Search.java
@@ -0,0 +1,313 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Contributors:
+ *     Apache Software Foundation 
+ *     Australian National University - adaptation to DaCapo test harness
+ */
+package org.dacapo.lusearchFix;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.FilterIndexReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.TopDocCollector;
+
+/**
+ * Simple command-line based search demo.
+ * 
+ * @date $Date: 2009-12-24 11:19:36 +1100 (Thu, 24 Dec 2009) $
+ * @id $Id: Search.java 738 2009-12-24 00:19:36Z steveb-oss $
+ */
+public class Search {
+
+  static final int MAX_DOCS_TO_COLLECT = 20;
+  public int completed = 0;
+  private int COMPLETION_GOAL; 
+
+  /**
+   * Use the norms from one field for all fields. Norms are read into memory,
+   * using a byte of memory per document per searched field. This can cause
+   * search of large collections with a large number of fields to run out of
+   * memory. If all of the fields contain only a single token, then the norms
+   * are all identical, then single norm vector may be shared.
+   */
+  private static class OneNormsReader extends FilterIndexReader {
+    private String field;
+
+    public OneNormsReader(IndexReader in, String field) {
+      super(in);
+      this.field = field;
+    }
+
+    public byte[] norms(String field) throws IOException {
+      return in.norms(this.field);
+    }
+  }
+
+  public Search() {
+  }
+
+  /** Simple command-line based search demo. */
+  public void main(String[] args) throws Exception {
+    String usage = "Usage:\tjava org.dacapo.lusearchFix.Search [-index dir] [-field f] [-repeat n] [-queries file] [-raw] [-norms field] [-paging hitsPerPage]";
+    usage += "\n\tSpecify 'false' for hitsPerPage to use streaming instead of paging search.";
+    if (args.length > 0 && ("-h".equals(args[0]) || "-help".equals(args[0]))) {
+      System.out.println(usage);
+      System.exit(0);
+    }
+
+    String index = "index";
+    String field = "contents";
+    String queryBase = null;
+    int repeat = 0;
+    boolean raw = false;
+    String normsField = null;
+    int hitsPerPage = 10;
+    String outBase = null;
+    int threads = 1;
+    int totalQueries = 32;
+
+    for (int i = 0; i < args.length; i++) {
+      if ("-index".equals(args[i])) {
+        index = args[i + 1];
+        i++;
+      } else if ("-field".equals(args[i])) {
+        field = args[i + 1];
+        i++;
+      } else if ("-queries".equals(args[i])) {
+        queryBase = args[i + 1];
+        i++;
+      } else if ("-repeat".equals(args[i])) {
+        repeat = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-raw".equals(args[i])) {
+        raw = true;
+      } else if ("-norms".equals(args[i])) {
+        normsField = args[i + 1];
+        i++;
+      } else if ("-paging".equals(args[i])) {
+        hitsPerPage = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-output".equals(args[i])) {
+        outBase = args[i + 1];
+        i++;
+      } else if ("-threads".equals(args[i])) {
+        threads = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-totalqueries".equals(args[i])) {
+        totalQueries = Integer.parseInt(args[i + 1]);
+        i++;
+      }
+    }
+    completed = 0;
+    COMPLETION_GOAL = (int)( 0.8 * totalQueries);
+    final QueryThread[] queryThreads = new QueryThread[totalQueries];
+    finish_abort {
+      for (int j = 0; j < totalQueries; j++) {
+        queryThreads[j] = new QueryThread(this, "Query" + j, j, threads, totalQueries, index, outBase, queryBase, field, normsField, raw, hitsPerPage);
+        async { queryThreads[j].run(); }
+      }
+    }
+  }
+
+  class QueryThread {
+    Search parent;
+    int id;
+    int threadCount;
+    int totalQueries;
+    String name;
+    String index;
+    String outBase;
+    String queryBase;
+    String field;
+    String normsField;
+    boolean raw;
+    int hitsPerPage;
+
+    public QueryThread(Search parent, String name, int id, int threadCount, int totalQueries, String index, String outBase, String queryBase, String field,
+        String normsField, boolean raw, int hitsPerPage) {
+      //super(name);
+      this.parent = parent;
+      this.id = id;
+      this.threadCount = threadCount;
+      this.totalQueries = totalQueries;
+      this.name = name;
+      this.index = index;
+      this.outBase = outBase;
+      this.queryBase = queryBase;
+      this.field = field;
+      this.normsField = normsField;
+      this.raw = raw;
+      this.hitsPerPage = hitsPerPage;
+    }
+
+    public void run() {
+      try {
+        //int count = totalQueries / threadCount + (id < (totalQueries % threadCount) ? 1 : 0);
+        //for (int i = 0, queryId = id; i < count; i++, queryId += threadCount) {
+          // make and run query
+          new QueryProcessor(parent, name, id, index, outBase, queryBase, field, normsField, raw, hitsPerPage).run();
+        //}
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+
+  }
+
+  public class QueryProcessor {
+
+    Search parent;
+    String field;
+    int hitsPerPage;
+    boolean raw;
+
+    IndexReader reader;
+    Searcher searcher;
+    BufferedReader in;
+    PrintWriter out;
+
+    public QueryProcessor(Search parent, String name, int id, String index, String outBase, String queryBase, String field, String normsField, boolean raw,
+        int hitsPerPage) {
+      this.parent = parent;
+      this.field = field;
+      this.raw = raw;
+      this.hitsPerPage = hitsPerPage;
+      try {
+        reader = IndexReader.open(index);
+        if (normsField != null)
+          reader = new OneNormsReader(reader, normsField);
+        searcher = new IndexSearcher(reader);
+
+        String query = queryBase + (id < 10 ? "00" : (id < 100 ? "0" : "")) + id + ".txt";
+        in = new BufferedReader(new FileReader(query));
+        out = new PrintWriter(new BufferedWriter(new FileWriter(outBase + id)));
+
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+
+    public void run() throws java.io.IOException {
+      Analyzer analyzer = new StandardAnalyzer();
+      QueryParser parser = new QueryParser(field, analyzer);
+
+      while (true) {
+        String line = in.readLine();
+
+        if (line == null || line.length() == -1)
+          break;
+
+        line = line.trim();
+        if (line.length() == 0)
+          break;
+
+        Query query = null;
+        try {
+          query = parser.parse(line);
+        } catch (org.apache.lucene.queryParser.ParseException e) {
+          e.printStackTrace();
+        }
+        searcher.search(query, null, 10);
+
+        doPagingSearch(query);
+      }
+
+      reader.close();
+      out.flush();
+      out.close();
+     
+      synchronized (parent) {
+        ++parent.completed;
+        if (parent.completed % 4 == 0) {
+          System.out.println(parent.completed + " query batches completed");
+        }
+        //parent.notify();
+      }
+  
+      if(parent.completed >= parent.COMPLETION_GOAL) {
+        System.out.println("Aborting as "+parent.completed+" completed");
+        abort;
+      }
+    }
+
+    /**
+     * This demonstrates a typical paging search scenario, where the search
+     * engine presents pages of size n to the user. The user can then go to the
+     * next page if interested in the next hits.
+     * 
+     * When the query is executed for the first time, then only enough results
+     * are collected to fill 5 result pages. If the user wants to page beyond
+     * this limit, then the query is executed another time and all hits are
+     * collected.
+     * 
+     */
+    public void doPagingSearch(Query query) throws IOException {
+
+      // Collect enough docs to show 5 pages
+      TopDocCollector collector = new TopDocCollector(MAX_DOCS_TO_COLLECT);
+      searcher.search(query, collector);
+      ScoreDoc[] hits = collector.topDocs().scoreDocs;
+
+      int numTotalHits = collector.getTotalHits();
+      if (numTotalHits > 0)
+        out.println(numTotalHits + " total matching documents for " + query.toString(field));
+
+      int start = 0;
+      int end = Math.min(numTotalHits, hitsPerPage);
+
+      while (start < Math.min(MAX_DOCS_TO_COLLECT, numTotalHits)) {
+        end = Math.min(hits.length, start + hitsPerPage);
+
+        for (int i = start; i < end; i++) {
+          if (raw) { // output raw format
+            out.println("doc=" + hits[i].doc + " score=" + hits[i].score);
+            continue;
+          }
+
+          Document doc = searcher.doc(hits[i].doc);
+          String path = doc.get("path");
+          if (path != null) {
+            out.println("\t" + (i + 1) + ". " + path);
+            String title = doc.get("title");
+            if (title != null) {
+              out.println("   Title: " + doc.get("title"));
+            }
+          } else {
+            out.println((i + 1) + ". " + "No path for this document");
+          }
+
+        }
+        start = end;
+      }
+    }
+  }
+}
+
diff --git a/benchmarks/bms/Featherlight/bms-lusearch-fix-build.xml b/benchmarks/bms/Featherlight/bms-lusearch-fix-build.xml
new file mode 100644
index 0000000..f067bfb
--- /dev/null
+++ b/benchmarks/bms/Featherlight/bms-lusearch-fix-build.xml
@@ -0,0 +1,53 @@
+<!--
+ * Copyright (c) 2017 The Australian National University.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License v2.0.
+ * You may obtain the license at
+ *
+ *    http://www.opensource.org/licenses/apache2.0.php
+ -->
+<project name="lusearch-fix" default="all" basedir="../..">
+    <description>DaCapo lusearch-fix benchmark</description>
+    <property file="dacapo.properties"/>
+
+    <property name="bm-name" value="lusearch-fix"/>
+
+    <import file="../common.xml"/>
+
+    <target name="fix-operation">
+        <move file="libs/lucene/build.xml" tofile="libs/lucene/build-tmp.xml"/>
+        <copy file="libs/lucene/build-tmp.xml" tofile="libs/lucene/build.xml"/>
+        <touch file="libs/lucene/lucene.patch"/>
+        <patch patchfile="${bm-files}/lusearch-fix.patch" dir="${basedir}" strip="0" ignorewhitespace="yes"/>
+    </target>
+
+    <target name="bm-build" depends="fix-operation, lucene">
+        <mkdir dir="${bm-build-dir}"/>
+        <javac srcdir="${bm-src-dir}" source="1.5"
+               classpath="${harness-classpath}:${lucene-jars}/${lucene-core-jar-name}:${lucene-jars}/${lucene-demos-jar-name}:${jikesrvm-jar}"
+               destdir="${bm-build-dir}"
+               includes="org/dacapo/lusearchFix/*" debug="true" debuglevel="lines,vars,source"/>
+        <delete file="libs/lucene/build.xml"/>
+        <delete file="libs/lucene/lucene.patch"/>
+        <move file="libs/lucene/build-tmp.xml" tofile="libs/lucene/build.xml"/>
+    </target>
+
+    <target name="jar">
+        <jar destfile="${bm-jars}/dacapo-${bm-name}.jar" basedir="${bm-build-dir}"/>
+    </target>
+
+    <target name="copy-data">
+        <mkdir dir="${bm-data}/lusearchFix"/>
+        <copy todir="${bm-data}/lusearchFix">
+            <fileset dir="bms/lusearch/data/lusearch">
+                <include name="**"/>
+            </fileset>
+        </copy>
+    </target>
+
+    <target name="data" depends="copy-data">
+        <zip basedir="${bm-data}" includes="**" destfile="${bm-dat}/${bm-name}.zip"/>
+        <delete dir="${bm-data}"/>
+    </target>
+
+</project>
diff --git a/benchmarks/bms/Featherlight/libs.xml b/benchmarks/bms/Featherlight/libs.xml
new file mode 100644
index 0000000..5427330
--- /dev/null
+++ b/benchmarks/bms/Featherlight/libs.xml
@@ -0,0 +1,122 @@
+<!--
+ * Copyright (c) 2009 The Australian National University.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License v2.0.
+ * You may obtain the license at
+ * 
+ *    http://www.opensource.org/licenses/apache2.0.php
+ -->
+<project name="libs">
+    <property name="lib-base" value="${basedir}/libs"/>
+
+    <import file="../path.xml"/>
+
+    <!-- bcel -->
+    <property name="bcel-jar" value="${lib-base}/bcel/dist/jar/bcel-5.2.jar"/>
+    <target name="bcel">
+        <ant antfile="${lib-base}/bcel/build.xml"/>
+    </target>
+
+    <!-- dacapo-digest -->
+    <property name="dacapo-digest-jar" value="${lib-base}/dacapo-digest/dist/jar/dacapo-digest.jar"/>
+    <target name="dacapo-digest">
+        <ant antfile="${lib-base}/dacapo-digest/build.xml"/>
+    </target>
+
+    <!-- daytrader -->
+    <target name="daytrader">
+        <ant antfile="${lib-base}/daytrader/build.xml"/>
+    </target>
+
+    <!-- jpetstore -->
+    <property name="jpetstore-common" value="${lib-base}/jpetstore/dist/jar/ibatis-common-2.jar"/>
+    <property name="jpetstore-dao" value="${lib-base}/jpetstore/dist/jar/ibatis-dao-2.jar"/>
+    <property name="jpetstore-sqlmap" value="${lib-base}/jpetstore/dist/jar/ibatis-sqlmap-2.jar"/>
+    <property name="jpetstore-jakarta-oro" value="${lib-base}/jpetstore/dist/jar/jakarta-oro.jar"/>
+    <property name="jpetstore-struts" value="${lib-base}/jpetstore/dist/jar/struts.jar"/>
+    <property name="jpetstore-zip" value="${lib-base}/jpetstore/dist/jar/jpetstore.zip"/>
+    <target name="jpetstore">
+        <ant antfile="${lib-base}/jpetstore/build.xml"/>
+    </target>
+
+    <!-- jakarta commons HTTP client -->
+    <property name="commons-httpclient-jar" value="${lib-base}/commons-httpclient/dist/jar/commons-httpclient.jar"/>
+    <target name="commons-httpclient" depends="commons-logging,commons-codec">
+        <ant antfile="${lib-base}/commons-httpclient/build.xml"/>
+    </target>
+
+    <!-- jakarta commons logging -->
+    <property name="commons-logging-jar" value="${lib-base}/commons-logging/dist/jar/commons-logging.jar"/>
+    <target name="commons-logging">
+        <ant antfile="${lib-base}/commons-logging/build.xml"/>
+    </target>
+
+    <!-- jakarta commons codec -->
+    <property name="commons-codec-jar" value="${lib-base}/commons-codec/dist/jar/commons-codec.jar"/>
+    <target name="commons-codec">
+        <ant antfile="${lib-base}/commons-codec/build.xml"/>
+    </target>
+
+    <!-- janino -->
+    <property name="janino-jar" value="${lib-base}/janino/dist/jar/janino-2.5.15.jar"/>
+    <target name="janino">
+        <ant antfile="${lib-base}/janino/build.xml"/>
+    </target>
+
+    <!-- jdbcbench -->
+    <property name="jdbcbench-jar" value="${lib-base}/jdbcbench/dist/jar/jdbcbench.jar"/>
+    <target name="jdbcbench">
+        <ant antfile="${lib-base}/jdbcbench/build.xml"/>
+    </target>
+
+    <!-- derby -->
+    <property name="derby-jar" value="${lib-base}/derby/dist/jar/derby.jar"/>
+    <property name="derbyclient-jar" value="${lib-base}/derby/dist/jar/derbyclient.jar"/>
+    <property name="derbynet-jar" value="${lib-base}/derby/dist/jar/derbynet.jar"/>
+    <property name="derbytools-jar" value="${lib-base}/derby/dist/jar/derbytools.jar"/>
+    <property name="derbytesting-jar" value="${lib-base}/derby/dist/jar/derbyTesting.jar"/>
+    <target name="derby">
+        <ant antfile="${lib-base}/derby/build.xml"/>
+    </target>
+
+    <!-- junit -->
+    <property name="junit-jar" value="${lib-base}/junit/dist/jar/junit-3.8.1.jar"/>
+    <target name="junit">
+        <ant antfile="${lib-base}/junit/build.xml"/>
+    </target>
+
+    <!-- h2-->
+    <property name="h2-version" value="1.2.121"/>
+    <property name="h2-jar" value="${lib-base}/h2/dist/jar/h2-${h2-version}.jar"/>
+    <target name="h2">
+        <ant antfile="${lib-base}/h2/build.xml"/>
+    </target>
+
+    <!-- lucene -->
+    <property name="lucene-jars" value="${lib-base}/lucene/dist/jar"/>
+    <property name="lucene-core-jar-name" value="lucene-core-2.4.jar"/>
+    <property name="lucene-demos-jar-name" value="lucene-demos-2.4.jar"/>
+    <target name="lucene">
+        <ant antfile="${lib-base}/lucene/build.xml"/>
+    </target>
+ 
+    <!-- jikesrvm -->
+    <property name="jikesrvm-jar" value="${jikesrvm-path}"/>
+
+    <!-- xerces -->
+    <property name="xerces-jars" value="${lib-base}/xerces/dist/jar"/>
+    <property name="xerces-impl-jar-name" value="xercesImpl.jar"/>
+    <property name="xerces-api-jar-name" value="xml-apis.jar"/>
+    <target name="xerces">
+        <ant antfile="${lib-base}/xerces/build.xml"/>
+    </target>
+
+    <!-- asm -->
+    <property name="asm-verison" value="3.3"/>
+    <property name="asm-jar" value="${lib-base}/asm/dist/jar/asm-${asm-verison}.jar"/>
+    <property name="asm-commons-jar" value="${lib-base}/asm/dist/jar/asm-commons-${asm-verison}.jar"/>
+    <target name="asm">
+      <ant antfile="${lib-base}/asm/build.xml"/>
+    </target>
+
+</project>
diff --git a/benchmarks/bms/Featherlight/lucene-build.xml b/benchmarks/bms/Featherlight/lucene-build.xml
new file mode 100644
index 0000000..eed6e3a
--- /dev/null
+++ b/benchmarks/bms/Featherlight/lucene-build.xml
@@ -0,0 +1,650 @@
+<?xml version="1.0"?>
+
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+ 
+        http://www.apache.org/licenses/LICENSE-2.0
+ 
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ -->
+
+<project name="core" default="default" basedir=".">
+
+  <property name="junit.includes" value="**/Test*.java"/>
+
+  <import file="common-build.xml"/>
+  <import file="../../../../path.xml"/>
+
+  <property name="build.demo.template" value="src/demo/demo-build.template"/> 
+
+  <property name="demo.name" value="lucene-demos-${version}"/>
+  <property name="demo.war.name" value="luceneweb"/>
+
+  <!-- Type of checksum to compute for distribution files -->
+  <property name="checksum.algorithm" value="md5" />
+	
+  <!-- Build classpath -->
+  <path id="classpath">
+    <pathelement location="${build.dir}/classes/java"/>
+    <pathelement location="${jikesrvm-path}"/>
+  </path>
+
+  <path id="demo.classpath">
+    <path refid="classpath"/>
+    <pathelement location="${build.dir}/classes/demo"/>
+  </path>
+  
+  <path id="test.classpath">
+    <path refid="demo.classpath"/>
+    <path refid="junit-path"/>
+    <pathelement location="${build.dir}/classes/test"/>
+  </path>
+
+
+  <path id="junit.classpath">
+    <path refid="junit-path"/>
+    <pathelement location="${build.dir}/classes/test"/>
+    <pathelement location="${build.dir}/classes/java"/>
+    <pathelement location="${build.dir}/classes/demo"/>
+    <pathelement path="${java.class.path}"/>
+  </path>
+
+  <patternset id="src.dist.patterns"
+              includes="src/,build.xml,*build*.xml,docs/,*.txt,contrib/,*pom.xml*"
+              excludes="contrib/db/*/lib/,contrib/*/ext-libs/,src/site/build/,contrib/benchmark/temp/*,contrib/benchmark/work/*"
+  />
+  <patternset id="binary.build.dist.patterns"
+              includes="${final.name}.jar,${demo.war.name}.war,${demo.name}.jar,docs/,contrib/*/*.jar"
+  />
+  <patternset id="binary.root.dist.patterns"
+              includes="src/demo/,src/jsp/,docs/,*.txt,contrib/*/README*,**/CHANGES.txt"
+              excludes="${build.demo.template}"
+  />
+
+
+  <!-- ================================================================== -->
+  <!-- Prepares the build directory                                       -->
+  <!-- ================================================================== -->
+
+  <!-- Overrides common.compile-core to add rmic -->
+  <target name="compile-core" depends="common.compile-core"
+          description="Compiles core classes, including rmic">
+    <rmic classname="org.apache.lucene.search.RemoteSearchable"
+      base="${build.dir}/classes/java" stubversion="1.2">
+      <classpath refid="classpath"/>
+    </rmic>
+  </target>
+
+  <target name="test-core" depends="common.test"
+          description="Runs unit tests for the core Lucene code"
+  />
+  <target name="test" depends="test-core, test-contrib"
+          description="Runs all unit tests (including contribs)"
+  />
+  
+  <!-- ================================================================== -->
+  <!-- J A R                                                              -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+
+  <target name="jar-demo" depends="compile-demo">
+  	<sequential>
+  	  <build-manifest title="Lucene Search Engine: demos"/>
+      <jar
+        destfile="${build.dir}/${demo.name}.jar"
+        basedir="${build.dir}/classes/demo"
+        excludes="**/*.java"
+      	manifest="${manifest.file}">
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </jar>
+  	</sequential>
+  </target>
+
+  <target name="jar-demo-src" depends="compile-demo">
+  	<sequential>
+  	  <build-manifest title="Lucene Search Engine: demos"/>
+      <jar
+        destfile="${build.dir}/${demo.name}-src.jar"
+        basedir="src/demo"
+      	manifest="${manifest.file}">
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </jar>
+  	</sequential>
+  </target>
+
+  <target name="war-demo" depends="jar-core,jar-demo">
+    <sequential>
+      <build-manifest title="Lucene Search Engine: demos"/>
+  	  <war destfile="${build.dir}/${demo.war.name}.war"
+           webxml="src/jsp/WEB-INF/web.xml"
+      	   manifest="${manifest.file}">
+        <fileset dir="src/jsp" excludes="WEB-INF/web.xml"/>
+        <lib dir="${build.dir}" includes="${demo.name}.jar"/>
+        <lib dir="${build.dir}" includes="${final.name}.jar"/>
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </war>
+    </sequential>
+  </target>
+
+
+  <!-- ================================================================== -->
+  <!-- B U I L D  D E M O                                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="compile-demo" depends="compile-core">
+    <mkdir dir="${build.dir}/classes/demo"/>
+
+    <compile
+      srcdir="src/demo"
+      destdir="${build.dir}/classes/demo">
+      <classpath refid="demo.classpath"/>
+    </compile>
+  </target>
+
+  <!-- GCJ -->
+  <target name="gcj" depends="jar,jar-demo">
+    <exec executable="make" dir="src/gcj" failonerror="true"/>
+  </target>
+
+
+  <!-- TODO: Remove dependency on demo from test -->
+  <target name="compile-test" depends="compile-demo,common.compile-test"/>
+
+
+
+  <!-- ================================================================== -->
+  <!-- D O C U M E N T A T I O N                                          -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="docs" description="Build the website">
+      <echo>DEPRECATED - Doing Nothing.  See http://wiki.apache.org/lucene-java/HowToUpdateTheWebsite</echo>
+  </target>
+
+  <target name="javadocs" description="Generate javadoc" 
+  	      depends="javadocs-all, javadocs-core, javadocs-demo, javadocs-contrib"/>
+	
+  <target name="javadocs-core" description="Generate javadoc for core classes">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}/core"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}/core"
+      	title="${Name} ${version} core API">
+        <sources>
+          <packageset dir="src/java"/>
+          <link href="../"/>
+        </sources>
+      </invoke-javadoc>
+     <jarify basedir="${javadoc.dir}/core" destfile="${build.dir}/${final.name}-javadoc.jar"/>
+    </sequential>
+  </target>
+
+  <target name="javadocs-demo" description="Generate javadoc for demo classes">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}/demo"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}/demo"
+      	title="${Name} ${version} demo API">
+        <sources>
+          <packageset dir="src/demo"/>
+          <link href="../"/>
+        </sources>
+      </invoke-javadoc>
+      <jarify basedir="${javadoc.dir}/demo" destfile="${build.dir}/${demo.name}-javadoc.jar"/>
+    </sequential>
+  </target>
+	
+  <target name="javadocs-contrib" description="Generate javadoc for contrib classes">
+    <contrib-crawl target="javadocs"
+                   failonerror="false"/>
+  </target>
+  	
+  <target name="javadocs-all" description="Generate javadoc for core, demo and contrib classes" depends="build-contrib">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}">
+        <sources>
+          <!-- TODO: find a dynamic way to do include multiple source roots -->
+          <packageset dir="src/java"/>
+
+          <packageset dir="src/demo"/>
+
+          <!-- please keep this list up to date, and in alpha order...   -->
+        
+          <!-- ie: `find contrib/* -path \*src/java | sort` -->
+
+          <!-- if you make changes to the list of package sets, also -->
+          <!-- make sure the group list below is updated.            -->
+          <!-- Also remember to keep site.xml in sync.            -->		  
+
+          <packageset dir="contrib/analyzers/src/java"/>
+          <packageset dir="contrib/ant/src/java"/>
+          <packageset dir="contrib/benchmark/src/java"/>
+          <packageset dir="contrib/db/bdb-je/src/java"/>
+          <packageset dir="contrib/db/bdb/src/java"/>
+          <packageset dir="contrib/highlighter/src/java"/>
+          <packageset dir="contrib/instantiated/src/java"/>
+          <packageset dir="contrib/lucli/src/java"/>
+          <packageset dir="contrib/memory/src/java"/>
+          <packageset dir="contrib/miscellaneous/src/java"/>
+          <packageset dir="contrib/queries/src/java"/>
+          <packageset dir="contrib/regex/src/java"/>
+          <packageset dir="contrib/similarity/src/java"/>
+          <packageset dir="contrib/snowball/src/java"/>
+          <packageset dir="contrib/spellchecker/src/java"/>
+          <packageset dir="contrib/surround/src/java"/>
+          <packageset dir="contrib/swing/src/java"/>
+          <packageset dir="contrib/wikipedia/src/java"/>
+          <packageset dir="contrib/wordnet/src/java"/>
+          <packageset dir="contrib/xml-query-parser/src/java"/>
+          <!-- end alpha sort -->
+
+          <!-- If the main javadoc Group listing includes an "Other   -->
+          <!-- Packages" group after the ones listed here, then those -->
+          <!-- packages are not being matched by any of these rules   -->
+  
+          <group title="Core" packages="org.apache.*:org.apache.lucene.analysis:org.apache.lucene.analysis.standard*"/>
+  
+          <group title="Demo" packages="org.apache.lucene.demo*"/>
+  
+          <group title="contrib: Analysis" packages="org.apache.lucene.analysis.*"/>
+          <group title="contrib: Ant" packages="org.apache.lucene.ant*"/>
+          <group title="contrib: Benchmark" packages="org.apache.lucene.benchmark*"/>
+          <group title="contrib: DB" packages="org.apache.lucene.store.db*:org.apache.lucene.store.je*:com.sleepycat*"/>
+          <group title="contrib: Highlighter" packages="org.apache.lucene.search.highlight*"/>
+          <group title="contrib: Instantiated" packages="org.apache.lucene.store.instantiated*"/>
+          <group title="contrib: Lucli" packages="lucli*"/>
+          <group title="contrib: Memory" packages="org.apache.lucene.index.memory*"/>
+          <group title="contrib: Miscellaneous " packages="org.apache.lucene.misc*:org.apache.lucene.queryParser.analyzing*:org.apache.lucene.queryParser.precedence*"/>
+          <group title="contrib: Queries" packages="org.apache.lucene.search.similar*"/>
+          <group title="contrib: RegEx" packages="org.apache.lucene.search.regex*:org.apache.regexp*"/>
+          <!-- no group for similarity. -->
+          <!-- nothing in there at the moment, so no package structure -->
+          <group title="contrib: Snowball" packages="org.apache.lucene.analysis.snowball*:net.sf.snowball*"/>
+
+          <group title="contrib: SpellChecker" packages="org.apache.lucene.search.spell*"/>
+          <group title="contrib: Surround Parser" packages="org.apache.lucene.queryParser.surround*"/>
+          <group title="contrib: Swing" packages="org.apache.lucene.swing*"/>
+          <group title="contrib: Wikipedia" packages="org.apache.lucene.wikipedia*"/>
+          <group title="contrib: WordNet" packages="org.apache.lucene.wordnet*"/>
+          <group title="contrib: XML Query Parser" packages="org.apache.lucene.xmlparser*"/>
+
+        </sources>
+      </invoke-javadoc>
+  	</sequential>
+  </target>
+
+
+  <!-- ================================================================== -->
+  <!-- D I S T R I B U T I O N                                            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package" depends="jar-core, javadocs, war-demo, build-contrib, init-dist">
+     <copy file="${build.demo.template}" tofile="${build.dir}/build-demo.xml">
+        <filterset begintoken="@PLACEHOLDER_" endtoken="@"> 
+	  <filter token="version" value="${version}"/>
+	  <filter token="javac.source" value="${javac.source}"/>
+	  <filter token="javac.target" value="${javac.target}"/>
+        </filterset>
+     </copy>
+  </target>
+
+  <target name="nightly" depends="test, package-tgz, changes-to-html">
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the distribution with zip                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-zip" depends="package"
+    description="--> Generates the Lucene distribution as .zip">
+
+    <delete file="${dist.dir}/lucene-${version}.zip"/>
+    <zip destfile="${dist.dir}/lucene-${version}.zip">
+      <zipfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="binary.root.dist.patterns"/>
+      </zipfileset>
+      <zipfileset dir="${build.dir}" includes="build-demo.xml" fullpath="lucene-${version}/build.xml"/>
+      <zipfileset prefix="lucene-${version}" dir="${build.dir}">
+        <patternset refid="binary.build.dist.patterns"/>
+      </zipfileset>
+    </zip>
+	<lucene-checksum file="${dist.dir}/lucene-${version}.zip"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- packages the distribution with tar-gzip                            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-tgz" depends="package"
+    description="--> Generates the lucene distribution as .tar.gz">
+
+    <delete file="${build.dir}/lucene-${version}.tar"/>
+    <delete file="${dist.dir}/lucene-${version}.tar.gz"/>
+    <tar tarfile="${build.dir}/lucene-${version}.tar">
+      <tarfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="binary.root.dist.patterns"/>
+      </tarfileset>
+      <tarfileset dir="${build.dir}" includes="build-demo.xml" fullpath="lucene-${version}/build.xml"/>
+      <tarfileset prefix="lucene-${version}" dir="${build.dir}">
+        <patternset refid="binary.build.dist.patterns"/>
+      </tarfileset>
+    </tar>
+
+    <gzip zipfile="${dist.dir}/lucene-${version}.tar.gz"
+      src="${build.dir}/lucene-${version}.tar"
+      />
+	<lucene-checksum file="${dist.dir}/lucene-${version}.tar.gz"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- packages the distribution with zip and tar-gzip                    -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-all-binary" depends="package-zip, package-tgz"
+    description="--> Generates the .tar.gz and .zip distributions"/>
+
+  <!-- ================================================================== -->
+  <!-- same as package-all. it is just here for compatibility.            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="dist" depends="package-all-binary"/>
+
+  <!-- ================================================================== -->
+  <!-- S O U R C E  D I S T R I B U T I O N                               -->
+  <!-- ================================================================== -->
+    <target name="init-dist" >
+
+        <!-- Package is not called first if packaging src standalone, so the dist.dir may not exist -->
+        <mkdir dir="${build.dir}"/>
+        <mkdir dir="${dist.dir}"/>
+        <mkdir dir="${maven.dist.dir}"/>
+    </target>
+  <!-- ================================================================== -->
+  <!-- Packages the sources with zip                                      -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-zip-src" depends="init, init-dist"
+    description="--> Generates the Lucene sources as .zip">
+    <zip destfile="${dist.dir}/lucene-${version}-src.zip">
+      <zipfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="src.dist.patterns"/>
+      </zipfileset>
+    </zip>
+	<lucene-checksum file="${dist.dir}/lucene-${version}-src.zip"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the sources with tar-gzip                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-tgz-src" depends="init, init-dist"
+    description="--> Generates the Lucene distribution as .tar.gz">
+
+    <delete file="${build.dir}/lucene-${version}-src.tar"/>
+    <delete file="${dist.dir}/lucene-${version}-src.tar.gz"/>
+    <tar tarfile="${build.dir}/lucene-${version}-src.tar">
+      <tarfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="src.dist.patterns"/>
+      </tarfileset>
+    </tar>
+
+    <gzip zipfile="${dist.dir}/lucene-${version}-src.tar.gz"
+          src="${build.dir}/lucene-${version}-src.tar"
+    />
+	<lucene-checksum file="${dist.dir}/lucene-${version}-src.tar.gz"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the sources with zip and tar-gzip                         -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-all-src" depends="package-zip-src, package-tgz-src"
+    description="--> Generates the .tar.gz and .zip source distributions"/>
+
+  <!-- ================================================================== -->
+  <!-- same as package-all-src. it is just here for compatibility.        -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="dist-src" depends="package-all-src"/>
+
+  <target name="dist-all" depends="dist, dist-src"/>
+
+  <target name="generate-maven-artifacts" depends="maven.ant.tasks-check, package, jar-src, jar-demo-src, javadocs">
+    <sequential>
+      <m2-deploy pom.xml="lucene-parent-pom.xml.template"/>
+      <m2-deploy pom.xml="lucene-core-pom.xml.template">
+        <artifact-attachments>
+          <attach file="${build.dir}/${final.name}-src.jar"
+                  classifier="sources"/>
+          <attach file="${build.dir}/${final.name}-javadoc.jar"
+                  classifier="javadoc"/>
+        </artifact-attachments>
+      </m2-deploy>
+      
+      <m2-deploy pom.xml="lucene-demos-pom.xml.template">
+        <artifact-attachments>
+          <attach file="${build.dir}/${demo.name}-src.jar"
+                  classifier="sources"/>
+          <attach file="${build.dir}/${demo.name}-javadoc.jar"
+                  classifier="javadoc"/>
+        </artifact-attachments>
+      </m2-deploy>
+      
+      <m2-deploy pom.xml="lucene-contrib-pom.xml.template"/>
+      <contrib-crawl target="dist-maven"/>
+    </sequential>
+  </target>
+	
+  <!-- ================================================================== -->
+  <!-- Build the JavaCC files into the source tree                        -->
+  <!-- ================================================================== -->
+  <target name="jjdoc">
+    <mkdir dir="${build.dir}/docs/grammars"/>
+    <jjdoc target="src/java/org/apache/lucene/queryParser/QueryParser.jj"
+           outputfile="${build.dir}/docs/grammars/QueryParser.html"
+           javacchome="${javacc.home}"
+    />
+    <jjdoc target="src/java/org/apache/lucene/analysis/standard/StandardTokenizer.jj"
+           outputfile="${build.dir}/docs/grammars/StandardTokenizer.html"
+           javacchome="${javacc.home}"
+    />
+    <jjdoc target="src/demo/org/apache/lucene/demo/html/HTMLParser.jj"
+           outputfile="${build.dir}/docs/grammars/HTMLParser.html"
+           javacchome="${javacc.home}"
+    />
+  </target>
+
+  <target name="clean-javacc">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/analysis/standard" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+        <exclude name="ParseException.java"/>
+      </fileset>
+      <fileset dir="src/java/org/apache/lucene/queryParser" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+      <fileset dir="src/demo/org/apache/lucene/demo/html" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+    </delete>
+  </target>
+
+  <target name="javacc" depends="clean-javacc,javacc-QueryParser,javacc-HTMLParser"/>
+
+  <target name="javacc-QueryParser" depends="init,javacc-check" if="javacc.present">
+    <invoke-javacc target="src/java/org/apache/lucene/queryParser/QueryParser.jj"
+                   outputDir="src/java/org/apache/lucene/queryParser"
+    />
+  </target>
+  
+  <target name="javacc-HTMLParser" depends="init,javacc-check" if="javacc.present">
+    <invoke-javacc target="src/demo/org/apache/lucene/demo/html/HTMLParser.jj"
+                   outputDir="src/demo/org/apache/lucene/demo/html"
+    />
+  </target>
+  
+  <!-- ================================================================== -->
+  <!-- Build the JFlex files into the source tree                         -->
+  <!-- ================================================================== -->
+
+  <target name="jflex" depends="clean-jflex,jflex-StandardAnalyzer" />
+
+  <target name="jflex-StandardAnalyzer" depends="init,jflex-check" if="jflex.present">
+    <taskdef classname="JFlex.anttask.JFlexTask" name="jflex">
+      <classpath location="${jflex.home}/lib/JFlex.jar" />
+    </taskdef>
+
+    <jflex file="src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex"
+           outdir="src/java/org/apache/lucene/analysis/standard"
+           nobak="on" />
+  </target>
+
+  <target name="clean-jflex">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/analysis/standard" includes="*.java">
+        <containsregexp expression="generated.*by.*JFlex"/>
+      </fileset>
+    </delete>
+  </target>
+
+  <macrodef name="contrib-crawl">
+    <attribute name="target" default=""/>
+    <attribute name="failonerror" default="true"/>
+    <sequential>
+      <subant target="@{target}" failonerror="@{failonerror}">
+        <fileset dir="."
+                 includes="contrib/*/build.xml"
+        />
+      </subant>
+    </sequential>
+  </macrodef>
+
+  <target name="build-contrib"
+          description="Builds all contrib modules and their tests">
+    <contrib-crawl target="build-artifacts-and-tests"/>
+  </target>
+
+  <target name="test-contrib" depends="build-contrib">
+    <!-- Don't fail on error, instead check for flag file so we run
+         all the tests possible and can "ant generate-test-reports"
+         for all of them.
+
+         Because of this, we depend on "build-contrib" even though the
+         Individual contrib "test" targets probably have the
+         neccessary dependencies.  If they fail to compile, we won't
+         know about it.
+     -->
+    <contrib-crawl target="test" failonerror="false"/>
+    <available property="contribs.failed" file="junitfailed.flag">
+      <filepath>
+        <dirset dir="${build.dir}/contrib/">
+          <include name="**/test/" />
+        </dirset>
+      </filepath>
+    </available>
+    <fail if="contribs.failed">Contrib tests failed!</fail>
+  </target>
+
+  <!-- Macro for building checksum files
+       This is only needed until the "format" option is supported
+       by ant's built in checksum task
+   -->
+  <macrodef name="lucene-checksum">
+    <attribute name="file"/>
+    <!-- NOTE: we use the value of @{file} in the names any properties
+         set because macro's don't have variables, and otherwise we
+         wouldn't be able to checksum more then one file per build
+      -->
+    <sequential>
+      <checksum file="@{file}"
+                property="@{file}.sum"
+                algorithm="${checksum.algorithm}" />
+      <basename file="@{file}" property="@{file}.base" />
+      <concat destfile="@{file}.${checksum.algorithm}"
+              force="yes"
+              append="false"
+              fixlastline="yes">
+        <header trimleading="yes">${@{file}.sum}  </header>
+        <!-- empty fileset to trick concat -->
+        <fileset dir="." excludes="**" />
+        <footer trimleading="yes">${@{file}.base}
+        </footer>
+      </concat>
+    </sequential>
+  </macrodef>
+
+  <!--
+   compile changes.txt into an html file
+   -->
+
+  <target name="changes-to-html">
+    <mkdir dir="${changes.target.dir}"/>
+    <exec executable="perl" input="CHANGES.txt" output="${changes.target.dir}/Changes.html" failonerror="true">
+      <arg value="${changes.src.dir}/changes2html.pl"/>
+    </exec>
+    <copy todir="${changes.target.dir}">
+      <fileset dir="${changes.src.dir}" includes="*.css"/>
+    </copy>
+  </target>
+
+  <!--
+   Committer helpers
+   -->
+
+  <property name="patch.file" value="${basedir}/../patches/${patch.name}"/>
+  <!-- Apply a patch.  Assumes  patch can be applied in the basedir.
+  -Dpatch.name assumes the patch is located in ${basedir}/../patches/${patch.name}
+  -Dpatch.file means the patch can be located anywhere on the file system
+  -->
+  <target name="apply-patch" depends="clean" description="Apply a patch file.  Set -Dpatch.file, or -Dpatch.name when the patch is in the directory ../patches/">
+    <patch patchfile="${patch.file}" strip="0"/>
+  </target>
+
+  <target name="rat-sources-typedef">
+    <typedef resource="org/apache/rat/anttasks/antlib.xml" uri="antlib:rat.anttasks">
+      <classpath>
+        <fileset dir="." includes="rat*.jar"/>
+      </classpath>
+    </typedef>
+  </target>
+
+  <target name="rat-sources" depends="rat-sources-typedef"
+	  description="runs the tasks over src/java">
+    <rat:report xmlns:rat="antlib:org.apache.rat.anttasks">
+      <fileset dir="src/java">
+      </fileset>
+    </rat:report>
+  </target>
+
+</project>
diff --git a/benchmarks/bms/ForkJoin/Makefile b/benchmarks/bms/ForkJoin/Makefile
new file mode 100755
index 0000000..416013e
--- /dev/null
+++ b/benchmarks/bms/ForkJoin/Makefile
@@ -0,0 +1,17 @@
+all:
+	cp Search.java ../lusearch-fix/src/org/dacapo/lusearchFix/Search.java
+	cp ./bms-lusearch-fix-build.xml  ../lusearch-fix/build.xml
+	cp ./libs.xml ../../libs/.
+	wget -c http://archive.apache.org/dist/lucene/java/lucene-2.4.1-src.tar.gz
+	mv lucene-2.4.1-src.tar.gz ../../libs/lucene/downloads/.
+	wget -c http://archive.apache.org/dist/commons/cli/binaries/commons-cli-1.2-bin.tar.gz
+	mv commons-cli-1.2-bin.tar.gz ../../harness/downloads/
+	cd ../../libs/lucene/downloads; tar xvfz lucene-2.4.1-src.tar.gz
+	cp QueryParserTokenManager.java ../../libs/lucene/downloads/lucene-2.4.1/src/java/org/apache/lucene/queryParser/.
+	cp lucene-build.xml  ../../libs/lucene/downloads/lucene-2.4.1/build.xml
+	rm ../../libs/lucene/downloads/lucene-2.4.1-src.tar.gz || true
+	cp -rf ../../libs/lucene/downloads/lucene-2.4.1 .
+	tar cvfz lucene-2.4.1-src.tar.gz lucene-2.4.1
+	rm -rf lucene-2.4.1
+	mv lucene-2.4.1-src.tar.gz ../../libs/lucene/downloads/.
+	cd ../../; ant clean lusearch-fix
diff --git a/benchmarks/bms/ForkJoin/QueryParserTokenManager.java b/benchmarks/bms/ForkJoin/QueryParserTokenManager.java
new file mode 100644
index 0000000..3347108
--- /dev/null
+++ b/benchmarks/bms/ForkJoin/QueryParserTokenManager.java
@@ -0,0 +1,1185 @@
+/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */
+package org.apache.lucene.queryParser;
+import java.io.IOException;
+import java.io.StringReader;
+import java.text.DateFormat;
+import java.text.Collator;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Vector;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.document.DateField;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.ConstantScoreRangeQuery;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.util.Parameter;
+
+/** Token Manager. */
+public class QueryParserTokenManager implements QueryParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_3(int pos, long active0)
+{
+   switch (pos)
+   {
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_3(int pos, long active0)
+{
+   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_3()
+{
+   switch(curChar)
+   {
+      case 40:
+         return jjStopAtPos(0, 13);
+      case 41:
+         return jjStopAtPos(0, 14);
+      case 42:
+         return jjStartNfaWithStates_3(0, 16, 36);
+      case 43:
+         return jjStopAtPos(0, 11);
+      case 45:
+         return jjStopAtPos(0, 12);
+      case 58:
+         return jjStopAtPos(0, 15);
+      case 91:
+         return jjStopAtPos(0, 23);
+      case 94:
+         return jjStopAtPos(0, 17);
+      case 123:
+         return jjStopAtPos(0, 24);
+      default :
+         return jjMoveNfa_3(0, 0);
+   }
+}
+private int jjStartNfaWithStates_3(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_3(state, pos + 1);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_3(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 36;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+               case 25:
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 0:
+                  if ((0xfbffd4f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  else if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  else if (curChar == 33)
+                  {
+                     if (kind > 10)
+                        kind = 10;
+                  }
+                  if ((0x7bffd0f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  else if (curChar == 42)
+                  {
+                     if (kind > 21)
+                        kind = 21;
+                  }
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 4:
+                  if (curChar == 38 && kind > 8)
+                     kind = 8;
+                  break;
+               case 5:
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 13:
+                  if (curChar == 33 && kind > 10)
+                     kind = 10;
+                  break;
+               case 14:
+                  if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 15:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 18:
+                  if (curChar == 34 && kind > 18)
+                     kind = 18;
+                  break;
+               case 20:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjAddStates(8, 9);
+                  break;
+               case 21:
+                  if (curChar == 46)
+                     jjCheckNAdd(22);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjCheckNAdd(22);
+                  break;
+               case 23:
+                  if (curChar == 42 && kind > 21)
+                     kind = 21;
+                  break;
+               case 24:
+                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 27:
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if ((0x7bffd0f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+                  if ((0x7bfff8f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 31:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+                  if ((0x7bfff8f8ffffd9ffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 34:
+                  jjCheckNAddStates(10, 12);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddTwoStates(27, 27);
+                  break;
+               case 0:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddStates(13, 15);
+                  else if (curChar == 126)
+                  {
+                     if (kind > 20)
+                        kind = 20;
+                     jjstateSet[jjnewStateCnt++] = 20;
+                  }
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  else if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  else if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  else if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 1:
+                  if (curChar == 68 && kind > 8)
+                     kind = 8;
+                  break;
+               case 2:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 3:
+                  if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 6:
+                  if (curChar == 82 && kind > 9)
+                     kind = 9;
+                  break;
+               case 7:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  break;
+               case 8:
+                  if (curChar == 124 && kind > 9)
+                     kind = 9;
+                  break;
+               case 9:
+                  if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 10:
+                  if (curChar == 84 && kind > 10)
+                     kind = 10;
+                  break;
+               case 11:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 12:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  break;
+               case 15:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 16:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 17;
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 19:
+                  if (curChar != 126)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjstateSet[jjnewStateCnt++] = 20;
+                  break;
+               case 24:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 25:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 26:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(27, 27);
+                  break;
+               case 27:
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 30:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(31, 31);
+                  break;
+               case 31:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 33:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(34, 34);
+                  break;
+               case 34:
+                  jjCheckNAddStates(10, 12);
+                  break;
+               case 35:
+                  if (curChar == 92)
+                     jjCheckNAddStates(13, 15);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+               case 25:
+               case 27:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  break;
+               case 15:
+               case 17:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 24:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+               case 31:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+               case 34:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(10, 12);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { 
+        return curPos; 
+      }
+   }
+}
+private final int jjStopStringLiteralDfa_1(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x40000000L) != 0L)
+         {
+            jjmatchedKind = 33;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_1(int pos, long active0)
+{
+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_1(0x40000000L);
+      case 125:
+         return jjStopAtPos(0, 31);
+      default :
+         return jjMoveNfa_1(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_1(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x40000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 30, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_1(0, active0);
+}
+private int jjStartNfaWithStates_1(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_1(state, pos + 1);
+}
+private int jjMoveNfa_1(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 33)
+                        kind = 33;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 32)
+                     kind = 32;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xdfffffffffffffffL & l) == 0L)
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(16, 18);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(16, 18);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   return jjMoveNfa_0(0, 0);
+}
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 3;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 25)
+                     kind = 25;
+                  jjAddStates(19, 20);
+                  break;
+               case 1:
+                  if (curChar == 46)
+                     jjCheckNAdd(2);
+                  break;
+               case 2:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 25)
+                     kind = 25;
+                  jjCheckNAdd(2);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjStopStringLiteralDfa_2(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x4000000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_2(int pos, long active0)
+{
+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_2(0x4000000L);
+      case 93:
+         return jjStopAtPos(0, 27);
+      default :
+         return jjMoveNfa_2(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 26, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(0, active0);
+}
+private int jjStartNfaWithStates_2(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_2(state, pos + 1);
+}
+private int jjMoveNfa_2(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 29)
+                        kind = 29;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 28)
+                     kind = 28;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xffffffffdfffffffL & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(16, 18);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(16, 18);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+static final int[] jjnextStates = {
+   15, 16, 18, 29, 32, 23, 33, 30, 20, 21, 32, 23, 33, 31, 34, 27, 
+   2, 4, 5, 0, 1, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
+"\50", "\51", "\72", "\52", "\136", null, null, null, null, null, "\133", "\173", 
+null, "\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "Boost",
+   "RangeEx",
+   "RangeIn",
+   "DEFAULT",
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 
+   3, -1, 3, -1, -1, -1, 3, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x3ffffff01L, 
+};
+static final long[] jjtoSkip = {
+   0x80L, 
+};
+protected CharStream input_stream;
+private final int[] jjrounds = new int[36];
+private final int[] jjstateSet = new int[72];
+protected char curChar;
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream){
+   input_stream = stream;
+}
+
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 36; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 4 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 3;
+int defaultLexState = 3;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      return matchedToken;
+   }
+
+   switch(curLexState)
+   {
+     case 0:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_0();
+       break;
+     case 1:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_1();
+       break;
+     case 2:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_2();
+       break;
+     case 3:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_3();
+       break;
+   }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else
+        {
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/benchmarks/bms/ForkJoin/Search.java b/benchmarks/bms/ForkJoin/Search.java
new file mode 100644
index 0000000..c618c5a
--- /dev/null
+++ b/benchmarks/bms/ForkJoin/Search.java
@@ -0,0 +1,330 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Contributors:
+ *     Apache Software Foundation 
+ *     Australian National University - adaptation to DaCapo test harness
+ */
+package org.dacapo.lusearchFix;
+
+import jsr166y.*;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.FilterIndexReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.TopDocCollector;
+
+/**
+ * Simple command-line based search demo.
+ * 
+ * @date $Date: 2009-12-24 11:19:36 +1100 (Thu, 24 Dec 2009) $
+ * @id $Id: Search.java 738 2009-12-24 00:19:36Z steveb-oss $
+ */
+public class Search {
+
+  static final int MAX_DOCS_TO_COLLECT = 20;
+  private ForkJoinPool pool;
+  public int completed = 0;
+  private int COMPLETION_GOAL; 
+
+  /**
+   * Use the norms from one field for all fields. Norms are read into memory,
+   * using a byte of memory per document per searched field. This can cause
+   * search of large collections with a large number of fields to run out of
+   * memory. If all of the fields contain only a single token, then the norms
+   * are all identical, then single norm vector may be shared.
+   */
+  private static class OneNormsReader extends FilterIndexReader {
+    private String field;
+
+    public OneNormsReader(IndexReader in, String field) {
+      super(in);
+      this.field = field;
+    }
+
+    public byte[] norms(String field) throws IOException {
+      return in.norms(this.field);
+    }
+  }
+
+  public Search() {
+  }
+
+  /** Simple command-line based search demo. */
+  public void main(String[] args) throws Exception {
+    String usage = "Usage:\tjava org.dacapo.lusearchFix.Search [-index dir] [-field f] [-repeat n] [-queries file] [-raw] [-norms field] [-paging hitsPerPage]";
+    usage += "\n\tSpecify 'false' for hitsPerPage to use streaming instead of paging search.";
+    if (args.length > 0 && ("-h".equals(args[0]) || "-help".equals(args[0]))) {
+      System.out.println(usage);
+      System.exit(0);
+    }
+
+    String index = "index";
+    String field = "contents";
+    String queryBase = null;
+    int repeat = 0;
+    boolean raw = false;
+    String normsField = null;
+    int hitsPerPage = 10;
+    String outBase = null;
+    int threads = 1;
+    int totalQueries = 32;
+
+    for (int i = 0; i < args.length; i++) {
+      if ("-index".equals(args[i])) {
+        index = args[i + 1];
+        i++;
+      } else if ("-field".equals(args[i])) {
+        field = args[i + 1];
+        i++;
+      } else if ("-queries".equals(args[i])) {
+        queryBase = args[i + 1];
+        i++;
+      } else if ("-repeat".equals(args[i])) {
+        repeat = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-raw".equals(args[i])) {
+        raw = true;
+      } else if ("-norms".equals(args[i])) {
+        normsField = args[i + 1];
+        i++;
+      } else if ("-paging".equals(args[i])) {
+        hitsPerPage = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-output".equals(args[i])) {
+        outBase = args[i + 1];
+        i++;
+      } else if ("-threads".equals(args[i])) {
+        threads = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-totalqueries".equals(args[i])) {
+        totalQueries = Integer.parseInt(args[i + 1]);
+        i++;
+      }
+    }
+    completed = 0;
+    this.pool = new ForkJoinPool(threads);
+    COMPLETION_GOAL = (int)( 0.8 * totalQueries);
+    final QueryThread[] queryThreads = new QueryThread[totalQueries];
+    for (int j = 0; j < totalQueries; j++) {
+      queryThreads[j] = new QueryThread(this, "Query" + j, j, threads, totalQueries, index, outBase, queryBase, field, normsField, raw, hitsPerPage);
+    }
+    try {
+      this.pool.invoke(new RecursiveAction() {
+        @Override
+        public void compute() {
+          for(int i=0; i<queryThreads.length; i++) {
+            final int index = i;
+            new RecursiveAction() {
+              @Override
+              public void compute() {
+                queryThreads[index].run();
+              }
+            }.fork();
+          }
+          helpQuiesce();
+        }
+      });
+    } catch(java.util.concurrent.CancellationException e) { }
+  }
+
+  class QueryThread {
+    Search parent;
+    int id;
+    int threadCount;
+    int totalQueries;
+    String name;
+    String index;
+    String outBase;
+    String queryBase;
+    String field;
+    String normsField;
+    boolean raw;
+    int hitsPerPage;
+
+    public QueryThread(Search parent, String name, int id, int threadCount, int totalQueries, String index, String outBase, String queryBase, String field,
+        String normsField, boolean raw, int hitsPerPage) {
+      //super(name);
+      this.parent = parent;
+      this.id = id;
+      this.threadCount = threadCount;
+      this.totalQueries = totalQueries;
+      this.name = name;
+      this.index = index;
+      this.outBase = outBase;
+      this.queryBase = queryBase;
+      this.field = field;
+      this.normsField = normsField;
+      this.raw = raw;
+      this.hitsPerPage = hitsPerPage;
+    }
+
+    public void run() {
+      try {
+        //int count = totalQueries / threadCount + (id < (totalQueries % threadCount) ? 1 : 0);
+        //for (int i = 0, queryId = id; i < count; i++, queryId += threadCount) {
+          // make and run query
+          new QueryProcessor(parent, name, id, index, outBase, queryBase, field, normsField, raw, hitsPerPage).run();
+        //}
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+
+  }
+
+  public class QueryProcessor {
+
+    Search parent;
+    String field;
+    int hitsPerPage;
+    boolean raw;
+
+    IndexReader reader;
+    Searcher searcher;
+    BufferedReader in;
+    PrintWriter out;
+
+    public QueryProcessor(Search parent, String name, int id, String index, String outBase, String queryBase, String field, String normsField, boolean raw,
+        int hitsPerPage) {
+      this.parent = parent;
+      this.field = field;
+      this.raw = raw;
+      this.hitsPerPage = hitsPerPage;
+      try {
+        reader = IndexReader.open(index);
+        if (normsField != null)
+          reader = new OneNormsReader(reader, normsField);
+        searcher = new IndexSearcher(reader);
+
+        String query = queryBase + (id < 10 ? "00" : (id < 100 ? "0" : "")) + id + ".txt";
+        in = new BufferedReader(new FileReader(query));
+        out = new PrintWriter(new BufferedWriter(new FileWriter(outBase + id)));
+
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+
+    public void run() throws java.io.IOException {
+      Analyzer analyzer = new StandardAnalyzer();
+      QueryParser parser = new QueryParser(field, analyzer);
+
+      while (true) {
+        String line = in.readLine();
+
+        if (line == null || line.length() == -1)
+          break;
+
+        line = line.trim();
+        if (line.length() == 0)
+          break;
+
+        Query query = null;
+        try {
+          query = parser.parse(line);
+        } catch (org.apache.lucene.queryParser.ParseException e) {
+          e.printStackTrace();
+        }
+        searcher.search(query, null, 10);
+
+        doPagingSearch(query);
+      }
+
+      reader.close();
+      out.flush();
+      out.close();
+     
+      synchronized (parent) {
+        ++parent.completed;
+        if (parent.completed % 4 == 0) {
+          System.out.println(parent.completed + " query batches completed");
+        }
+        //parent.notify();
+      }
+  
+      if(parent.completed >= parent.COMPLETION_GOAL) {
+        System.out.println("Aborting as "+parent.completed+" completed");
+        parent.pool.shutdownNow();
+      }
+    }
+
+    /**
+     * This demonstrates a typical paging search scenario, where the search
+     * engine presents pages of size n to the user. The user can then go to the
+     * next page if interested in the next hits.
+     * 
+     * When the query is executed for the first time, then only enough results
+     * are collected to fill 5 result pages. If the user wants to page beyond
+     * this limit, then the query is executed another time and all hits are
+     * collected.
+     * 
+     */
+    public void doPagingSearch(Query query) throws IOException {
+
+      // Collect enough docs to show 5 pages
+      TopDocCollector collector = new TopDocCollector(MAX_DOCS_TO_COLLECT);
+      searcher.search(query, collector);
+      ScoreDoc[] hits = collector.topDocs().scoreDocs;
+
+      int numTotalHits = collector.getTotalHits();
+      if (numTotalHits > 0)
+        out.println(numTotalHits + " total matching documents for " + query.toString(field));
+
+      int start = 0;
+      int end = Math.min(numTotalHits, hitsPerPage);
+
+      while (start < Math.min(MAX_DOCS_TO_COLLECT, numTotalHits)) {
+        end = Math.min(hits.length, start + hitsPerPage);
+
+        for (int i = start; i < end; i++) {
+          if (raw) { // output raw format
+            out.println("doc=" + hits[i].doc + " score=" + hits[i].score);
+            continue;
+          }
+
+          Document doc = searcher.doc(hits[i].doc);
+          String path = doc.get("path");
+          if (path != null) {
+            out.println("\t" + (i + 1) + ". " + path);
+            String title = doc.get("title");
+            if (title != null) {
+              out.println("   Title: " + doc.get("title"));
+            }
+          } else {
+            out.println((i + 1) + ". " + "No path for this document");
+          }
+
+        }
+        start = end;
+      }
+    }
+  }
+}
+
diff --git a/benchmarks/bms/ForkJoin/bms-lusearch-fix-build.xml b/benchmarks/bms/ForkJoin/bms-lusearch-fix-build.xml
new file mode 100644
index 0000000..9f0dc15
--- /dev/null
+++ b/benchmarks/bms/ForkJoin/bms-lusearch-fix-build.xml
@@ -0,0 +1,53 @@
+<!--
+ * Copyright (c) 2017 The Australian National University.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License v2.0.
+ * You may obtain the license at
+ *
+ *    http://www.opensource.org/licenses/apache2.0.php
+ -->
+<project name="lusearch-fix" default="all" basedir="../..">
+    <description>DaCapo lusearch-fix benchmark</description>
+    <property file="dacapo.properties"/>
+
+    <property name="bm-name" value="lusearch-fix"/>
+
+    <import file="../common.xml"/>
+
+    <target name="fix-operation">
+        <move file="libs/lucene/build.xml" tofile="libs/lucene/build-tmp.xml"/>
+        <copy file="libs/lucene/build-tmp.xml" tofile="libs/lucene/build.xml"/>
+        <touch file="libs/lucene/lucene.patch"/>
+        <patch patchfile="${bm-files}/lusearch-fix.patch" dir="${basedir}" strip="0" ignorewhitespace="yes"/>
+    </target>
+
+    <target name="bm-build" depends="fix-operation, lucene">
+        <mkdir dir="${bm-build-dir}"/>
+        <javac srcdir="${bm-src-dir}" source="1.5"
+               classpath="${harness-classpath}:${lucene-jars}/${lucene-core-jar-name}:${lucene-jars}/${lucene-demos-jar-name}:${jsr166y-jar}"
+               destdir="${bm-build-dir}"
+               includes="org/dacapo/lusearchFix/*" debug="true" debuglevel="lines,vars,source"/>
+        <delete file="libs/lucene/build.xml"/>
+        <delete file="libs/lucene/lucene.patch"/>
+        <move file="libs/lucene/build-tmp.xml" tofile="libs/lucene/build.xml"/>
+    </target>
+
+    <target name="jar">
+        <jar destfile="${bm-jars}/dacapo-${bm-name}.jar" basedir="${bm-build-dir}"/>
+    </target>
+
+    <target name="copy-data">
+        <mkdir dir="${bm-data}/lusearchFix"/>
+        <copy todir="${bm-data}/lusearchFix">
+            <fileset dir="bms/lusearch/data/lusearch">
+                <include name="**"/>
+            </fileset>
+        </copy>
+    </target>
+
+    <target name="data" depends="copy-data">
+        <zip basedir="${bm-data}" includes="**" destfile="${bm-dat}/${bm-name}.zip"/>
+        <delete dir="${bm-data}"/>
+    </target>
+
+</project>
diff --git a/benchmarks/bms/ForkJoin/libs.xml b/benchmarks/bms/ForkJoin/libs.xml
new file mode 100644
index 0000000..6726f0d
--- /dev/null
+++ b/benchmarks/bms/ForkJoin/libs.xml
@@ -0,0 +1,120 @@
+<!--
+ * Copyright (c) 2009 The Australian National University.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License v2.0.
+ * You may obtain the license at
+ * 
+ *    http://www.opensource.org/licenses/apache2.0.php
+ -->
+<project name="libs">
+    <property name="lib-base" value="${basedir}/libs"/>
+
+    <!-- bcel -->
+    <property name="bcel-jar" value="${lib-base}/bcel/dist/jar/bcel-5.2.jar"/>
+    <target name="bcel">
+        <ant antfile="${lib-base}/bcel/build.xml"/>
+    </target>
+
+    <!-- dacapo-digest -->
+    <property name="dacapo-digest-jar" value="${lib-base}/dacapo-digest/dist/jar/dacapo-digest.jar"/>
+    <target name="dacapo-digest">
+        <ant antfile="${lib-base}/dacapo-digest/build.xml"/>
+    </target>
+
+    <!-- daytrader -->
+    <target name="daytrader">
+        <ant antfile="${lib-base}/daytrader/build.xml"/>
+    </target>
+
+    <!-- jpetstore -->
+    <property name="jpetstore-common" value="${lib-base}/jpetstore/dist/jar/ibatis-common-2.jar"/>
+    <property name="jpetstore-dao" value="${lib-base}/jpetstore/dist/jar/ibatis-dao-2.jar"/>
+    <property name="jpetstore-sqlmap" value="${lib-base}/jpetstore/dist/jar/ibatis-sqlmap-2.jar"/>
+    <property name="jpetstore-jakarta-oro" value="${lib-base}/jpetstore/dist/jar/jakarta-oro.jar"/>
+    <property name="jpetstore-struts" value="${lib-base}/jpetstore/dist/jar/struts.jar"/>
+    <property name="jpetstore-zip" value="${lib-base}/jpetstore/dist/jar/jpetstore.zip"/>
+    <target name="jpetstore">
+        <ant antfile="${lib-base}/jpetstore/build.xml"/>
+    </target>
+
+    <!-- jakarta commons HTTP client -->
+    <property name="commons-httpclient-jar" value="${lib-base}/commons-httpclient/dist/jar/commons-httpclient.jar"/>
+    <target name="commons-httpclient" depends="commons-logging,commons-codec">
+        <ant antfile="${lib-base}/commons-httpclient/build.xml"/>
+    </target>
+
+    <!-- jakarta commons logging -->
+    <property name="commons-logging-jar" value="${lib-base}/commons-logging/dist/jar/commons-logging.jar"/>
+    <target name="commons-logging">
+        <ant antfile="${lib-base}/commons-logging/build.xml"/>
+    </target>
+
+    <!-- jakarta commons codec -->
+    <property name="commons-codec-jar" value="${lib-base}/commons-codec/dist/jar/commons-codec.jar"/>
+    <target name="commons-codec">
+        <ant antfile="${lib-base}/commons-codec/build.xml"/>
+    </target>
+
+    <!-- janino -->
+    <property name="janino-jar" value="${lib-base}/janino/dist/jar/janino-2.5.15.jar"/>
+    <target name="janino">
+        <ant antfile="${lib-base}/janino/build.xml"/>
+    </target>
+
+    <!-- jdbcbench -->
+    <property name="jdbcbench-jar" value="${lib-base}/jdbcbench/dist/jar/jdbcbench.jar"/>
+    <target name="jdbcbench">
+        <ant antfile="${lib-base}/jdbcbench/build.xml"/>
+    </target>
+
+    <!-- derby -->
+    <property name="derby-jar" value="${lib-base}/derby/dist/jar/derby.jar"/>
+    <property name="derbyclient-jar" value="${lib-base}/derby/dist/jar/derbyclient.jar"/>
+    <property name="derbynet-jar" value="${lib-base}/derby/dist/jar/derbynet.jar"/>
+    <property name="derbytools-jar" value="${lib-base}/derby/dist/jar/derbytools.jar"/>
+    <property name="derbytesting-jar" value="${lib-base}/derby/dist/jar/derbyTesting.jar"/>
+    <target name="derby">
+        <ant antfile="${lib-base}/derby/build.xml"/>
+    </target>
+
+    <!-- junit -->
+    <property name="junit-jar" value="${lib-base}/junit/dist/jar/junit-3.8.1.jar"/>
+    <target name="junit">
+        <ant antfile="${lib-base}/junit/build.xml"/>
+    </target>
+
+    <!-- h2-->
+    <property name="h2-version" value="1.2.121"/>
+    <property name="h2-jar" value="${lib-base}/h2/dist/jar/h2-${h2-version}.jar"/>
+    <target name="h2">
+        <ant antfile="${lib-base}/h2/build.xml"/>
+    </target>
+
+    <!-- lucene -->
+    <property name="lucene-jars" value="${lib-base}/lucene/dist/jar"/>
+    <property name="lucene-core-jar-name" value="lucene-core-2.4.jar"/>
+    <property name="lucene-demos-jar-name" value="lucene-demos-2.4.jar"/>
+    <target name="lucene">
+        <ant antfile="${lib-base}/lucene/build.xml"/>
+    </target>
+ 
+    <!-- jsr166y -->
+    <property name="jsr166y-jar" value="${lib-base}/../../../micro/jsr166y.jar"/>
+
+    <!-- xerces -->
+    <property name="xerces-jars" value="${lib-base}/xerces/dist/jar"/>
+    <property name="xerces-impl-jar-name" value="xercesImpl.jar"/>
+    <property name="xerces-api-jar-name" value="xml-apis.jar"/>
+    <target name="xerces">
+        <ant antfile="${lib-base}/xerces/build.xml"/>
+    </target>
+
+    <!-- asm -->
+    <property name="asm-verison" value="3.3"/>
+    <property name="asm-jar" value="${lib-base}/asm/dist/jar/asm-${asm-verison}.jar"/>
+    <property name="asm-commons-jar" value="${lib-base}/asm/dist/jar/asm-commons-${asm-verison}.jar"/>
+    <target name="asm">
+      <ant antfile="${lib-base}/asm/build.xml"/>
+    </target>
+
+</project>
diff --git a/benchmarks/bms/ForkJoin/lucene-build.xml b/benchmarks/bms/ForkJoin/lucene-build.xml
new file mode 100644
index 0000000..26d640a
--- /dev/null
+++ b/benchmarks/bms/ForkJoin/lucene-build.xml
@@ -0,0 +1,648 @@
+<?xml version="1.0"?>
+
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+ 
+        http://www.apache.org/licenses/LICENSE-2.0
+ 
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ -->
+
+<project name="core" default="default" basedir=".">
+
+  <property name="junit.includes" value="**/Test*.java"/>
+
+  <import file="common-build.xml"/>
+
+  <property name="build.demo.template" value="src/demo/demo-build.template"/> 
+
+  <property name="demo.name" value="lucene-demos-${version}"/>
+  <property name="demo.war.name" value="luceneweb"/>
+
+  <!-- Type of checksum to compute for distribution files -->
+  <property name="checksum.algorithm" value="md5" />
+	
+  <!-- Build classpath -->
+  <path id="classpath">
+    <pathelement location="${build.dir}/classes/java"/>
+  </path>
+
+  <path id="demo.classpath">
+    <path refid="classpath"/>
+    <pathelement location="${build.dir}/classes/demo"/>
+  </path>
+  
+  <path id="test.classpath">
+    <path refid="demo.classpath"/>
+    <path refid="junit-path"/>
+    <pathelement location="${build.dir}/classes/test"/>
+  </path>
+
+
+  <path id="junit.classpath">
+    <path refid="junit-path"/>
+    <pathelement location="${build.dir}/classes/test"/>
+    <pathelement location="${build.dir}/classes/java"/>
+    <pathelement location="${build.dir}/classes/demo"/>
+    <pathelement path="${java.class.path}"/>
+  </path>
+
+  <patternset id="src.dist.patterns"
+              includes="src/,build.xml,*build*.xml,docs/,*.txt,contrib/,*pom.xml*"
+              excludes="contrib/db/*/lib/,contrib/*/ext-libs/,src/site/build/,contrib/benchmark/temp/*,contrib/benchmark/work/*"
+  />
+  <patternset id="binary.build.dist.patterns"
+              includes="${final.name}.jar,${demo.war.name}.war,${demo.name}.jar,docs/,contrib/*/*.jar"
+  />
+  <patternset id="binary.root.dist.patterns"
+              includes="src/demo/,src/jsp/,docs/,*.txt,contrib/*/README*,**/CHANGES.txt"
+              excludes="${build.demo.template}"
+  />
+
+
+  <!-- ================================================================== -->
+  <!-- Prepares the build directory                                       -->
+  <!-- ================================================================== -->
+
+  <!-- Overrides common.compile-core to add rmic -->
+  <target name="compile-core" depends="common.compile-core"
+          description="Compiles core classes, including rmic">
+    <rmic classname="org.apache.lucene.search.RemoteSearchable"
+      base="${build.dir}/classes/java" stubversion="1.2">
+      <classpath refid="classpath"/>
+    </rmic>
+  </target>
+
+  <target name="test-core" depends="common.test"
+          description="Runs unit tests for the core Lucene code"
+  />
+  <target name="test" depends="test-core, test-contrib"
+          description="Runs all unit tests (including contribs)"
+  />
+  
+  <!-- ================================================================== -->
+  <!-- J A R                                                              -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+
+  <target name="jar-demo" depends="compile-demo">
+  	<sequential>
+  	  <build-manifest title="Lucene Search Engine: demos"/>
+      <jar
+        destfile="${build.dir}/${demo.name}.jar"
+        basedir="${build.dir}/classes/demo"
+        excludes="**/*.java"
+      	manifest="${manifest.file}">
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </jar>
+  	</sequential>
+  </target>
+
+  <target name="jar-demo-src" depends="compile-demo">
+  	<sequential>
+  	  <build-manifest title="Lucene Search Engine: demos"/>
+      <jar
+        destfile="${build.dir}/${demo.name}-src.jar"
+        basedir="src/demo"
+      	manifest="${manifest.file}">
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </jar>
+  	</sequential>
+  </target>
+
+  <target name="war-demo" depends="jar-core,jar-demo">
+    <sequential>
+      <build-manifest title="Lucene Search Engine: demos"/>
+  	  <war destfile="${build.dir}/${demo.war.name}.war"
+           webxml="src/jsp/WEB-INF/web.xml"
+      	   manifest="${manifest.file}">
+        <fileset dir="src/jsp" excludes="WEB-INF/web.xml"/>
+        <lib dir="${build.dir}" includes="${demo.name}.jar"/>
+        <lib dir="${build.dir}" includes="${final.name}.jar"/>
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </war>
+    </sequential>
+  </target>
+
+
+  <!-- ================================================================== -->
+  <!-- B U I L D  D E M O                                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="compile-demo" depends="compile-core">
+    <mkdir dir="${build.dir}/classes/demo"/>
+
+    <compile
+      srcdir="src/demo"
+      destdir="${build.dir}/classes/demo">
+      <classpath refid="demo.classpath"/>
+    </compile>
+  </target>
+
+  <!-- GCJ -->
+  <target name="gcj" depends="jar,jar-demo">
+    <exec executable="make" dir="src/gcj" failonerror="true"/>
+  </target>
+
+
+  <!-- TODO: Remove dependency on demo from test -->
+  <target name="compile-test" depends="compile-demo,common.compile-test"/>
+
+
+
+  <!-- ================================================================== -->
+  <!-- D O C U M E N T A T I O N                                          -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="docs" description="Build the website">
+      <echo>DEPRECATED - Doing Nothing.  See http://wiki.apache.org/lucene-java/HowToUpdateTheWebsite</echo>
+  </target>
+
+  <target name="javadocs" description="Generate javadoc" 
+  	      depends="javadocs-all, javadocs-core, javadocs-demo, javadocs-contrib"/>
+	
+  <target name="javadocs-core" description="Generate javadoc for core classes">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}/core"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}/core"
+      	title="${Name} ${version} core API">
+        <sources>
+          <packageset dir="src/java"/>
+          <link href="../"/>
+        </sources>
+      </invoke-javadoc>
+     <jarify basedir="${javadoc.dir}/core" destfile="${build.dir}/${final.name}-javadoc.jar"/>
+    </sequential>
+  </target>
+
+  <target name="javadocs-demo" description="Generate javadoc for demo classes">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}/demo"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}/demo"
+      	title="${Name} ${version} demo API">
+        <sources>
+          <packageset dir="src/demo"/>
+          <link href="../"/>
+        </sources>
+      </invoke-javadoc>
+      <jarify basedir="${javadoc.dir}/demo" destfile="${build.dir}/${demo.name}-javadoc.jar"/>
+    </sequential>
+  </target>
+	
+  <target name="javadocs-contrib" description="Generate javadoc for contrib classes">
+    <contrib-crawl target="javadocs"
+                   failonerror="false"/>
+  </target>
+  	
+  <target name="javadocs-all" description="Generate javadoc for core, demo and contrib classes" depends="build-contrib">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}">
+        <sources>
+          <!-- TODO: find a dynamic way to do include multiple source roots -->
+          <packageset dir="src/java"/>
+
+          <packageset dir="src/demo"/>
+
+          <!-- please keep this list up to date, and in alpha order...   -->
+        
+          <!-- ie: `find contrib/* -path \*src/java | sort` -->
+
+          <!-- if you make changes to the list of package sets, also -->
+          <!-- make sure the group list below is updated.            -->
+          <!-- Also remember to keep site.xml in sync.            -->		  
+
+          <packageset dir="contrib/analyzers/src/java"/>
+          <packageset dir="contrib/ant/src/java"/>
+          <packageset dir="contrib/benchmark/src/java"/>
+          <packageset dir="contrib/db/bdb-je/src/java"/>
+          <packageset dir="contrib/db/bdb/src/java"/>
+          <packageset dir="contrib/highlighter/src/java"/>
+          <packageset dir="contrib/instantiated/src/java"/>
+          <packageset dir="contrib/lucli/src/java"/>
+          <packageset dir="contrib/memory/src/java"/>
+          <packageset dir="contrib/miscellaneous/src/java"/>
+          <packageset dir="contrib/queries/src/java"/>
+          <packageset dir="contrib/regex/src/java"/>
+          <packageset dir="contrib/similarity/src/java"/>
+          <packageset dir="contrib/snowball/src/java"/>
+          <packageset dir="contrib/spellchecker/src/java"/>
+          <packageset dir="contrib/surround/src/java"/>
+          <packageset dir="contrib/swing/src/java"/>
+          <packageset dir="contrib/wikipedia/src/java"/>
+          <packageset dir="contrib/wordnet/src/java"/>
+          <packageset dir="contrib/xml-query-parser/src/java"/>
+          <!-- end alpha sort -->
+
+          <!-- If the main javadoc Group listing includes an "Other   -->
+          <!-- Packages" group after the ones listed here, then those -->
+          <!-- packages are not being matched by any of these rules   -->
+  
+          <group title="Core" packages="org.apache.*:org.apache.lucene.analysis:org.apache.lucene.analysis.standard*"/>
+  
+          <group title="Demo" packages="org.apache.lucene.demo*"/>
+  
+          <group title="contrib: Analysis" packages="org.apache.lucene.analysis.*"/>
+          <group title="contrib: Ant" packages="org.apache.lucene.ant*"/>
+          <group title="contrib: Benchmark" packages="org.apache.lucene.benchmark*"/>
+          <group title="contrib: DB" packages="org.apache.lucene.store.db*:org.apache.lucene.store.je*:com.sleepycat*"/>
+          <group title="contrib: Highlighter" packages="org.apache.lucene.search.highlight*"/>
+          <group title="contrib: Instantiated" packages="org.apache.lucene.store.instantiated*"/>
+          <group title="contrib: Lucli" packages="lucli*"/>
+          <group title="contrib: Memory" packages="org.apache.lucene.index.memory*"/>
+          <group title="contrib: Miscellaneous " packages="org.apache.lucene.misc*:org.apache.lucene.queryParser.analyzing*:org.apache.lucene.queryParser.precedence*"/>
+          <group title="contrib: Queries" packages="org.apache.lucene.search.similar*"/>
+          <group title="contrib: RegEx" packages="org.apache.lucene.search.regex*:org.apache.regexp*"/>
+          <!-- no group for similarity. -->
+          <!-- nothing in there at the moment, so no package structure -->
+          <group title="contrib: Snowball" packages="org.apache.lucene.analysis.snowball*:net.sf.snowball*"/>
+
+          <group title="contrib: SpellChecker" packages="org.apache.lucene.search.spell*"/>
+          <group title="contrib: Surround Parser" packages="org.apache.lucene.queryParser.surround*"/>
+          <group title="contrib: Swing" packages="org.apache.lucene.swing*"/>
+          <group title="contrib: Wikipedia" packages="org.apache.lucene.wikipedia*"/>
+          <group title="contrib: WordNet" packages="org.apache.lucene.wordnet*"/>
+          <group title="contrib: XML Query Parser" packages="org.apache.lucene.xmlparser*"/>
+
+        </sources>
+      </invoke-javadoc>
+  	</sequential>
+  </target>
+
+
+  <!-- ================================================================== -->
+  <!-- D I S T R I B U T I O N                                            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package" depends="jar-core, javadocs, war-demo, build-contrib, init-dist">
+     <copy file="${build.demo.template}" tofile="${build.dir}/build-demo.xml">
+        <filterset begintoken="@PLACEHOLDER_" endtoken="@"> 
+	  <filter token="version" value="${version}"/>
+	  <filter token="javac.source" value="${javac.source}"/>
+	  <filter token="javac.target" value="${javac.target}"/>
+        </filterset>
+     </copy>
+  </target>
+
+  <target name="nightly" depends="test, package-tgz, changes-to-html">
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the distribution with zip                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-zip" depends="package"
+    description="--> Generates the Lucene distribution as .zip">
+
+    <delete file="${dist.dir}/lucene-${version}.zip"/>
+    <zip destfile="${dist.dir}/lucene-${version}.zip">
+      <zipfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="binary.root.dist.patterns"/>
+      </zipfileset>
+      <zipfileset dir="${build.dir}" includes="build-demo.xml" fullpath="lucene-${version}/build.xml"/>
+      <zipfileset prefix="lucene-${version}" dir="${build.dir}">
+        <patternset refid="binary.build.dist.patterns"/>
+      </zipfileset>
+    </zip>
+	<lucene-checksum file="${dist.dir}/lucene-${version}.zip"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- packages the distribution with tar-gzip                            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-tgz" depends="package"
+    description="--> Generates the lucene distribution as .tar.gz">
+
+    <delete file="${build.dir}/lucene-${version}.tar"/>
+    <delete file="${dist.dir}/lucene-${version}.tar.gz"/>
+    <tar tarfile="${build.dir}/lucene-${version}.tar">
+      <tarfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="binary.root.dist.patterns"/>
+      </tarfileset>
+      <tarfileset dir="${build.dir}" includes="build-demo.xml" fullpath="lucene-${version}/build.xml"/>
+      <tarfileset prefix="lucene-${version}" dir="${build.dir}">
+        <patternset refid="binary.build.dist.patterns"/>
+      </tarfileset>
+    </tar>
+
+    <gzip zipfile="${dist.dir}/lucene-${version}.tar.gz"
+      src="${build.dir}/lucene-${version}.tar"
+      />
+	<lucene-checksum file="${dist.dir}/lucene-${version}.tar.gz"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- packages the distribution with zip and tar-gzip                    -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-all-binary" depends="package-zip, package-tgz"
+    description="--> Generates the .tar.gz and .zip distributions"/>
+
+  <!-- ================================================================== -->
+  <!-- same as package-all. it is just here for compatibility.            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="dist" depends="package-all-binary"/>
+
+  <!-- ================================================================== -->
+  <!-- S O U R C E  D I S T R I B U T I O N                               -->
+  <!-- ================================================================== -->
+    <target name="init-dist" >
+
+        <!-- Package is not called first if packaging src standalone, so the dist.dir may not exist -->
+        <mkdir dir="${build.dir}"/>
+        <mkdir dir="${dist.dir}"/>
+        <mkdir dir="${maven.dist.dir}"/>
+    </target>
+  <!-- ================================================================== -->
+  <!-- Packages the sources with zip                                      -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-zip-src" depends="init, init-dist"
+    description="--> Generates the Lucene sources as .zip">
+    <zip destfile="${dist.dir}/lucene-${version}-src.zip">
+      <zipfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="src.dist.patterns"/>
+      </zipfileset>
+    </zip>
+	<lucene-checksum file="${dist.dir}/lucene-${version}-src.zip"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the sources with tar-gzip                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-tgz-src" depends="init, init-dist"
+    description="--> Generates the Lucene distribution as .tar.gz">
+
+    <delete file="${build.dir}/lucene-${version}-src.tar"/>
+    <delete file="${dist.dir}/lucene-${version}-src.tar.gz"/>
+    <tar tarfile="${build.dir}/lucene-${version}-src.tar">
+      <tarfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="src.dist.patterns"/>
+      </tarfileset>
+    </tar>
+
+    <gzip zipfile="${dist.dir}/lucene-${version}-src.tar.gz"
+          src="${build.dir}/lucene-${version}-src.tar"
+    />
+	<lucene-checksum file="${dist.dir}/lucene-${version}-src.tar.gz"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the sources with zip and tar-gzip                         -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-all-src" depends="package-zip-src, package-tgz-src"
+    description="--> Generates the .tar.gz and .zip source distributions"/>
+
+  <!-- ================================================================== -->
+  <!-- same as package-all-src. it is just here for compatibility.        -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="dist-src" depends="package-all-src"/>
+
+  <target name="dist-all" depends="dist, dist-src"/>
+
+  <target name="generate-maven-artifacts" depends="maven.ant.tasks-check, package, jar-src, jar-demo-src, javadocs">
+    <sequential>
+      <m2-deploy pom.xml="lucene-parent-pom.xml.template"/>
+      <m2-deploy pom.xml="lucene-core-pom.xml.template">
+        <artifact-attachments>
+          <attach file="${build.dir}/${final.name}-src.jar"
+                  classifier="sources"/>
+          <attach file="${build.dir}/${final.name}-javadoc.jar"
+                  classifier="javadoc"/>
+        </artifact-attachments>
+      </m2-deploy>
+      
+      <m2-deploy pom.xml="lucene-demos-pom.xml.template">
+        <artifact-attachments>
+          <attach file="${build.dir}/${demo.name}-src.jar"
+                  classifier="sources"/>
+          <attach file="${build.dir}/${demo.name}-javadoc.jar"
+                  classifier="javadoc"/>
+        </artifact-attachments>
+      </m2-deploy>
+      
+      <m2-deploy pom.xml="lucene-contrib-pom.xml.template"/>
+      <contrib-crawl target="dist-maven"/>
+    </sequential>
+  </target>
+	
+  <!-- ================================================================== -->
+  <!-- Build the JavaCC files into the source tree                        -->
+  <!-- ================================================================== -->
+  <target name="jjdoc">
+    <mkdir dir="${build.dir}/docs/grammars"/>
+    <jjdoc target="src/java/org/apache/lucene/queryParser/QueryParser.jj"
+           outputfile="${build.dir}/docs/grammars/QueryParser.html"
+           javacchome="${javacc.home}"
+    />
+    <jjdoc target="src/java/org/apache/lucene/analysis/standard/StandardTokenizer.jj"
+           outputfile="${build.dir}/docs/grammars/StandardTokenizer.html"
+           javacchome="${javacc.home}"
+    />
+    <jjdoc target="src/demo/org/apache/lucene/demo/html/HTMLParser.jj"
+           outputfile="${build.dir}/docs/grammars/HTMLParser.html"
+           javacchome="${javacc.home}"
+    />
+  </target>
+
+  <target name="clean-javacc">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/analysis/standard" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+        <exclude name="ParseException.java"/>
+      </fileset>
+      <fileset dir="src/java/org/apache/lucene/queryParser" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+      <fileset dir="src/demo/org/apache/lucene/demo/html" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+    </delete>
+  </target>
+
+  <target name="javacc" depends="clean-javacc,javacc-QueryParser,javacc-HTMLParser"/>
+
+  <target name="javacc-QueryParser" depends="init,javacc-check" if="javacc.present">
+    <invoke-javacc target="src/java/org/apache/lucene/queryParser/QueryParser.jj"
+                   outputDir="src/java/org/apache/lucene/queryParser"
+    />
+  </target>
+  
+  <target name="javacc-HTMLParser" depends="init,javacc-check" if="javacc.present">
+    <invoke-javacc target="src/demo/org/apache/lucene/demo/html/HTMLParser.jj"
+                   outputDir="src/demo/org/apache/lucene/demo/html"
+    />
+  </target>
+  
+  <!-- ================================================================== -->
+  <!-- Build the JFlex files into the source tree                         -->
+  <!-- ================================================================== -->
+
+  <target name="jflex" depends="clean-jflex,jflex-StandardAnalyzer" />
+
+  <target name="jflex-StandardAnalyzer" depends="init,jflex-check" if="jflex.present">
+    <taskdef classname="JFlex.anttask.JFlexTask" name="jflex">
+      <classpath location="${jflex.home}/lib/JFlex.jar" />
+    </taskdef>
+
+    <jflex file="src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex"
+           outdir="src/java/org/apache/lucene/analysis/standard"
+           nobak="on" />
+  </target>
+
+  <target name="clean-jflex">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/analysis/standard" includes="*.java">
+        <containsregexp expression="generated.*by.*JFlex"/>
+      </fileset>
+    </delete>
+  </target>
+
+  <macrodef name="contrib-crawl">
+    <attribute name="target" default=""/>
+    <attribute name="failonerror" default="true"/>
+    <sequential>
+      <subant target="@{target}" failonerror="@{failonerror}">
+        <fileset dir="."
+                 includes="contrib/*/build.xml"
+        />
+      </subant>
+    </sequential>
+  </macrodef>
+
+  <target name="build-contrib"
+          description="Builds all contrib modules and their tests">
+    <contrib-crawl target="build-artifacts-and-tests"/>
+  </target>
+
+  <target name="test-contrib" depends="build-contrib">
+    <!-- Don't fail on error, instead check for flag file so we run
+         all the tests possible and can "ant generate-test-reports"
+         for all of them.
+
+         Because of this, we depend on "build-contrib" even though the
+         Individual contrib "test" targets probably have the
+         neccessary dependencies.  If they fail to compile, we won't
+         know about it.
+     -->
+    <contrib-crawl target="test" failonerror="false"/>
+    <available property="contribs.failed" file="junitfailed.flag">
+      <filepath>
+        <dirset dir="${build.dir}/contrib/">
+          <include name="**/test/" />
+        </dirset>
+      </filepath>
+    </available>
+    <fail if="contribs.failed">Contrib tests failed!</fail>
+  </target>
+
+  <!-- Macro for building checksum files
+       This is only needed until the "format" option is supported
+       by ant's built in checksum task
+   -->
+  <macrodef name="lucene-checksum">
+    <attribute name="file"/>
+    <!-- NOTE: we use the value of @{file} in the names any properties
+         set because macro's don't have variables, and otherwise we
+         wouldn't be able to checksum more then one file per build
+      -->
+    <sequential>
+      <checksum file="@{file}"
+                property="@{file}.sum"
+                algorithm="${checksum.algorithm}" />
+      <basename file="@{file}" property="@{file}.base" />
+      <concat destfile="@{file}.${checksum.algorithm}"
+              force="yes"
+              append="false"
+              fixlastline="yes">
+        <header trimleading="yes">${@{file}.sum}  </header>
+        <!-- empty fileset to trick concat -->
+        <fileset dir="." excludes="**" />
+        <footer trimleading="yes">${@{file}.base}
+        </footer>
+      </concat>
+    </sequential>
+  </macrodef>
+
+  <!--
+   compile changes.txt into an html file
+   -->
+
+  <target name="changes-to-html">
+    <mkdir dir="${changes.target.dir}"/>
+    <exec executable="perl" input="CHANGES.txt" output="${changes.target.dir}/Changes.html" failonerror="true">
+      <arg value="${changes.src.dir}/changes2html.pl"/>
+    </exec>
+    <copy todir="${changes.target.dir}">
+      <fileset dir="${changes.src.dir}" includes="*.css"/>
+    </copy>
+  </target>
+
+  <!--
+   Committer helpers
+   -->
+
+  <property name="patch.file" value="${basedir}/../patches/${patch.name}"/>
+  <!-- Apply a patch.  Assumes  patch can be applied in the basedir.
+  -Dpatch.name assumes the patch is located in ${basedir}/../patches/${patch.name}
+  -Dpatch.file means the patch can be located anywhere on the file system
+  -->
+  <target name="apply-patch" depends="clean" description="Apply a patch file.  Set -Dpatch.file, or -Dpatch.name when the patch is in the directory ../patches/">
+    <patch patchfile="${patch.file}" strip="0"/>
+  </target>
+
+  <target name="rat-sources-typedef">
+    <typedef resource="org/apache/rat/anttasks/antlib.xml" uri="antlib:rat.anttasks">
+      <classpath>
+        <fileset dir="." includes="rat*.jar"/>
+      </classpath>
+    </typedef>
+  </target>
+
+  <target name="rat-sources" depends="rat-sources-typedef"
+	  description="runs the tasks over src/java">
+    <rat:report xmlns:rat="antlib:org.apache.rat.anttasks">
+      <fileset dir="src/java">
+      </fileset>
+    </rat:report>
+  </target>
+
+</project>
diff --git a/benchmarks/bms/ManualAbort/Makefile b/benchmarks/bms/ManualAbort/Makefile
new file mode 100755
index 0000000..8339096
--- /dev/null
+++ b/benchmarks/bms/ManualAbort/Makefile
@@ -0,0 +1,23 @@
+AJWS=../../../../../translator/transform.sh
+
+all:
+	wget -c http://archive.apache.org/dist/lucene/java/lucene-2.4.1-src.tar.gz
+	tar xvfz lucene-2.4.1-src.tar.gz; cd lucene-2.4.1; ant jar-core; mv build/lucene-core-2.4.jar ../.
+	rm -rf lucene-2.4.1; mv lucene-2.4.1-src.tar.gz ../../libs/lucene/downloads/.
+	EXTRA_JARS_AJWS="./lucene-core-2.4.jar" $(AJWS) Search.java
+	cp classes/Search.java ../lusearch-fix/src/org/dacapo/lusearchFix/Search.java
+	cp ./bms-lusearch-fix-build.xml  ../lusearch-fix/build.xml
+	cp ./libs.xml ../../libs/.
+	wget -c http://archive.apache.org/dist/commons/cli/binaries/commons-cli-1.2-bin.tar.gz
+	mv commons-cli-1.2-bin.tar.gz ../../harness/downloads/
+	cd ../../libs/lucene/downloads; tar xvfz lucene-2.4.1-src.tar.gz
+	cp QueryParserTokenManager.java ../../libs/lucene/downloads/lucene-2.4.1/src/java/org/apache/lucene/queryParser/.
+	cp lucene-build.xml  ../../libs/lucene/downloads/lucene-2.4.1/build.xml
+	rm ../../libs/lucene/downloads/lucene-2.4.1-src.tar.gz || true
+	cp -rf ../../libs/lucene/downloads/lucene-2.4.1 .
+	tar cvfz lucene-2.4.1-src.tar.gz lucene-2.4.1
+	rm -rf lucene-2.4.1
+	mv lucene-2.4.1-src.tar.gz ../../libs/lucene/downloads/.
+	cd ../../; ant clean lusearch-fix
+clean:
+	rm -rf classes logs 2>/dev/null
diff --git a/benchmarks/bms/ManualAbort/QueryParserTokenManager.java b/benchmarks/bms/ManualAbort/QueryParserTokenManager.java
new file mode 100644
index 0000000..07a7383
--- /dev/null
+++ b/benchmarks/bms/ManualAbort/QueryParserTokenManager.java
@@ -0,0 +1,1189 @@
+/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */
+package org.apache.lucene.queryParser;
+import java.io.IOException;
+import java.io.StringReader;
+import java.text.DateFormat;
+import java.text.Collator;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Vector;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.document.DateField;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.ConstantScoreRangeQuery;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.util.Parameter;
+
+/** Token Manager. */
+public class QueryParserTokenManager implements QueryParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_3(int pos, long active0)
+{
+   switch (pos)
+   {
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_3(int pos, long active0)
+{
+   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_3()
+{
+   switch(curChar)
+   {
+      case 40:
+         return jjStopAtPos(0, 13);
+      case 41:
+         return jjStopAtPos(0, 14);
+      case 42:
+         return jjStartNfaWithStates_3(0, 16, 36);
+      case 43:
+         return jjStopAtPos(0, 11);
+      case 45:
+         return jjStopAtPos(0, 12);
+      case 58:
+         return jjStopAtPos(0, 15);
+      case 91:
+         return jjStopAtPos(0, 23);
+      case 94:
+         return jjStopAtPos(0, 17);
+      case 123:
+         return jjStopAtPos(0, 24);
+      default :
+         return jjMoveNfa_3(0, 0);
+   }
+}
+private int jjStartNfaWithStates_3(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_3(state, pos + 1);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_3(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 36;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+               case 25:
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 0:
+                  if ((0xfbffd4f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  else if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  else if (curChar == 33)
+                  {
+                     if (kind > 10)
+                        kind = 10;
+                  }
+                  if ((0x7bffd0f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  else if (curChar == 42)
+                  {
+                     if (kind > 21)
+                        kind = 21;
+                  }
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 4:
+                  if (curChar == 38 && kind > 8)
+                     kind = 8;
+                  break;
+               case 5:
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 13:
+                  if (curChar == 33 && kind > 10)
+                     kind = 10;
+                  break;
+               case 14:
+                  if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 15:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 18:
+                  if (curChar == 34 && kind > 18)
+                     kind = 18;
+                  break;
+               case 20:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjAddStates(8, 9);
+                  break;
+               case 21:
+                  if (curChar == 46)
+                     jjCheckNAdd(22);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjCheckNAdd(22);
+                  break;
+               case 23:
+                  if (curChar == 42 && kind > 21)
+                     kind = 21;
+                  break;
+               case 24:
+                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 27:
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if ((0x7bffd0f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+                  if ((0x7bfff8f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 31:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+                  if ((0x7bfff8f8ffffd9ffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 34:
+                  jjCheckNAddStates(10, 12);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddTwoStates(27, 27);
+                  break;
+               case 0:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddStates(13, 15);
+                  else if (curChar == 126)
+                  {
+                     if (kind > 20)
+                        kind = 20;
+                     jjstateSet[jjnewStateCnt++] = 20;
+                  }
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  else if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  else if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  else if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 1:
+                  if (curChar == 68 && kind > 8)
+                     kind = 8;
+                  break;
+               case 2:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 3:
+                  if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 6:
+                  if (curChar == 82 && kind > 9)
+                     kind = 9;
+                  break;
+               case 7:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  break;
+               case 8:
+                  if (curChar == 124 && kind > 9)
+                     kind = 9;
+                  break;
+               case 9:
+                  if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 10:
+                  if (curChar == 84 && kind > 10)
+                     kind = 10;
+                  break;
+               case 11:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 12:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  break;
+               case 15:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 16:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 17;
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 19:
+                  if (curChar != 126)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjstateSet[jjnewStateCnt++] = 20;
+                  break;
+               case 24:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 25:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 26:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(27, 27);
+                  break;
+               case 27:
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 30:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(31, 31);
+                  break;
+               case 31:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 33:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(34, 34);
+                  break;
+               case 34:
+                  jjCheckNAddStates(10, 12);
+                  break;
+               case 35:
+                  if (curChar == 92)
+                     jjCheckNAddStates(13, 15);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+               case 25:
+               case 27:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  break;
+               case 15:
+               case 17:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 24:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+               case 31:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+               case 34:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(10, 12);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      org.jikesrvm.scheduler.WS.pauseStealOnThread();
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { 
+        org.jikesrvm.scheduler.WS.resumeStealOnThread();
+        return curPos; 
+      }
+   }
+}
+private final int jjStopStringLiteralDfa_1(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x40000000L) != 0L)
+         {
+            jjmatchedKind = 33;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_1(int pos, long active0)
+{
+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_1(0x40000000L);
+      case 125:
+         return jjStopAtPos(0, 31);
+      default :
+         return jjMoveNfa_1(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_1(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x40000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 30, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_1(0, active0);
+}
+private int jjStartNfaWithStates_1(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_1(state, pos + 1);
+}
+private int jjMoveNfa_1(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 33)
+                        kind = 33;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 32)
+                     kind = 32;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xdfffffffffffffffL & l) == 0L)
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(16, 18);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(16, 18);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   return jjMoveNfa_0(0, 0);
+}
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 3;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 25)
+                     kind = 25;
+                  jjAddStates(19, 20);
+                  break;
+               case 1:
+                  if (curChar == 46)
+                     jjCheckNAdd(2);
+                  break;
+               case 2:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 25)
+                     kind = 25;
+                  jjCheckNAdd(2);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjStopStringLiteralDfa_2(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x4000000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_2(int pos, long active0)
+{
+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_2(0x4000000L);
+      case 93:
+         return jjStopAtPos(0, 27);
+      default :
+         return jjMoveNfa_2(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 26, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(0, active0);
+}
+private int jjStartNfaWithStates_2(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_2(state, pos + 1);
+}
+private int jjMoveNfa_2(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 29)
+                        kind = 29;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 28)
+                     kind = 28;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xffffffffdfffffffL & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(16, 18);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(16, 18);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+static final int[] jjnextStates = {
+   15, 16, 18, 29, 32, 23, 33, 30, 20, 21, 32, 23, 33, 31, 34, 27, 
+   2, 4, 5, 0, 1, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
+"\50", "\51", "\72", "\52", "\136", null, null, null, null, null, "\133", "\173", 
+null, "\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "Boost",
+   "RangeEx",
+   "RangeIn",
+   "DEFAULT",
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 
+   3, -1, 3, -1, -1, -1, 3, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x3ffffff01L, 
+};
+static final long[] jjtoSkip = {
+   0x80L, 
+};
+protected CharStream input_stream;
+private final int[] jjrounds = new int[36];
+private final int[] jjstateSet = new int[72];
+protected char curChar;
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream){
+   input_stream = stream;
+}
+
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 36; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 4 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 3;
+int defaultLexState = 3;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      org.jikesrvm.scheduler.WS.pauseStealOnThread();
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      org.jikesrvm.scheduler.WS.resumeStealOnThread();
+      return matchedToken;
+   }
+
+   switch(curLexState)
+   {
+     case 0:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_0();
+       break;
+     case 1:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_1();
+       break;
+     case 2:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_2();
+       break;
+     case 3:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_3();
+       break;
+   }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else
+        {
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/benchmarks/bms/ManualAbort/Search.java b/benchmarks/bms/ManualAbort/Search.java
new file mode 100644
index 0000000..2b9430e
--- /dev/null
+++ b/benchmarks/bms/ManualAbort/Search.java
@@ -0,0 +1,333 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Contributors:
+ *     Apache Software Foundation 
+ *     Australian National University - adaptation to DaCapo test harness
+ */
+package org.dacapo.lusearchFix;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.FilterIndexReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.TopDocCollector;
+
+/**
+ * Simple command-line based search demo.
+ * 
+ * @date $Date: 2009-12-24 11:19:36 +1100 (Thu, 24 Dec 2009) $
+ * @id $Id: Search.java 738 2009-12-24 00:19:36Z steveb-oss $
+ */
+public class Search {
+
+  static final int MAX_DOCS_TO_COLLECT = 20;
+  public int completed = 0;
+  private int COMPLETION_GOAL; 
+
+  /**
+   * Use the norms from one field for all fields. Norms are read into memory,
+   * using a byte of memory per document per searched field. This can cause
+   * search of large collections with a large number of fields to run out of
+   * memory. If all of the fields contain only a single token, then the norms
+   * are all identical, then single norm vector may be shared.
+   */
+  private static class OneNormsReader extends FilterIndexReader {
+    private String field;
+
+    public OneNormsReader(IndexReader in, String field) {
+      super(in);
+      this.field = field;
+    }
+
+    public byte[] norms(String field) throws IOException {
+      return in.norms(this.field);
+    }
+  }
+
+  public Search() {
+  }
+
+  /** Simple command-line based search demo. */
+  public void main(String[] args) throws Exception {
+    String usage = "Usage:\tjava org.dacapo.lusearchFix.Search [-index dir] [-field f] [-repeat n] [-queries file] [-raw] [-norms field] [-paging hitsPerPage]";
+    usage += "\n\tSpecify 'false' for hitsPerPage to use streaming instead of paging search.";
+    if (args.length > 0 && ("-h".equals(args[0]) || "-help".equals(args[0]))) {
+      System.out.println(usage);
+      System.exit(0);
+    }
+
+    String index = "index";
+    String field = "contents";
+    String queryBase = null;
+    int repeat = 0;
+    boolean raw = false;
+    String normsField = null;
+    int hitsPerPage = 10;
+    String outBase = null;
+    int threads = 1;
+    int totalQueries = 32;
+
+    for (int i = 0; i < args.length; i++) {
+      if ("-index".equals(args[i])) {
+        index = args[i + 1];
+        i++;
+      } else if ("-field".equals(args[i])) {
+        field = args[i + 1];
+        i++;
+      } else if ("-queries".equals(args[i])) {
+        queryBase = args[i + 1];
+        i++;
+      } else if ("-repeat".equals(args[i])) {
+        repeat = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-raw".equals(args[i])) {
+        raw = true;
+      } else if ("-norms".equals(args[i])) {
+        normsField = args[i + 1];
+        i++;
+      } else if ("-paging".equals(args[i])) {
+        hitsPerPage = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-output".equals(args[i])) {
+        outBase = args[i + 1];
+        i++;
+      } else if ("-threads".equals(args[i])) {
+        threads = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-totalqueries".equals(args[i])) {
+        totalQueries = Integer.parseInt(args[i + 1]);
+        i++;
+      }
+    }
+    completed = 0;
+    COMPLETION_GOAL = (int)( 0.8 * totalQueries);
+    final QueryThread[] queryThreads = new QueryThread[totalQueries];
+    finish_abort {
+      for (int j = 0; j < totalQueries; j++) {
+        queryThreads[j] = new QueryThread(this, "Query" + j, j, threads, totalQueries, index, outBase, queryBase, field, normsField, raw, hitsPerPage);
+        async { queryThreads[j].run(); }
+      }
+    }
+  }
+
+  class QueryThread {
+    Search parent;
+    int id;
+    int threadCount;
+    int totalQueries;
+    String name;
+    String index;
+    String outBase;
+    String queryBase;
+    String field;
+    String normsField;
+    boolean raw;
+    int hitsPerPage;
+
+    public QueryThread(Search parent, String name, int id, int threadCount, int totalQueries, String index, String outBase, String queryBase, String field,
+        String normsField, boolean raw, int hitsPerPage) {
+      //super(name);
+      this.parent = parent;
+      this.id = id;
+      this.threadCount = threadCount;
+      this.totalQueries = totalQueries;
+      this.name = name;
+      this.index = index;
+      this.outBase = outBase;
+      this.queryBase = queryBase;
+      this.field = field;
+      this.normsField = normsField;
+      this.raw = raw;
+      this.hitsPerPage = hitsPerPage;
+    }
+
+    public void run() {
+      if(parent.completed >= parent.COMPLETION_GOAL) {
+        System.out.println("Aborting as "+parent.completed+" completed");
+        return;
+      }
+      try {
+        //int count = totalQueries / threadCount + (id < (totalQueries % threadCount) ? 1 : 0);
+        //for (int i = 0, queryId = id; i < count; i++, queryId += threadCount) {
+          // make and run query
+          new QueryProcessor(parent, name, id, index, outBase, queryBase, field, normsField, raw, hitsPerPage).run();
+        //}
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+
+  }
+
+  public class QueryProcessor {
+
+    Search parent;
+    String field;
+    int hitsPerPage;
+    boolean raw;
+
+    IndexReader reader;
+    Searcher searcher;
+    BufferedReader in;
+    PrintWriter out;
+
+    public QueryProcessor(Search parent, String name, int id, String index, String outBase, String queryBase, String field, String normsField, boolean raw,
+        int hitsPerPage) {
+      this.parent = parent;
+      this.field = field;
+      this.raw = raw;
+      this.hitsPerPage = hitsPerPage;
+      try {
+        reader = IndexReader.open(index);
+        if (normsField != null)
+          reader = new OneNormsReader(reader, normsField);
+        searcher = new IndexSearcher(reader);
+
+        String query = queryBase + (id < 10 ? "00" : (id < 100 ? "0" : "")) + id + ".txt";
+        in = new BufferedReader(new FileReader(query));
+        out = new PrintWriter(new BufferedWriter(new FileWriter(outBase + id)));
+
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+
+    public void run() throws java.io.IOException {
+      Analyzer analyzer = new StandardAnalyzer();
+      QueryParser parser = new QueryParser(field, analyzer);
+
+      while (true) {
+        if(parent.completed >= parent.COMPLETION_GOAL) {
+          System.out.println("Aborting as "+parent.completed+" completed");
+          return;
+        }
+        String line = in.readLine();
+
+        if (line == null || line.length() == -1)
+          break;
+
+        line = line.trim();
+        if (line.length() == 0)
+          break;
+
+        Query query = null;
+        try {
+          query = parser.parse(line);
+        } catch (org.apache.lucene.queryParser.ParseException e) {
+          e.printStackTrace();
+        }
+        if(parent.completed >= parent.COMPLETION_GOAL) {
+          System.out.println("Aborting as "+parent.completed+" completed");
+          return;
+        }
+        searcher.search(query, null, 10);
+
+        if(parent.completed >= parent.COMPLETION_GOAL) {
+          System.out.println("Aborting as "+parent.completed+" completed");
+          return;
+        }
+        doPagingSearch(query);
+      }
+
+      reader.close();
+      out.flush();
+      out.close();
+     
+      synchronized (parent) {
+        ++parent.completed;
+        if (parent.completed % 4 == 0) {
+          System.out.println(parent.completed + " query batches completed");
+        }
+        //parent.notify();
+      }
+  
+    }
+
+    /**
+     * This demonstrates a typical paging search scenario, where the search
+     * engine presents pages of size n to the user. The user can then go to the
+     * next page if interested in the next hits.
+     * 
+     * When the query is executed for the first time, then only enough results
+     * are collected to fill 5 result pages. If the user wants to page beyond
+     * this limit, then the query is executed another time and all hits are
+     * collected.
+     * 
+     */
+    public void doPagingSearch(Query query) throws IOException {
+
+      // Collect enough docs to show 5 pages
+      TopDocCollector collector = new TopDocCollector(MAX_DOCS_TO_COLLECT);
+      searcher.search(query, collector);
+      ScoreDoc[] hits = collector.topDocs().scoreDocs;
+
+      int numTotalHits = collector.getTotalHits();
+      if (numTotalHits > 0)
+        out.println(numTotalHits + " total matching documents for " + query.toString(field));
+
+      int start = 0;
+      int end = Math.min(numTotalHits, hitsPerPage);
+
+      while (start < Math.min(MAX_DOCS_TO_COLLECT, numTotalHits)) {
+        if(parent.completed >= parent.COMPLETION_GOAL) {
+          System.out.println("Aborting as "+parent.completed+" completed");
+          return;
+        }
+        end = Math.min(hits.length, start + hitsPerPage);
+
+        for (int i = start; i < end; i++) {
+          if(parent.completed >= parent.COMPLETION_GOAL) {
+            System.out.println("Aborting as "+parent.completed+" completed");
+            return;
+          }
+          if (raw) { // output raw format
+            out.println("doc=" + hits[i].doc + " score=" + hits[i].score);
+            continue;
+          }
+
+          Document doc = searcher.doc(hits[i].doc);
+          String path = doc.get("path");
+          if (path != null) {
+            out.println("\t" + (i + 1) + ". " + path);
+            String title = doc.get("title");
+            if (title != null) {
+              out.println("   Title: " + doc.get("title"));
+            }
+          } else {
+            out.println((i + 1) + ". " + "No path for this document");
+          }
+
+        }
+        start = end;
+      }
+    }
+  }
+}
+
diff --git a/benchmarks/bms/ManualAbort/bms-lusearch-fix-build.xml b/benchmarks/bms/ManualAbort/bms-lusearch-fix-build.xml
new file mode 100644
index 0000000..f067bfb
--- /dev/null
+++ b/benchmarks/bms/ManualAbort/bms-lusearch-fix-build.xml
@@ -0,0 +1,53 @@
+<!--
+ * Copyright (c) 2017 The Australian National University.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License v2.0.
+ * You may obtain the license at
+ *
+ *    http://www.opensource.org/licenses/apache2.0.php
+ -->
+<project name="lusearch-fix" default="all" basedir="../..">
+    <description>DaCapo lusearch-fix benchmark</description>
+    <property file="dacapo.properties"/>
+
+    <property name="bm-name" value="lusearch-fix"/>
+
+    <import file="../common.xml"/>
+
+    <target name="fix-operation">
+        <move file="libs/lucene/build.xml" tofile="libs/lucene/build-tmp.xml"/>
+        <copy file="libs/lucene/build-tmp.xml" tofile="libs/lucene/build.xml"/>
+        <touch file="libs/lucene/lucene.patch"/>
+        <patch patchfile="${bm-files}/lusearch-fix.patch" dir="${basedir}" strip="0" ignorewhitespace="yes"/>
+    </target>
+
+    <target name="bm-build" depends="fix-operation, lucene">
+        <mkdir dir="${bm-build-dir}"/>
+        <javac srcdir="${bm-src-dir}" source="1.5"
+               classpath="${harness-classpath}:${lucene-jars}/${lucene-core-jar-name}:${lucene-jars}/${lucene-demos-jar-name}:${jikesrvm-jar}"
+               destdir="${bm-build-dir}"
+               includes="org/dacapo/lusearchFix/*" debug="true" debuglevel="lines,vars,source"/>
+        <delete file="libs/lucene/build.xml"/>
+        <delete file="libs/lucene/lucene.patch"/>
+        <move file="libs/lucene/build-tmp.xml" tofile="libs/lucene/build.xml"/>
+    </target>
+
+    <target name="jar">
+        <jar destfile="${bm-jars}/dacapo-${bm-name}.jar" basedir="${bm-build-dir}"/>
+    </target>
+
+    <target name="copy-data">
+        <mkdir dir="${bm-data}/lusearchFix"/>
+        <copy todir="${bm-data}/lusearchFix">
+            <fileset dir="bms/lusearch/data/lusearch">
+                <include name="**"/>
+            </fileset>
+        </copy>
+    </target>
+
+    <target name="data" depends="copy-data">
+        <zip basedir="${bm-data}" includes="**" destfile="${bm-dat}/${bm-name}.zip"/>
+        <delete dir="${bm-data}"/>
+    </target>
+
+</project>
diff --git a/benchmarks/bms/ManualAbort/libs.xml b/benchmarks/bms/ManualAbort/libs.xml
new file mode 100644
index 0000000..5427330
--- /dev/null
+++ b/benchmarks/bms/ManualAbort/libs.xml
@@ -0,0 +1,122 @@
+<!--
+ * Copyright (c) 2009 The Australian National University.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License v2.0.
+ * You may obtain the license at
+ * 
+ *    http://www.opensource.org/licenses/apache2.0.php
+ -->
+<project name="libs">
+    <property name="lib-base" value="${basedir}/libs"/>
+
+    <import file="../path.xml"/>
+
+    <!-- bcel -->
+    <property name="bcel-jar" value="${lib-base}/bcel/dist/jar/bcel-5.2.jar"/>
+    <target name="bcel">
+        <ant antfile="${lib-base}/bcel/build.xml"/>
+    </target>
+
+    <!-- dacapo-digest -->
+    <property name="dacapo-digest-jar" value="${lib-base}/dacapo-digest/dist/jar/dacapo-digest.jar"/>
+    <target name="dacapo-digest">
+        <ant antfile="${lib-base}/dacapo-digest/build.xml"/>
+    </target>
+
+    <!-- daytrader -->
+    <target name="daytrader">
+        <ant antfile="${lib-base}/daytrader/build.xml"/>
+    </target>
+
+    <!-- jpetstore -->
+    <property name="jpetstore-common" value="${lib-base}/jpetstore/dist/jar/ibatis-common-2.jar"/>
+    <property name="jpetstore-dao" value="${lib-base}/jpetstore/dist/jar/ibatis-dao-2.jar"/>
+    <property name="jpetstore-sqlmap" value="${lib-base}/jpetstore/dist/jar/ibatis-sqlmap-2.jar"/>
+    <property name="jpetstore-jakarta-oro" value="${lib-base}/jpetstore/dist/jar/jakarta-oro.jar"/>
+    <property name="jpetstore-struts" value="${lib-base}/jpetstore/dist/jar/struts.jar"/>
+    <property name="jpetstore-zip" value="${lib-base}/jpetstore/dist/jar/jpetstore.zip"/>
+    <target name="jpetstore">
+        <ant antfile="${lib-base}/jpetstore/build.xml"/>
+    </target>
+
+    <!-- jakarta commons HTTP client -->
+    <property name="commons-httpclient-jar" value="${lib-base}/commons-httpclient/dist/jar/commons-httpclient.jar"/>
+    <target name="commons-httpclient" depends="commons-logging,commons-codec">
+        <ant antfile="${lib-base}/commons-httpclient/build.xml"/>
+    </target>
+
+    <!-- jakarta commons logging -->
+    <property name="commons-logging-jar" value="${lib-base}/commons-logging/dist/jar/commons-logging.jar"/>
+    <target name="commons-logging">
+        <ant antfile="${lib-base}/commons-logging/build.xml"/>
+    </target>
+
+    <!-- jakarta commons codec -->
+    <property name="commons-codec-jar" value="${lib-base}/commons-codec/dist/jar/commons-codec.jar"/>
+    <target name="commons-codec">
+        <ant antfile="${lib-base}/commons-codec/build.xml"/>
+    </target>
+
+    <!-- janino -->
+    <property name="janino-jar" value="${lib-base}/janino/dist/jar/janino-2.5.15.jar"/>
+    <target name="janino">
+        <ant antfile="${lib-base}/janino/build.xml"/>
+    </target>
+
+    <!-- jdbcbench -->
+    <property name="jdbcbench-jar" value="${lib-base}/jdbcbench/dist/jar/jdbcbench.jar"/>
+    <target name="jdbcbench">
+        <ant antfile="${lib-base}/jdbcbench/build.xml"/>
+    </target>
+
+    <!-- derby -->
+    <property name="derby-jar" value="${lib-base}/derby/dist/jar/derby.jar"/>
+    <property name="derbyclient-jar" value="${lib-base}/derby/dist/jar/derbyclient.jar"/>
+    <property name="derbynet-jar" value="${lib-base}/derby/dist/jar/derbynet.jar"/>
+    <property name="derbytools-jar" value="${lib-base}/derby/dist/jar/derbytools.jar"/>
+    <property name="derbytesting-jar" value="${lib-base}/derby/dist/jar/derbyTesting.jar"/>
+    <target name="derby">
+        <ant antfile="${lib-base}/derby/build.xml"/>
+    </target>
+
+    <!-- junit -->
+    <property name="junit-jar" value="${lib-base}/junit/dist/jar/junit-3.8.1.jar"/>
+    <target name="junit">
+        <ant antfile="${lib-base}/junit/build.xml"/>
+    </target>
+
+    <!-- h2-->
+    <property name="h2-version" value="1.2.121"/>
+    <property name="h2-jar" value="${lib-base}/h2/dist/jar/h2-${h2-version}.jar"/>
+    <target name="h2">
+        <ant antfile="${lib-base}/h2/build.xml"/>
+    </target>
+
+    <!-- lucene -->
+    <property name="lucene-jars" value="${lib-base}/lucene/dist/jar"/>
+    <property name="lucene-core-jar-name" value="lucene-core-2.4.jar"/>
+    <property name="lucene-demos-jar-name" value="lucene-demos-2.4.jar"/>
+    <target name="lucene">
+        <ant antfile="${lib-base}/lucene/build.xml"/>
+    </target>
+ 
+    <!-- jikesrvm -->
+    <property name="jikesrvm-jar" value="${jikesrvm-path}"/>
+
+    <!-- xerces -->
+    <property name="xerces-jars" value="${lib-base}/xerces/dist/jar"/>
+    <property name="xerces-impl-jar-name" value="xercesImpl.jar"/>
+    <property name="xerces-api-jar-name" value="xml-apis.jar"/>
+    <target name="xerces">
+        <ant antfile="${lib-base}/xerces/build.xml"/>
+    </target>
+
+    <!-- asm -->
+    <property name="asm-verison" value="3.3"/>
+    <property name="asm-jar" value="${lib-base}/asm/dist/jar/asm-${asm-verison}.jar"/>
+    <property name="asm-commons-jar" value="${lib-base}/asm/dist/jar/asm-commons-${asm-verison}.jar"/>
+    <target name="asm">
+      <ant antfile="${lib-base}/asm/build.xml"/>
+    </target>
+
+</project>
diff --git a/benchmarks/bms/ManualAbort/lucene-build.xml b/benchmarks/bms/ManualAbort/lucene-build.xml
new file mode 100644
index 0000000..eed6e3a
--- /dev/null
+++ b/benchmarks/bms/ManualAbort/lucene-build.xml
@@ -0,0 +1,650 @@
+<?xml version="1.0"?>
+
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+ 
+        http://www.apache.org/licenses/LICENSE-2.0
+ 
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ -->
+
+<project name="core" default="default" basedir=".">
+
+  <property name="junit.includes" value="**/Test*.java"/>
+
+  <import file="common-build.xml"/>
+  <import file="../../../../path.xml"/>
+
+  <property name="build.demo.template" value="src/demo/demo-build.template"/> 
+
+  <property name="demo.name" value="lucene-demos-${version}"/>
+  <property name="demo.war.name" value="luceneweb"/>
+
+  <!-- Type of checksum to compute for distribution files -->
+  <property name="checksum.algorithm" value="md5" />
+	
+  <!-- Build classpath -->
+  <path id="classpath">
+    <pathelement location="${build.dir}/classes/java"/>
+    <pathelement location="${jikesrvm-path}"/>
+  </path>
+
+  <path id="demo.classpath">
+    <path refid="classpath"/>
+    <pathelement location="${build.dir}/classes/demo"/>
+  </path>
+  
+  <path id="test.classpath">
+    <path refid="demo.classpath"/>
+    <path refid="junit-path"/>
+    <pathelement location="${build.dir}/classes/test"/>
+  </path>
+
+
+  <path id="junit.classpath">
+    <path refid="junit-path"/>
+    <pathelement location="${build.dir}/classes/test"/>
+    <pathelement location="${build.dir}/classes/java"/>
+    <pathelement location="${build.dir}/classes/demo"/>
+    <pathelement path="${java.class.path}"/>
+  </path>
+
+  <patternset id="src.dist.patterns"
+              includes="src/,build.xml,*build*.xml,docs/,*.txt,contrib/,*pom.xml*"
+              excludes="contrib/db/*/lib/,contrib/*/ext-libs/,src/site/build/,contrib/benchmark/temp/*,contrib/benchmark/work/*"
+  />
+  <patternset id="binary.build.dist.patterns"
+              includes="${final.name}.jar,${demo.war.name}.war,${demo.name}.jar,docs/,contrib/*/*.jar"
+  />
+  <patternset id="binary.root.dist.patterns"
+              includes="src/demo/,src/jsp/,docs/,*.txt,contrib/*/README*,**/CHANGES.txt"
+              excludes="${build.demo.template}"
+  />
+
+
+  <!-- ================================================================== -->
+  <!-- Prepares the build directory                                       -->
+  <!-- ================================================================== -->
+
+  <!-- Overrides common.compile-core to add rmic -->
+  <target name="compile-core" depends="common.compile-core"
+          description="Compiles core classes, including rmic">
+    <rmic classname="org.apache.lucene.search.RemoteSearchable"
+      base="${build.dir}/classes/java" stubversion="1.2">
+      <classpath refid="classpath"/>
+    </rmic>
+  </target>
+
+  <target name="test-core" depends="common.test"
+          description="Runs unit tests for the core Lucene code"
+  />
+  <target name="test" depends="test-core, test-contrib"
+          description="Runs all unit tests (including contribs)"
+  />
+  
+  <!-- ================================================================== -->
+  <!-- J A R                                                              -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+
+  <target name="jar-demo" depends="compile-demo">
+  	<sequential>
+  	  <build-manifest title="Lucene Search Engine: demos"/>
+      <jar
+        destfile="${build.dir}/${demo.name}.jar"
+        basedir="${build.dir}/classes/demo"
+        excludes="**/*.java"
+      	manifest="${manifest.file}">
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </jar>
+  	</sequential>
+  </target>
+
+  <target name="jar-demo-src" depends="compile-demo">
+  	<sequential>
+  	  <build-manifest title="Lucene Search Engine: demos"/>
+      <jar
+        destfile="${build.dir}/${demo.name}-src.jar"
+        basedir="src/demo"
+      	manifest="${manifest.file}">
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </jar>
+  	</sequential>
+  </target>
+
+  <target name="war-demo" depends="jar-core,jar-demo">
+    <sequential>
+      <build-manifest title="Lucene Search Engine: demos"/>
+  	  <war destfile="${build.dir}/${demo.war.name}.war"
+           webxml="src/jsp/WEB-INF/web.xml"
+      	   manifest="${manifest.file}">
+        <fileset dir="src/jsp" excludes="WEB-INF/web.xml"/>
+        <lib dir="${build.dir}" includes="${demo.name}.jar"/>
+        <lib dir="${build.dir}" includes="${final.name}.jar"/>
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </war>
+    </sequential>
+  </target>
+
+
+  <!-- ================================================================== -->
+  <!-- B U I L D  D E M O                                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="compile-demo" depends="compile-core">
+    <mkdir dir="${build.dir}/classes/demo"/>
+
+    <compile
+      srcdir="src/demo"
+      destdir="${build.dir}/classes/demo">
+      <classpath refid="demo.classpath"/>
+    </compile>
+  </target>
+
+  <!-- GCJ -->
+  <target name="gcj" depends="jar,jar-demo">
+    <exec executable="make" dir="src/gcj" failonerror="true"/>
+  </target>
+
+
+  <!-- TODO: Remove dependency on demo from test -->
+  <target name="compile-test" depends="compile-demo,common.compile-test"/>
+
+
+
+  <!-- ================================================================== -->
+  <!-- D O C U M E N T A T I O N                                          -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="docs" description="Build the website">
+      <echo>DEPRECATED - Doing Nothing.  See http://wiki.apache.org/lucene-java/HowToUpdateTheWebsite</echo>
+  </target>
+
+  <target name="javadocs" description="Generate javadoc" 
+  	      depends="javadocs-all, javadocs-core, javadocs-demo, javadocs-contrib"/>
+	
+  <target name="javadocs-core" description="Generate javadoc for core classes">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}/core"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}/core"
+      	title="${Name} ${version} core API">
+        <sources>
+          <packageset dir="src/java"/>
+          <link href="../"/>
+        </sources>
+      </invoke-javadoc>
+     <jarify basedir="${javadoc.dir}/core" destfile="${build.dir}/${final.name}-javadoc.jar"/>
+    </sequential>
+  </target>
+
+  <target name="javadocs-demo" description="Generate javadoc for demo classes">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}/demo"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}/demo"
+      	title="${Name} ${version} demo API">
+        <sources>
+          <packageset dir="src/demo"/>
+          <link href="../"/>
+        </sources>
+      </invoke-javadoc>
+      <jarify basedir="${javadoc.dir}/demo" destfile="${build.dir}/${demo.name}-javadoc.jar"/>
+    </sequential>
+  </target>
+	
+  <target name="javadocs-contrib" description="Generate javadoc for contrib classes">
+    <contrib-crawl target="javadocs"
+                   failonerror="false"/>
+  </target>
+  	
+  <target name="javadocs-all" description="Generate javadoc for core, demo and contrib classes" depends="build-contrib">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}">
+        <sources>
+          <!-- TODO: find a dynamic way to do include multiple source roots -->
+          <packageset dir="src/java"/>
+
+          <packageset dir="src/demo"/>
+
+          <!-- please keep this list up to date, and in alpha order...   -->
+        
+          <!-- ie: `find contrib/* -path \*src/java | sort` -->
+
+          <!-- if you make changes to the list of package sets, also -->
+          <!-- make sure the group list below is updated.            -->
+          <!-- Also remember to keep site.xml in sync.            -->		  
+
+          <packageset dir="contrib/analyzers/src/java"/>
+          <packageset dir="contrib/ant/src/java"/>
+          <packageset dir="contrib/benchmark/src/java"/>
+          <packageset dir="contrib/db/bdb-je/src/java"/>
+          <packageset dir="contrib/db/bdb/src/java"/>
+          <packageset dir="contrib/highlighter/src/java"/>
+          <packageset dir="contrib/instantiated/src/java"/>
+          <packageset dir="contrib/lucli/src/java"/>
+          <packageset dir="contrib/memory/src/java"/>
+          <packageset dir="contrib/miscellaneous/src/java"/>
+          <packageset dir="contrib/queries/src/java"/>
+          <packageset dir="contrib/regex/src/java"/>
+          <packageset dir="contrib/similarity/src/java"/>
+          <packageset dir="contrib/snowball/src/java"/>
+          <packageset dir="contrib/spellchecker/src/java"/>
+          <packageset dir="contrib/surround/src/java"/>
+          <packageset dir="contrib/swing/src/java"/>
+          <packageset dir="contrib/wikipedia/src/java"/>
+          <packageset dir="contrib/wordnet/src/java"/>
+          <packageset dir="contrib/xml-query-parser/src/java"/>
+          <!-- end alpha sort -->
+
+          <!-- If the main javadoc Group listing includes an "Other   -->
+          <!-- Packages" group after the ones listed here, then those -->
+          <!-- packages are not being matched by any of these rules   -->
+  
+          <group title="Core" packages="org.apache.*:org.apache.lucene.analysis:org.apache.lucene.analysis.standard*"/>
+  
+          <group title="Demo" packages="org.apache.lucene.demo*"/>
+  
+          <group title="contrib: Analysis" packages="org.apache.lucene.analysis.*"/>
+          <group title="contrib: Ant" packages="org.apache.lucene.ant*"/>
+          <group title="contrib: Benchmark" packages="org.apache.lucene.benchmark*"/>
+          <group title="contrib: DB" packages="org.apache.lucene.store.db*:org.apache.lucene.store.je*:com.sleepycat*"/>
+          <group title="contrib: Highlighter" packages="org.apache.lucene.search.highlight*"/>
+          <group title="contrib: Instantiated" packages="org.apache.lucene.store.instantiated*"/>
+          <group title="contrib: Lucli" packages="lucli*"/>
+          <group title="contrib: Memory" packages="org.apache.lucene.index.memory*"/>
+          <group title="contrib: Miscellaneous " packages="org.apache.lucene.misc*:org.apache.lucene.queryParser.analyzing*:org.apache.lucene.queryParser.precedence*"/>
+          <group title="contrib: Queries" packages="org.apache.lucene.search.similar*"/>
+          <group title="contrib: RegEx" packages="org.apache.lucene.search.regex*:org.apache.regexp*"/>
+          <!-- no group for similarity. -->
+          <!-- nothing in there at the moment, so no package structure -->
+          <group title="contrib: Snowball" packages="org.apache.lucene.analysis.snowball*:net.sf.snowball*"/>
+
+          <group title="contrib: SpellChecker" packages="org.apache.lucene.search.spell*"/>
+          <group title="contrib: Surround Parser" packages="org.apache.lucene.queryParser.surround*"/>
+          <group title="contrib: Swing" packages="org.apache.lucene.swing*"/>
+          <group title="contrib: Wikipedia" packages="org.apache.lucene.wikipedia*"/>
+          <group title="contrib: WordNet" packages="org.apache.lucene.wordnet*"/>
+          <group title="contrib: XML Query Parser" packages="org.apache.lucene.xmlparser*"/>
+
+        </sources>
+      </invoke-javadoc>
+  	</sequential>
+  </target>
+
+
+  <!-- ================================================================== -->
+  <!-- D I S T R I B U T I O N                                            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package" depends="jar-core, javadocs, war-demo, build-contrib, init-dist">
+     <copy file="${build.demo.template}" tofile="${build.dir}/build-demo.xml">
+        <filterset begintoken="@PLACEHOLDER_" endtoken="@"> 
+	  <filter token="version" value="${version}"/>
+	  <filter token="javac.source" value="${javac.source}"/>
+	  <filter token="javac.target" value="${javac.target}"/>
+        </filterset>
+     </copy>
+  </target>
+
+  <target name="nightly" depends="test, package-tgz, changes-to-html">
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the distribution with zip                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-zip" depends="package"
+    description="--> Generates the Lucene distribution as .zip">
+
+    <delete file="${dist.dir}/lucene-${version}.zip"/>
+    <zip destfile="${dist.dir}/lucene-${version}.zip">
+      <zipfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="binary.root.dist.patterns"/>
+      </zipfileset>
+      <zipfileset dir="${build.dir}" includes="build-demo.xml" fullpath="lucene-${version}/build.xml"/>
+      <zipfileset prefix="lucene-${version}" dir="${build.dir}">
+        <patternset refid="binary.build.dist.patterns"/>
+      </zipfileset>
+    </zip>
+	<lucene-checksum file="${dist.dir}/lucene-${version}.zip"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- packages the distribution with tar-gzip                            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-tgz" depends="package"
+    description="--> Generates the lucene distribution as .tar.gz">
+
+    <delete file="${build.dir}/lucene-${version}.tar"/>
+    <delete file="${dist.dir}/lucene-${version}.tar.gz"/>
+    <tar tarfile="${build.dir}/lucene-${version}.tar">
+      <tarfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="binary.root.dist.patterns"/>
+      </tarfileset>
+      <tarfileset dir="${build.dir}" includes="build-demo.xml" fullpath="lucene-${version}/build.xml"/>
+      <tarfileset prefix="lucene-${version}" dir="${build.dir}">
+        <patternset refid="binary.build.dist.patterns"/>
+      </tarfileset>
+    </tar>
+
+    <gzip zipfile="${dist.dir}/lucene-${version}.tar.gz"
+      src="${build.dir}/lucene-${version}.tar"
+      />
+	<lucene-checksum file="${dist.dir}/lucene-${version}.tar.gz"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- packages the distribution with zip and tar-gzip                    -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-all-binary" depends="package-zip, package-tgz"
+    description="--> Generates the .tar.gz and .zip distributions"/>
+
+  <!-- ================================================================== -->
+  <!-- same as package-all. it is just here for compatibility.            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="dist" depends="package-all-binary"/>
+
+  <!-- ================================================================== -->
+  <!-- S O U R C E  D I S T R I B U T I O N                               -->
+  <!-- ================================================================== -->
+    <target name="init-dist" >
+
+        <!-- Package is not called first if packaging src standalone, so the dist.dir may not exist -->
+        <mkdir dir="${build.dir}"/>
+        <mkdir dir="${dist.dir}"/>
+        <mkdir dir="${maven.dist.dir}"/>
+    </target>
+  <!-- ================================================================== -->
+  <!-- Packages the sources with zip                                      -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-zip-src" depends="init, init-dist"
+    description="--> Generates the Lucene sources as .zip">
+    <zip destfile="${dist.dir}/lucene-${version}-src.zip">
+      <zipfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="src.dist.patterns"/>
+      </zipfileset>
+    </zip>
+	<lucene-checksum file="${dist.dir}/lucene-${version}-src.zip"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the sources with tar-gzip                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-tgz-src" depends="init, init-dist"
+    description="--> Generates the Lucene distribution as .tar.gz">
+
+    <delete file="${build.dir}/lucene-${version}-src.tar"/>
+    <delete file="${dist.dir}/lucene-${version}-src.tar.gz"/>
+    <tar tarfile="${build.dir}/lucene-${version}-src.tar">
+      <tarfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="src.dist.patterns"/>
+      </tarfileset>
+    </tar>
+
+    <gzip zipfile="${dist.dir}/lucene-${version}-src.tar.gz"
+          src="${build.dir}/lucene-${version}-src.tar"
+    />
+	<lucene-checksum file="${dist.dir}/lucene-${version}-src.tar.gz"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the sources with zip and tar-gzip                         -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-all-src" depends="package-zip-src, package-tgz-src"
+    description="--> Generates the .tar.gz and .zip source distributions"/>
+
+  <!-- ================================================================== -->
+  <!-- same as package-all-src. it is just here for compatibility.        -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="dist-src" depends="package-all-src"/>
+
+  <target name="dist-all" depends="dist, dist-src"/>
+
+  <target name="generate-maven-artifacts" depends="maven.ant.tasks-check, package, jar-src, jar-demo-src, javadocs">
+    <sequential>
+      <m2-deploy pom.xml="lucene-parent-pom.xml.template"/>
+      <m2-deploy pom.xml="lucene-core-pom.xml.template">
+        <artifact-attachments>
+          <attach file="${build.dir}/${final.name}-src.jar"
+                  classifier="sources"/>
+          <attach file="${build.dir}/${final.name}-javadoc.jar"
+                  classifier="javadoc"/>
+        </artifact-attachments>
+      </m2-deploy>
+      
+      <m2-deploy pom.xml="lucene-demos-pom.xml.template">
+        <artifact-attachments>
+          <attach file="${build.dir}/${demo.name}-src.jar"
+                  classifier="sources"/>
+          <attach file="${build.dir}/${demo.name}-javadoc.jar"
+                  classifier="javadoc"/>
+        </artifact-attachments>
+      </m2-deploy>
+      
+      <m2-deploy pom.xml="lucene-contrib-pom.xml.template"/>
+      <contrib-crawl target="dist-maven"/>
+    </sequential>
+  </target>
+	
+  <!-- ================================================================== -->
+  <!-- Build the JavaCC files into the source tree                        -->
+  <!-- ================================================================== -->
+  <target name="jjdoc">
+    <mkdir dir="${build.dir}/docs/grammars"/>
+    <jjdoc target="src/java/org/apache/lucene/queryParser/QueryParser.jj"
+           outputfile="${build.dir}/docs/grammars/QueryParser.html"
+           javacchome="${javacc.home}"
+    />
+    <jjdoc target="src/java/org/apache/lucene/analysis/standard/StandardTokenizer.jj"
+           outputfile="${build.dir}/docs/grammars/StandardTokenizer.html"
+           javacchome="${javacc.home}"
+    />
+    <jjdoc target="src/demo/org/apache/lucene/demo/html/HTMLParser.jj"
+           outputfile="${build.dir}/docs/grammars/HTMLParser.html"
+           javacchome="${javacc.home}"
+    />
+  </target>
+
+  <target name="clean-javacc">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/analysis/standard" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+        <exclude name="ParseException.java"/>
+      </fileset>
+      <fileset dir="src/java/org/apache/lucene/queryParser" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+      <fileset dir="src/demo/org/apache/lucene/demo/html" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+    </delete>
+  </target>
+
+  <target name="javacc" depends="clean-javacc,javacc-QueryParser,javacc-HTMLParser"/>
+
+  <target name="javacc-QueryParser" depends="init,javacc-check" if="javacc.present">
+    <invoke-javacc target="src/java/org/apache/lucene/queryParser/QueryParser.jj"
+                   outputDir="src/java/org/apache/lucene/queryParser"
+    />
+  </target>
+  
+  <target name="javacc-HTMLParser" depends="init,javacc-check" if="javacc.present">
+    <invoke-javacc target="src/demo/org/apache/lucene/demo/html/HTMLParser.jj"
+                   outputDir="src/demo/org/apache/lucene/demo/html"
+    />
+  </target>
+  
+  <!-- ================================================================== -->
+  <!-- Build the JFlex files into the source tree                         -->
+  <!-- ================================================================== -->
+
+  <target name="jflex" depends="clean-jflex,jflex-StandardAnalyzer" />
+
+  <target name="jflex-StandardAnalyzer" depends="init,jflex-check" if="jflex.present">
+    <taskdef classname="JFlex.anttask.JFlexTask" name="jflex">
+      <classpath location="${jflex.home}/lib/JFlex.jar" />
+    </taskdef>
+
+    <jflex file="src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex"
+           outdir="src/java/org/apache/lucene/analysis/standard"
+           nobak="on" />
+  </target>
+
+  <target name="clean-jflex">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/analysis/standard" includes="*.java">
+        <containsregexp expression="generated.*by.*JFlex"/>
+      </fileset>
+    </delete>
+  </target>
+
+  <macrodef name="contrib-crawl">
+    <attribute name="target" default=""/>
+    <attribute name="failonerror" default="true"/>
+    <sequential>
+      <subant target="@{target}" failonerror="@{failonerror}">
+        <fileset dir="."
+                 includes="contrib/*/build.xml"
+        />
+      </subant>
+    </sequential>
+  </macrodef>
+
+  <target name="build-contrib"
+          description="Builds all contrib modules and their tests">
+    <contrib-crawl target="build-artifacts-and-tests"/>
+  </target>
+
+  <target name="test-contrib" depends="build-contrib">
+    <!-- Don't fail on error, instead check for flag file so we run
+         all the tests possible and can "ant generate-test-reports"
+         for all of them.
+
+         Because of this, we depend on "build-contrib" even though the
+         Individual contrib "test" targets probably have the
+         neccessary dependencies.  If they fail to compile, we won't
+         know about it.
+     -->
+    <contrib-crawl target="test" failonerror="false"/>
+    <available property="contribs.failed" file="junitfailed.flag">
+      <filepath>
+        <dirset dir="${build.dir}/contrib/">
+          <include name="**/test/" />
+        </dirset>
+      </filepath>
+    </available>
+    <fail if="contribs.failed">Contrib tests failed!</fail>
+  </target>
+
+  <!-- Macro for building checksum files
+       This is only needed until the "format" option is supported
+       by ant's built in checksum task
+   -->
+  <macrodef name="lucene-checksum">
+    <attribute name="file"/>
+    <!-- NOTE: we use the value of @{file} in the names any properties
+         set because macro's don't have variables, and otherwise we
+         wouldn't be able to checksum more then one file per build
+      -->
+    <sequential>
+      <checksum file="@{file}"
+                property="@{file}.sum"
+                algorithm="${checksum.algorithm}" />
+      <basename file="@{file}" property="@{file}.base" />
+      <concat destfile="@{file}.${checksum.algorithm}"
+              force="yes"
+              append="false"
+              fixlastline="yes">
+        <header trimleading="yes">${@{file}.sum}  </header>
+        <!-- empty fileset to trick concat -->
+        <fileset dir="." excludes="**" />
+        <footer trimleading="yes">${@{file}.base}
+        </footer>
+      </concat>
+    </sequential>
+  </macrodef>
+
+  <!--
+   compile changes.txt into an html file
+   -->
+
+  <target name="changes-to-html">
+    <mkdir dir="${changes.target.dir}"/>
+    <exec executable="perl" input="CHANGES.txt" output="${changes.target.dir}/Changes.html" failonerror="true">
+      <arg value="${changes.src.dir}/changes2html.pl"/>
+    </exec>
+    <copy todir="${changes.target.dir}">
+      <fileset dir="${changes.src.dir}" includes="*.css"/>
+    </copy>
+  </target>
+
+  <!--
+   Committer helpers
+   -->
+
+  <property name="patch.file" value="${basedir}/../patches/${patch.name}"/>
+  <!-- Apply a patch.  Assumes  patch can be applied in the basedir.
+  -Dpatch.name assumes the patch is located in ${basedir}/../patches/${patch.name}
+  -Dpatch.file means the patch can be located anywhere on the file system
+  -->
+  <target name="apply-patch" depends="clean" description="Apply a patch file.  Set -Dpatch.file, or -Dpatch.name when the patch is in the directory ../patches/">
+    <patch patchfile="${patch.file}" strip="0"/>
+  </target>
+
+  <target name="rat-sources-typedef">
+    <typedef resource="org/apache/rat/anttasks/antlib.xml" uri="antlib:rat.anttasks">
+      <classpath>
+        <fileset dir="." includes="rat*.jar"/>
+      </classpath>
+    </typedef>
+  </target>
+
+  <target name="rat-sources" depends="rat-sources-typedef"
+	  description="runs the tasks over src/java">
+    <rat:report xmlns:rat="antlib:org.apache.rat.anttasks">
+      <fileset dir="src/java">
+      </fileset>
+    </rat:report>
+  </target>
+
+</project>
diff --git a/benchmarks/bms/Sequential/Makefile b/benchmarks/bms/Sequential/Makefile
new file mode 100755
index 0000000..9d7cbed
--- /dev/null
+++ b/benchmarks/bms/Sequential/Makefile
@@ -0,0 +1,17 @@
+all:
+	cp Search.java ../lusearch-fix/src/org/dacapo/lusearchFix/Search.java
+	cp ./bms-lusearch-fix-build.xml  ../lusearch-fix/build.xml
+	cp ./libs.xml ../../libs/.
+	wget -c http://archive.apache.org/dist/lucene/java/lucene-2.4.1-src.tar.gz
+	mv lucene-2.4.1-src.tar.gz ../../libs/lucene/downloads/.
+	wget -c http://archive.apache.org/dist/commons/cli/binaries/commons-cli-1.2-bin.tar.gz
+	mv commons-cli-1.2-bin.tar.gz ../../harness/downloads/
+	cd ../../libs/lucene/downloads; tar xvfz lucene-2.4.1-src.tar.gz
+	cp QueryParserTokenManager.java ../../libs/lucene/downloads/lucene-2.4.1/src/java/org/apache/lucene/queryParser/.
+	cp lucene-build.xml  ../../libs/lucene/downloads/lucene-2.4.1/build.xml
+	rm ../../libs/lucene/downloads/lucene-2.4.1-src.tar.gz 2>/dev/null
+	cp -rf ../../libs/lucene/downloads/lucene-2.4.1 .
+	tar cvfz lucene-2.4.1-src.tar.gz lucene-2.4.1
+	rm -rf lucene-2.4.1
+	mv lucene-2.4.1-src.tar.gz ../../libs/lucene/downloads/.
+	cd ../../; ant clean lusearch-fix
diff --git a/benchmarks/bms/Sequential/QueryParserTokenManager.java b/benchmarks/bms/Sequential/QueryParserTokenManager.java
new file mode 100644
index 0000000..3347108
--- /dev/null
+++ b/benchmarks/bms/Sequential/QueryParserTokenManager.java
@@ -0,0 +1,1185 @@
+/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */
+package org.apache.lucene.queryParser;
+import java.io.IOException;
+import java.io.StringReader;
+import java.text.DateFormat;
+import java.text.Collator;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Vector;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.document.DateField;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.ConstantScoreRangeQuery;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.util.Parameter;
+
+/** Token Manager. */
+public class QueryParserTokenManager implements QueryParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_3(int pos, long active0)
+{
+   switch (pos)
+   {
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_3(int pos, long active0)
+{
+   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_3()
+{
+   switch(curChar)
+   {
+      case 40:
+         return jjStopAtPos(0, 13);
+      case 41:
+         return jjStopAtPos(0, 14);
+      case 42:
+         return jjStartNfaWithStates_3(0, 16, 36);
+      case 43:
+         return jjStopAtPos(0, 11);
+      case 45:
+         return jjStopAtPos(0, 12);
+      case 58:
+         return jjStopAtPos(0, 15);
+      case 91:
+         return jjStopAtPos(0, 23);
+      case 94:
+         return jjStopAtPos(0, 17);
+      case 123:
+         return jjStopAtPos(0, 24);
+      default :
+         return jjMoveNfa_3(0, 0);
+   }
+}
+private int jjStartNfaWithStates_3(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_3(state, pos + 1);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_3(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 36;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+               case 25:
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 0:
+                  if ((0xfbffd4f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  else if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  else if (curChar == 33)
+                  {
+                     if (kind > 10)
+                        kind = 10;
+                  }
+                  if ((0x7bffd0f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  else if (curChar == 42)
+                  {
+                     if (kind > 21)
+                        kind = 21;
+                  }
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 4:
+                  if (curChar == 38 && kind > 8)
+                     kind = 8;
+                  break;
+               case 5:
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 13:
+                  if (curChar == 33 && kind > 10)
+                     kind = 10;
+                  break;
+               case 14:
+                  if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 15:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 18:
+                  if (curChar == 34 && kind > 18)
+                     kind = 18;
+                  break;
+               case 20:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjAddStates(8, 9);
+                  break;
+               case 21:
+                  if (curChar == 46)
+                     jjCheckNAdd(22);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjCheckNAdd(22);
+                  break;
+               case 23:
+                  if (curChar == 42 && kind > 21)
+                     kind = 21;
+                  break;
+               case 24:
+                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 27:
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if ((0x7bffd0f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+                  if ((0x7bfff8f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 31:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+                  if ((0x7bfff8f8ffffd9ffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 34:
+                  jjCheckNAddStates(10, 12);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddTwoStates(27, 27);
+                  break;
+               case 0:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddStates(13, 15);
+                  else if (curChar == 126)
+                  {
+                     if (kind > 20)
+                        kind = 20;
+                     jjstateSet[jjnewStateCnt++] = 20;
+                  }
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  else if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  else if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  else if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 1:
+                  if (curChar == 68 && kind > 8)
+                     kind = 8;
+                  break;
+               case 2:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 3:
+                  if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 6:
+                  if (curChar == 82 && kind > 9)
+                     kind = 9;
+                  break;
+               case 7:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  break;
+               case 8:
+                  if (curChar == 124 && kind > 9)
+                     kind = 9;
+                  break;
+               case 9:
+                  if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 10:
+                  if (curChar == 84 && kind > 10)
+                     kind = 10;
+                  break;
+               case 11:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 12:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  break;
+               case 15:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 16:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 17;
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 19:
+                  if (curChar != 126)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjstateSet[jjnewStateCnt++] = 20;
+                  break;
+               case 24:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 25:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 26:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(27, 27);
+                  break;
+               case 27:
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 30:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(31, 31);
+                  break;
+               case 31:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                     jjCheckNAddStates(10, 12);
+                  break;
+               case 33:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(34, 34);
+                  break;
+               case 34:
+                  jjCheckNAddStates(10, 12);
+                  break;
+               case 35:
+                  if (curChar == 92)
+                     jjCheckNAddStates(13, 15);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 36:
+               case 25:
+               case 27:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddTwoStates(25, 26);
+                  }
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddStates(3, 7);
+                  }
+                  break;
+               case 15:
+               case 17:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 24:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddTwoStates(25, 26);
+                  break;
+               case 28:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddStates(3, 7);
+                  break;
+               case 29:
+               case 31:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(29, 30);
+                  break;
+               case 32:
+               case 34:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(10, 12);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { 
+        return curPos; 
+      }
+   }
+}
+private final int jjStopStringLiteralDfa_1(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x40000000L) != 0L)
+         {
+            jjmatchedKind = 33;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_1(int pos, long active0)
+{
+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_1(0x40000000L);
+      case 125:
+         return jjStopAtPos(0, 31);
+      default :
+         return jjMoveNfa_1(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_1(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x40000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 30, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_1(0, active0);
+}
+private int jjStartNfaWithStates_1(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_1(state, pos + 1);
+}
+private int jjMoveNfa_1(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 33)
+                        kind = 33;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 32)
+                     kind = 32;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xdfffffffffffffffL & l) == 0L)
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(16, 18);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 33)
+                     kind = 33;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(16, 18);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   return jjMoveNfa_0(0, 0);
+}
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 3;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 25)
+                     kind = 25;
+                  jjAddStates(19, 20);
+                  break;
+               case 1:
+                  if (curChar == 46)
+                     jjCheckNAdd(2);
+                  break;
+               case 2:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 25)
+                     kind = 25;
+                  jjCheckNAdd(2);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjStopStringLiteralDfa_2(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x4000000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_2(int pos, long active0)
+{
+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_2(0x4000000L);
+      case 93:
+         return jjStopAtPos(0, 27);
+      default :
+         return jjMoveNfa_2(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 26, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(0, active0);
+}
+private int jjStartNfaWithStates_2(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_2(state, pos + 1);
+}
+private int jjMoveNfa_2(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 29)
+                        kind = 29;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(16, 18);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 28)
+                     kind = 28;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xffffffffdfffffffL & l) == 0L)
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(16, 18);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 29)
+                     kind = 29;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(16, 18);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+static final int[] jjnextStates = {
+   15, 16, 18, 29, 32, 23, 33, 30, 20, 21, 32, 23, 33, 31, 34, 27, 
+   2, 4, 5, 0, 1, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
+"\50", "\51", "\72", "\52", "\136", null, null, null, null, null, "\133", "\173", 
+null, "\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "Boost",
+   "RangeEx",
+   "RangeIn",
+   "DEFAULT",
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 
+   3, -1, 3, -1, -1, -1, 3, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x3ffffff01L, 
+};
+static final long[] jjtoSkip = {
+   0x80L, 
+};
+protected CharStream input_stream;
+private final int[] jjrounds = new int[36];
+private final int[] jjstateSet = new int[72];
+protected char curChar;
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream){
+   input_stream = stream;
+}
+
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 36; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 4 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 3;
+int defaultLexState = 3;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      return matchedToken;
+   }
+
+   switch(curLexState)
+   {
+     case 0:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_0();
+       break;
+     case 1:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_1();
+       break;
+     case 2:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_2();
+       break;
+     case 3:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_3();
+       break;
+   }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else
+        {
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/benchmarks/bms/Sequential/Search.java b/benchmarks/bms/Sequential/Search.java
new file mode 100644
index 0000000..9486d48
--- /dev/null
+++ b/benchmarks/bms/Sequential/Search.java
@@ -0,0 +1,313 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Contributors:
+ *     Apache Software Foundation 
+ *     Australian National University - adaptation to DaCapo test harness
+ */
+package org.dacapo.lusearchFix;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.FilterIndexReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.TopDocCollector;
+
+/**
+ * Simple command-line based search demo.
+ * 
+ * @date $Date: 2009-12-24 11:19:36 +1100 (Thu, 24 Dec 2009) $
+ * @id $Id: Search.java 738 2009-12-24 00:19:36Z steveb-oss $
+ */
+public class Search {
+
+  static final int MAX_DOCS_TO_COLLECT = 20;
+  public int completed = 0;
+  private int COMPLETION_GOAL; 
+
+  /**
+   * Use the norms from one field for all fields. Norms are read into memory,
+   * using a byte of memory per document per searched field. This can cause
+   * search of large collections with a large number of fields to run out of
+   * memory. If all of the fields contain only a single token, then the norms
+   * are all identical, then single norm vector may be shared.
+   */
+  private static class OneNormsReader extends FilterIndexReader {
+    private String field;
+
+    public OneNormsReader(IndexReader in, String field) {
+      super(in);
+      this.field = field;
+    }
+
+    public byte[] norms(String field) throws IOException {
+      return in.norms(this.field);
+    }
+  }
+
+  public Search() {
+  }
+
+  /** Simple command-line based search demo. */
+  public void main(String[] args) throws Exception {
+    String usage = "Usage:\tjava org.dacapo.lusearchFix.Search [-index dir] [-field f] [-repeat n] [-queries file] [-raw] [-norms field] [-paging hitsPerPage]";
+    usage += "\n\tSpecify 'false' for hitsPerPage to use streaming instead of paging search.";
+    if (args.length > 0 && ("-h".equals(args[0]) || "-help".equals(args[0]))) {
+      System.out.println(usage);
+      System.exit(0);
+    }
+
+    String index = "index";
+    String field = "contents";
+    String queryBase = null;
+    int repeat = 0;
+    boolean raw = false;
+    String normsField = null;
+    int hitsPerPage = 10;
+    String outBase = null;
+    int threads = 1;
+    int totalQueries = 32;
+
+    for (int i = 0; i < args.length; i++) {
+      if ("-index".equals(args[i])) {
+        index = args[i + 1];
+        i++;
+      } else if ("-field".equals(args[i])) {
+        field = args[i + 1];
+        i++;
+      } else if ("-queries".equals(args[i])) {
+        queryBase = args[i + 1];
+        i++;
+      } else if ("-repeat".equals(args[i])) {
+        repeat = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-raw".equals(args[i])) {
+        raw = true;
+      } else if ("-norms".equals(args[i])) {
+        normsField = args[i + 1];
+        i++;
+      } else if ("-paging".equals(args[i])) {
+        hitsPerPage = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-output".equals(args[i])) {
+        outBase = args[i + 1];
+        i++;
+      } else if ("-threads".equals(args[i])) {
+        threads = Integer.parseInt(args[i + 1]);
+        i++;
+      } else if ("-totalqueries".equals(args[i])) {
+        totalQueries = Integer.parseInt(args[i + 1]);
+        i++;
+      }
+    }
+    completed = 0;
+    COMPLETION_GOAL = (int)( 0.8 * totalQueries);
+    final QueryThread[] queryThreads = new QueryThread[totalQueries];
+    try {
+      for (int j = 0; j < totalQueries; j++) {
+        queryThreads[j] = new QueryThread(this, "Query" + j, j, threads, totalQueries, index, outBase, queryBase, field, normsField, raw, hitsPerPage);
+        queryThreads[j].run();
+      }
+    } catch(java.util.concurrent.CancellationException e) { }
+  }
+
+  class QueryThread {
+    Search parent;
+    int id;
+    int threadCount;
+    int totalQueries;
+    String name;
+    String index;
+    String outBase;
+    String queryBase;
+    String field;
+    String normsField;
+    boolean raw;
+    int hitsPerPage;
+
+    public QueryThread(Search parent, String name, int id, int threadCount, int totalQueries, String index, String outBase, String queryBase, String field,
+        String normsField, boolean raw, int hitsPerPage) {
+      //super(name);
+      this.parent = parent;
+      this.id = id;
+      this.threadCount = threadCount;
+      this.totalQueries = totalQueries;
+      this.name = name;
+      this.index = index;
+      this.outBase = outBase;
+      this.queryBase = queryBase;
+      this.field = field;
+      this.normsField = normsField;
+      this.raw = raw;
+      this.hitsPerPage = hitsPerPage;
+    }
+
+    public void run() {
+      try {
+        //int count = totalQueries / threadCount + (id < (totalQueries % threadCount) ? 1 : 0);
+        //for (int i = 0, queryId = id; i < count; i++, queryId += threadCount) {
+          // make and run query
+          new QueryProcessor(parent, name, id, index, outBase, queryBase, field, normsField, raw, hitsPerPage).run();
+        //}
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+
+  }
+
+  public class QueryProcessor {
+
+    Search parent;
+    String field;
+    int hitsPerPage;
+    boolean raw;
+
+    IndexReader reader;
+    Searcher searcher;
+    BufferedReader in;
+    PrintWriter out;
+
+    public QueryProcessor(Search parent, String name, int id, String index, String outBase, String queryBase, String field, String normsField, boolean raw,
+        int hitsPerPage) {
+      this.parent = parent;
+      this.field = field;
+      this.raw = raw;
+      this.hitsPerPage = hitsPerPage;
+      try {
+        reader = IndexReader.open(index);
+        if (normsField != null)
+          reader = new OneNormsReader(reader, normsField);
+        searcher = new IndexSearcher(reader);
+
+        String query = queryBase + (id < 10 ? "00" : (id < 100 ? "0" : "")) + id + ".txt";
+        in = new BufferedReader(new FileReader(query));
+        out = new PrintWriter(new BufferedWriter(new FileWriter(outBase + id)));
+
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+
+    public void run() throws java.io.IOException {
+      Analyzer analyzer = new StandardAnalyzer();
+      QueryParser parser = new QueryParser(field, analyzer);
+
+      while (true) {
+        String line = in.readLine();
+
+        if (line == null || line.length() == -1)
+          break;
+
+        line = line.trim();
+        if (line.length() == 0)
+          break;
+
+        Query query = null;
+        try {
+          query = parser.parse(line);
+        } catch (org.apache.lucene.queryParser.ParseException e) {
+          e.printStackTrace();
+        }
+        searcher.search(query, null, 10);
+
+        doPagingSearch(query);
+      }
+
+      reader.close();
+      out.flush();
+      out.close();
+     
+      synchronized (parent) {
+        ++parent.completed;
+        if (parent.completed % 4 == 0) {
+          System.out.println(parent.completed + " query batches completed");
+        }
+        //parent.notify();
+      }
+  
+      if(parent.completed >= parent.COMPLETION_GOAL) {
+        System.out.println("Aborting as "+parent.completed+" completed");
+        throw new java.util.concurrent.CancellationException("Goal found");
+      }
+    }
+
+    /**
+     * This demonstrates a typical paging search scenario, where the search
+     * engine presents pages of size n to the user. The user can then go to the
+     * next page if interested in the next hits.
+     * 
+     * When the query is executed for the first time, then only enough results
+     * are collected to fill 5 result pages. If the user wants to page beyond
+     * this limit, then the query is executed another time and all hits are
+     * collected.
+     * 
+     */
+    public void doPagingSearch(Query query) throws IOException {
+
+      // Collect enough docs to show 5 pages
+      TopDocCollector collector = new TopDocCollector(MAX_DOCS_TO_COLLECT);
+      searcher.search(query, collector);
+      ScoreDoc[] hits = collector.topDocs().scoreDocs;
+
+      int numTotalHits = collector.getTotalHits();
+      if (numTotalHits > 0)
+        out.println(numTotalHits + " total matching documents for " + query.toString(field));
+
+      int start = 0;
+      int end = Math.min(numTotalHits, hitsPerPage);
+
+      while (start < Math.min(MAX_DOCS_TO_COLLECT, numTotalHits)) {
+        end = Math.min(hits.length, start + hitsPerPage);
+
+        for (int i = start; i < end; i++) {
+          if (raw) { // output raw format
+            out.println("doc=" + hits[i].doc + " score=" + hits[i].score);
+            continue;
+          }
+
+          Document doc = searcher.doc(hits[i].doc);
+          String path = doc.get("path");
+          if (path != null) {
+            out.println("\t" + (i + 1) + ". " + path);
+            String title = doc.get("title");
+            if (title != null) {
+              out.println("   Title: " + doc.get("title"));
+            }
+          } else {
+            out.println((i + 1) + ". " + "No path for this document");
+          }
+
+        }
+        start = end;
+      }
+    }
+  }
+}
+
diff --git a/benchmarks/bms/Sequential/bms-lusearch-fix-build.xml b/benchmarks/bms/Sequential/bms-lusearch-fix-build.xml
new file mode 100644
index 0000000..56f07b6
--- /dev/null
+++ b/benchmarks/bms/Sequential/bms-lusearch-fix-build.xml
@@ -0,0 +1,53 @@
+<!--
+ * Copyright (c) 2017 The Australian National University.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License v2.0.
+ * You may obtain the license at
+ *
+ *    http://www.opensource.org/licenses/apache2.0.php
+ -->
+<project name="lusearch-fix" default="all" basedir="../..">
+    <description>DaCapo lusearch-fix benchmark</description>
+    <property file="dacapo.properties"/>
+
+    <property name="bm-name" value="lusearch-fix"/>
+
+    <import file="../common.xml"/>
+
+    <target name="fix-operation">
+        <move file="libs/lucene/build.xml" tofile="libs/lucene/build-tmp.xml"/>
+        <copy file="libs/lucene/build-tmp.xml" tofile="libs/lucene/build.xml"/>
+        <touch file="libs/lucene/lucene.patch"/>
+        <patch patchfile="${bm-files}/lusearch-fix.patch" dir="${basedir}" strip="0" ignorewhitespace="yes"/>
+    </target>
+
+    <target name="bm-build" depends="fix-operation, lucene">
+        <mkdir dir="${bm-build-dir}"/>
+        <javac srcdir="${bm-src-dir}" source="1.5"
+               classpath="${harness-classpath}:${lucene-jars}/${lucene-core-jar-name}:${lucene-jars}/${lucene-demos-jar-name}"
+               destdir="${bm-build-dir}"
+               includes="org/dacapo/lusearchFix/*" debug="true" debuglevel="lines,vars,source"/>
+        <delete file="libs/lucene/build.xml"/>
+        <delete file="libs/lucene/lucene.patch"/>
+        <move file="libs/lucene/build-tmp.xml" tofile="libs/lucene/build.xml"/>
+    </target>
+
+    <target name="jar">
+        <jar destfile="${bm-jars}/dacapo-${bm-name}.jar" basedir="${bm-build-dir}"/>
+    </target>
+
+    <target name="copy-data">
+        <mkdir dir="${bm-data}/lusearchFix"/>
+        <copy todir="${bm-data}/lusearchFix">
+            <fileset dir="bms/lusearch/data/lusearch">
+                <include name="**"/>
+            </fileset>
+        </copy>
+    </target>
+
+    <target name="data" depends="copy-data">
+        <zip basedir="${bm-data}" includes="**" destfile="${bm-dat}/${bm-name}.zip"/>
+        <delete dir="${bm-data}"/>
+    </target>
+
+</project>
diff --git a/benchmarks/bms/Sequential/libs.xml b/benchmarks/bms/Sequential/libs.xml
new file mode 100644
index 0000000..841468e
--- /dev/null
+++ b/benchmarks/bms/Sequential/libs.xml
@@ -0,0 +1,117 @@
+<!--
+ * Copyright (c) 2009 The Australian National University.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License v2.0.
+ * You may obtain the license at
+ * 
+ *    http://www.opensource.org/licenses/apache2.0.php
+ -->
+<project name="libs">
+    <property name="lib-base" value="${basedir}/libs"/>
+
+    <!-- bcel -->
+    <property name="bcel-jar" value="${lib-base}/bcel/dist/jar/bcel-5.2.jar"/>
+    <target name="bcel">
+        <ant antfile="${lib-base}/bcel/build.xml"/>
+    </target>
+
+    <!-- dacapo-digest -->
+    <property name="dacapo-digest-jar" value="${lib-base}/dacapo-digest/dist/jar/dacapo-digest.jar"/>
+    <target name="dacapo-digest">
+        <ant antfile="${lib-base}/dacapo-digest/build.xml"/>
+    </target>
+
+    <!-- daytrader -->
+    <target name="daytrader">
+        <ant antfile="${lib-base}/daytrader/build.xml"/>
+    </target>
+
+    <!-- jpetstore -->
+    <property name="jpetstore-common" value="${lib-base}/jpetstore/dist/jar/ibatis-common-2.jar"/>
+    <property name="jpetstore-dao" value="${lib-base}/jpetstore/dist/jar/ibatis-dao-2.jar"/>
+    <property name="jpetstore-sqlmap" value="${lib-base}/jpetstore/dist/jar/ibatis-sqlmap-2.jar"/>
+    <property name="jpetstore-jakarta-oro" value="${lib-base}/jpetstore/dist/jar/jakarta-oro.jar"/>
+    <property name="jpetstore-struts" value="${lib-base}/jpetstore/dist/jar/struts.jar"/>
+    <property name="jpetstore-zip" value="${lib-base}/jpetstore/dist/jar/jpetstore.zip"/>
+    <target name="jpetstore">
+        <ant antfile="${lib-base}/jpetstore/build.xml"/>
+    </target>
+
+    <!-- jakarta commons HTTP client -->
+    <property name="commons-httpclient-jar" value="${lib-base}/commons-httpclient/dist/jar/commons-httpclient.jar"/>
+    <target name="commons-httpclient" depends="commons-logging,commons-codec">
+        <ant antfile="${lib-base}/commons-httpclient/build.xml"/>
+    </target>
+
+    <!-- jakarta commons logging -->
+    <property name="commons-logging-jar" value="${lib-base}/commons-logging/dist/jar/commons-logging.jar"/>
+    <target name="commons-logging">
+        <ant antfile="${lib-base}/commons-logging/build.xml"/>
+    </target>
+
+    <!-- jakarta commons codec -->
+    <property name="commons-codec-jar" value="${lib-base}/commons-codec/dist/jar/commons-codec.jar"/>
+    <target name="commons-codec">
+        <ant antfile="${lib-base}/commons-codec/build.xml"/>
+    </target>
+
+    <!-- janino -->
+    <property name="janino-jar" value="${lib-base}/janino/dist/jar/janino-2.5.15.jar"/>
+    <target name="janino">
+        <ant antfile="${lib-base}/janino/build.xml"/>
+    </target>
+
+    <!-- jdbcbench -->
+    <property name="jdbcbench-jar" value="${lib-base}/jdbcbench/dist/jar/jdbcbench.jar"/>
+    <target name="jdbcbench">
+        <ant antfile="${lib-base}/jdbcbench/build.xml"/>
+    </target>
+
+    <!-- derby -->
+    <property name="derby-jar" value="${lib-base}/derby/dist/jar/derby.jar"/>
+    <property name="derbyclient-jar" value="${lib-base}/derby/dist/jar/derbyclient.jar"/>
+    <property name="derbynet-jar" value="${lib-base}/derby/dist/jar/derbynet.jar"/>
+    <property name="derbytools-jar" value="${lib-base}/derby/dist/jar/derbytools.jar"/>
+    <property name="derbytesting-jar" value="${lib-base}/derby/dist/jar/derbyTesting.jar"/>
+    <target name="derby">
+        <ant antfile="${lib-base}/derby/build.xml"/>
+    </target>
+
+    <!-- junit -->
+    <property name="junit-jar" value="${lib-base}/junit/dist/jar/junit-3.8.1.jar"/>
+    <target name="junit">
+        <ant antfile="${lib-base}/junit/build.xml"/>
+    </target>
+
+    <!-- h2-->
+    <property name="h2-version" value="1.2.121"/>
+    <property name="h2-jar" value="${lib-base}/h2/dist/jar/h2-${h2-version}.jar"/>
+    <target name="h2">
+        <ant antfile="${lib-base}/h2/build.xml"/>
+    </target>
+
+    <!-- lucene -->
+    <property name="lucene-jars" value="${lib-base}/lucene/dist/jar"/>
+    <property name="lucene-core-jar-name" value="lucene-core-2.4.jar"/>
+    <property name="lucene-demos-jar-name" value="lucene-demos-2.4.jar"/>
+    <target name="lucene">
+        <ant antfile="${lib-base}/lucene/build.xml"/>
+    </target>
+ 
+    <!-- xerces -->
+    <property name="xerces-jars" value="${lib-base}/xerces/dist/jar"/>
+    <property name="xerces-impl-jar-name" value="xercesImpl.jar"/>
+    <property name="xerces-api-jar-name" value="xml-apis.jar"/>
+    <target name="xerces">
+        <ant antfile="${lib-base}/xerces/build.xml"/>
+    </target>
+
+    <!-- asm -->
+    <property name="asm-verison" value="3.3"/>
+    <property name="asm-jar" value="${lib-base}/asm/dist/jar/asm-${asm-verison}.jar"/>
+    <property name="asm-commons-jar" value="${lib-base}/asm/dist/jar/asm-commons-${asm-verison}.jar"/>
+    <target name="asm">
+      <ant antfile="${lib-base}/asm/build.xml"/>
+    </target>
+
+</project>
diff --git a/benchmarks/bms/Sequential/lucene-build.xml b/benchmarks/bms/Sequential/lucene-build.xml
new file mode 100644
index 0000000..26d640a
--- /dev/null
+++ b/benchmarks/bms/Sequential/lucene-build.xml
@@ -0,0 +1,648 @@
+<?xml version="1.0"?>
+
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+ 
+        http://www.apache.org/licenses/LICENSE-2.0
+ 
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ -->
+
+<project name="core" default="default" basedir=".">
+
+  <property name="junit.includes" value="**/Test*.java"/>
+
+  <import file="common-build.xml"/>
+
+  <property name="build.demo.template" value="src/demo/demo-build.template"/> 
+
+  <property name="demo.name" value="lucene-demos-${version}"/>
+  <property name="demo.war.name" value="luceneweb"/>
+
+  <!-- Type of checksum to compute for distribution files -->
+  <property name="checksum.algorithm" value="md5" />
+	
+  <!-- Build classpath -->
+  <path id="classpath">
+    <pathelement location="${build.dir}/classes/java"/>
+  </path>
+
+  <path id="demo.classpath">
+    <path refid="classpath"/>
+    <pathelement location="${build.dir}/classes/demo"/>
+  </path>
+  
+  <path id="test.classpath">
+    <path refid="demo.classpath"/>
+    <path refid="junit-path"/>
+    <pathelement location="${build.dir}/classes/test"/>
+  </path>
+
+
+  <path id="junit.classpath">
+    <path refid="junit-path"/>
+    <pathelement location="${build.dir}/classes/test"/>
+    <pathelement location="${build.dir}/classes/java"/>
+    <pathelement location="${build.dir}/classes/demo"/>
+    <pathelement path="${java.class.path}"/>
+  </path>
+
+  <patternset id="src.dist.patterns"
+              includes="src/,build.xml,*build*.xml,docs/,*.txt,contrib/,*pom.xml*"
+              excludes="contrib/db/*/lib/,contrib/*/ext-libs/,src/site/build/,contrib/benchmark/temp/*,contrib/benchmark/work/*"
+  />
+  <patternset id="binary.build.dist.patterns"
+              includes="${final.name}.jar,${demo.war.name}.war,${demo.name}.jar,docs/,contrib/*/*.jar"
+  />
+  <patternset id="binary.root.dist.patterns"
+              includes="src/demo/,src/jsp/,docs/,*.txt,contrib/*/README*,**/CHANGES.txt"
+              excludes="${build.demo.template}"
+  />
+
+
+  <!-- ================================================================== -->
+  <!-- Prepares the build directory                                       -->
+  <!-- ================================================================== -->
+
+  <!-- Overrides common.compile-core to add rmic -->
+  <target name="compile-core" depends="common.compile-core"
+          description="Compiles core classes, including rmic">
+    <rmic classname="org.apache.lucene.search.RemoteSearchable"
+      base="${build.dir}/classes/java" stubversion="1.2">
+      <classpath refid="classpath"/>
+    </rmic>
+  </target>
+
+  <target name="test-core" depends="common.test"
+          description="Runs unit tests for the core Lucene code"
+  />
+  <target name="test" depends="test-core, test-contrib"
+          description="Runs all unit tests (including contribs)"
+  />
+  
+  <!-- ================================================================== -->
+  <!-- J A R                                                              -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+
+  <target name="jar-demo" depends="compile-demo">
+  	<sequential>
+  	  <build-manifest title="Lucene Search Engine: demos"/>
+      <jar
+        destfile="${build.dir}/${demo.name}.jar"
+        basedir="${build.dir}/classes/demo"
+        excludes="**/*.java"
+      	manifest="${manifest.file}">
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </jar>
+  	</sequential>
+  </target>
+
+  <target name="jar-demo-src" depends="compile-demo">
+  	<sequential>
+  	  <build-manifest title="Lucene Search Engine: demos"/>
+      <jar
+        destfile="${build.dir}/${demo.name}-src.jar"
+        basedir="src/demo"
+      	manifest="${manifest.file}">
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </jar>
+  	</sequential>
+  </target>
+
+  <target name="war-demo" depends="jar-core,jar-demo">
+    <sequential>
+      <build-manifest title="Lucene Search Engine: demos"/>
+  	  <war destfile="${build.dir}/${demo.war.name}.war"
+           webxml="src/jsp/WEB-INF/web.xml"
+      	   manifest="${manifest.file}">
+        <fileset dir="src/jsp" excludes="WEB-INF/web.xml"/>
+        <lib dir="${build.dir}" includes="${demo.name}.jar"/>
+        <lib dir="${build.dir}" includes="${final.name}.jar"/>
+        <metainf dir="${common.dir}">
+          <include name="LICENSE.txt"/>
+          <include name="NOTICE.txt"/>
+        </metainf>
+      </war>
+    </sequential>
+  </target>
+
+
+  <!-- ================================================================== -->
+  <!-- B U I L D  D E M O                                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="compile-demo" depends="compile-core">
+    <mkdir dir="${build.dir}/classes/demo"/>
+
+    <compile
+      srcdir="src/demo"
+      destdir="${build.dir}/classes/demo">
+      <classpath refid="demo.classpath"/>
+    </compile>
+  </target>
+
+  <!-- GCJ -->
+  <target name="gcj" depends="jar,jar-demo">
+    <exec executable="make" dir="src/gcj" failonerror="true"/>
+  </target>
+
+
+  <!-- TODO: Remove dependency on demo from test -->
+  <target name="compile-test" depends="compile-demo,common.compile-test"/>
+
+
+
+  <!-- ================================================================== -->
+  <!-- D O C U M E N T A T I O N                                          -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="docs" description="Build the website">
+      <echo>DEPRECATED - Doing Nothing.  See http://wiki.apache.org/lucene-java/HowToUpdateTheWebsite</echo>
+  </target>
+
+  <target name="javadocs" description="Generate javadoc" 
+  	      depends="javadocs-all, javadocs-core, javadocs-demo, javadocs-contrib"/>
+	
+  <target name="javadocs-core" description="Generate javadoc for core classes">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}/core"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}/core"
+      	title="${Name} ${version} core API">
+        <sources>
+          <packageset dir="src/java"/>
+          <link href="../"/>
+        </sources>
+      </invoke-javadoc>
+     <jarify basedir="${javadoc.dir}/core" destfile="${build.dir}/${final.name}-javadoc.jar"/>
+    </sequential>
+  </target>
+
+  <target name="javadocs-demo" description="Generate javadoc for demo classes">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}/demo"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}/demo"
+      	title="${Name} ${version} demo API">
+        <sources>
+          <packageset dir="src/demo"/>
+          <link href="../"/>
+        </sources>
+      </invoke-javadoc>
+      <jarify basedir="${javadoc.dir}/demo" destfile="${build.dir}/${demo.name}-javadoc.jar"/>
+    </sequential>
+  </target>
+	
+  <target name="javadocs-contrib" description="Generate javadoc for contrib classes">
+    <contrib-crawl target="javadocs"
+                   failonerror="false"/>
+  </target>
+  	
+  <target name="javadocs-all" description="Generate javadoc for core, demo and contrib classes" depends="build-contrib">
+  	<sequential>
+      <mkdir dir="${javadoc.dir}"/>
+      <invoke-javadoc
+        destdir="${javadoc.dir}">
+        <sources>
+          <!-- TODO: find a dynamic way to do include multiple source roots -->
+          <packageset dir="src/java"/>
+
+          <packageset dir="src/demo"/>
+
+          <!-- please keep this list up to date, and in alpha order...   -->
+        
+          <!-- ie: `find contrib/* -path \*src/java | sort` -->
+
+          <!-- if you make changes to the list of package sets, also -->
+          <!-- make sure the group list below is updated.            -->
+          <!-- Also remember to keep site.xml in sync.            -->		  
+
+          <packageset dir="contrib/analyzers/src/java"/>
+          <packageset dir="contrib/ant/src/java"/>
+          <packageset dir="contrib/benchmark/src/java"/>
+          <packageset dir="contrib/db/bdb-je/src/java"/>
+          <packageset dir="contrib/db/bdb/src/java"/>
+          <packageset dir="contrib/highlighter/src/java"/>
+          <packageset dir="contrib/instantiated/src/java"/>
+          <packageset dir="contrib/lucli/src/java"/>
+          <packageset dir="contrib/memory/src/java"/>
+          <packageset dir="contrib/miscellaneous/src/java"/>
+          <packageset dir="contrib/queries/src/java"/>
+          <packageset dir="contrib/regex/src/java"/>
+          <packageset dir="contrib/similarity/src/java"/>
+          <packageset dir="contrib/snowball/src/java"/>
+          <packageset dir="contrib/spellchecker/src/java"/>
+          <packageset dir="contrib/surround/src/java"/>
+          <packageset dir="contrib/swing/src/java"/>
+          <packageset dir="contrib/wikipedia/src/java"/>
+          <packageset dir="contrib/wordnet/src/java"/>
+          <packageset dir="contrib/xml-query-parser/src/java"/>
+          <!-- end alpha sort -->
+
+          <!-- If the main javadoc Group listing includes an "Other   -->
+          <!-- Packages" group after the ones listed here, then those -->
+          <!-- packages are not being matched by any of these rules   -->
+  
+          <group title="Core" packages="org.apache.*:org.apache.lucene.analysis:org.apache.lucene.analysis.standard*"/>
+  
+          <group title="Demo" packages="org.apache.lucene.demo*"/>
+  
+          <group title="contrib: Analysis" packages="org.apache.lucene.analysis.*"/>
+          <group title="contrib: Ant" packages="org.apache.lucene.ant*"/>
+          <group title="contrib: Benchmark" packages="org.apache.lucene.benchmark*"/>
+          <group title="contrib: DB" packages="org.apache.lucene.store.db*:org.apache.lucene.store.je*:com.sleepycat*"/>
+          <group title="contrib: Highlighter" packages="org.apache.lucene.search.highlight*"/>
+          <group title="contrib: Instantiated" packages="org.apache.lucene.store.instantiated*"/>
+          <group title="contrib: Lucli" packages="lucli*"/>
+          <group title="contrib: Memory" packages="org.apache.lucene.index.memory*"/>
+          <group title="contrib: Miscellaneous " packages="org.apache.lucene.misc*:org.apache.lucene.queryParser.analyzing*:org.apache.lucene.queryParser.precedence*"/>
+          <group title="contrib: Queries" packages="org.apache.lucene.search.similar*"/>
+          <group title="contrib: RegEx" packages="org.apache.lucene.search.regex*:org.apache.regexp*"/>
+          <!-- no group for similarity. -->
+          <!-- nothing in there at the moment, so no package structure -->
+          <group title="contrib: Snowball" packages="org.apache.lucene.analysis.snowball*:net.sf.snowball*"/>
+
+          <group title="contrib: SpellChecker" packages="org.apache.lucene.search.spell*"/>
+          <group title="contrib: Surround Parser" packages="org.apache.lucene.queryParser.surround*"/>
+          <group title="contrib: Swing" packages="org.apache.lucene.swing*"/>
+          <group title="contrib: Wikipedia" packages="org.apache.lucene.wikipedia*"/>
+          <group title="contrib: WordNet" packages="org.apache.lucene.wordnet*"/>
+          <group title="contrib: XML Query Parser" packages="org.apache.lucene.xmlparser*"/>
+
+        </sources>
+      </invoke-javadoc>
+  	</sequential>
+  </target>
+
+
+  <!-- ================================================================== -->
+  <!-- D I S T R I B U T I O N                                            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package" depends="jar-core, javadocs, war-demo, build-contrib, init-dist">
+     <copy file="${build.demo.template}" tofile="${build.dir}/build-demo.xml">
+        <filterset begintoken="@PLACEHOLDER_" endtoken="@"> 
+	  <filter token="version" value="${version}"/>
+	  <filter token="javac.source" value="${javac.source}"/>
+	  <filter token="javac.target" value="${javac.target}"/>
+        </filterset>
+     </copy>
+  </target>
+
+  <target name="nightly" depends="test, package-tgz, changes-to-html">
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the distribution with zip                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-zip" depends="package"
+    description="--> Generates the Lucene distribution as .zip">
+
+    <delete file="${dist.dir}/lucene-${version}.zip"/>
+    <zip destfile="${dist.dir}/lucene-${version}.zip">
+      <zipfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="binary.root.dist.patterns"/>
+      </zipfileset>
+      <zipfileset dir="${build.dir}" includes="build-demo.xml" fullpath="lucene-${version}/build.xml"/>
+      <zipfileset prefix="lucene-${version}" dir="${build.dir}">
+        <patternset refid="binary.build.dist.patterns"/>
+      </zipfileset>
+    </zip>
+	<lucene-checksum file="${dist.dir}/lucene-${version}.zip"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- packages the distribution with tar-gzip                            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-tgz" depends="package"
+    description="--> Generates the lucene distribution as .tar.gz">
+
+    <delete file="${build.dir}/lucene-${version}.tar"/>
+    <delete file="${dist.dir}/lucene-${version}.tar.gz"/>
+    <tar tarfile="${build.dir}/lucene-${version}.tar">
+      <tarfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="binary.root.dist.patterns"/>
+      </tarfileset>
+      <tarfileset dir="${build.dir}" includes="build-demo.xml" fullpath="lucene-${version}/build.xml"/>
+      <tarfileset prefix="lucene-${version}" dir="${build.dir}">
+        <patternset refid="binary.build.dist.patterns"/>
+      </tarfileset>
+    </tar>
+
+    <gzip zipfile="${dist.dir}/lucene-${version}.tar.gz"
+      src="${build.dir}/lucene-${version}.tar"
+      />
+	<lucene-checksum file="${dist.dir}/lucene-${version}.tar.gz"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- packages the distribution with zip and tar-gzip                    -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-all-binary" depends="package-zip, package-tgz"
+    description="--> Generates the .tar.gz and .zip distributions"/>
+
+  <!-- ================================================================== -->
+  <!-- same as package-all. it is just here for compatibility.            -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="dist" depends="package-all-binary"/>
+
+  <!-- ================================================================== -->
+  <!-- S O U R C E  D I S T R I B U T I O N                               -->
+  <!-- ================================================================== -->
+    <target name="init-dist" >
+
+        <!-- Package is not called first if packaging src standalone, so the dist.dir may not exist -->
+        <mkdir dir="${build.dir}"/>
+        <mkdir dir="${dist.dir}"/>
+        <mkdir dir="${maven.dist.dir}"/>
+    </target>
+  <!-- ================================================================== -->
+  <!-- Packages the sources with zip                                      -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-zip-src" depends="init, init-dist"
+    description="--> Generates the Lucene sources as .zip">
+    <zip destfile="${dist.dir}/lucene-${version}-src.zip">
+      <zipfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="src.dist.patterns"/>
+      </zipfileset>
+    </zip>
+	<lucene-checksum file="${dist.dir}/lucene-${version}-src.zip"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the sources with tar-gzip                                 -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-tgz-src" depends="init, init-dist"
+    description="--> Generates the Lucene distribution as .tar.gz">
+
+    <delete file="${build.dir}/lucene-${version}-src.tar"/>
+    <delete file="${dist.dir}/lucene-${version}-src.tar.gz"/>
+    <tar tarfile="${build.dir}/lucene-${version}-src.tar">
+      <tarfileset prefix="lucene-${version}" dir=".">
+        <patternset refid="src.dist.patterns"/>
+      </tarfileset>
+    </tar>
+
+    <gzip zipfile="${dist.dir}/lucene-${version}-src.tar.gz"
+          src="${build.dir}/lucene-${version}-src.tar"
+    />
+	<lucene-checksum file="${dist.dir}/lucene-${version}-src.tar.gz"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Packages the sources with zip and tar-gzip                         -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="package-all-src" depends="package-zip-src, package-tgz-src"
+    description="--> Generates the .tar.gz and .zip source distributions"/>
+
+  <!-- ================================================================== -->
+  <!-- same as package-all-src. it is just here for compatibility.        -->
+  <!-- ================================================================== -->
+  <!--                                                                    -->
+  <!-- ================================================================== -->
+  <target name="dist-src" depends="package-all-src"/>
+
+  <target name="dist-all" depends="dist, dist-src"/>
+
+  <target name="generate-maven-artifacts" depends="maven.ant.tasks-check, package, jar-src, jar-demo-src, javadocs">
+    <sequential>
+      <m2-deploy pom.xml="lucene-parent-pom.xml.template"/>
+      <m2-deploy pom.xml="lucene-core-pom.xml.template">
+        <artifact-attachments>
+          <attach file="${build.dir}/${final.name}-src.jar"
+                  classifier="sources"/>
+          <attach file="${build.dir}/${final.name}-javadoc.jar"
+                  classifier="javadoc"/>
+        </artifact-attachments>
+      </m2-deploy>
+      
+      <m2-deploy pom.xml="lucene-demos-pom.xml.template">
+        <artifact-attachments>
+          <attach file="${build.dir}/${demo.name}-src.jar"
+                  classifier="sources"/>
+          <attach file="${build.dir}/${demo.name}-javadoc.jar"
+                  classifier="javadoc"/>
+        </artifact-attachments>
+      </m2-deploy>
+      
+      <m2-deploy pom.xml="lucene-contrib-pom.xml.template"/>
+      <contrib-crawl target="dist-maven"/>
+    </sequential>
+  </target>
+	
+  <!-- ================================================================== -->
+  <!-- Build the JavaCC files into the source tree                        -->
+  <!-- ================================================================== -->
+  <target name="jjdoc">
+    <mkdir dir="${build.dir}/docs/grammars"/>
+    <jjdoc target="src/java/org/apache/lucene/queryParser/QueryParser.jj"
+           outputfile="${build.dir}/docs/grammars/QueryParser.html"
+           javacchome="${javacc.home}"
+    />
+    <jjdoc target="src/java/org/apache/lucene/analysis/standard/StandardTokenizer.jj"
+           outputfile="${build.dir}/docs/grammars/StandardTokenizer.html"
+           javacchome="${javacc.home}"
+    />
+    <jjdoc target="src/demo/org/apache/lucene/demo/html/HTMLParser.jj"
+           outputfile="${build.dir}/docs/grammars/HTMLParser.html"
+           javacchome="${javacc.home}"
+    />
+  </target>
+
+  <target name="clean-javacc">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/analysis/standard" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+        <exclude name="ParseException.java"/>
+      </fileset>
+      <fileset dir="src/java/org/apache/lucene/queryParser" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+      <fileset dir="src/demo/org/apache/lucene/demo/html" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
+    </delete>
+  </target>
+
+  <target name="javacc" depends="clean-javacc,javacc-QueryParser,javacc-HTMLParser"/>
+
+  <target name="javacc-QueryParser" depends="init,javacc-check" if="javacc.present">
+    <invoke-javacc target="src/java/org/apache/lucene/queryParser/QueryParser.jj"
+                   outputDir="src/java/org/apache/lucene/queryParser"
+    />
+  </target>
+  
+  <target name="javacc-HTMLParser" depends="init,javacc-check" if="javacc.present">
+    <invoke-javacc target="src/demo/org/apache/lucene/demo/html/HTMLParser.jj"
+                   outputDir="src/demo/org/apache/lucene/demo/html"
+    />
+  </target>
+  
+  <!-- ================================================================== -->
+  <!-- Build the JFlex files into the source tree                         -->
+  <!-- ================================================================== -->
+
+  <target name="jflex" depends="clean-jflex,jflex-StandardAnalyzer" />
+
+  <target name="jflex-StandardAnalyzer" depends="init,jflex-check" if="jflex.present">
+    <taskdef classname="JFlex.anttask.JFlexTask" name="jflex">
+      <classpath location="${jflex.home}/lib/JFlex.jar" />
+    </taskdef>
+
+    <jflex file="src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex"
+           outdir="src/java/org/apache/lucene/analysis/standard"
+           nobak="on" />
+  </target>
+
+  <target name="clean-jflex">
+    <delete>
+      <fileset dir="src/java/org/apache/lucene/analysis/standard" includes="*.java">
+        <containsregexp expression="generated.*by.*JFlex"/>
+      </fileset>
+    </delete>
+  </target>
+
+  <macrodef name="contrib-crawl">
+    <attribute name="target" default=""/>
+    <attribute name="failonerror" default="true"/>
+    <sequential>
+      <subant target="@{target}" failonerror="@{failonerror}">
+        <fileset dir="."
+                 includes="contrib/*/build.xml"
+        />
+      </subant>
+    </sequential>
+  </macrodef>
+
+  <target name="build-contrib"
+          description="Builds all contrib modules and their tests">
+    <contrib-crawl target="build-artifacts-and-tests"/>
+  </target>
+
+  <target name="test-contrib" depends="build-contrib">
+    <!-- Don't fail on error, instead check for flag file so we run
+         all the tests possible and can "ant generate-test-reports"
+         for all of them.
+
+         Because of this, we depend on "build-contrib" even though the
+         Individual contrib "test" targets probably have the
+         neccessary dependencies.  If they fail to compile, we won't
+         know about it.
+     -->
+    <contrib-crawl target="test" failonerror="false"/>
+    <available property="contribs.failed" file="junitfailed.flag">
+      <filepath>
+        <dirset dir="${build.dir}/contrib/">
+          <include name="**/test/" />
+        </dirset>
+      </filepath>
+    </available>
+    <fail if="contribs.failed">Contrib tests failed!</fail>
+  </target>
+
+  <!-- Macro for building checksum files
+       This is only needed until the "format" option is supported
+       by ant's built in checksum task
+   -->
+  <macrodef name="lucene-checksum">
+    <attribute name="file"/>
+    <!-- NOTE: we use the value of @{file} in the names any properties
+         set because macro's don't have variables, and otherwise we
+         wouldn't be able to checksum more then one file per build
+      -->
+    <sequential>
+      <checksum file="@{file}"
+                property="@{file}.sum"
+                algorithm="${checksum.algorithm}" />
+      <basename file="@{file}" property="@{file}.base" />
+      <concat destfile="@{file}.${checksum.algorithm}"
+              force="yes"
+              append="false"
+              fixlastline="yes">
+        <header trimleading="yes">${@{file}.sum}  </header>
+        <!-- empty fileset to trick concat -->
+        <fileset dir="." excludes="**" />
+        <footer trimleading="yes">${@{file}.base}
+        </footer>
+      </concat>
+    </sequential>
+  </macrodef>
+
+  <!--
+   compile changes.txt into an html file
+   -->
+
+  <target name="changes-to-html">
+    <mkdir dir="${changes.target.dir}"/>
+    <exec executable="perl" input="CHANGES.txt" output="${changes.target.dir}/Changes.html" failonerror="true">
+      <arg value="${changes.src.dir}/changes2html.pl"/>
+    </exec>
+    <copy todir="${changes.target.dir}">
+      <fileset dir="${changes.src.dir}" includes="*.css"/>
+    </copy>
+  </target>
+
+  <!--
+   Committer helpers
+   -->
+
+  <property name="patch.file" value="${basedir}/../patches/${patch.name}"/>
+  <!-- Apply a patch.  Assumes  patch can be applied in the basedir.
+  -Dpatch.name assumes the patch is located in ${basedir}/../patches/${patch.name}
+  -Dpatch.file means the patch can be located anywhere on the file system
+  -->
+  <target name="apply-patch" depends="clean" description="Apply a patch file.  Set -Dpatch.file, or -Dpatch.name when the patch is in the directory ../patches/">
+    <patch patchfile="${patch.file}" strip="0"/>
+  </target>
+
+  <target name="rat-sources-typedef">
+    <typedef resource="org/apache/rat/anttasks/antlib.xml" uri="antlib:rat.anttasks">
+      <classpath>
+        <fileset dir="." includes="rat*.jar"/>
+      </classpath>
+    </typedef>
+  </target>
+
+  <target name="rat-sources" depends="rat-sources-typedef"
+	  description="runs the tasks over src/java">
+    <rat:report xmlns:rat="antlib:org.apache.rat.anttasks">
+      <fileset dir="src/java">
+      </fileset>
+    </rat:report>
+  </target>
+
+</project>
diff --git a/benchmarks/bms/lusearch-fix/build.xml b/benchmarks/bms/lusearch-fix/build.xml
index 56f07b6..f067bfb 100644
--- a/benchmarks/bms/lusearch-fix/build.xml
+++ b/benchmarks/bms/lusearch-fix/build.xml
@@ -24,7 +24,7 @@
     <target name="bm-build" depends="fix-operation, lucene">
         <mkdir dir="${bm-build-dir}"/>
         <javac srcdir="${bm-src-dir}" source="1.5"
-               classpath="${harness-classpath}:${lucene-jars}/${lucene-core-jar-name}:${lucene-jars}/${lucene-demos-jar-name}"
+               classpath="${harness-classpath}:${lucene-jars}/${lucene-core-jar-name}:${lucene-jars}/${lucene-demos-jar-name}:${jikesrvm-jar}"
                destdir="${bm-build-dir}"
                includes="org/dacapo/lusearchFix/*" debug="true" debuglevel="lines,vars,source"/>
         <delete file="libs/lucene/build.xml"/>
diff --git a/benchmarks/harness/build.xml b/benchmarks/harness/build.xml
index 76d1f82..5d794b8 100644
--- a/benchmarks/harness/build.xml
+++ b/benchmarks/harness/build.xml
@@ -3,6 +3,7 @@
     
     <import file="../util.xml"/>
     <import file="../libs/libs.xml"/>
+    <import file="../path.xml"/>
     
     <property file="ant/local.properties"/>
     <property file="ant/dacapo.properties"/>
@@ -59,7 +60,7 @@
     <target name="harness" depends="init,dacapo-digest,cli,parser">
         <!-- include digest --> 
         <unjar src="${dacapo-digest-jar}" dest="${output-dir}" />
-        <javac srcdir="${src}" destdir="${output-dir}" debug="true" debuglevel="lines,vars,source"/>
+        <javac srcdir="${src}" destdir="${output-dir}" classpath="${jikesrvm-path}:." debug="true" debuglevel="lines,vars,source"/>
         <javadoc sourcepath="${src}" destdir="${output-doc-dir}" />
     </target>
     
diff --git a/benchmarks/harness/src/org/dacapo/harness/Benchmark.java b/benchmarks/harness/src/org/dacapo/harness/Benchmark.java
index f374232..95ae64b 100644
--- a/benchmarks/harness/src/org/dacapo/harness/Benchmark.java
+++ b/benchmarks/harness/src/org/dacapo/harness/Benchmark.java
@@ -57,7 +57,7 @@ public abstract class Benchmark {
   /**
    * Perform digest operations on standard output and standard error
    */
-  private static boolean validateOutput = true;
+  private static boolean validateOutput = false; //disabling as when aborting the results are anyway invalid
 
   /**
    * Perform System.gc() just prior to each iteration
@@ -67,7 +67,7 @@ public abstract class Benchmark {
   /**
    * Perform validation
    */
-  private static boolean validate = true;
+  private static boolean validate = false; //disabling as when aborting the results are anyway invalid
 
   /**
    * Don't clean up output files
@@ -662,8 +662,8 @@ public abstract class Benchmark {
   public static void setCommandLineOptions(CommandLineArgs line) {
     silent = line.getSilent();
     preserve = line.getPreserve();
-    validate = line.getValidate();
-    validateOutput = line.getValidateOutput();
+    //validate = line.getValidate();
+    //validateOutput = line.getValidateOutput();
     preIterationGC = line.getPreIterationGC();
     timeoutDialation = line.getTimeoutDialation();
     if (line.getValidationReport() != null)
diff --git a/benchmarks/harness/src/org/dacapo/harness/EuroPAR19.java b/benchmarks/harness/src/org/dacapo/harness/EuroPAR19.java
new file mode 100644
index 0000000..29ad2dc
--- /dev/null
+++ b/benchmarks/harness/src/org/dacapo/harness/EuroPAR19.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2006, 2009 The Australian National University.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License v2.0.
+ * You may obtain the license at
+ * 
+ *    http://www.opensource.org/licenses/apache2.0.php
+ */
+package org.dacapo.harness;
+
+/**
+ * @date $Date: 2009-12-24 11:19:36 +1100 (Thu, 24 Dec 2009) $
+ * @id $Id: EuroPAR19.java 738 2009-12-24 00:19:36Z steveb-oss $
+ */
+public class EuroPAR19 extends Callback {
+
+  private boolean harness_start = false;
+
+  public EuroPAR19(CommandLineArgs args) {
+    super(args);
+  }
+
+  /* Immediately prior to start of the benchmark */
+  @Override
+  public void start(String benchmark) {
+    if(iterations+1 == args.getIterations()) {
+      harness_start = true;
+      System.err.println("MMTk Harness Started");
+      org.mmtk.plan.Plan.harnessBegin();
+    }
+    super.start(benchmark);
+  };
+
+  /* Immediately after the end of the benchmark */
+  @Override
+  public void stop(long duration) {
+    super.stop(duration);
+    System.err.flush();
+  };
+
+  @Override
+  public void complete(String benchmark, boolean valid) {
+    super.complete(benchmark, valid);
+    System.err.println("my hook " + (valid ? "PASSED " : "FAILED ") + (isWarmup() ? "warmup " : "") + benchmark);
+    if(harness_start) {
+      org.mmtk.plan.Plan.harnessEnd();
+    }
+    System.err.flush();
+  };
+}
diff --git a/benchmarks/libs/libs.xml b/benchmarks/libs/libs.xml
index 70c1b6b..5427330 100644
--- a/benchmarks/libs/libs.xml
+++ b/benchmarks/libs/libs.xml
@@ -9,6 +9,8 @@
 <project name="libs">
     <property name="lib-base" value="${basedir}/libs"/>
 
+    <import file="../path.xml"/>
+
     <!-- bcel -->
     <property name="bcel-jar" value="${lib-base}/bcel/dist/jar/bcel-5.2.jar"/>
     <target name="bcel">
@@ -97,6 +99,9 @@
     <target name="lucene">
         <ant antfile="${lib-base}/lucene/build.xml"/>
     </target>
+ 
+    <!-- jikesrvm -->
+    <property name="jikesrvm-jar" value="${jikesrvm-path}"/>
 
     <!-- xerces -->
     <property name="xerces-jars" value="${lib-base}/xerces/dist/jar"/>
diff --git a/benchmarks/path.xml b/benchmarks/path.xml
new file mode 100644
index 0000000..bca8153
--- /dev/null
+++ b/benchmarks/path.xml
@@ -0,0 +1,6 @@
+<project name="workstealing" basedir=".">
+        <!--
+                SET THE PATHS BELOW RELATIVE TO HOME DIRECTORY ONLY !!
+        -->
+        <property name="jikesrvm-path" value="/home/vivek/jikesrvm/JikesRVM/dist/production_ws/jksvm.jar"/>
+</project>
diff --git a/benchmarks/util.xml b/benchmarks/util.xml
index 2a46408..2c3d5e8 100644
--- a/benchmarks/util.xml
+++ b/benchmarks/util.xml
@@ -47,7 +47,7 @@
 
 	<!-- get the source if necessary -->
 	<target name="get-source" unless="target-valid-md5">
-		<get src="${target-url}" dest="${target-filename}" />
+		<!--get src="${target-url}" dest="${target-filename}" /-->
 	</target>
 
 	<!-- if there is no checksum then generate one -->
@@ -57,10 +57,12 @@
 
 	<!-- verify that the checksum is the expected checksum (i.e. not generated this run) -->
 	<target name="get-source-verify-checksum" if="target-available-checksum" >
+        <!--
 		<condition property="target-verified">
 			<checksum file="${target-filename}" fileext=".${checksum-alg}" algorithm="${checksum-alg}" />
 		</condition>
 		<fail message="File ${target-filename} failed to validate against checksum" unless="target-verified" />
+        -->
 	</target>
 
 	<macrodef name="checksum-verify">
-- 
2.7.4

